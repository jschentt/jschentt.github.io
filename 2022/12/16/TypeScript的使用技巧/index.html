<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="一、Enum 类型使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。 1.数字枚举12345678enum Direction &amp;#123;  NORTH,  SOUTH,  EAST,  WEST,&amp;#125;let dir: Direction &#x3D; Direction.NORTH;  默认情况下，NO">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript的使用技巧">
<meta property="og:url" content="http://example.com/2022/12/16/TypeScript%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/index.html">
<meta property="og:site_name" content="Bruce Chen&#39;s Blog">
<meta property="og:description" content="一、Enum 类型使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。 1.数字枚举12345678enum Direction &amp;#123;  NORTH,  SOUTH,  EAST,  WEST,&amp;#125;let dir: Direction &#x3D; Direction.NORTH;  默认情况下，NO">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-16T06:17:58.000Z">
<meta property="article:modified_time" content="2022-12-16T06:23:00.136Z">
<meta property="article:author" content="Bruce Chen">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/12/16/TypeScript%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>TypeScript的使用技巧 | Bruce Chen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
    <a target="_blank" rel="noopener" href="https://github.com/jschentt" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bruce Chen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">quick notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">83</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/TypeScript%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TypeScript的使用技巧
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 14:17:58 / 修改时间：14:23:00" itemprop="dateCreated datePublished" datetime="2022-12-16T14:17:58+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">前端框架总结</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、Enum-类型"><a href="#一、Enum-类型" class="headerlink" title="一、Enum 类型"></a>一、Enum 类型</h1><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</p>
<h2 id="1-数字枚举"><a href="#1-数字枚举" class="headerlink" title="1.数字枚举"></a>1.数字枚举</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dir: Direction = Direction.NORTH;</span><br></pre></td></tr></table></figure>

<p>默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var Direction;</span><br><span class="line">(function (Direction) &#123;</span><br><span class="line">  Direction[(Direction[&quot;NORTH&quot;] = 0)] = &quot;NORTH&quot;;</span><br><span class="line">  Direction[(Direction[&quot;SOUTH&quot;] = 1)] = &quot;SOUTH&quot;;</span><br><span class="line">  Direction[(Direction[&quot;EAST&quot;] = 2)] = &quot;EAST&quot;;</span><br><span class="line">  Direction[(Direction[&quot;WEST&quot;] = 3)] = &quot;WEST&quot;;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br><span class="line">var dir = Direction.NORTH;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以设置 NORTH 的初始值，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH = 3,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-字符串枚举"><a href="#2-字符串枚举" class="headerlink" title="2.字符串枚举"></a>2.字符串枚举</h2><p>在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH = &quot;NORTH&quot;,</span><br><span class="line">  SOUTH = &quot;SOUTH&quot;,</span><br><span class="line">  EAST = &quot;EAST&quot;,</span><br><span class="line">  WEST = &quot;WEST&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对于的 ES5 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var Direction;</span><br><span class="line">(function (Direction) &#123;</span><br><span class="line">    Direction[&quot;NORTH&quot;] = &quot;NORTH&quot;;</span><br><span class="line">    Direction[&quot;SOUTH&quot;] = &quot;SOUTH&quot;;</span><br><span class="line">    Direction[&quot;EAST&quot;] = &quot;EAST&quot;;</span><br><span class="line">    Direction[&quot;WEST&quot;] = &quot;WEST&quot;;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="3-异构枚举"><a href="#3-异构枚举" class="headerlink" title="3.异构枚举"></a>3.异构枚举</h2><p>异构枚举的成员值是数字和字符串的混合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Enum &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  C = &quot;C&quot;,</span><br><span class="line">  D = &quot;D&quot;,</span><br><span class="line">  E = 8,</span><br><span class="line">  F,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对于的 ES5 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var Enum;</span><br><span class="line">(function (Enum) &#123;</span><br><span class="line">    Enum[Enum[&quot;A&quot;] = 0] = &quot;A&quot;;</span><br><span class="line">    Enum[Enum[&quot;B&quot;] = 1] = &quot;B&quot;;</span><br><span class="line">    Enum[&quot;C&quot;] = &quot;C&quot;;</span><br><span class="line">    Enum[&quot;D&quot;] = &quot;D&quot;;</span><br><span class="line">    Enum[Enum[&quot;E&quot;] = 8] = &quot;E&quot;;</span><br><span class="line">    Enum[Enum[&quot;F&quot;] = 9] = &quot;F&quot;;</span><br><span class="line">&#125;)(Enum || (Enum = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Enum.A) //输出：0</span><br><span class="line">console.log(Enum[0]) // 输出：A</span><br></pre></td></tr></table></figure>

<h1 id="二、特殊数据类型"><a href="#二、特殊数据类型" class="headerlink" title="二、特殊数据类型"></a>二、特殊数据类型</h1><h2 id="1-Unknown-类型"><a href="#1-Unknown-类型" class="headerlink" title="1. Unknown 类型"></a>1. Unknown 类型</h2><p>就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）。下面我们来看一下 unknown 类型的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let value: unknown;</span><br><span class="line"></span><br><span class="line">value = true; // OK</span><br><span class="line">value = 42; // OK</span><br><span class="line">value = &quot;Hello World&quot;; // OK</span><br><span class="line">value = []; // OK</span><br><span class="line">value = &#123;&#125;; // OK</span><br><span class="line">value = Math.random; // OK</span><br><span class="line">value = null; // OK</span><br><span class="line">value = undefined; // OK</span><br><span class="line">value = new TypeError(); // OK</span><br><span class="line">value = Symbol(&quot;type&quot;); // OK</span><br></pre></td></tr></table></figure>

<p>对 <code>value</code> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <code>unknown</code> 的值赋值给其他类型的变量时会发生什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let value: unknown;</span><br><span class="line"></span><br><span class="line">let value1: unknown = value; // OK</span><br><span class="line">let value2: any = value; // OK</span><br><span class="line">let value3: boolean = value; // Error</span><br><span class="line">let value4: number = value; // Error</span><br><span class="line">let value5: string = value; // Error</span><br><span class="line">let value6: object = value; // Error</span><br><span class="line">let value7: any[] = value; // Error</span><br><span class="line">let value8: Function = value; // Error</span><br></pre></td></tr></table></figure>

<p><code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 <code>unknown</code> 类型的值。毕竟我们不知道变量 <code>value</code> 中存储了什么类型的值。</p>
<p>现在让我们看看当我们尝试对类型为 unknown 的值执行操作时会发生什么。以下是我们在之前 any 章节看过的相同操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let value: unknown;</span><br><span class="line"></span><br><span class="line">value.foo.bar; // Error</span><br><span class="line">value.trim(); // Error</span><br><span class="line">value(); // Error</span><br><span class="line">new value(); // Error</span><br><span class="line">value[0][1]; // Error</span><br></pre></td></tr></table></figure>

<p>将 <code>value</code> 变量类型设置为 <code>unknown</code> 后，这些操作都不再被认为是类型正确的。通过将 <code>any</code> 类型改变为 <code>unknown</code> 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。</p>
<h2 id="2-Never-类型"><a href="#2-Never-类型" class="headerlink" title="2. Never 类型"></a>2. Never 类型</h2><p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如，<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 返回never的函数必须存在无法达到的终点</span><br><span class="line">function error(message: string): never &#123;</span><br><span class="line">  throw new Error(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function infiniteLoop(): never &#123;</span><br><span class="line">  while (true) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Foo = string | number;</span><br><span class="line"></span><br><span class="line">function controlFlowAnalysisWithNever(foo: Foo) &#123;</span><br><span class="line">  if (typeof foo === &quot;string&quot;) &#123;</span><br><span class="line">    // 这里 foo 被收窄为 string 类型</span><br><span class="line">  &#125; else if (typeof foo === &quot;number&quot;) &#123;</span><br><span class="line">    // 这里 foo 被收窄为 number 类型</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // foo 在这里是 never</span><br><span class="line">    const check: never = foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Foo = string | number | boolean;</span><br></pre></td></tr></table></figure>

<p>然而他忘记同时修改 <code>controlFlowAnalysisWithNever</code> 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 <code>boolean</code> 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保</p>
<p><code>controlFlowAnalysisWithNever</code> 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</p>
<h1 id="三、Typescript-的类型系统"><a href="#三、Typescript-的类型系统" class="headerlink" title="三、Typescript 的类型系统"></a>三、Typescript 的类型系统</h1><p>充分使用编辑器的 language service 功能（类型提示，类型检查，类型推倒，自动补全，类型定义跳转)</p>
<p>把类型当做值的集合思考</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type A= &#x27;A&#x27; // 单值集合 &#123; &#x27;A&#x27; &#125;</span><br><span class="line">type B= &#x27;B&#x27; // 单值集合 &#123; &#x27;B&#x27; &#125;</span><br><span class="line">type AB = &#x27;A&#x27; | &#x27;B&#x27;  // 集合的并集 &#123; &#x27;A&#x27;, &#x27;B&#x27; &#125;</span><br><span class="line">type twoInt =  2 | 4 | 5 ... // 无限元素集合 &#123; 1,2,3,4&#125;</span><br><span class="line">type threeInt = 3 | 6 | 9 // 无限集合</span><br><span class="line">type twoIntersectThreeInt = twoInt &amp; threeInt // 无限集合的交集</span><br><span class="line">type twoUnionThreeInt = 2| 3 | 4 | 6 ... // 无限集合的并集</span><br><span class="line">keyof (A&amp;B) = (keyof A) | (keyof B)</span><br><span class="line">keyof (A|B) = (keyof A) &amp; (keyof B)</span><br></pre></td></tr></table></figure>

<p>术语和集合术语对照表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Typescript术语	                  集合术语</span><br><span class="line">never	                          空集</span><br><span class="line">literal type	                  单值集合</span><br><span class="line">value 可赋值给 T	              value ∈T</span><br><span class="line">T1 assignable to T2	              T1是T2的子集</span><br><span class="line">T1 extends T2	                  T1是T2的子集</span><br><span class="line">T1	                              T2</span><br><span class="line">T1 &amp; T2	                          T1 和T2的交集</span><br><span class="line">unknown	                          universal set</span><br></pre></td></tr></table></figure>

<h1 id="四、了解-type-和-interface-的区别"><a href="#四、了解-type-和-interface-的区别" class="headerlink" title="四、了解 type 和 interface 的区别"></a>四、了解 type 和 interface 的区别</h1><p>绝大部分情况下，type 和 interface 都能等价转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 普通对象</span><br><span class="line">type TState = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    capital: string;</span><br><span class="line">&#125;</span><br><span class="line">interface IState &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    capital: string;</span><br><span class="line">&#125;</span><br><span class="line">// index signature</span><br><span class="line">type TDict = &#123;[key:string]: string &#125;</span><br><span class="line">interface IDict &#123;</span><br><span class="line">    [key:string]: string</span><br><span class="line">&#125;</span><br><span class="line">type TFn = (x:number) =&gt; string;</span><br><span class="line">interface IFn &#123;</span><br><span class="line">    (x:number):string;</span><br><span class="line">&#125;</span><br><span class="line">// function with props</span><br><span class="line">type TFnWithProps = &#123;</span><br><span class="line">    (x:number):number;</span><br><span class="line">    prop: string;</span><br><span class="line">&#125;</span><br><span class="line">interface IFnWithProps &#123;</span><br><span class="line">    (x:number):number;</span><br><span class="line">    prop: string;</span><br><span class="line">&#125;</span><br><span class="line">//  constructor</span><br><span class="line">type TConstructor = new(x:number) =&gt; &#123;x:number&#125;</span><br><span class="line">interface IConstructor&#123;</span><br><span class="line">    new(x:number): &#123;x:number&#125;</span><br><span class="line">&#125;</span><br><span class="line">// generic</span><br><span class="line">type TPair&lt;T&gt;= &#123;</span><br><span class="line">    first: T;</span><br><span class="line">    second: T;</span><br><span class="line">&#125;</span><br><span class="line">interface IPair&lt;T&gt; &#123;</span><br><span class="line">    first: T;</span><br><span class="line">    second: T;</span><br><span class="line">&#125;</span><br><span class="line">// extends</span><br><span class="line">type TStateWithProps = TState &amp; &#123; population : number&#125;</span><br><span class="line">interface IStateWithProp extends IState &#123;</span><br><span class="line">    population: number;</span><br><span class="line">&#125;</span><br><span class="line">// implements</span><br><span class="line">class StateT implements TState &#123;</span><br><span class="line">    name = &#x27;&#x27;;</span><br><span class="line">    capital = &#x27;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">class StateI implements IState &#123;</span><br><span class="line">    name=&#x27;&#x27;;</span><br><span class="line">    capital = &#x27;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type 和 interface 亦有所区别</p>
<ol>
<li>interface 无法应用于 union type | intersection type | conditional type | tuple</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type AorB = &#x27;A&#x27; | &#x27;B&#x27;</span><br><span class="line">type NamedVariable = (Input | Output) &amp; &#123; name: string&#125;</span><br><span class="line">type Pair = [number,number]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>interface 可以 argumented,而 type 不可以</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// inner</span><br><span class="line">interface IState &#123;</span><br><span class="line">    name :string;</span><br><span class="line">    capital: string;</span><br><span class="line">&#125;</span><br><span class="line">// outer</span><br><span class="line">interface IState &#123;</span><br><span class="line">    population: number</span><br><span class="line">&#125;</span><br><span class="line">const wyoming: IState = &#123;</span><br><span class="line">    name: &#x27;Wyoming&#x27;,</span><br><span class="line">    capital: &#x27;Cheyenne&#x27;,</span><br><span class="line">    population: 500_000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、keyof-操作符"><a href="#五、keyof-操作符" class="headerlink" title="五、keyof 操作符"></a>五、keyof 操作符</h1><h2 id="keyof-简介"><a href="#keyof-简介" class="headerlink" title="keyof 简介"></a>keyof 简介</h2><p>TypeScript 允许我们遍历某种类型的属性，并通过 keyof 操作符提取其属性的名称。keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</p>
<p>下面我们来看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  location: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span><br><span class="line">type K2 = keyof Person[];  // number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...</span><br><span class="line">type K3 = keyof &#123; [x: string]: Person &#125;;  // string | number</span><br></pre></td></tr></table></figure>

<p>除了接口外，keyof 也可以用于操作类，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  name: string = &quot;Semlinker&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sname: keyof Person;</span><br><span class="line">sname = &quot;name&quot;;</span><br></pre></td></tr></table></figure>

<p>若把 <code>sname = &quot;name&quot;</code> 改为 <code>sname = &quot;age&quot;</code> 的话，TypeScript 编译器会提示以下错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type &#x27;&quot;age&quot;&#x27; is not assignable to type &#x27;&quot;name&quot;&#x27;.</span><br></pre></td></tr></table></figure>

<p>keyof 操作符除了支持接口和类之外，它也支持基本数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let K1: keyof boolean; // let K1: &quot;valueOf&quot;</span><br><span class="line">let K2: keyof number; // let K2: &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; | ...</span><br><span class="line">let K3: keyof symbol; // let K3: &quot;valueOf&quot;</span><br></pre></td></tr></table></figure>

<p>此外 keyof 也称为输入索引类型查询，与之相对应的是索引访问类型，也称为查找类型。在语法上，它们看起来像属性或元素访问，但最终会被转换为类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type P1 = Person[&quot;name&quot;];  // string</span><br><span class="line">type P2 = Person[&quot;name&quot; | &quot;age&quot;];  // string | number</span><br><span class="line">type P3 = string[&quot;charAt&quot;];  // (pos: number) =&gt; string</span><br><span class="line">type P4 = string[][&quot;push&quot;];  // (...items: string[]) =&gt; number</span><br><span class="line">type P5 = string[][0];  // string</span><br></pre></td></tr></table></figure>

<h2 id="keyof-的作用"><a href="#keyof-的作用" class="headerlink" title="keyof 的作用"></a>keyof 的作用</h2><p>JavaScript 是一种高度动态的语言。有时在静态类型系统中捕获某些操作的语义可能会很棘手。以一个简单的 prop 函数为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function prop(obj, key) &#123;</span><br><span class="line">  return obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数接收 obj 和 key 两个参数，并返回对应属性的值。对象上的不同属性，可以具有完全不同的类型，我们甚至不知道 obj 对象长什么样。</p>
<p>那么在 TypeScript 中如何定义上面的 prop 函数呢？我们来尝试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function prop(obj: object, key: string) &#123;</span><br><span class="line">  return obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，为了避免调用 prop 函数时传入错误的参数类型，我们为 obj 和 key 参数设置了类型，分别为 {} 和 string 类型。然而，事情并没有那么简单。针对上述的代码，TypeScript 编译器会输出以下错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element implicitly has an &#x27;any&#x27; type because expression of type &#x27;string&#x27; can&#x27;t be used to index type &#x27;&#123;&#125;&#x27;.</span><br></pre></td></tr></table></figure>

<p>元素隐式地拥有 any 类型，因为 string 类型不能被用于索引 {} 类型。要解决这个问题，你可以使用以下非常暴力的方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function prop(obj: object, key: string) &#123;</span><br><span class="line">  return (obj as any)[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显该方案并不是一个好的方案，我们来回顾一下 prop 函数的作用，该函数用于获取某个对象中指定属性的属性值。因此我们期望用户输入的属性是对象上已存在的属性，那么如何限制属性名的范围呢？这时我们可以利用本文的主角 keyof 操作符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) &#123;</span><br><span class="line">  return obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们使用了 TypeScript 的泛型和泛型约束。首先定义了 T 类型并使用 extends 关键字约束该类型必须是 object 类型的子类型，然后使用 keyof 操作符获取 T 类型的所有键，其返回类型是联合类型，最后利用 extends 关键字约束 K 类型必须为 keyof T 联合类型的子类型。 是骡子是马拉出来遛遛就知道了，我们来实际测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type Todo = &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  text: string;</span><br><span class="line">  done: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const todo: Todo = &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  text: &quot;Learn TypeScript keyof&quot;,</span><br><span class="line">  done: false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) &#123;</span><br><span class="line">  return obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const id = prop(todo, &quot;id&quot;); // const id: number</span><br><span class="line">const text = prop(todo, &quot;text&quot;); // const text: string</span><br><span class="line">const done = prop(todo, &quot;done&quot;); // const done: boolean</span><br></pre></td></tr></table></figure>

<p>很明显使用泛型，重新定义后的 prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) 函数，已经可以正确地推导出指定键对应的类型。那么当访问 todo 对象上不存在的属性时，会出现什么情况？比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const date = prop(todo, &quot;date&quot;);</span><br></pre></td></tr></table></figure>

<p>对于上述代码，TypeScript 编译器会提示以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Argument of type &#x27;&quot;date&quot;&#x27; is not assignable to parameter of type &#x27;&quot;id&quot; | &quot;text&quot; | &quot;done&quot;&#x27;.</span><br></pre></td></tr></table></figure>

<p>这就阻止我们尝试读取不存在的属性。</p>
<h2 id="keyof-与对象的数值属性"><a href="#keyof-与对象的数值属性" class="headerlink" title="keyof 与对象的数值属性"></a>keyof 与对象的数值属性</h2><p>在使用对象的数值属性时，我们也可以使用 keyof 关键字。请记住，如果我们定义一个带有数值属性的对象，那么我们既需要定义该属性，又需要使用数组语法访问该属性， 如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ClassWithNumericProperty &#123;</span><br><span class="line">  [1]: string = &quot;Semlinker&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let classWithNumeric = new ClassWithNumericProperty();</span><br><span class="line">console.log(`$&#123;classWithNumeric[1]&#125; `);</span><br></pre></td></tr></table></figure>

<p>下面我们来举个示例，介绍一下在含有数值属性的对象中，如何使用 keyof 操作符来安全地访问对象的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum Currency &#123;</span><br><span class="line">  CNY = 6,</span><br><span class="line">  EUR = 8,</span><br><span class="line">  USD = 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const CurrencyName = &#123;</span><br><span class="line">  [Currency.CNY]: &quot;人民币&quot;,</span><br><span class="line">  [Currency.EUR]: &quot;欧元&quot;,</span><br><span class="line">  [Currency.USD]: &quot;美元&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(`CurrencyName[Currency.CNY] = $&#123;CurrencyName[Currency.CNY]&#125;`);</span><br><span class="line">console.log(`CurrencyName[36] = $&#123;CurrencyName[6]&#125;`);</span><br></pre></td></tr></table></figure>

<p>上面的代码中，首先定义了一个 Currency 枚举用于表示三种货币类型，接着定义一个 CurrencyName 对象，该对象使用数值属性作为键，对应的值是该货币类型的名称。该代码成功运行后，控制台会输出以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CurrencyName[Currency.CNY] = 人民币</span><br><span class="line">CurrencyName[36] = 人民币</span><br></pre></td></tr></table></figure>

<p>为了方便用户能根据货币类型来获取对应的货币名称，我们来定义一个 getCurrencyName 函数，具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getCurrencyName&lt;T, K extends keyof T&gt;(key: K, map: T): T[K] &#123;</span><br><span class="line">  return map[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(`name = $&#123;getCurrencyName(Currency.CNY, CurrencyName)&#125;`);</span><br></pre></td></tr></table></figure>

<p>同样，getCurrencyName 函数和前面介绍的 prop 函数一样，使用了泛型和泛型约束，从而来保证属性的安全访问。最后，我们来简单介绍一下 keyof 与 typeof 操作符如何配合使用。</p>
<h2 id="keyof-与-typeof-操作符"><a href="#keyof-与-typeof-操作符" class="headerlink" title="keyof 与 typeof 操作符"></a>keyof 与 typeof 操作符</h2><p>typeof 操作符用于获取变量的类型。因此这个操作符的后面接的始终是一个变量，且需要运用到类型定义当中。为了方便大家理解，我们来举一个具体的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Person = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let man: Person = &#123;</span><br><span class="line">  name: &quot;Semlinker&quot;,</span><br><span class="line">  age: 30</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Human = typeof man;</span><br></pre></td></tr></table></figure>

<p>了解完 typeof 和 keyof 操作符的作用，我们来举个例子，介绍一下它们如何结合在一起使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const COLORS = &#123;</span><br><span class="line">  red: &#x27;red&#x27;,</span><br><span class="line">  blue: &#x27;blue&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 首先通过typeof操作符获取color变量的类型，然后通过keyof操作符获取该类型的所有键，</span><br><span class="line">// 即字符串字面量联合类型 &#x27;red&#x27; | &#x27;blue&#x27;</span><br><span class="line">type Colors = keyof typeof COLORS</span><br><span class="line">let color: Colors;</span><br><span class="line">color = &#x27;red&#x27; // Ok</span><br><span class="line">color = &#x27;blue&#x27; // Ok</span><br><span class="line"></span><br><span class="line">// Type &#x27;&quot;yellow&quot;&#x27; is not assignable to type &#x27;&quot;red&quot; | &quot;blue&quot;&#x27;.</span><br><span class="line">color = &#x27;yellow&#x27; // Error</span><br></pre></td></tr></table></figure>

<h1 id="六、TypeScript-泛型"><a href="#六、TypeScript-泛型" class="headerlink" title="六、TypeScript 泛型"></a>六、TypeScript 泛型</h1><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p>在像 <code>C#</code> 和 <code>Java</code> 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>
<p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p>
<p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">  (arg: T): T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myGenericNumber = new GenericNumber&lt;number&gt;();</span><br><span class="line">myGenericNumber.zeroValue = 0;</span><br><span class="line">myGenericNumber.add = function (x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h2><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p>
<ul>
<li>T（Type）：表示一个 TypeScript 类型</li>
<li>K（Key）：表示对象中的键类型</li>
<li>V（Value）：表示对象中的值类型</li>
<li>E（Element）：表示元素类型</li>
</ul>
<h2 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h2><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p>
<p><strong>1.typeof</strong><br>在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const sem: Person = &#123; name: &#x27;semlinker&#x27;, age: 30 &#125;;</span><br><span class="line">type Sem= typeof sem; // -&gt; Person</span><br><span class="line"></span><br><span class="line">function toArray(x: number): Array&lt;number&gt; &#123;</span><br><span class="line">  return [x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Func = typeof toArray; // -&gt; (x: number) =&gt; number[]</span><br></pre></td></tr></table></figure>

<p><strong>2.keyof</strong><br>keyof 操作符可以用来获取一个对象中的所有 key 值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot;</span><br><span class="line">type K2 = keyof Person[]; // &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot;</span><br><span class="line">type K3 = keyof &#123; [x: string]: Person &#125;;  // string | number</span><br></pre></td></tr></table></figure>

<p><strong>3.in</strong><br>in 用来遍历枚举类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Keys = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;</span><br><span class="line"></span><br><span class="line">type Obj =  &#123;</span><br><span class="line">  [p in Keys]: any</span><br><span class="line">&#125; // -&gt; &#123; a: any, b: any, c: any &#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.infer</strong><br>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T&gt; = T extends (</span><br><span class="line">  ...args: any[]</span><br><span class="line">) =&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure>

<p>以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p>
<p><strong>5.extends</strong><br>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ILengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends ILengthwise&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length);</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(3);  // Error, number doesn&#x27;t have a .length property</span><br></pre></td></tr></table></figure>

<p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;length: 10, value: 3&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>6.Partial</strong></p>
<p>Partial<T> 的作用就是将某个类型里的属性全部变为可选项 ?。</p>
<p><strong>定义：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * node_modules/typescript/lib/lib.es5.d.ts</span><br><span class="line"> * Make all properties in T optional</span><br><span class="line"> */</span><br><span class="line">type Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，首先通过 keyof T 拿到 T 的所有属性名，然后使用 in 进行遍历，将值赋给 P，最后通过 T[P] 取得相应的属性值。中间的 ? 号，用于将所有属性变为可选。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) &#123;</span><br><span class="line">  return &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const todo1 = &#123;</span><br><span class="line">  title: &quot;organize desk&quot;,</span><br><span class="line">  description: &quot;clear clutter&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const todo2 = updateTodo(todo1, &#123;</span><br><span class="line">  description: &quot;throw out trash&quot;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的 updateTodo 方法中，我们利用 Partial<T> 工具类型，定义 fieldsToUpdate 的类型为 Partial<Todo>，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   title?: string | undefined;</span><br><span class="line">   description?: string | undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、充分利用泛型和类型运算避免冗余类型标记"><a href="#七、充分利用泛型和类型运算避免冗余类型标记" class="headerlink" title="七、充分利用泛型和类型运算避免冗余类型标记"></a>七、充分利用泛型和类型运算避免冗余类型标记</h1><p>使用泛型提取公共的 util type，简化类型编写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface ButtonProps &#123;</span><br><span class="line">    type: string;</span><br><span class="line">    size: &#x27;large&#x27; | &#x27;middle&#x27;| &#x27;small&#x27;</span><br><span class="line">&#125;</span><br><span class="line">interface ButtonPropsWithChildren&#123;</span><br><span class="line">    type: string;</span><br><span class="line">    size: &#x27;large&#x27; | &#x27;middle&#x27;| &#x27;small&#x27;,</span><br><span class="line">    children: React.ReactNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 PropsWithChildren 简化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; PropsWithChildren &#125; from &#x27;react&#x27;;</span><br><span class="line">type ButtonPropsWithChildren = PropsWithChildren&lt;ButtonProps&gt;</span><br></pre></td></tr></table></figure>

<p>使用 index type | mapped type | keyof 等进行类型传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface State &#123;</span><br><span class="line">    userId: string;</span><br><span class="line">    pageTitle: string;</span><br><span class="line">    recentFiles: string[]</span><br><span class="line">    pageContents: string;</span><br><span class="line">&#125;</span><br><span class="line">interface TopNavState &#123;</span><br><span class="line">    userId: string;</span><br><span class="line">    pageTitle: string;</span><br><span class="line">    recentFiles: string[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可通过 lookup type 简化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface TopNavState = &#123;</span><br><span class="line">    userId: State[&#x27;userId&#x27;];</span><br><span class="line">    pageTitle: State[&#x27;pageTitle&#x27;]</span><br><span class="line">    recentFiles: State[&#x27;recentFiles&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 mapped type 可进一步简化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type TopNavState = &#123;</span><br><span class="line">    [k in &#x27;userId&#x27; | &#x27;pageTitle&#x27; | &#x27;recentFiles&#x27;] : State[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再使用工具类进一步简化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type TopNavState = Pick&lt;State, &#x27;userId&#x27;, &#x27;pageTitle&#x27;, &#x27;rencentFiles&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>我们也可以利用 typeof 来进行类型传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getUserInfo(userId:string)&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    userId,</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    height,</span><br><span class="line">    weight,</span><br><span class="line">    favoriteColor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">type UserInfo = ReturnType&lt;typeof getUserInfo&gt;</span><br></pre></td></tr></table></figure>

<p>编写 utility type 时，多多使用 generic constraint 保证实例化时的类型安全</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123;</span><br><span class="line">    first: string;</span><br><span class="line">    last: string</span><br><span class="line">&#125;</span><br><span class="line">type Pick1&lt;T, K&gt;&#123;</span><br><span class="line">    [k in K]: T[k]</span><br><span class="line">&#125;</span><br><span class="line">type FirstLast = Pick1&lt;Name, &#x27;first&#x27;| &#x27;last&#x27;&gt;</span><br><span class="line">type FirstMiddle = Pick1&lt;Name, &#x27;first&#x27;, &#x27;middle&#x27;&gt; // 应该报错但没报错</span><br><span class="line">type Pick2&lt;T, K extends keyof T&gt; = &#123; // 添加泛型约束</span><br><span class="line">    [k in K]: T[K]</span><br><span class="line">&#125;</span><br><span class="line">type FirstMiddle = Pick2&lt;Name, &#x27;first&#x27;, &#x27;middle&#x27;&gt; // 正确的报错了</span><br></pre></td></tr></table></figure>

<h1 id="八、用-TypeScript-编写-React-的最佳实践"><a href="#八、用-TypeScript-编写-React-的最佳实践" class="headerlink" title="八、用 TypeScript 编写 React 的最佳实践"></a>八、用 TypeScript 编写 React 的最佳实践</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>React 的核心概念之一是组件。在这里，我们将引用 React v16.8 以后的标准组件，这意味着使用 Hook 而不是类的组件。</p>
<p>通常，一个基本的组件有很多需要关注的地方。让我们看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">// 函数声明式写法</span><br><span class="line">function Heading(): React.ReactNode &#123;</span><br><span class="line">  return &lt;h1&gt;My Website Heading&lt;/h1&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数扩展式写法</span><br><span class="line">const OtherHeading: React.FC = () =&gt; &lt;h1&gt;My Website Heading&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>注意这里的关键区别。在第一个例子中，我们使用函数声明式写法，我们注明了这个函数返回值是 <code>React.ReactNode</code> 类型。相反，第二个例子使用了一个函数表达式。因为第二个实例返回一个函数，而不是一个值或表达式，所以我们我们注明了这个函数返回值是 <code>React.FC</code> 类型。</p>
<p>记住这两种方式可能会让人混淆。这主要取决于设计选择。无论您选择在项目中使用哪个，都要始终如一地使用它。</p>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p>我们将介绍的下一个核心概念是 Props。你可以使用 interface 或 type 来定义 Props 。让我们看另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">interface Props &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type OtherProps = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Notice here we&#x27;re using the function declaration with the interface Props</span><br><span class="line">function Heading(&#123; name, color &#125;: Props): React.ReactNode &#123;</span><br><span class="line">  return &lt;h1&gt;My Website Heading&lt;/h1&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Notice here we&#x27;re using the function expression with the type OtherProps</span><br><span class="line">const OtherHeading: React.FC&lt;OtherProps&gt; = (&#123; name, color &#125;) =&gt;</span><br><span class="line">  &lt;h1&gt;My Website Heading&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>关于 interface 或 type ，我们建议遵循 react-typescript-cheatsheet 社区提出的准则：</p>
<ul>
<li>在编写库或第三方环境类型定义时，始终将 interface 用于公共 API 的定义。</li>
<li>考虑为你的 React 组件的 State 和 Props 使用 type ，因为它更受约束。”</li>
</ul>
<p>让我们再看一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">type Props = &#123;</span><br><span class="line">   /** color to use for the background */</span><br><span class="line">  color?: string;</span><br><span class="line">   /** standard children prop: accepts any valid React Node */</span><br><span class="line">  children: React.ReactNode;</span><br><span class="line">   /** callback function passed to the onClick handler*/</span><br><span class="line">  onClick: ()  =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Button: React.FC&lt;Props&gt; = (&#123; children, color = &#x27;tomato&#x27;, onClick &#125;) =&gt; &#123;</span><br><span class="line">   return &lt;button style=&#123;&#123; backgroundColor: color &#125;&#125; onClick=&#123;onClick&#125;&gt;&#123;children&#125;&lt;/button&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在此 <code>&lt;Button /&gt;</code> 组件中，我们为 Props 使用 type。每个 Props 上方都有简短的说明，以为其他开发人员提供更多背景信息。? 表示 Props 是可选的。<code>children props</code> 是一个 <code>React.ReactNode</code> 表示它还是一个 React 组件。</p>
<p>通常，在 React 和 TypeScript 项目中编写 Props 时，请记住以下几点：</p>
<ul>
<li>始终使用 TSDoc 标记为你的 Props 添加描述性注释 <code>/** comment */</code>。</li>
<li>无论你为组件 Props 使用 type 还是 interface ，都应始终使用它们。</li>
<li>如果 props 是可选的，请适当处理或使用默认值。</li>
</ul>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>幸运的是，当使用 Hook 时， TypeScript 类型推断工作得很好。这意味着你没有什么好担心的。举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// `value` is inferred as a string</span><br><span class="line">// `setValue` is inferred as (newValue: string) =&gt; void</span><br><span class="line">const [value, setValue] = useState(&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>TypeScript 推断出 useState 钩子给出的值。这是一个 React 和 TypeScript 协同工作的成果。</p>
<p>在极少数情况下，你需要使用一个空值初始化 Hook ，可以使用泛型并传递联合以正确键入 Hook 。查看此实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  email: string;</span><br><span class="line">  id: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// the generic is the &lt; &gt;</span><br><span class="line">// the union is the User | null</span><br><span class="line">// together, TypeScript knows, &quot;Ah, user can be User or null&quot;.</span><br><span class="line">const [user, setUser] = useState&lt;User | null&gt;(null);</span><br></pre></td></tr></table></figure>

<p>下面是一个使用 useReducer 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type AppState = &#123;&#125;;</span><br><span class="line">type Action =</span><br><span class="line">  | &#123; type: &quot;SET_ONE&quot;; payload: string &#125;</span><br><span class="line">  | &#123; type: &quot;SET_TWO&quot;; payload: number &#125;;</span><br><span class="line"></span><br><span class="line">export function reducer(state: AppState, action: Action): AppState &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &quot;SET_ONE&quot;:</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        one: action.payload // `payload` is string</span><br><span class="line">      &#125;;</span><br><span class="line">    case &quot;SET_TWO&quot;:</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        two: action.payload // `payload` is number</span><br><span class="line">      &#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，Hooks 并没有为 React 和 TypeScript 项目增加太多复杂性。</p>
<h2 id="常见用例"><a href="#常见用例" class="headerlink" title="常见用例"></a>常见用例</h2><h3 id="处理表单事件"><a href="#处理表单事件" class="headerlink" title="处理表单事件"></a>处理表单事件</h3><p>最常见的情况之一是 onChange 在表单的输入字段上正确键入使用的。这是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">const MyInput = () =&gt; &#123;</span><br><span class="line">  const [value, setValue] = React.useState(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">  // 事件类型是“ChangeEvent”</span><br><span class="line">  // 我们将 “HTMLInputElement” 传递给 input</span><br><span class="line">  function onChange(e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#123;</span><br><span class="line">    setValue(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &lt;input value=&#123;value&#125; onChange=&#123;onChange&#125; id=&quot;input-example&quot;/&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展组件的-Props"><a href="#扩展组件的-Props" class="headerlink" title="扩展组件的 Props"></a>扩展组件的 Props</h3><p>有时，你希望获取为一个组件声明的 Props，并对它们进行扩展，以便在另一个组件上使用它们。但是你可能想要修改一两个属性。还记得我们如何看待两种类型组件 Props、type 或 interface 的方法吗?取决于你使用的组件决定了你如何扩展组件 Props 。让我们先看看如何使用 type:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">type ButtonProps = &#123;</span><br><span class="line">    /** the background color of the button */</span><br><span class="line">    color: string;</span><br><span class="line">    /** the text to show inside the button */</span><br><span class="line">    text: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ContainerProps = ButtonProps &amp; &#123;</span><br><span class="line">    /** the height of the container (value used with &#x27;px&#x27;) */</span><br><span class="line">    height: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Container: React.FC&lt;ContainerProps&gt; = (&#123; color, height, width, text &#125;) =&gt; &#123;</span><br><span class="line">  return &lt;div style=&#123;&#123; backgroundColor: color, height: `$&#123;height&#125;px` &#125;&#125;&gt;&#123;text&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你使用 interface 来声明 props，那么我们可以使用关键字 extends 从本质上“扩展”该接口，但要进行一些修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">interface ButtonProps &#123;</span><br><span class="line">    /** the background color of the button */</span><br><span class="line">    color: string;</span><br><span class="line">    /** the text to show inside the button */</span><br><span class="line">    text: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ContainerProps extends ButtonProps &#123;</span><br><span class="line">    /** the height of the container (value used with &#x27;px&#x27;) */</span><br><span class="line">    height: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Container: React.FC&lt;ContainerProps&gt; = (&#123; color, height, width, text &#125;) =&gt; &#123;</span><br><span class="line">  return &lt;div style=&#123;&#123; backgroundColor: color, height: `$&#123;height&#125;px` &#125;&#125;&gt;&#123;text&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方法都可以解决问题。由您决定使用哪个。就个人而言，扩展 interface 更具可读性，但最终取决于你和你的团队。</p>
<h1 id="九、编译上下文"><a href="#九、编译上下文" class="headerlink" title="九、编译上下文"></a>九、编译上下文</h1><h2 id="tsconfig-json-的作用"><a href="#tsconfig-json-的作用" class="headerlink" title="tsconfig.json 的作用"></a>tsconfig.json 的作用</h2><ul>
<li>用于标识 TypeScript 项目的根路径；</li>
<li>用于配置 TypeScript 编译器；</li>
<li>用于指定编译的文件。</li>
</ul>
<h2 id="tsconfig-json-重要字段"><a href="#tsconfig-json-重要字段" class="headerlink" title="tsconfig.json 重要字段"></a>tsconfig.json 重要字段</h2><ul>
<li>files - 设置要编译的文件的名称；</li>
<li>include - 设置需要进行编译的文件，支持路径模式匹配；</li>
<li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li>
<li>compilerOptions - 设置与编译流程相关的选项。</li>
</ul>
<h2 id="compilerOptions-选项"><a href="#compilerOptions-选项" class="headerlink" title="compilerOptions 选项"></a>compilerOptions 选项</h2><p>compilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。</p>
<p>compilerOptions 每个选项的详细说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    /* 基本选项 */</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br><span class="line">    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件</span><br><span class="line">    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件</span><br><span class="line">    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误</span><br><span class="line">    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br><span class="line">    &quot;declaration&quot;: true,                   // 生成相应的 &#x27;.d.ts&#x27; 文件</span><br><span class="line">    &quot;sourceMap&quot;: true,                     // 生成相应的 &#x27;.map&#x27; 文件</span><br><span class="line">    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件</span><br><span class="line">    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录</span><br><span class="line">    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.</span><br><span class="line">    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释</span><br><span class="line">    &quot;noEmit&quot;: true,                        // 不生成输出文件</span><br><span class="line">    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数</span><br><span class="line">    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><span class="line"></span><br><span class="line">    /* 严格的类型检查选项 */</span><br><span class="line">    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项</span><br><span class="line">    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错</span><br><span class="line">    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查</span><br><span class="line">    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误</span><br><span class="line">    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><span class="line"></span><br><span class="line">    /* 额外的检查 */</span><br><span class="line">    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误</span><br><span class="line">    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误</span><br><span class="line">    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误</span><br><span class="line">    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><span class="line"></span><br><span class="line">    /* 模块解析选项 */</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br><span class="line">    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录</span><br><span class="line">    &quot;paths&quot;: &#123;&#125;,                           // 模块名到基于 baseUrl 的路径映射的列表</span><br><span class="line">    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br><span class="line">    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表</span><br><span class="line">    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br><span class="line">    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置</span><br><span class="line">    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br><span class="line">    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><span class="line"></span><br><span class="line">    /* 其他选项 */</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,        // 启用装饰器</span><br><span class="line">    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tsconfig.json 配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;, // 指定 ECMAScript 版本</span><br><span class="line">    &quot;lib&quot;: [</span><br><span class="line">      &quot;dom&quot;,</span><br><span class="line">      &quot;dom.iterable&quot;,</span><br><span class="line">      &quot;esnext&quot;</span><br><span class="line">    ], // 要包含在编译中的依赖库文件列表</span><br><span class="line">    &quot;allowJs&quot;: true, // 允许编译 JavaScript 文件</span><br><span class="line">    &quot;skipLibCheck&quot;: true, // 跳过所有声明文件的类型检查</span><br><span class="line">    &quot;esModuleInterop&quot;: true, // 禁用命名空间引用 (import * as fs from &quot;fs&quot;) 启用 CJS/AMD/UMD 风格引用 (import fs from &quot;fs&quot;)</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true, // 允许从没有默认导出的模块进行默认导入</span><br><span class="line">    &quot;strict&quot;: true, // 启用所有严格类型检查选项</span><br><span class="line">    &quot;forceConsistentCasingInFileNames&quot;: true, // 不允许对同一个文件使用不一致格式的引用</span><br><span class="line">    &quot;module&quot;: &quot;esnext&quot;, // 指定模块代码生成</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;, // 使用 Node.js 风格解析模块</span><br><span class="line">    &quot;resolveJsonModule&quot;: true, // 允许使用 .json 扩展名导入的模块</span><br><span class="line">    &quot;noEmit&quot;: true, // 不输出(意思是不编译代码，只执行类型检查)</span><br><span class="line">    &quot;jsx&quot;: &quot;react&quot;, // 在.tsx文件中支持JSX</span><br><span class="line">    &quot;sourceMap&quot;: true, // 生成相应的.map文件</span><br><span class="line">    &quot;declaration&quot;: true, // 生成相应的.d.ts文件</span><br><span class="line">    &quot;noUnusedLocals&quot;: true, // 报告未使用的本地变量的错误</span><br><span class="line">    &quot;noUnusedParameters&quot;: true, // 报告未使用参数的错误</span><br><span class="line">    &quot;experimentalDecorators&quot;: true, // 启用对ES装饰器的实验性支持</span><br><span class="line">    &quot;incremental&quot;: true, // 通过从以前的编译中读取/写入信息到磁盘上的文件来启用增量编译</span><br><span class="line">    &quot;noFallthroughCasesInSwitch&quot;: true </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;src/**/*&quot; // *** TypeScript文件应该进行类型检查 ***</span><br><span class="line">  ],</span><br><span class="line">  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;build&quot;] // *** 不进行类型检查的文件 ***</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="十、参考资料"><a href="#十、参考资料" class="headerlink" title="十、参考资料"></a>十、参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1641493?from=article.detail.1595718">了不起的 TypeScript 入门教程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.staleclosure.com/effective-typescript/">Effective Typescript</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40906515/article/details/106798727">用 TypeScript 编写 React 的最佳实践</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1595718">TypeScript keyof 操作符</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"># javascript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/16/Vue3%E6%9C%80%E6%96%B0%E7%9A%8415%E4%B8%AA%E5%B8%B8%E7%94%A8Api/" rel="prev" title="Vue3最新的15个常用Api">
      <i class="fa fa-chevron-left"></i> Vue3最新的15个常用Api
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/12/16/angular%E5%92%8Cvue%E8%BF%98%E6%9C%89jquery%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="next" title="angular和vue还有jquery的区别">
      angular和vue还有jquery的区别 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Enum-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">一、Enum 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B0%E5%AD%97%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.1.</span> <span class="nav-text">1.数字枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.2.</span> <span class="nav-text">2.字符串枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BC%82%E6%9E%84%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.3.</span> <span class="nav-text">3.异构枚举</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">二、特殊数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Unknown-%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">1. Unknown 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Never-%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">2. Never 类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Typescript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.</span> <span class="nav-text">三、Typescript 的类型系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BA%86%E8%A7%A3-type-%E5%92%8C-interface-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">四、了解 type 和 interface 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81keyof-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">五、keyof 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#keyof-%E7%AE%80%E4%BB%8B"><span class="nav-number">5.1.</span> <span class="nav-text">keyof 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keyof-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">keyof 的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keyof-%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E5%80%BC%E5%B1%9E%E6%80%A7"><span class="nav-number">5.3.</span> <span class="nav-text">keyof 与对象的数值属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keyof-%E4%B8%8E-typeof-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.4.</span> <span class="nav-text">keyof 与 typeof 操作符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81TypeScript-%E6%B3%9B%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">六、TypeScript 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.1.</span> <span class="nav-text">泛型接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">6.2.</span> <span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="nav-number">6.3.</span> <span class="nav-text">泛型变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.4.</span> <span class="nav-text">泛型工具类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E9%81%BF%E5%85%8D%E5%86%97%E4%BD%99%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0"><span class="nav-number">7.</span> <span class="nav-text">七、充分利用泛型和类型运算避免冗余类型标记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E7%94%A8-TypeScript-%E7%BC%96%E5%86%99-React-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">8.</span> <span class="nav-text">八、用 TypeScript 编写 React 的最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6"><span class="nav-number">8.1.</span> <span class="nav-text">组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Props"><span class="nav-number">8.2.</span> <span class="nav-text">Props</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hooks"><span class="nav-number">8.3.</span> <span class="nav-text">Hooks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E4%BE%8B"><span class="nav-number">8.4.</span> <span class="nav-text">常见用例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="nav-number">8.4.1.</span> <span class="nav-text">处理表单事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6%E7%9A%84-Props"><span class="nav-number">8.4.2.</span> <span class="nav-text">扩展组件的 Props</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E7%BC%96%E8%AF%91%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">9.</span> <span class="nav-text">九、编译上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tsconfig-json-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">9.1.</span> <span class="nav-text">tsconfig.json 的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tsconfig-json-%E9%87%8D%E8%A6%81%E5%AD%97%E6%AE%B5"><span class="nav-number">9.2.</span> <span class="nav-text">tsconfig.json 重要字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#compilerOptions-%E9%80%89%E9%A1%B9"><span class="nav-number">9.3.</span> <span class="nav-text">compilerOptions 选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">9.4.</span> <span class="nav-text">十、参考资料</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Chen"
      src="/images/portal.jpg">
  <p class="site-author-name" itemprop="name">Bruce Chen</p>
  <div class="site-description" itemprop="description">It's better to burn out than to fade away.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1440429303&auto=1&height=66"></iframe>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jschentt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jschentt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jschentt@gmail.com" title="E-Mail → mailto:jschentt@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/BruceCh56742806" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;BruceCh56742806" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/jinsheng.chen.5439" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;jinsheng.chen.5439" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
  </div>





      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
