<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="文章结构：  React 中的虚拟 DOM 是什么？ 虚拟 DOM 的简单实现（diff 算法） 虚拟 DOM 的内部工作原理 React 中的虚拟 DOM 与 Vue 中的虚拟 DOM 比较  React 中的虚拟 DOM 是什么？虽然 React 中的虚拟 DOM 很好用，但是这是一个无心插柳的结果。 React 的核心思想：一个 Component 拯救世界，忘掉烦恼，从此不再操心界面。 1">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解react中的虚拟DOM、diff算法">
<meta property="og:url" content="http://example.com/2022/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E3%80%81diff%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Bruce Chen&#39;s Blog">
<meta property="og:description" content="文章结构：  React 中的虚拟 DOM 是什么？ 虚拟 DOM 的简单实现（diff 算法） 虚拟 DOM 的内部工作原理 React 中的虚拟 DOM 与 Vue 中的虚拟 DOM 比较  React 中的虚拟 DOM 是什么？虽然 React 中的虚拟 DOM 很好用，但是这是一个无心插柳的结果。 React 的核心思想：一个 Component 拯救世界，忘掉烦恼，从此不再操心界面。 1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170801225429255-521935350.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830091841171-1021895840.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830101420718-2040904880.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830101733202-1167202046.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830102245702-1187605690.png">
<meta property="article:published_time" content="2022-10-24T08:35:00.000Z">
<meta property="article:modified_time" content="2022-11-08T08:04:38.781Z">
<meta property="article:author" content="Bruce Chen">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170801225429255-521935350.png">

<link rel="canonical" href="http://example.com/2022/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E3%80%81diff%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入理解react中的虚拟DOM、diff算法 | Bruce Chen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
    <a target="_blank" rel="noopener" href="https://github.com/jschentt" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bruce Chen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">quick notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">83</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E3%80%81diff%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解react中的虚拟DOM、diff算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:35:00" itemprop="dateCreated datePublished" datetime="2022-10-24T16:35:00+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>文章结构：</p>
<ul>
<li>React 中的虚拟 DOM 是什么？</li>
<li>虚拟 DOM 的简单实现（diff 算法）</li>
<li>虚拟 DOM 的内部工作原理</li>
<li>React 中的虚拟 DOM 与 Vue 中的虚拟 DOM 比较</li>
</ul>
<h2 id="React-中的虚拟-DOM-是什么？"><a href="#React-中的虚拟-DOM-是什么？" class="headerlink" title="React 中的虚拟 DOM 是什么？"></a>React 中的虚拟 DOM 是什么？</h2><p>虽然 React 中的虚拟 DOM 很好用，但是这是一个无心插柳的结果。</p>
<p><strong>React 的核心思想：一个 Component 拯救世界，忘掉烦恼，从此不再操心界面</strong>。</p>
<h3 id="1-Virtual-Dom-快，有两个前提"><a href="#1-Virtual-Dom-快，有两个前提" class="headerlink" title="1. Virtual Dom 快，有两个前提"></a>1. Virtual Dom 快，有两个前提</h3><h4 id="1-1-Javascript-很快"><a href="#1-1-Javascript-很快" class="headerlink" title="1.1 Javascript 很快"></a>1.1 Javascript 很快</h4><p><strong>Chrome 刚出来的时候，在 Chrome 里跑 Javascript 非常快，给了其它浏览器很大压力</strong>。而现在经过几轮你追我赶，各主流浏览器的 Javascript 执行速度都很快了。</p>
<p>在 <a target="_blank" rel="noopener" href="https://julialang.org/benchmarks/">https://julialang.org/benchmarks/</a> 这个网站上，我们可以看到，JavaScript 语言已经非常快了，和 C 就是几倍的关系，和 java 在同一个量级。<strong>所以说，单纯的 JavaScript 还是很快的。</strong></p>
<h4 id="1-2-Dom-很慢"><a href="#1-2-Dom-很慢" class="headerlink" title="1.2 Dom 很慢"></a>1.2 Dom 很慢</h4><p>当创建一个元素比如 div，有以下几项内容需要实现： <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement">HTML element</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element">Element</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers">GlobalEventHandler</a>。简单的说，就是插入一个 Dom 元素的时候，这个元素上本身或者继承很多属性如 width、height、offsetHeight、style、title，另外还需要注册这个元素的诸多方法，比如 onfocus、onclick 等等。 这还只是一个元素，如果元素比较多的时候，还涉及到嵌套，那么元素的属性和方法等等就会很多，效率很低。</p>
<p>比如，我们在一个空白网页的 body 中添加一个 div 元素，如下所示：</p>
<p><img src="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170801225429255-521935350.png" alt="image"></p>
<p>这个元素<strong>会挂载默认的 styles、得到这个元素的 computed 属性、注册相应的 Event Listener、DOM Breakpoints 以及大量的 properties，这些属性、方法的注册肯定是需要耗费大量时间的</strong>。</p>
<p>尤其是在 js 操作 DOM 的过程中，不仅有 dom 本身的繁重，js 的操作也需要浪费时间，我们认为 js 和 DOM 之间有一座桥，如果你频繁的在桥两边走动，显然效率是很低的，<strong>如果你的 JavaScript 操作 DOM 的方式还非常不合理，那么显然就会更糟糕了</strong>。</p>
<p><strong>而 React 的虚拟 DOM 就是解决这个问题的！</strong> 虽然它解决不了 DOM 自身的繁重，但是<strong>虚拟 DOM 可以对 JavaScript 操作 DOM 这一部分内容进行优化</strong>。</p>
<p>比如说，现在你的 list 是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;0&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>你希望把它变成下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;6&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;7&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;8&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;9&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;10&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>



<p><strong>通常的操作是什么?</strong></p>
<p>先把 0， 1，2，3 这些 Element 删掉，然后加几个新的 Element 6，7，8，9，10 进去，这里面就有 4 次 Element 删除，5 次 Element 添加。共计 9 次 DOM 操作。</p>
<p><strong>那 React 的虚拟 DOM 可以怎么做呢？</strong></p>
<p>而 React 会把这两个做一下 Diff，然后发现其实不用删除 0，1，2，3，而是可以直接改 innerHTML，然后只需要添加一个 Element（10）就行了，这样就是 4 次 innerHTML 操作加 1 个 Element 添加。<strong>共计 5 次操作，这样效率的提升是非常可观的。</strong></p>
<h3 id="2、-关于-React"><a href="#2、-关于-React" class="headerlink" title="2、 关于 React"></a>2、 关于 React</h3><h4 id="2-1-接口和设计"><a href="#2-1-接口和设计" class="headerlink" title="2.1 接口和设计"></a>2.1 接口和设计</h4><p><strong>在 React 的设计中，是完全不需要你来操作 DOM 的。我们也可以认为，在 React 中根本就没有 DOM 这个概念，有的只是 Component。</strong></p>
<p>当你写好一个 Component 以后，Component 会完全负责 UI，你不需要也不应该去也不能够指挥 Component 怎么显示，你只能告诉它你想要显示一个香蕉还是两个梨。</p>
<p><strong>隔离 DOM 并不仅仅是因为 DOM 慢，而也是为了把界面和业务完全隔离，操作数据的只关心数据，操作界面的只关心界面</strong>。比如在 websocket 聊天室的创建房间时，我们可以首先把 Component 写好，然后当获取到数据的时候，只要把数据放在 redux 中就好，然后 Component 就自动把房间添加到页面中去，而不是你先拿到数据，然后使用 js 操作 DOM 把数据显示在页面上。</p>
<p>即<strong>我提供一个 Component，然后你只管给我数据，界面的事情完全不用你操心，我保证会把界面变成你想要的样子。所以说 React 的着力点就在于 View 层，即 React 专注于 View 层</strong>。你可以把一个 React 的 Component 想象成一个 Pure Function，只要你给的数据是[1, 2, 3]，我保证显示的是[1, 2, 3]。没有什么删除一个 Element，添加一个 Element 这样的事情。NO。你要我显示什么就给我一个完整的列表。</p>
<p>另外，Flux 虽然说的是单向的 Data Flow(redux 也是)，但是实际上就是单向的 Observer，Store-&gt;View-&gt;Action-&gt;Store（箭头是数据流向，实现上可以理解为 View 监听 Store，View 直接 trigger action，然后 Store 监听 Action）。</p>
<h4 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h4><p>那么 react 如何实现呢？ 最简单的方法就是当数据变化时，我直接把原先的 DOM 卸载，然后把最新数据的 DOM 替换上去。 但是，虚拟 DOM 哪去了？ 这样做的效率显然是极低的。</p>
<p>所以虚拟 DOM 就来救场了。</p>
<p>那么虚拟 DOM 和 DOM 之间的关系是什么呢？</p>
<p>首先，Virtual DOM 并没有完全实现 DOM，即虚拟 DOM 和真正地 DOM 是不一样的，Virtual DOM 最主要的还是保留了 Element 之间的层次关系和一些基本属性。因为真实 DOM 实在是太复杂，一个空的 Element 都复杂得能让你崩溃，并且几乎所有内容我根本不关心好吗。所以 Virtual DOM 里每一个 Element 实际上只有几个属性，即最重要的，最为有用的，并且没有那么多乱七八糟的引用，比如一些注册的属性和函数啊，这些都是默认的，创建虚拟 DOM 进行 diff 的过程中大家都一致，是不需要进行比对的。所以哪怕是直接把 Virtual DOM 删了，根据新传进来的数据重新创建一个新的 Virtual DOM 出来都非常非常非常快。（每一个 component 的 render 函数就是在做这个事情，给新的 virtual dom 提供 input）。</p>
<p>所以，引入了 Virtual DOM 之后，React 是这么干的：你给我一个数据，我根据这个数据生成一个全新的 Virtual DOM，然后跟我上一次生成的 Virtual DOM 去 diff，得到一个 Patch，然后把这个 Patch 打到浏览器的 DOM 上去。完事。并且这里的 patch 显然不是完整的虚拟 DOM，而是新的虚拟 DOM 和上一次的虚拟 DOM 经过 diff 后的差异化的部分。</p>
<p>假设在任意时候有，VirtualDom1 &#x3D;&#x3D; DOM1 （组织结构相同, 显然虚拟 DOM 和真实 DOM 是不可能完全相等的，这里的&#x3D;&#x3D;是 js 中非完全相等）。当有新数据来的时候，我生成 VirtualDom2，然后去和 VirtualDom1 做 diff，得到一个 Patch（差异化的结果）。然后将这个 Patch 去应用到 DOM1 上，得到 DOM2。如果一切正常，那么有 VirtualDom2 &#x3D;&#x3D; DOM2（同样是结构上的相等）。</p>
<p>这里你可以做一些小实验，去破坏 VirtualDom1 &#x3D;&#x3D; DOM1 这个假设（手动在 DOM 里删除一些 Element，这时候 VirtualDom 里的 Element 没有被删除，所以两边不一样了）。<br>然后给新的数据，你会发现生成的界面就不是你想要的那个界面了。</p>
<p>最后，回到为什么 Virtual Dom 快这个问题上。<br>其实是由于每次生成 virtual dom 很快，diff 生成 patch 也比较快，而在对 DOM 进行 patch 的时候，虽然 DOM 的变更比较慢，但是 React 能够根据 Patch 的内容，优化一部分 DOM 操作，比如之前的那个例子。</p>
<p>重点就在最后，哪怕是我生成了 virtual dom(需要耗费时间)，哪怕是我跑了 diff（还需要花时间），但是我根据 patch 简化了那些 DOM 操作省下来的时间依然很可观（这个就是时间差的问题了，即节省下来的时间 &gt; 生成 virtual dom 的时间 + diff 时间）。所以总体上来说，还是比较快。</p>
<p>简单发散一下思路，如果哪一天，DOM 本身的操作已经非常非常非常快了，并且我们手动对于 DOM 的操作都是精心设计优化过后的，那么加上了 VirtualDom 还会快吗？<br>当然不行了，毕竟你多做了这么多额外的工作。</p>
<pre><code>    但是那一天会来到吗？
    诶，大不了到时候不用Virtual DOM。
</code></pre>
<p>注： 此部分内容整理自：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/29504639/answer/44680878">https://www.zhihu.com/question/29504639/answer/44680878</a></p>
<h2 id="虚拟-DOM-的简单实现（diff-算法）"><a href="#虚拟-DOM-的简单实现（diff-算法）" class="headerlink" title="虚拟 DOM 的简单实现（diff 算法）"></a>虚拟 DOM 的简单实现（diff 算法）</h2><p>目录</p>
<ul>
<li>1 前言</li>
<li>2 对前端应用状态管理思考</li>
<li>3 Virtual DOM 算法</li>
<li>4 算法实现<ul>
<li>4.1 步骤一：用 JS 对象模拟 DOM 树</li>
<li>4.2 步骤二：比较两棵虚拟 DOM 树的差异</li>
<li>4.3 步骤三：把差异应用到真正的 DOM 树上</li>
</ul>
</li>
<li>5 结语</li>
</ul>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上面一部分中，我们已经简单介绍了虚拟 DOM 的答题思路和好处，这里我们将通过自己写一个虚拟 DOM 来加深对其的理解，有一些自己的思考。</p>
<h3 id="对前端应用状态管理思考"><a href="#对前端应用状态管理思考" class="headerlink" title="对前端应用状态管理思考"></a>对前端应用状态管理思考</h3><p>维护状态，更新视图。</p>
<h3 id="虚拟-DOM-算法"><a href="#虚拟-DOM-算法" class="headerlink" title="虚拟 DOM 算法"></a>虚拟 DOM 算法</h3><p>DOM 是很慢的，如果我们创建一个简单的 div，然后把他的所有的属性都打印出来，你会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var div = document.createElement(&#x27;div&#x27;),</span><br><span class="line">    str = &#x27;&#x27;;</span><br><span class="line">for (var key in div) &#123;</span><br><span class="line">  str = str + &#x27; &#x27; + key;</span><br><span class="line">&#125;</span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure>

<p><img src="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830091841171-1021895840.png" alt="image"></p>
<p>可以看到，这些属性还是非常惊人的，包括样式的修饰特性、一般的特性、方法等等，如果我们打印出其长度，可以得到惊人的 227 个。<br>而这仅仅是一层，真正的 DOM 元素是非常庞大的，这是因为标准就是这么设计的，而且操作他们的时候你要小心翼翼，轻微的触碰就有可能导致页面发生重排，这是杀死性能的罪魁祸首。</p>
<p>而相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单，DOM 树上的结构信息我们都可以使用 JavaScript 对象很容易的表示出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var element = &#123;</span><br><span class="line">      tagName: &#x27;ul&#x27;,</span><br><span class="line">      props: &#123;</span><br><span class="line">        id: &#x27;list&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      children: &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          tagName: &#x27;li&#x27;,</span><br><span class="line">          props: &#123;</span><br><span class="line">            class: &#x27;item&#x27;</span><br><span class="line">          &#125;,</span><br><span class="line">          children: [&#x27;Item1&#x27;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          tagName: &#x27;li&#x27;,</span><br><span class="line">          props: &#123;</span><br><span class="line">            class: &#x27;item&#x27;</span><br><span class="line">          &#125;,</span><br><span class="line">          children: [&#x27;Item1&#x27;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          tagName: &#x27;li&#x27;,</span><br><span class="line">          props: &#123;</span><br><span class="line">            class: &#x27;item&#x27;</span><br><span class="line">          &#125;,</span><br><span class="line">          children: [&#x27;Item1&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，对于一个元素，我们只需要一个 JavaScript 对象就可以很容易的表示出来，这个对象中有三个属性:</p>
<ol>
<li>tagName: 用来表示这个元素的标签名。</li>
<li>props: 用来表示这元素所包含的属性。</li>
<li>children: 用来表示这元素的 children。</li>
</ol>
<p>而上面的这个对象使用 HTML 表示就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&#x27;list&#x27;&gt;</span><br><span class="line">  &lt;li class=&#x27;item&#x27;&gt;Item 1&lt;/li&gt;</span><br><span class="line">  &lt;li class=&#x27;item&#x27;&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;li class=&#x27;item&#x27;&gt;Item 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>



<p>OK! 既然原来的 DOM 信息可以使用 JavaScript 来表示，那么反过来，我们就可以用这个 JavaScript 对象来构建一个真正的 DOM 树。</p>
<p>所以之前所说的状态变更的时候会重新构建这个 JavaScript 对象，然后呢，用新渲染的对象和旧的对象去对比， 记录两棵树的差异，记录下来的就是我们需要改变的地方。 这就是所谓的虚拟 DOM，包括下面的几个步骤：</p>
<ol>
<li>用 JavaScript 对象来表示 DOM 树的结构； 然后用这个树构建一个真正的 DOM 树，插入到文档中。</li>
<li>当状态变更的时候，重新构造一个新的对象树，然后用这个新的树和旧的树作对比，记录两个树的差异。</li>
<li>把 2 所记录的差异应用在步骤一所构建的真正的 DOM 树上，视图就更新了。</li>
</ol>
<p>Virtual DOM 的本质就是在 JS 和 DOM 之间做一个缓存，可以类比 CPU 和硬盘，既然硬盘这么慢，我们就也在他们之间添加一个缓存； 既然 DOM 这么慢，我们就可以在 JS 和 DOM 之间添加一个缓存。 CPU（JS）只操作内存（虚拟 DOM），最后的时候在把变更写入硬盘（DOM）。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="1、-用-JavaScript-对象模拟-DOM-树"><a href="#1、-用-JavaScript-对象模拟-DOM-树" class="headerlink" title="1、 用 JavaScript 对象模拟 DOM 树"></a>1、 用 JavaScript 对象模拟 DOM 树</h4><p>用 JavaScript 对象来模拟一个 DOM 节点并不难，你只需要记录他的节点类型（tagName）、属性（props）、子节点（children）。</p>
<p>element.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Element(tagName, props, children) &#123;</span><br><span class="line">  this.tagName = tagName;</span><br><span class="line">  this.props = props;</span><br><span class="line">  this.children = children;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = function (tagName, props, children) &#123;</span><br><span class="line">   return new Element(tagName, props, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个构造函数，我们就可以传入标签名、属性以及子节点了，tagName 可以在我们 render 的时候直接根据它来创建真实的元素，这里的 props 使用一个对象传入，可以方便我们遍历。</p>
<p>基本使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var el = require(&#x27;./element&#x27;);</span><br><span class="line"></span><br><span class="line">var ul = el(&#x27;ul&#x27;, &#123;id: &#x27;list&#x27;&#125;, [</span><br><span class="line">    el(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item1&#x27;]),</span><br><span class="line">    el(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item2&#x27;]),</span><br><span class="line">    el(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item3&#x27;])</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>然而，现在的 ul 只是 JavaScript 表示的一个 DOM 结构，页面上并没有这个结构，所有我们可以根据 ul 构建一个真正的<code>&lt;ul&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.render = function () &#123;</span><br><span class="line">      // 根据tagName创建一个真实的元素</span><br><span class="line">      var el = document.createElement(this.tagName);</span><br><span class="line">      // 得到这个元素的属性对象，方便我们遍历。</span><br><span class="line">      var props = this.props;</span><br><span class="line"></span><br><span class="line">      for (var propName in props) &#123;</span><br><span class="line">        // 获取到这个元素值</span><br><span class="line">        var propValue = props[propName];</span><br><span class="line"></span><br><span class="line">        // 通过setAttribute设置元素属性。</span><br><span class="line">        el.setAttribute(propName, propValue);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 注意： 这里的children，我们传入的是一个数组，所以，children不存在时我们用【】来替代。</span><br><span class="line">      var children = this.children || [];</span><br><span class="line"></span><br><span class="line">      //遍历children</span><br><span class="line">      children.forEach(function (child) &#123;</span><br><span class="line">        var childEl = (child instanceof Element)</span><br><span class="line">                      ? child.render()</span><br><span class="line">                      : document.createTextNode(child);</span><br><span class="line">        // 无论childEl是元素还是文字节点，都需要添加到这个元素中。</span><br><span class="line">        el.appendChild(childEl);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      return el;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以，render 方法会根据 tagName 构建一个真正的 DOM 节点，然后设置这个节点的属性，最后递归的把自己的子节点也构建起来，所以只需要调用 ul 的 render 方法，通过 document.body.appendChild 就可以挂载到真实的页面上了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;div&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line"></span><br><span class="line">    function Element(tagName, props, children) &#123;</span><br><span class="line">      this.tagName = tagName;</span><br><span class="line">      this.props = props;</span><br><span class="line">      this.children = children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    var ul = new Element(&#x27;ul&#x27;, &#123;id: &#x27;list&#x27;&#125;, [</span><br><span class="line">        new Element(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item1&#x27;]),</span><br><span class="line">        new Element(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item2&#x27;]),</span><br><span class="line">        new Element(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item3&#x27;])</span><br><span class="line">      ]);</span><br><span class="line"></span><br><span class="line">    Element.prototype.render = function () &#123;</span><br><span class="line">      // 根据tagName创建一个真实的元素</span><br><span class="line">      var el = document.createElement(this.tagName);</span><br><span class="line">      // 得到这个元素的属性对象，方便我们遍历。</span><br><span class="line">      var props = this.props;</span><br><span class="line"></span><br><span class="line">      for (var propName in props) &#123;</span><br><span class="line">        // 获取到这个元素值</span><br><span class="line">        var propValue = props[propName];</span><br><span class="line"></span><br><span class="line">        // 通过setAttribute设置元素属性。</span><br><span class="line">        el.setAttribute(propName, propValue);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 注意： 这里的children，我们传入的是一个数组，所以，children不存在时我们用【】来替代。</span><br><span class="line">      var children = this.children || [];</span><br><span class="line"></span><br><span class="line">      //遍历children</span><br><span class="line">      children.forEach(function (child) &#123;</span><br><span class="line">        var childEl = (child instanceof Element)</span><br><span class="line">                      ? child.render()</span><br><span class="line">                      : document.createTextNode(child);</span><br><span class="line">        // 无论childEl是元素还是文字节点，都需要添加到这个元素中。</span><br><span class="line">        el.appendChild(childEl);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      return el;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var ulRoot = ul.render();</span><br><span class="line">    document.body.appendChild(ulRoot);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>上面的这段代码，就可以渲染出下面的结果了：</p>
<p><img src="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830101420718-2040904880.png" alt="image"></p>
<h4 id="2、比较两颗虚拟-DOM-树的差异"><a href="#2、比较两颗虚拟-DOM-树的差异" class="headerlink" title="2、比较两颗虚拟 DOM 树的差异"></a>2、比较两颗虚拟 DOM 树的差异</h4><p>比较两颗 DOM 树的差异是 Virtual DOM 算法中最为核心的部分，这也就是所谓的 Virtual DOM 的 diff 算法。 两个树的完全的 diff 算法是一个时间复杂度为 O(n3) 的问题。 但是在前端中，你会很少跨层地移动 DOM 元素，所以真实的 DOM 算法会对同一个层级的元素进行对比。</p>
<p><img src="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830101733202-1167202046.png" alt="image"></p>
<p>上图中，div 只会和同一层级的 div 对比，第二层级的只会和第二层级对比。 这样算法复杂度就可以达到 O(n)。</p>
<p><strong>（1）深度遍历优先，记录差异</strong></p>
<p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每一个节点就会有一个唯一的标记：</p>
<p><img src="https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830102245702-1187605690.png" alt="image"></p>
<p>上面的这个遍历过程就是深度优先，即深度完全完成之后，再转移位置。 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比，如果有差异的话就记录到一个对象里面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// diff函数，对比两颗树</span><br><span class="line">function diff(oldTree, newTree) &#123;</span><br><span class="line">  // 当前的节点的标志。因为在深度优先遍历的过程中，每个节点都有一个index。</span><br><span class="line">  var index = 0;</span><br><span class="line"></span><br><span class="line">  // 在遍历到每个节点的时候，都需要进行对比，找到差异，并记录在下面的对象中。</span><br><span class="line">  var pathches = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  // 开始进行深度优先遍历</span><br><span class="line">  dfsWalk(oldTree, newTree, index, pathches);</span><br><span class="line"></span><br><span class="line">  // 最终diff算法返回的是一个两棵树的差异。</span><br><span class="line">  return pathches;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对两棵树进行深度优先遍历。</span><br><span class="line">function dfsWalk(oldNode, newNode, index, pathches) &#123;</span><br><span class="line">  // 对比oldNode和newNode的不同，记录下来</span><br><span class="line">  pathches[index] = [...];</span><br><span class="line"></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, index, pathches);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历子节点</span><br><span class="line">function diffChildren(oldChildren, newChildren, index, pathches) &#123;</span><br><span class="line">  var leftNode = null;</span><br><span class="line">  var currentNodeIndex = index;</span><br><span class="line">  oldChildren.forEach(function (child, i) &#123;</span><br><span class="line">    var newChild = newChildren[i];</span><br><span class="line">    currentNodeIndex = (leftNode &amp;&amp; leftNode.count)</span><br><span class="line">    ? currentNodeIndex + leftNode.count + 1</span><br><span class="line">    : currentNodeIndex + 1</span><br><span class="line"></span><br><span class="line">    // 深度遍历子节点</span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, pathches);</span><br><span class="line">    leftNode = child;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，上面的 div 和新的 div 有差异，当前的标记是 0， 那么我们可以使用数组来存储新旧节点的不同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...]</span><br></pre></td></tr></table></figure>

<p>同理使用 patches[1]来记录 p，使用 patches[3]来记录 ul，以此类推。</p>
<p><strong>（2）差异类型</strong></p>
<p>上面说的节点的差异指的是什么呢？ 对 DOM 操作可能会：</p>
<ol>
<li>替换原来的节点，如把上面的 div 换成了 section。</li>
<li>移动、删除、新增子节点， 例如上面 div 的子节点，把 p 和 ul 顺序互换。</li>
<li>修改了节点的属性。</li>
<li>对于文本节点，文本内容可能会改变。 例如修改上面的文本内容 2 内容为 Virtual DOM2.<br>　　所以，我们可以定义下面的几种类型：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var REPLACE = 0;</span><br><span class="line">var REORDER = 1;</span><br><span class="line">var PROPS = 2;</span><br><span class="line">var TEXT = 3;</span><br></pre></td></tr></table></figure>

<p>对于节点替换，很简单，判断新旧节点的 tagName 是不是一样的，如果不一样的说明需要替换掉。 如 div 换成了 section，就记录下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">  type: REPALCE,</span><br><span class="line">  node: newNode // el(&#x27;section&#x27;, props, children)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>除此之外，如果给 div 新增了属性 id 为 container，就记录下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pathches[0] = [</span><br><span class="line">  &#123;</span><br><span class="line">    type: REPLACE,</span><br><span class="line">    node: newNode</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: PROPS,</span><br><span class="line">    props: &#123;</span><br><span class="line">      id: &#x27;container&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果是文本节点发生了变化，那么就记录下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pathches[2] = [</span><br><span class="line">  &#123;</span><br><span class="line">    type:  TEXT,</span><br><span class="line">    content: &#x27;virtual DOM2&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>那么如果我们把 div 的子节点重新排序下了呢？ 比如 p、ul、div 的顺序换成了 div、p、ul，那么这个该怎么对比呢？ 如果按照同级进行顺序对比的话，他们就会被替换掉，如 p 和 div 的 tagName 不同，p 就会被 div 所代替，最终，三个节点就都会被替换，这样 DOM 开销就会非常大，而实际上是不需要替换节点的，只需要移动就可以了， 我们只需要知道怎么去移动。这里牵扯到了两个列表的对比算法，如下。</p>
<p><strong>（3）列表对比算法</strong></p>
<p>假设现在可以用英文字母唯一地标识每一个子节点：</p>
<p>旧的节点顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c d e f g h i</span><br></pre></td></tr></table></figure>

<p>现在对节点进行了删除、插入、移动的操作。新增 j 节点，删除 e 节点，移动 h 节点：</p>
<p>新的节点顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c h d f g i j</span><br></pre></td></tr></table></figure>

<p>现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），最常见的解决算法是 Levenshtein Distance，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定 DOM 操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考代码。</p>
<p>我们能够获取到某个父节点的子节点的操作，就可以记录下来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">  type: REORDER,</span><br><span class="line">  moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>但是要注意的是，因为 tagName 是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识 key，列表对比的时候，使用 key 进行对比，这样才能复用老的 DOM 树上的节点。</p>
<p>这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 diff.js。</p>
<h3 id="3、把差异引用到真正的-DOM-树上"><a href="#3、把差异引用到真正的-DOM-树上" class="headerlink" title="3、把差异引用到真正的 DOM 树上"></a>3、把差异引用到真正的 DOM 树上</h3><p>因为步骤一所构建的 JavaScript 对象树和 render 出来真正的 DOM 树的信息、结构是一样的。所以我们可以对那棵 DOM 树也进行深度优先的遍历，遍历的时候从步骤二生成的 patches 对象中找出当前遍历的节点差异，然后进行 DOM 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function patch (node, patches) &#123;</span><br><span class="line">  var walker = &#123;index: 0&#125;</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dfsWalk (node, walker, patches) &#123;</span><br><span class="line">  var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异</span><br><span class="line"></span><br><span class="line">  var len = node.childNodes</span><br><span class="line">    ? node.childNodes.length</span><br><span class="line">    : 0</span><br><span class="line">  for (var i = 0; i &lt; len; i++) &#123; // 深度遍历子节点</span><br><span class="line">    var child = node.childNodes[i]</span><br><span class="line">    walker.index++</span><br><span class="line">    dfsWalk(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (currentPatches) &#123;</span><br><span class="line">    applyPatches(node, currentPatches) // 对当前节点进行DOM操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function applyPatches (node, currentPatches) &#123;</span><br><span class="line">  currentPatches.forEach(function (currentPatch) &#123;</span><br><span class="line">    switch (currentPatch.type) &#123;</span><br><span class="line">      case REPLACE:</span><br><span class="line">        node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class="line">        break</span><br><span class="line">      case REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        break</span><br><span class="line">      case PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        break</span><br><span class="line">      case TEXT:</span><br><span class="line">        node.textContent = currentPatch.content</span><br><span class="line">        break</span><br><span class="line">      default:</span><br><span class="line">        throw new Error(&#x27;Unknown patch type &#x27; + currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、结语</p>
<p>virtual DOM 算法主要实现上面步骤的三个函数： element、diff、patch，然后就可以实际的进行使用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构建虚拟DOM</span><br><span class="line">var tree = el(&#x27;div&#x27;, &#123;&#x27;id&#x27;: &#x27;container&#x27;&#125;, [</span><br><span class="line">    el(&#x27;h1&#x27;, &#123;style: &#x27;color: blue&#x27;&#125;, [&#x27;simple virtal dom&#x27;]),</span><br><span class="line">    el(&#x27;p&#x27;, [&#x27;Hello, virtual-dom&#x27;]),</span><br><span class="line">    el(&#x27;ul&#x27;, [el(&#x27;li&#x27;)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 2. 通过虚拟DOM构建真正的DOM</span><br><span class="line">var root = tree.render()</span><br><span class="line">document.body.appendChild(root)</span><br><span class="line"></span><br><span class="line">// 3. 生成新的虚拟DOM</span><br><span class="line">var newTree = el(&#x27;div&#x27;, &#123;&#x27;id&#x27;: &#x27;container&#x27;&#125;, [</span><br><span class="line">    el(&#x27;h1&#x27;, &#123;style: &#x27;color: red&#x27;&#125;, [&#x27;simple virtal dom&#x27;]),</span><br><span class="line">    el(&#x27;p&#x27;, [&#x27;Hello, virtual-dom&#x27;]),</span><br><span class="line">    el(&#x27;ul&#x27;, [el(&#x27;li&#x27;), el(&#x27;li&#x27;)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 4. 比较两棵虚拟DOM树的不同</span><br><span class="line">var patches = diff(tree, newTree)</span><br><span class="line"></span><br><span class="line">// 5. 在真正的DOM元素上应用变更</span><br><span class="line">patch(root, patches)</span><br></pre></td></tr></table></figure>

<p>当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的 ReactJS 了。</p>
<ul>
<li>源码地址： <a target="_blank" rel="noopener" href="https://github.com/livoras/simple-virtual-dom">https://github.com/livoras/simple-virtual-dom</a></li>
<li>参考文章：<a target="_blank" rel="noopener" href="https://github.com/livoras/blog/issues/13">https://github.com/livoras/blog/issues/13</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"># javascript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/24/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="prev" title="数组和链表的区别">
      <i class="fa fa-chevron-left"></i> 数组和链表的区别
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/24/ts%E4%B8%AD%E6%B3%9B%E5%9E%8B%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/" rel="next" title="ts中泛型、泛型方法、泛型类、泛型接口">
      ts中泛型、泛型方法、泛型类、泛型接口 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F-DOM-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">React 中的虚拟 DOM 是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Virtual-Dom-%E5%BF%AB%EF%BC%8C%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%89%8D%E6%8F%90"><span class="nav-number">1.1.</span> <span class="nav-text">1. Virtual Dom 快，有两个前提</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-Javascript-%E5%BE%88%E5%BF%AB"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 Javascript 很快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-Dom-%E5%BE%88%E6%85%A2"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 Dom 很慢</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81-%E5%85%B3%E4%BA%8E-React"><span class="nav-number">1.2.</span> <span class="nav-text">2、 关于 React</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 接口和设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88diff-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">虚拟 DOM 的简单实现（diff 算法）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">2.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%80%9D%E8%80%83"><span class="nav-number">2.2.</span> <span class="nav-text">对前端应用状态管理思考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F-DOM-%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">虚拟 DOM 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.</span> <span class="nav-text">算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81-%E7%94%A8-JavaScript-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E6%8B%9F-DOM-%E6%A0%91"><span class="nav-number">2.4.1.</span> <span class="nav-text">1、 用 JavaScript 对象模拟 DOM 树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%AF%94%E8%BE%83%E4%B8%A4%E9%A2%97%E8%99%9A%E6%8B%9F-DOM-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-number">2.4.2.</span> <span class="nav-text">2、比较两颗虚拟 DOM 树的差异</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%8A%8A%E5%B7%AE%E5%BC%82%E5%BC%95%E7%94%A8%E5%88%B0%E7%9C%9F%E6%AD%A3%E7%9A%84-DOM-%E6%A0%91%E4%B8%8A"><span class="nav-number">2.5.</span> <span class="nav-text">3、把差异引用到真正的 DOM 树上</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Chen"
      src="/images/portal.jpg">
  <p class="site-author-name" itemprop="name">Bruce Chen</p>
  <div class="site-description" itemprop="description">It's better to burn out than to fade away.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1440429303&auto=1&height=66"></iframe>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jschentt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jschentt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jschentt@gmail.com" title="E-Mail → mailto:jschentt@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/BruceCh56742806" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;BruceCh56742806" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/jinsheng.chen.5439" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;jinsheng.chen.5439" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
  </div>





      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
