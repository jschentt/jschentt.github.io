<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="It&#39;s better to burn out than to fade away.">
<meta property="og:type" content="website">
<meta property="og:title" content="Bruce Chen&#39;s Blog">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Bruce Chen&#39;s Blog">
<meta property="og:description" content="It&#39;s better to burn out than to fade away.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Bruce Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Bruce Chen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
    <a target="_blank" rel="noopener" href="https://github.com/jschentt" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bruce Chen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">quick notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">83</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/React-Hooks-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/React-Hooks-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">React Hooks 用法详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 14:17:11 / 修改时间：14:21:18" itemprop="dateCreated datePublished" datetime="2022-12-16T14:17:11+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">前端框架总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>React 中提供的 hooks：</strong></p>
<ul>
<li><p>useState：setState</p>
</li>
<li><p>useReducer：setState，同时 useState 也是该方法的封装</p>
</li>
<li><p>useRef: ref</p>
</li>
<li><p>useImperativeHandle: 给 ref 分配特定的属性</p>
</li>
<li><p>useContext: context，需配合 createContext 使用</p>
</li>
<li><p>useMemo: 可以对 setState 的优化</p>
</li>
<li><p>useCallback: useMemo 的变形，对函数进行优化</p>
</li>
<li><p>useEffect: 类似 componentDidMount&#x2F;Update, componentWillUnmount，当效果为 componentDidMount&#x2F;Update 时，总是在整个更新周期的最后（页面渲染完成后）才执行</p>
</li>
<li><p>useLayoutEffect: 用法与 useEffect 相同，区别在于该方法的回调会在数据更新完成后，页面渲染之前进行，该方法会阻碍页面的渲染</p>
</li>
<li><p>useDebugValue：用于在 React 开发者工具中显示自定义 hook 的标签</p>
</li>
</ul>
<h1 id="一、Hooks-初体验"><a href="#一、Hooks-初体验" class="headerlink" title="一、Hooks 初体验"></a>一、Hooks 初体验</h1><p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState  &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">    // 声明一个名为“count”的新状态变量</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Example;</span><br></pre></td></tr></table></figure>

<p>useState 就是一个 Hook，可以在我们不使用 class 组件的情况下，拥有自身的 state，并且可以通过修改 state 来控制 UI 的展示。</p>
<h2 id="1、useState-状态"><a href="#1、useState-状态" class="headerlink" title="1、useState 状态"></a>1、useState 状态</h2><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, setState] = useState(initialState)</span><br></pre></td></tr></table></figure>

<ul>
<li>传入唯一的参数: initialState，可以是数字，字符串等，也可以是对象或者数组。</li>
<li>返回的是包含两个元素的数组：第一个元素，state 变量，setState 修改 state 值的方法。</li>
</ul>
<p>与在类中使用 setState 的异同点：</p>
<ul>
<li>相同点：在一次渲染周期中调用多次 setState，数据只改变一次。</li>
<li>不同点：类中的 setState 是合并，而函数组件中的 setState 是替换。</li>
</ul>
<p>使用对比</p>
<p>之前想要使用组件内部的状态，必须使用 class 组件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default class Example extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而现在，我们使用函数式组件也可以实现一样的功能了。也就意味着函数式组件内部也可以使用 state 了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">    // 声明一个名为“count”的新状态变量</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Example;</span><br></pre></td></tr></table></figure>

<p>优化</p>
<p>创建初始状态是比较昂贵的，所以我们可以在使用 useState API 时，传入一个函数，就可以避免重新创建忽略的初始状态。</p>
<p>普通的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 直接传入一个值，在每次 render 时都会执行 createRows 函数获取返回值</span><br><span class="line">const [rows, setRows] = useState(createRows(props.count));</span><br></pre></td></tr></table></figure>

<p>优化后的方式（推荐）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// createRows 只会被执行一次</span><br><span class="line">const [rows, setRows] = useState(() =&gt; createRows(props.count));</span><br></pre></td></tr></table></figure>

<h1 id="2、useEffect-执行副作用操作"><a href="#2、useEffect-执行副作用操作" class="headerlink" title="2、useEffect 执行副作用操作"></a>2、useEffect 执行副作用操作</h1><ul>
<li><strong>effect（副作用）：指那些没有发生在数据向视图转换过程中的逻辑，如 ajax 请求、访问原生 dom 元素、本地持久化缓存、绑定&#x2F;解绑事件、添加订阅、设置定时器、记录日志等</strong>。</li>
<li><strong>副作用操作可以分两类：需要清除的和不需要清除的。</strong></li>
<li><strong>需要清除的，比如开启的定时器，订阅外部数据源等，这些操作如果在组件消亡后不及时清除会导致内存泄漏。</strong></li>
<li><strong>不需要清除的，比如发起网络请求，手动变更 DOM，记录日志等。</strong></li>
<li>原先在函数组件内（这里指在 React 渲染阶段）改变 dom 、发送 ajax 请求以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性</li>
<li>useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API</li>
<li><strong>useEffect 接收一个函数，该函数会在组件渲染到屏幕之后才执行，该函数有要求：要么返回一个能清除副作用的函数，要么就不返回任何内容</strong></li>
<li>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。</li>
</ul>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、useEffect(() =&gt; &#123; doSomething &#125;);</span><br><span class="line"></span><br><span class="line">2、useEffect(() =&gt; &#123; doSomething &#125;,[]);</span><br><span class="line"></span><br><span class="line">3、useEffect(() =&gt; &#123; doSomething &#125;,[count]);</span><br></pre></td></tr></table></figure>

<p>第一个参数为 effect 函数，该函数将在 componentDidMount 时触发和 componentDidUpdate 时有条件触发（该添加为 useEffect 的第二个数组参数）</p>
<p>第二个参数是可选的，根据条件限制看是否触发</p>
<ul>
<li><p>如果不传，如语法 1，则每次页面数据有更新（如 componentDidUpdate），都会触发 effect。</p>
</li>
<li><p>如果为空数组[]，如语法 2，则每次初始化的时候只执行一次 effect（如 componentDidMmount）</p>
</li>
<li><p>如果只需要在指定变量变化时触发 effect，将该变量放入数组。如语法 3，count 只要变化，就会执行 effect，如观察者监听</p>
</li>
</ul>
<p>清除副作用</p>
<p>副作用函数还可以通过返回一个函数来指定如何清除副作用，为防止内存泄漏，清除函数会在组件卸载前执行。如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已被清除。</p>
<p><strong>例 1、比如 window.addEventListener(‘resize’, handleResize);：监听 resize 等</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    window.addEventListener(&#x27;resize&#x27;, handleResize);</span><br><span class="line">    window.addEventListener(&#x27;keydown&#x27;, onKeyDown);</span><br><span class="line">    window.addEventListener(&#x27;keyup&#x27;, onKeyUp);</span><br><span class="line">    return (() =&gt; &#123;</span><br><span class="line">      window.removeEventListener(&#x27;resize&#x27;, handleResize);</span><br><span class="line">      window.removeEventListener(&#x27;keydown&#x27;, onKeyDown);</span><br><span class="line">      window.removeEventListener(&#x27;keyup&#x27;, onKeyUp);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, [globalRef]);</span><br></pre></td></tr></table></figure>

<p><strong>例 2、清除定时器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Counter()&#123;</span><br><span class="line">    let [number,setNumber] = useState(0);</span><br><span class="line">    let [text,setText] = useState(&#x27;&#x27;);</span><br><span class="line">    useEffect(()=&gt;&#123;</span><br><span class="line">        let $timer = setInterval(()=&gt;&#123;</span><br><span class="line">            setNumber(number=&gt;number+1);</span><br><span class="line">        &#125;,1000);</span><br><span class="line">        // useEffect 如果返回一个函数的话，该函数会在组件卸载和更新时调用</span><br><span class="line">        // useEffect 在执行副作用函数之前，会先调用上一次返回的函数</span><br><span class="line">        // 如果要清除副作用，要么返回一个清除副作用的函数</span><br><span class="line">       /*  return ()=&gt;&#123;</span><br><span class="line">            console.log(&#x27;destroy effect&#x27;);</span><br><span class="line">            clearInterval($timer);</span><br><span class="line">        &#125; */</span><br><span class="line">    &#125;);</span><br><span class="line">    // &#125;,[]);//要么在这里传入一个空的依赖项数组，这样就不会去重复执行</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;input value=&#123;text&#125; onChange=&#123;(event)=&gt;setText(event.target.value)&#125;/&gt;</span><br><span class="line">          &lt;p&gt;&#123;number&#125;&lt;/p&gt;</span><br><span class="line">          &lt;button&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3、useContext-组件之间传值"><a href="#3、useContext-组件之间传值" class="headerlink" title="3、useContext 组件之间传值"></a>3、useContext 组件之间传值</h1><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const value = useContext(MyContext);</span><br></pre></td></tr></table></figure>

<p>之前在用类声明组件时，父子组件的传值是通过组件属性和 props 进行的，那现在使用方法(Function)来声明组件，已经没有了 constructor 构造函数也就没有了 props 的接收，但是也可以直接收，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">组件：</span><br><span class="line">&lt;SwitchList dataList=&#123;toolsList&#125; isReverse=&#123;false&#125;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接收：</span><br><span class="line">const SwitchList = (&#123;dataList = null, isReverse = false&#125;: any): React.ReactElement =&gt; &#123;</span><br><span class="line">    //TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React Hooks 也为我们准备了 useContext。它可以帮助我们跨越组件层级直接传递变量，实现共享。</p>
<h3 id="一：利用-createContext-创建上下文"><a href="#一：利用-createContext-创建上下文" class="headerlink" title="一：利用 createContext 创建上下文"></a>一：利用 createContext 创建上下文</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState , createContext &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">// 创建一个 CountContext</span><br><span class="line">const CountContext = createContext()</span><br><span class="line"></span><br><span class="line">function Example()&#123;</span><br><span class="line">  const [ count , setCount ] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">      &#123;/* 将 context 传递给 子组件,context 值由value props决定*/&#125;</span><br><span class="line">      &lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class="line">        &lt;Counter/&gt;</span><br><span class="line">      &lt;/CountContext.Provider&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">export default Example;</span><br></pre></td></tr></table></figure>

<h3 id="二：使用-useContext-获取上下文"><a href="#二：使用-useContext-获取上下文" class="headerlink" title="二：使用 useContext 获取上下文"></a>二：使用 useContext 获取上下文</h3><p>对于要接收 context 的后代组件，只需引入 useContext() Hooks 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Counter()&#123;</span><br><span class="line">  const count = useContext(CountContext)  //一句话就可以得到count</span><br><span class="line">  return (&lt;h2&gt;&#123;count&#125;&lt;/h2&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强调一点：<br>useContext 的参数必须是 context 对象本身：</p>
<ul>
<li>正确： useContext(MyContext)</li>
<li>错误： useContext(MyContext.Consumer)</li>
<li>错误： useContext(MyContext.Provider)</li>
</ul>
<p>当组件上层最近的<code> &lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>&lt;MyContext.Provider&gt; </code>的 context value 值。</p>
<h1 id="4、useReducer-处理更为复杂-state-结构"><a href="#4、useReducer-处理更为复杂-state-结构" class="headerlink" title="4、useReducer 处理更为复杂 state 结构"></a>4、useReducer 处理更为复杂 state 结构</h1><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>

<p>useReducer 接收一个形如 (state, action) &#x3D;&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。</p>
<p>我们可以使用 useReducer 来重新写我们开篇计数器的 demo：</p>
<p>Example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const initialState = &#123;count: 0&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#x27;increment&#x27;:</span><br><span class="line">            return &#123;count: state.count + 1&#125;;</span><br><span class="line">        case &#x27;decrement&#x27;:</span><br><span class="line">            return &#123;count: state.count - 1&#125;;</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 使用 useReducer 函数创建状态 state 以及更新状态的 dispatch 函数</span><br><span class="line">    const [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            Count: &#123;state.count&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化：延迟初始化</strong></p>
<p>还可以懒惰地创建初始状态。为此，您可以将 init 函数作为第三个参数传递。初始状态将设置为 init(initialArg)。</p>
<p>它允许您提取用于计算 reducer 外部的初始状态的逻辑。这对于稍后重置状态以响应操作也很方便：</p>
<p>Example.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function init(initialCount) &#123;</span><br><span class="line">    return &#123;count: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#x27;increment&#x27;:</span><br><span class="line">            return &#123;count: state.count + 1&#125;;</span><br><span class="line">        case &#x27;decrement&#x27;:</span><br><span class="line">            return &#123;count: state.count - 1&#125;;</span><br><span class="line">        case &#x27;reset&#x27;:</span><br><span class="line">            return init(action.payload);</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default (&#123;initialCount = 0&#125;) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            Count: &#123;state.count&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button</span><br><span class="line">                onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;</span><br><span class="line">                Reset</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 useState 的区别</p>
<ul>
<li>当 state 状态值结构比较复杂时，使用 useReducer 更有优势。</li>
<li><strong>使用 useState 获取的 setState 方法更新数据时是异步的；而使用 useReducer 获取的 dispatch 方法更新数据是同步的。</strong></li>
</ul>
<p>针对第二点区别，我们可以演示一下： 在上面 useState 用法的例子中，我们新增一个 button：</p>
<p>useState 中的 Example.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">    // 声明一个名为“count”的新状态变量</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">                setCount(count + 1);</span><br><span class="line">                setCount(count + 1);</span><br><span class="line">            &#125;&#125;&gt;</span><br><span class="line">                测试能否连加两次</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Example;</span><br></pre></td></tr></table></figure>

<p>点击 测试能否连加两次 按钮，会发现，点击一次， count 还是只增加了 1，由此可见，useState 确实是 异步 更新数据；</p>
<p>在上面 useReducer 用法的例子中，我们新增一个 button： useReducer 中的 Example.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const initialState = &#123;count: 0&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#x27;increment&#x27;:</span><br><span class="line">            return &#123;count: state.count + 1&#125;;</span><br><span class="line">        case &#x27;decrement&#x27;:</span><br><span class="line">            return &#123;count: state.count - 1&#125;;</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 使用 useReducer 函数创建状态 state 以及更新状态的 dispatch 函数</span><br><span class="line">    const [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            Count: &#123;state.count&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">                dispatch(&#123;type: &#x27;increment&#x27;&#125;);</span><br><span class="line">                dispatch(&#123;type: &#x27;increment&#x27;&#125;);</span><br><span class="line">            &#125;&#125;&gt;</span><br><span class="line">                测试能否连加两次</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击 测试能否连加两次 按钮，会发现，点击一次， count 增加了 2，由此可见，每次 dispatch 一个 action 就会更新一次数据，useReducer 确实是 同步 更新数据；</p>
<p>对于 useReducer 和 useState 的区别主要是以下两点：</p>
<ul>
<li>当 state 状态值结构比较复杂时，使用 useReducer 更有优势。</li>
<li>使用 useState 获取的 setState 方法更新数据时是异步的；而使用 useReducer 获取的 dispatch 方法更新数据是同步的。</li>
</ul>
<h1 id="5、useMemo-性能优化"><a href="#5、useMemo-性能优化" class="headerlink" title="5、useMemo 性能优化"></a>5、useMemo 性能优化</h1><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>

<p>返回一个 memoized 值。 传递“创建”函数和依赖项数组。useMemo 只会在其中一个依赖项发生更改时重新计算 memoized 值。此优化有助于避免在每个渲染上进行昂贵的计算。</p>
<blockquote>
<p>useMemo 在渲染过程中传递的函数会运行。不要做那些在渲染时通常不会做的事情。例如，副作用属于 useEffect，而不是 useMemo。</p>
</blockquote>
<p>用法</p>
<p>useMemo 可以帮助我们优化子组件的渲染，比如这种场景： 在 A 组件中有两个子组件 B 和 C，当 A 组件中传给 B 的 props 发生变化时，A 组件状态会改变，重新渲染。此时 B 和 C 也都会重新渲染。其实这种情况是比较浪费资源的，现在我们就可以使用 useMemo 进行优化，B 组件用到的 props 变化时，只有 B 发生改变，而 C 却不会重新渲染。</p>
<p>例子：</p>
<p>ExampleA.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default (&#123; text &#125;) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;Example A：&#x27;, &#x27;render&#x27;);</span><br><span class="line">    return &lt;div&gt;Example A 组件：&#123; text &#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExampleB.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default (&#123; text &#125;) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;Example B：&#x27;, &#x27;render&#x27;);</span><br><span class="line">    return &lt;div&gt;Example B 组件：&#123; text &#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>App.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import ExampleA from &#x27;./ExampleA&#x27;;</span><br><span class="line">import ExampleB from &#x27;./ExampleB&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;./App.css&#x27;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const [a, setA] = useState(&#x27;ExampleA&#x27;);</span><br><span class="line">    const [b, setB] = useState(&#x27;ExampleB&#x27;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ExampleA text=&#123; a &#125; /&gt;</span><br><span class="line">            &lt;ExampleB text=&#123; b &#125; /&gt;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123; () =&gt; setA(&#x27;修改后的 ExampleA&#x27;) &#125;&gt;修改传给 ExampleA 的属性&lt;/button&gt;</span><br><span class="line">            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">            &lt;button onClick=&#123; () =&gt; setB(&#x27;修改后的 ExampleB&#x27;) &#125;&gt;修改传给 ExampleB 的属性&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们点击上面任意一个按钮，都会看到控制台打印了两条输出， A 和 B 组件都会被重新渲染。</p>
<p>现在我们使用 useMemo 进行优化</p>
<p>App.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useMemo &#125; from &#x27;react&#x27;;</span><br><span class="line">import ExampleA from &#x27;./ExampleA&#x27;;</span><br><span class="line">import ExampleB from &#x27;./ExampleB&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;./App.css&#x27;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const [a, setA] = useState(&#x27;ExampleA&#x27;);</span><br><span class="line">    const [b, setB] = useState(&#x27;ExampleB&#x27;);</span><br><span class="line"></span><br><span class="line">+    const exampleA = useMemo(() =&gt; &lt;ExampleA /&gt;, [a]);</span><br><span class="line">+    const exampleB = useMemo(() =&gt; &lt;ExampleB /&gt;, [b]);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">+            &#123;/* &lt;ExampleA text=&#123; a &#125; /&gt;</span><br><span class="line">+            &lt;ExampleB text=&#123; b &#125; /&gt; */&#125;</span><br><span class="line">+            &#123; exampleA &#125;</span><br><span class="line">+            &#123; exampleB &#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123; () =&gt; setA(&#x27;修改后的 ExampleA&#x27;) &#125;&gt;修改传给 ExampleA 的属性&lt;/button&gt;</span><br><span class="line">            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">            &lt;button onClick=&#123; () =&gt; setB(&#x27;修改后的 ExampleB&#x27;) &#125;&gt;修改传给 ExampleB 的属性&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们点击不同的按钮，控制台都只会打印一条输出，改变 a 或者 b，A 和 B 组件都只有一个会重新渲染。</p>
<h1 id="6、useCallback-优化函数式组件性能"><a href="#6、useCallback-优化函数式组件性能" class="headerlink" title="6、useCallback 优化函数式组件性能"></a>6、useCallback 优化函数式组件性能</h1><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const memoizedCallback = useCallback(() =&gt; &#123; doSomething(a, b); &#125;, [a, b]);</span><br></pre></td></tr></table></figure>

<p>返回值 memoizedCallback 是一个 memoized 回调。传递内联回调和一系列依赖项。useCallback 将返回一个回忆的 memoized 版本，该版本仅在其中一个依赖项发生更改时才会更改。当将回调传递给依赖于引用相等性的优化子组件以防止不必要的渲染（例如 shouldComponentUpdate）时，这非常有用。</p>
<p>这个 Hook 的 API 不能够一两句解释的清楚，建议看一下这篇文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56975681">useHooks 第一期：聊聊 hooks 中的 useCallback</a>。里面介绍的比较详细。</p>
<h1 id="7、useRef-获取-dom"><a href="#7、useRef-获取-dom" class="headerlink" title="7、useRef 获取 dom"></a>7、useRef 获取 dom</h1><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>

<p>类组件、React 元素用 <code>React.createRef</code>，如：<code>remindRef: any = React.createRef();</code>通过 <code>this.remindRef.current</code>获取</p>
<p>函数组件使用 useRef，如<code>let globalToolRef: any = useRef(null);</code>通过<code>globalToolRef.current</code>获取</p>
<p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传递的参数（initialValue）。返回的对象将存留在整个组件的生命周期中。</p>
<ul>
<li>从本质上讲，useRef 就像一个“盒子”，可以在其.current 财产中保持一个可变的价值。</li>
<li>useRef() Hooks 不仅适用于 DOM 引用。 “ref” 对象是一个通用容器，其 current 属性是可变的，可以保存任何值（可以是元素、对象、基本类型、甚至函数），类似于类上的实例属性。</li>
</ul>
<blockquote>
<p>注意：useRef() 比 ref 属性更有用。与在类中使用 instance(实例) 字段的方式类似，它可以 方便地保留任何可变值。</p>
</blockquote>
<blockquote>
<p>注意，内容更改时 useRef 不会通知您。变异.current 属性不会导致重新渲染。如果要在 React 将引用附加或分离到 DOM 节点时运行某些代码，则可能需要使用回调引用。</p>
</blockquote>
<p>使用</p>
<p>下面这个例子中展示了可以在 useRef() 生成的 ref 的 current 中存入元素、字符串</p>
<p>Example.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef, useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 使用 useRef 创建 inputEl</span><br><span class="line">    const inputEl = useRef(null);</span><br><span class="line"></span><br><span class="line">    const [text, updateText] = useState(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">    // 使用 useRef 创建 textRef</span><br><span class="line">    const textRef = useRef();</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        // 将 text 值存入 textRef.current 中</span><br><span class="line">        textRef.current = text;</span><br><span class="line">        console.log(&#x27;textRef.current：&#x27;, textRef.current);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const onButtonClick = () =&gt; &#123;</span><br><span class="line">        // `current` points to the mounted text input element</span><br><span class="line">        inputEl.current.value = &quot;Hello, useRef&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &#123;/* 保存 input 的 ref 到 inputEl */&#125;</span><br><span class="line">            &lt;input ref=&#123; inputEl &#125; type=&quot;text&quot; /&gt;</span><br><span class="line">            &lt;button onClick=&#123; onButtonClick &#125;&gt;在 input 上展示文字&lt;/button&gt;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击 在 input 上展示文字 按钮，就可以看到第一个 input 上出现 Hello, useRef；在第二个 input 中输入内容，可以看到控制台打印出对应的内容。</p>
<h1 id="8、useLayoutEffect"><a href="#8、useLayoutEffect" class="headerlink" title="8、useLayoutEffect"></a>8、useLayoutEffect</h1><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useLayoutEffect(() =&gt; &#123; doSomething &#125;);</span><br></pre></td></tr></table></figure>

<p>与 useEffect Hooks 类似，都是执行副作用操作。但是它是在所有 DOM 更新完成后触发。可以用来执行一些与布局相关的副作用，比如获取 DOM 元素宽高，窗口滚动距离等等。</p>
<blockquote>
<p>进行副作用操作时尽量优先选择 useEffect，以免阻止视觉更新。与 DOM 无关的副作用操作请使用 useEffect。</p>
</blockquote>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>用法与 useEffect 类似。</p>
<p>Example.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef, useState, useLayoutEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const divRef = useRef(null);</span><br><span class="line"></span><br><span class="line">    const [height, setHeight] = useState(100);</span><br><span class="line"></span><br><span class="line">    useLayoutEffect(() =&gt; &#123;</span><br><span class="line">        // DOM 更新完成后打印出 div 的高度</span><br><span class="line">        console.log(&#x27;useLayoutEffect: &#x27;, divRef.current.clientHeight);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return &lt;&gt;</span><br><span class="line">        &lt;div ref=&#123; divRef &#125; style=&#123;&#123; background: &#x27;red&#x27;, height: height &#125;&#125;&gt;Hello&lt;/div&gt;</span><br><span class="line">        &lt;button onClick=&#123; () =&gt; setHeight(height + 50) &#125;&gt;改变 div 高度&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特定场景下的页面闪烁问题。</li>
<li>useEffect 可以满足百分之 99 的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。</li>
<li>useEffect 在全部渲染完毕后才会执行</li>
<li>useLayoutEffect 会在 浏览器 layout 之后，painting 之前执行</li>
<li>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect</li>
<li>可以使用它来读取 DOM 布局并同步触发重渲染</li>
<li>在浏览器执行绘制之前 useLayoutEffect 内部的更新计划将被同步刷新</li>
<li>尽可能使用标准的 useEffect 以避免阻塞视图更新</li>
</ul>
<h1 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h1><p><strong>因为函数组件没有实例，所以函数组件无法像类组件一样可以接收 ref 属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">         // &lt;Child ref=&#123;xxx&#125; /&gt; 这样是不行的</span><br><span class="line">            &lt;Child /&gt;</span><br><span class="line">            &lt;button&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>forwardRef 可以在父组件中操作子组件的 ref 对象</li>
<li>forwardRef 可以将父组件中的 ref 对象转发到子组件中的 dom 元素上</li>
<li>子组件接受 props 和 ref 作为参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function Child(props,ref)&#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;input type=&quot;text&quot; ref=&#123;ref&#125;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">Child = React.forwardRef(Child);</span><br><span class="line">function Parent()&#123;</span><br><span class="line">  let [number,setNumber] = useState(0);</span><br><span class="line">  // 在使用类组件的时候，创建 ref 返回一个对象，该对象的 current 属性值为空</span><br><span class="line">  // 只有当它被赋给某个元素的 ref 属性时，才会有值</span><br><span class="line">  // 所以父组件（类组件）创建一个 ref 对象，然后传递给子组件（类组件），子组件内部有元素使用了</span><br><span class="line">  // 那么父组件就可以操作子组件中的某个元素</span><br><span class="line">  // 但是函数组件无法接收 ref 属性 &lt;Child ref=&#123;xxx&#125; /&gt; 这样是不行的</span><br><span class="line">  // 所以就需要用到 forwardRef 进行转发</span><br><span class="line">  const inputRef = useRef();//&#123;current:&#x27;&#x27;&#125;</span><br><span class="line">  function getFocus()&#123;</span><br><span class="line">    inputRef.current.value = &#x27;focus&#x27;;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Child ref=&#123;inputRef&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;setNumber(&#123;number:number+1&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;/button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10、useImperativeHandle"><a href="#10、useImperativeHandle" class="headerlink" title="10、useImperativeHandle"></a>10、useImperativeHandle</h1><ul>
<li>useImperativeHandle 可以让你在使用 ref 时，自定义暴露给父组件的实例值，不能让父组件想干嘛就干嘛</li>
<li><strong>在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用</strong></li>
<li><strong>父组件可以使用操作子组件中的多个 ref</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;useState,useEffect,createRef,useRef,forwardRef,useImperativeHandle&#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function Child(props,parentRef)&#123;</span><br><span class="line">    // 子组件内部自己创建 ref</span><br><span class="line">    let focusRef = useRef();</span><br><span class="line">    let inputRef = useRef();</span><br><span class="line">    useImperativeHandle(parentRef,()=&gt;&#123;</span><br><span class="line">      // 这个函数会返回一个对象</span><br><span class="line">      // 该对象会作为父组件 current 属性的值</span><br><span class="line">      // 通过这种方式，父组件可以使用操作子组件中的多个 ref</span><br><span class="line">        return &#123;</span><br><span class="line">            focusRef,</span><br><span class="line">            inputRef,</span><br><span class="line">            name:&#x27;计数器&#x27;,</span><br><span class="line">            focus()&#123;</span><br><span class="line">                focusRef.current.focus();</span><br><span class="line">            &#125;,</span><br><span class="line">            changeText(text)&#123;</span><br><span class="line">                inputRef.current.value = text;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;input ref=&#123;focusRef&#125;/&gt;</span><br><span class="line">            &lt;input ref=&#123;inputRef&#125;/&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">const ForwardChild = forwardRef(Child);</span><br><span class="line">function Parent()&#123;</span><br><span class="line">  const parentRef = useRef();//&#123;current:&#x27;&#x27;&#125;</span><br><span class="line">  function getFocus()&#123;</span><br><span class="line">    parentRef.current.focus();</span><br><span class="line">    // 因为子组件中没有定义这个属性，实现了保护，所以这里的代码无效</span><br><span class="line">    parentRef.current.addNumber(666);</span><br><span class="line">    parentRef.current.changeText(&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;);</span><br><span class="line">    console.log(parentRef.current.name);</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;ForwardChild ref=&#123;parentRef&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;/button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官网介绍 forwardRef 与 useImperativeHandle 结合使用</p>
<p><img src="https://img-blog.csdnimg.cn/20200803182456425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjMzMzU0OA==,size_16,color_FFFFFF,t_70" alt="image"></p>
<h1 id="11、useMemo-和-useCallback-的使用"><a href="#11、useMemo-和-useCallback-的使用" class="headerlink" title="11、useMemo 和 useCallback 的使用"></a>11、useMemo 和 useCallback 的使用</h1><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p>
</blockquote>
<p>也就是说 useMemo 可以让函数在某个依赖项改变的时候才运行，这可以避免很多不必要的开销。举个例子：</p>
<p><strong>不使用 useMemo</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Example() &#123;</span><br><span class="line">    const [count, setCount] = useState(1);</span><br><span class="line">    const [val, setValue] = useState(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">    function getNum() &#123;</span><br><span class="line">        return Array.from(&#123;length: count * 100&#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a+b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h4&gt;总和：&#123;getNum()&#125;&lt;/h4&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个组件，维护了两个 state，可以看到 getNum 的计算仅仅跟 count 有关，但是现在无论是 count 还是 val 变化，都会导致 getNum 重新计算，所以这里我们希望 val 修改的时候，不需要再次计算，这种情况下我们可以使用 useMemo。</p>
<p><strong>使用 useMemo</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Example() &#123;</span><br><span class="line">    const [count, setCount] = useState(1);</span><br><span class="line">    const [val, setValue] = useState(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">    const getNum = useMemo(() =&gt; &#123;</span><br><span class="line">        return Array.from(&#123;length: count * 100&#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a+b)</span><br><span class="line">    &#125;, [count])</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h4&gt;总和：&#123;getNum()&#125;&lt;/h4&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 useMemo 后，并将 count 作为依赖值传递进去，此时仅当 count 变化时才会重新执行 getNum。</p>
<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。</p>
</blockquote>
<p>看起来似乎和 useMemo 差不多，我们来看看这两者有什么异同：</p>
<p>useMemo 和 useCallback 接收的参数都是一样，都是在其依赖项发生变化后才执行，都是返回缓存的值，区别在于 useMemo 返回的是函数运行的结果，useCallback 返回的是函数。</p>
<blockquote>
<p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)</p>
</blockquote>
<p><strong>使用场景</strong></p>
<p>正如上面所说的，当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。也就是说父组件传递一个函数给子组件的时候，由于父组件的更新会导致该函数重新生成从而传递给子组件的函数引用发生了变化，这就会导致子组件也会更新，而很多时候子组件的更新是没必要的，所以我们可以通过 useCallback 来缓存该函数，然后传递给子组件。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    const [count, setCount] = useState(1);</span><br><span class="line">    const [val, setValue] = useState(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">    const getNum = useCallback(() =&gt; &#123;</span><br><span class="line">        return Array.from(&#123;length: count * 100&#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a+b)</span><br><span class="line">    &#125;, [count])</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;Child getNum=&#123;getNum&#125; /&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Child = React.memo(function (&#123; getNum &#125;: any) &#123;</span><br><span class="line">    return &lt;h4&gt;总和：&#123;getNum()&#125;&lt;/h4&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 useCallback 之后，仅当 count 发生变化时 Child 组件才会重新渲染，而 val 变化时，Child 组件是不会重新渲染的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/React-router5-x-%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/React-router5-x-%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">React-router5.x 路由的使用及配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 14:17:02 / 修改时间：14:21:44" itemprop="dateCreated datePublished" datetime="2022-12-16T14:17:02+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">前端框架总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 React router 中通常使用的组件有三种：</p>
<ul>
<li>路由组件（作为根组件）: BrowserRouter（history 模式） 和 HashRouter（hash 模式）</li>
<li>路径匹配组件: Route 和 Switch</li>
<li>导航组件: Link 和 NavLink</li>
</ul>
<p>关于路由组件，如果我们的应用有服务器响应 web 的请求，建议使用<BrowserRouter>组件; 如果使用静态文件服务器，建议使用<HashRouter>组件</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure>

<h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, Fragment &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Provider &#125; from &#x27;react-redux&#x27;;</span><br><span class="line">import &#123; BrowserRouter, Route &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import store from &#x27;./store&#x27;;</span><br><span class="line">import Header from &#x27;./common/header&#x27;;</span><br><span class="line">import Home from &#x27;./pages/home&#x27;;</span><br><span class="line">import Detail from &#x27;./pages/detail&#x27;;</span><br><span class="line">import Login from &#x27;./pages/login&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">          &lt;BrowserRouter&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;Header /&gt;</span><br><span class="line">              &lt;Route path=&#x27;/&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">              &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class="line">              &lt;Route path=&#x27;/detail/:id&#x27; exact component=&#123;Detail&#125;&gt;&lt;/Route&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          &lt;/BrowserRouter&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<h2 id="3-路由组件-BrowserRouter-和-HashRouter"><a href="#3-路由组件-BrowserRouter-和-HashRouter" class="headerlink" title="3. 路由组件 BrowserRouter 和 HashRouter"></a>3. 路由组件 BrowserRouter 和 HashRouter</h2><p>BrowserRouter（history 模式） 和 HashRouter（hash 模式）作为路由配置的最外层容器，是两种不同的模式，可根据需要选择。</p>
<p><strong>history 模式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">          &lt;Header /&gt;</span><br><span class="line">          &lt;Route path=&#x27;/&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">          &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class="line">          &lt;Route path=&#x27;/detail/:id&#x27; exact component=&#123;Detail&#125;&gt;&lt;/Route&gt;</span><br><span class="line">      &lt;/BrowserRouter&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>hash 模式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">          &lt;Header /&gt;</span><br><span class="line">          &lt;Route path=&#x27;/&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">          &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class="line">          &lt;Route path=&#x27;/detail/:id&#x27; exact component=&#123;Detail&#125;&gt;&lt;/Route&gt;</span><br><span class="line">      &lt;/HashRouter&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-路径匹配组件-Route-和-Switch"><a href="#4-路径匹配组件-Route-和-Switch" class="headerlink" title="4. 路径匹配组件: Route 和 Switch"></a>4. 路径匹配组件: Route 和 Switch</h2><h3 id="一、Route-用来控制路径对应显示的组件"><a href="#一、Route-用来控制路径对应显示的组件" class="headerlink" title="一、Route: 用来控制路径对应显示的组件"></a>一、Route: 用来控制路径对应显示的组件</h3><p>有以下几个参数：</p>
<ul>
<li>4.1 path：指定路由跳转路径</li>
<li>4.2 exact: 精确匹配路由</li>
<li>4.3 component：路由对应的组件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import About from &#x27;./pages/about&#x27;;</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">&lt;Route path=&#x27;/about&#x27; exact component=&#123;About&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.4 render： 通过写 render 函数返回具体的 dom：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#x27;/about&#x27; exact render=&#123;() =&gt; (&lt;div&gt;about&lt;/div&gt;)&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure>

<p>render 也可以直接返回 About 组件，像下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#x27;/about&#x27; exact render=&#123;() =&gt; &lt;About /&gt; &#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure>

<p>但是，这样写的好处是，不仅可以通过 render 方法传递 props 属性，并且可以传递自定义属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#x27;/about&#x27; exact render=&#123;(props) =&gt; &#123;</span><br><span class="line">    return &lt;About &#123;...props&#125; name=&#123;&#x27;cedric&#x27;&#125; /&gt;</span><br><span class="line">&#125;&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure>

<p>然后，就可在 About 组件中获取 props 和 name 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    console.log(this.props)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// this.props：</span><br><span class="line">// history: &#123;length: 9, action: &quot;POP&quot;, location: &#123;…&#125;, createHref: ƒ, push: ƒ, …&#125;</span><br><span class="line">// location: &#123;pathname: &quot;/home&quot;, search: &quot;&quot;, hash: &quot;&quot;, state: undefined, key: &quot;ad7bco&quot;&#125;</span><br><span class="line">// match: &#123;path: &quot;/home&quot;, url: &quot;/home&quot;, isExact: true, params: &#123;…&#125;&#125;</span><br><span class="line">// name: &quot;cedric&quot;</span><br></pre></td></tr></table></figure>

<p>render 方法也可用来进行权限认证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#x27;/user&#x27; exact render=&#123;(props) =&gt; &#123;</span><br><span class="line">    // isLogin 从 redux 中拿到, 判断用户是否登录</span><br><span class="line">    return isLogin ? &lt;User &#123;...props&#125; name=&#123;&#x27;cedric&#x27;&#125; /&gt; : &lt;div&gt;请先登录&lt;/div&gt;</span><br><span class="line">&#125;&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.5 location: 将 与当前历史记录位置以外的位置相匹配，则此功能在路由过渡动效中非常有用</li>
<li>4.6 sensitive：是否区分路由大小写</li>
<li>4.7 strict: 是否配置路由后面的 ‘&#x2F;‘</li>
</ul>
<h3 id="二、Switch"><a href="#二、Switch" class="headerlink" title="二、Switch"></a>二、Switch</h3><p>渲染与该地址匹配的第一个子节点<Route>或者<Redirect>。</p>
<p>类似于选项卡，只是匹配到第一个路由后，就不再继续匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path=&#x27;/home&#x27;  component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&#x27;/login&#x27;  component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&#x27;/detail&#x27;  component=&#123;detail&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Redirect to=&quot;/home&quot; from=&#x27;/&#x27; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line"></span><br><span class="line">// 类似于：</span><br><span class="line">// switch(Route.path) &#123;</span><br><span class="line">//     case &#x27;/home&#x27;:</span><br><span class="line">//         return Home</span><br><span class="line">//     case &#x27;/login&#x27;:</span><br><span class="line">//         return Login</span><br><span class="line">//     ··· ···</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

<p>所以，如果像下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path=&#x27;/home&#x27;  component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&#x27;/login&#x27;  component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&#x27;/detail&#x27;  component=&#123;detail&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&#x27;/detail/:id&#x27;  component=&#123;detailId&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Redirect to=&quot;/home&quot; from=&#x27;/&#x27; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<p>当路由为&#x2F;detail&#x2F;1 时，只会访问匹配组件 detail, 所以需要在 detail 路由上加上 exact:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path=&#x27;/home&#x27;  component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&#x27;/login&#x27;  component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&#x27;/detail&#x27; exact  component=&#123;detail&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&#x27;/detail/:id&#x27;  component=&#123;detailId&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Redirect to=&quot;/home&quot; from=&#x27;/&#x27; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果路由 Route 外部包裹 Switch 时，路由匹配到对应的组件后，就不会继续渲染其他组件了。但是如果外部不包裹 Switch 时，所有路由组件会先渲染一遍，然后选择到匹配的路由进行显示。</strong></p>
<h2 id="5-导航组件-Link-和-NavLink"><a href="#5-导航组件-Link-和-NavLink" class="headerlink" title="5. 导航组件: Link 和 NavLink"></a>5. 导航组件: Link 和 NavLink</h2><p>Link 和 NavLink 都可以用来指定路由跳转，NavLink 的可选参数更多。</p>
<p><strong>Link</strong></p>
<p>两种配置方式：</p>
<p><strong>通过字符串执行跳转路由</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#x27;/login&#x27;&gt;</span><br><span class="line">    &lt;span&gt;登录&lt;/span&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<p><strong>通过对象指定跳转路由</strong></p>
<ul>
<li>pathname: 表示要链接到的路径的字符串。</li>
<li>search: 表示查询参数的字符串形式。</li>
<li>hash: 放入网址的 hash，例如 #a-hash。</li>
<li>state: 状态持续到 location。通常用于隐式传参（埋点），可以用来统计页面来源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">        pathname: &#x27;/login&#x27;,</span><br><span class="line">        search: &#x27;?name=cedric&#x27;,</span><br><span class="line">        hash: &#x27;#someHash&#x27;,</span><br><span class="line">        state: &#123; fromWechat: true &#125;</span><br><span class="line">    &#125;&#125;&gt;</span><br><span class="line">    &lt;span&gt;登录&lt;/span&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<p>点击链接 进入 Login 页面后，就可以在 this.props.location.state 中看到 fromWechat: true</p>
<p><strong>NavLink</strong></p>
<p>可以看做 一个特殊版本的 Link，当它与当前 URL 匹配时，为其渲染元素添加样式属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#x27;/login&#x27; activeClassName=&quot;selected&quot;&gt;</span><br><span class="line">    &lt;span&gt;登录&lt;/span&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/login&quot;</span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    fontWeight: &#x27;bold&#x27;,</span><br><span class="line">    color: &#x27;red&#x27;</span><br><span class="line">   &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;span&gt;登录&lt;/span&gt;</span><br><span class="line">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>exact: 如果为 true，则仅在位置完全匹配时才应用 active 的类&#x2F;样式。</li>
<li>strict: 当为 true，要考虑位置是否匹配当前的 URL 时，pathname 尾部的斜线要考虑在内。</li>
<li>location 接收一个 location 对象，当 url 满足这个对象的条件才会跳转</li>
<li>isActive: 接收一个回调函数，只有当 active 状态变化时才能触发，如果返回 false 则跳转失败</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const oddEvent = (match, location) =&gt; &#123;</span><br><span class="line">  if (!match) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  const eventID = parseInt(match.params.eventID)</span><br><span class="line">  return !isNaN(eventID) &amp;&amp; eventID % 2 === 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/login&quot;</span><br><span class="line">  isActive=&#123;oddEvent&#125;</span><br><span class="line">&gt;login&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-Redirect"><a href="#6-Redirect" class="headerlink" title="6. Redirect"></a>6. Redirect</h2><p><Redirect> 将导航到一个新的地址。即重定向。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path=&#x27;/home&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Redirect to=&quot;/home&quot; from=&#x27;/&#x27; exact /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<p>上面，当访问路由‘&#x2F;’时，会直接重定向到‘&#x2F;home’。<br><Redirect> 常在用户是否登录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Center extends PureComponent &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; loginStatus &#125; = this.props;</span><br><span class="line">        if (loginStatus) &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;个人中心&lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &lt;Redirect to=&#x27;/login&#x27; /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可使用对象形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect</span><br><span class="line">  to=&#123;&#123;</span><br><span class="line">    pathname: &quot;/login&quot;,</span><br><span class="line">    search: &quot;?utm=your+face&quot;,</span><br><span class="line">    state: &#123; referrer: currentLocation &#125;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="7-withRouter"><a href="#7-withRouter" class="headerlink" title="7. withRouter"></a>7. withRouter</h2><p>withRouter 可以将一个非路由组件包裹为路由组件，使这个非路由组件也能访问到当前路由的 match, location, history 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; withRouter &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">class Detail extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        ··· ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        ··· ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = (dispatch) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        ··· ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(withRouter(Detail));</span><br></pre></td></tr></table></figure>

<h2 id="8-编程式导航-history-对象"><a href="#8-编程式导航-history-对象" class="headerlink" title="8. 编程式导航 - history 对象"></a>8. 编程式导航 - history 对象</h2><p>例如，点击 img 进入登录页：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Home extends PureComponent &#123;</span><br><span class="line"></span><br><span class="line">    goHome = () =&gt; &#123;</span><br><span class="line">        console.log(this.props);</span><br><span class="line"></span><br><span class="line">        this.props.history.push(&#123;</span><br><span class="line">            pathname: &#x27;/login&#x27;,</span><br><span class="line">            state: &#123;</span><br><span class="line">                identityId: 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;img className=&#x27;banner-img&#x27; alt=&#x27;&#x27; src=&quot;img.png&quot; onClick=&#123;this.goHome&#125; /&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>history 对象通常会具有以下属性和方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">length - (number 类型) history 堆栈的条目数</span><br><span class="line">action - (string 类型) 当前的操作(PUSH, REPLACE, POP)</span><br><span class="line">location - (object 类型) 当前的位置。location 会具有以下属性：</span><br><span class="line">pathname - (string 类型) URL 路径</span><br><span class="line">search - (string 类型) URL 中的查询字符串</span><br><span class="line">hash - (string 类型) URL 的哈希片段</span><br><span class="line">state - (object 类型) 提供给例如使用 push(path, state) 操作将 location 放入堆栈时的特定 location 状态。只在浏览器和内存历史中可用。</span><br><span class="line">push(path, [state]) - (function 类型) 在 history 堆栈添加一个新条目</span><br><span class="line">replace(path, [state]) - (function 类型) 替换在 history 堆栈中的当前条目</span><br><span class="line">go(n) - (function 类型) 将 history 堆栈中的指针调整 n</span><br><span class="line">goBack() - (function 类型) 等同于 go(-1)</span><br><span class="line">goForward() - (function 类型) 等同于 go(1)</span><br><span class="line">block(prompt) - (function 类型) 阻止跳转。</span><br></pre></td></tr></table></figure>

<p>注意，只有通过 Route 组件渲染的组件，才能在 this.props 上找到 history 对象<br>所以，如果想在路由组件的子组件中使用 history ，需要使用 withRouter 包裹:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; PureComponent &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; withRouter &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">class 子组件 extends PureComponent &#123;</span><br><span class="line"></span><br><span class="line">    goHome = () =&gt; &#123;</span><br><span class="line">        this.props.history.push(&#x27;/home&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(this.props)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div onClick=&#123;this.goHome&#125;&gt;子组件&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default withRouter(子组件);</span><br></pre></td></tr></table></figure>

<h2 id="9-路由过渡动画"><a href="#9-路由过渡动画" class="headerlink" title="9. 路由过渡动画"></a>9. 路由过渡动画</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import &#123; TransitionGroup, CSSTransition &#125; from &quot;react-transition-group&quot;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">          &lt;BrowserRouter&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;Header /&gt;</span><br><span class="line"></span><br><span class="line">              &#123;/* 最外部的&lt;Route&gt;&lt;/Route&gt;不进行任何路由匹配，仅仅是用来传递 location */&#125;</span><br><span class="line"></span><br><span class="line">              &lt;Route render=&#123;(&#123;location&#125;) =&gt; &#123;</span><br><span class="line">                console.log(location);</span><br><span class="line">                return (</span><br><span class="line">                  &lt;TransitionGroup&gt;</span><br><span class="line">                    &lt;CSSTransition</span><br><span class="line">                      key=&#123;location.key&#125;</span><br><span class="line">                      classNames=&#x27;fade&#x27;</span><br><span class="line">                      timeout=&#123;300&#125;</span><br><span class="line">                    &gt;</span><br><span class="line">                      &lt;Switch&gt;</span><br><span class="line">                        &lt;Redirect exact from=&#x27;/&#x27; to=&#x27;/home&#x27; /&gt;</span><br><span class="line">                        &lt;Route path=&#x27;/home&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">                        &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class="line">                        &lt;Route path=&#x27;/write&#x27; exact component=&#123;Write&#125;&gt;&lt;/Route&gt;</span><br><span class="line">                        &lt;Route path=&#x27;/detail/:id&#x27; exact component=&#123;Detail&#125;&gt;&lt;/Route&gt;</span><br><span class="line">                        &lt;Route render=&#123;() =&gt; &lt;div&gt;Not Found&lt;/div&gt;&#125; /&gt;</span><br><span class="line">                      &lt;/Switch&gt;</span><br><span class="line">                    &lt;/CSSTransition&gt;</span><br><span class="line">                  &lt;/TransitionGroup&gt;</span><br><span class="line">                )</span><br><span class="line">              &#125;&#125;&gt;</span><br><span class="line">              &lt;/Route&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          &lt;/BrowserRouter&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.fade-enter &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  z-index: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fade-enter.fade-enter-active &#123;</span><br><span class="line">  opacity: 1;</span><br><span class="line">  transition: opacity 300ms ease-in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-打包部署的路由配置"><a href="#10-打包部署的路由配置" class="headerlink" title="10. 打包部署的路由配置"></a>10. 打包部署的路由配置</h2><p>项目执行 npm run build 后，将打包后的 build 文件，放置到 Nginx 配置的静态地址中。</p>
<p>如果 react-router 路由 使用了 history 模式（即<BrowserRouter>），那么在 Nginx 配置中必须加上:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        ··· ···</span><br><span class="line">        try_files $uri /index.html;</span><br><span class="line">        ··· ···</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果 react-router 路由 使用了 hash 模式，那么在 Nginx 中不需要上面的配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BF%83%E5%BE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BF%83%E5%BE%97/" class="post-title-link" itemprop="url">微信小程序开发总结与心得</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 13:58:49 / 修改时间：14:01:51" itemprop="dateCreated datePublished" datetime="2022-12-16T13:58:49+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">小程序开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-微信小程序基本知识与概念"><a href="#1-微信小程序基本知识与概念" class="headerlink" title="1 微信小程序基本知识与概念"></a>1 微信小程序基本知识与概念</h2><p>微信小程序开发，入门算是非常简单，只要看官方文档即可<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/">小程序简易教程</a>。如何申请小程序账号，如何开发自己第一个小程序，如何发布，这一系列 hello world 操作官方文档都有手把手教学。小程序开发的每个步骤，提供的能力文档里都有，个人觉得，做小程序开发，有事没事都看下文档，因为小程序更新比较快速，同时一些细小的能力我们可能会漏掉，所以多看文档。</p>
<h3 id="1-1-简单说下目录结构和-app-json"><a href="#1-1-简单说下目录结构和-app-json" class="headerlink" title="1.1 简单说下目录结构和 app.json"></a>1.1 简单说下目录结构和 app.json</h3><p><strong>文件目录结构很灵活</strong></p>
<p>先来看看小程序项目的文件目录结构</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-101ad1c2c34b78e2?imageMogr2/auto-orient/strip%7CimageView2/2/w/358/format/webp" alt="image"></p>
<p>除了 app.json 必须位于根目录下，其他文件随意，并且都可以删。并且页面文件可以放到任何位置，只要在 app.json 中的 pages 中配置了就可以。可以说是很灵活。你还可以多个页面放在同个文件夹下。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-34ea9f7b6d403430?imageMogr2/auto-orient/strip%7CimageView2/2/w/294/format/webp" alt="image"></p>
<p><strong>接下来简单介绍下各个文件</strong>:</p>
<p>全局配置文件 app.json<br>对于一个小程序项目而言，最重要的文件是 app.json，它也是开发工具识别一个文件夹是否为小程序项目的标识。当使用开发者工具创建一个项目时，如果选择的是空文件夹，它会创建一个新的项目。如果是一个有文件的文件夹，它会看该文件夹中是否有 app.json 文件，如果有，则它会认为是一个小程序项目，则会打开该项目，如果文件夹中没有 app.json 文件，则提示无法创建项目。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-f636fee7c8bb0521?imageMogr2/auto-orient/strip%7CimageView2/2/w/411/format/webp" alt="image"></p>
<p>app.json 必须放置于项目的根目录下，它是小程序项目的全局配置文件。在小程序代码包准备完成进行启动后（下文会详细介绍小程序从用户点击打开小程序到小程序销毁的整个过程），会先读取 app.json 文件，进行小程序的初始化，比如初始化整个小程序外框样式，获取首页页面地址等。</p>
<blockquote>
<p>其实小程序就是微信提供的一个容器，各个页面就在这个容器里加载运行销毁</p>
</blockquote>
<p>下面介绍下小程序的全局配置选项:</p>
<p>注意：</p>
<blockquote>
<ul>
<li>所有配置项 key 必须使用双引号括起来，value 值为字符串类型的也必须使用双引号，不支持单引号</li>
<li>因为小程序功能迭代非常迅速，基础库版本更新也很快，所以下面的介绍是截止目前的最新版本库 2.4.0</li>
</ul>
</blockquote>
<ul>
<li><strong>pages</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;pages&quot;: [</span><br><span class="line">        &quot;pages/index/index&quot;,</span><br><span class="line">        &quot;pages/log/log&quot;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>在 app.json 中，pages 选项是必须配置的。该配置项注册了小程序所有页面的地址，其中每一项都是页面的 <strong>路径+文件名</strong> 。配置的字符串其实就是每个页面 wxml 路径，去掉.wxml 后缀。因为框架会自动去寻找路径下.json、.js、.wxml、.wxss 四个文件进行整合。也就意味着.json、.js、.wxss 这三个文件的文件名必须要和.wxml 的一致，否则不生效。所以一个页面至少必须得有.wxml 文件。</p>
<blockquote>
<p>总结：</p>
<p>页面的.json、.js、.wxss 文件必须与.wxml 文件同名，否则不生效<br>每个页面都必须在 pages 下注册，没有注册的页面，如果不访问，编译能通过，一旦试图访问该页面则会报错<br>可以通过在 pages 下添加一个选项快速新建一个页面，开发工具会自动生成对应的文件</p>
</blockquote>
<ul>
<li><strong>window</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;window&quot;:&#123;</span><br><span class="line">    &quot;enablePullDownRefresh&quot;: ture,</span><br><span class="line">    &quot;navigationStyle&quot;: &quot;custom&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该配置项用于配置小程序的全局外观样式，具体请查阅文档。这里重点提一下两个比较实用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//去掉默认的导航栏，轻松实现全面屏</span><br><span class="line">&quot;navigationStyle&quot;: &quot;custom&quot; ,</span><br><span class="line">//开启自带的下拉刷新，减少自己写样式</span><br><span class="line">&quot;enablePullDownRefresh&quot;: true,</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>tabBar</strong><br>该选项可以让我们轻松实现导航栏 tab 效果，不过有个不足就是跳转可操作性非常低。就是每个 tab 只能跳当前小程序页面，不能跳到其他小程序。如果需要跳到其他小程序，还需自己封装个组件。</p>
</li>
<li><p><strong>networkTimeout</strong><br>这是网络请求超时时间，可以设置不同类型请求的超时时间，比如 wx.request、wx.uploadFile 等。其实很多时候我们都会忽略这个选项，小程序默认是 60s 超时，但我们应该手动设置更低的值，因为我们的接口一般都会在 10s 内完成请求（如果超过 10s，那你是时候优化了），所以如果网络或者服务器出问题了，那么会让用户等 60s，最后还是失败，这对用户很不友好，还不如提前告诉用户，现在出问题了，请稍后再试。</p>
</li>
</ul>
<p>前段时间由于公司服务器网关出现了点小问题，导致有些请求连接不上，出现大量连接超时。通过之前添加的错误信息收集插件(这个是性能优化，下文有讲到)看到了很多接口返回 time-out 60s。让用户等了 60s 还是失败，这不友好。所以这个超时时间一般设置 15s-30s 比较好。</p>
<ul>
<li><p><strong>debug</strong><br>是否开启 debug 功能，开启后查看更多的调试信息，方便定位问题，开发阶段可以考虑开启</p>
</li>
<li><p><strong>functionalPages</strong><br>这个是结合插件使用的，因为微信小程序插件有很大限制，插件里提供的 api 很有限，wx.login 和 wx.requestPayment 在插件中不能使用，如果需要获取用户信息和进行支付，就必须通过插件提供的功能去实现。当你的小程序下的插件启用了插件功能时，必须设置该选项为 true</p>
</li>
</ul>
<blockquote>
<p>小程序插件必须挂载在一个微信小程序中，一个小程序也只能开通一个插件。当你小程序开通的插件启用了插件功能时，必须设置该选项为 true</p>
</blockquote>
<ul>
<li><strong>plugins</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: &#123;</span><br><span class="line">    &quot;myPlugin&quot;: &#123;</span><br><span class="line">        &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">        &quot;provider&quot;: &quot;wxidxxxxxxxxxxxxxxxx&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当小程序使用了插件就必须在这里声明引入。小程序自身开通的小程序不能在本身应用</p>
<ul>
<li><strong>navigateToMiniProgramAppIdList</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;navigateToMiniProgramAppIdList&quot;: [</span><br><span class="line">    &quot;wxe5f52902cf4de896&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>之前小程序之间只要是关联了通过公众号就可以相互跳转，如今微信做出了限制，要这里配置好需要跳转的小程序，上限为 10 个，还必须写死，不支持配置。所以当小程序有跳转到其他小程序，一定要配好这个，否则无法跳转。</p>
<ul>
<li><strong>usingComponents</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;hello-component&quot;: &quot;plugin://myPlugin/hello-component&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义组件或者插件提供的组件前，必须先在这里声明</p>
<h3 id="1-2-小程序启动与生命周期"><a href="#1-2-小程序启动与生命周期" class="headerlink" title="1.2 小程序启动与生命周期"></a>1.2 小程序启动与生命周期</h3><p>下面来说说小程序从用户点击打开到销毁的整个过程。用图说话更清晰，特地画了个流程图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-453ef44118136478?imageMogr2/auto-orient/strip%7CimageView2/2/w/985/format/webp" alt="image"></p>
<blockquote>
<p>小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。 假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。</p>
</blockquote>
<p>上面的流程图包含了所有内容，但毕竟文字有限，接下来详细说下几个点。</p>
<ol>
<li>小程序会先检测本地是否有代码包，然后先使用本地代码包进行小程序启动，再异步去检测远端版本。这就是小程序的离线能力，相对于 H5，这是优点，能加快小程序启动速度。</li>
<li>当本地有小程序代码包时，会异步去请求远端是否有最新版本。有则下载到本地，但该次的启动还是会用之前的代码。所以当我们发布了最新的版本，需要用户两次冷启动，才能使用到最新版本。如果想要用户一次冷启动就可以使用到最新版本，可以使用小程序提供的版本更新<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/update/wx.getUpdateManager.html">API 更新</a>。代码如下，只要在 app.js 的 onShow 函数加上以下代码，每次小程序有更新，都会提示用户更新小程序。不过这个每次提示更新，一定程度上影响用户体验。如果结合后端配置，每次进来读取配置，就可以实现根据需要是否进行该版本的更新，比如一定需要用户更新才能使用的，那就使用强制更新。对于一些小版本，就不需要使用这个强制更新。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">if (wx.canIUse(&#x27;getUpdateManager&#x27;)) &#123;</span><br><span class="line">        //检测是否有版本更新</span><br><span class="line">        var updateManager = wx.getUpdateManager()</span><br><span class="line">        updateManager.onCheckForUpdate(function (res) &#123;</span><br><span class="line">            // 请求完新版本信息的回调，有更新</span><br><span class="line">            if (res.hasUpdate) &#123;</span><br><span class="line">                wx.showLoading(&#123;</span><br><span class="line">                    title: &#x27;检测到新版本&#x27;,</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        updateManager.onUpdateReady(function () &#123;</span><br><span class="line">            wx.hideLoading();</span><br><span class="line">            wx.showModal(&#123;</span><br><span class="line">                title: &#x27;更新提示&#x27;,</span><br><span class="line">                content: &#x27;新版本已经准备好，是否重启应用？&#x27;,</span><br><span class="line">                success: function (res) &#123;</span><br><span class="line">                    if (res.confirm) &#123;</span><br><span class="line">                        //清楚本地缓存</span><br><span class="line">                        try &#123;</span><br><span class="line">                            wx.clearStorageSync()</span><br><span class="line">                        &#125; catch (e) &#123;</span><br><span class="line">                            // Do something when catch error</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span><br><span class="line">                        updateManager.applyUpdate()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        updateManager.onUpdateFailed(function () &#123;</span><br><span class="line">            // 新的版本下载失败</span><br><span class="line">            console.log(&#x27;新版本下载失败&#x27;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-开发工具"><a href="#1-3-开发工具" class="headerlink" title="1.3 开发工具"></a>1.3 开发工具</h3><p>对于小程序开发工具，还没有一款让开发者满意的工具，至少我不满意，哈哈哈！微信提供的<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html">微信开发者工具</a>。除了编译器不行外，其他都还行。但由于开发工具、ios、android 三个平台运行小程序的内核不同。所以有时会出现开发工具上没问题，真机有问题的情况，特别是样式，可以通过在开发工具中设置<strong>上传代码时样式自动补全</strong>来解决大多数问题。另外微信开发者工具提供了真机调试功能，该功能对真机调试非常方便</p>
<p>还有就是可以自定义编译条件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-9d9e1ef862ec01a2?imageMogr2/auto-orient/strip%7CimageView2/2/w/668/format/webp" alt="image"></p>
<p>可以模拟任意场景值、设置页面参数、模拟更新等。基本满足了所有的调试。不过还有一些效果，开发工具和真机可能会不同，所以还是需要在真机上确认。</p>
<h3 id="1-4-测试-审核-上线的那些事"><a href="#1-4-测试-审核-上线的那些事" class="headerlink" title="1.4 测试-审核-上线的那些事"></a>1.4 测试-审核-上线的那些事</h3><p>服务器域名 request 合法域名每个月只能修改 5 次。所以不应该每次请求一个新域名就添加一次。在开发阶段，在微信开发者工具上勾上不校验合法域名，真机上需要开启调试模式，就可以先不配置合法域名的情况下请求任何域名甚至 ip 地址。待开发完成了，再一次性配置所有合法域名，在微信开发者工具上取消不校验合法域名，真机上关闭调试模式，然后开始测试。</p>
<p>使用体验版+线上环境的接口，这就是和线上环境一模一样的，所以在发布前，使用体验版+线上环境过一遍。如果没问题，发布以后也就没问题了。</p>
<p>小程序二维码只要发布了线上版本调用生成小程序二维码接口才能成功返回二维码。而且二维码识别是线上版本，所以还未发布的小程序是无法生成二维码的。</p>
<p>线上版本有个版本回退功能，这里有个坑，就是版本回退以后，退回的版本需要重新审核才能发布</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-7f06298163544864?imageMogr2/auto-orient/strip%7CimageView2/2/w/307/format/webp" alt="image"></p>
<p>还有设置体验版时可以设置指定路径和参数，这样很方便测试</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-5430f5ac8e795afe?imageMogr2/auto-orient/strip%7CimageView2/2/w/610/format/webp" alt="image"></p>
<h2 id="2-重点介绍几个组件"><a href="#2-重点介绍几个组件" class="headerlink" title="2 重点介绍几个组件"></a>2 重点介绍几个组件</h2><p>接下来说说使用频率比较多，功能强大，但又有比较多坑的几个组件</p>
<h3 id="2-1-web-view"><a href="#2-1-web-view" class="headerlink" title="2.1 web-view"></a>2.1 web-view</h3><p>web-view 的出现，让小程序和 H5 网页之前的跳转成为了可能。通过把 H5 页面放置到 web-view 中，可以让 H5 页面在小程序内运行。同时在 H5 页面中也可以跳转回小程序页面。可以说是带来了很大的便利，但同时由于 web-view 的诸多限制，用起来也不是很舒服。</p>
<blockquote>
<ol>
<li>需要打开的 H5 页面必须在后台业务页面中配置，这其中还有个服务校验。另外 H5 页面必须是 https 协议，否则无法打开</li>
<li>web-view 中无法在页面中调起分享，如果需要分享，比如跳回小程序原生页面</li>
<li>小程序与 web-view 里 H5 通信问题。小程序向 web-view 传递，不敏感信息可以通过页面 url 传递。如果是敏感信息比如用户 token 等，可以让服务端重定向，比如请求服务端一个地址，让他把敏感信息写在 cookie 中，再重定向到我们的 H5 页面。之后 H5 页面就可以通过在 cookie 中拿这些敏感数据了，或者 http-only，发送请求时直接带上。</li>
<li>每次 web-view 中 src 值有变化就会重新加载一次页面。所以用 src 拼接参数时，需要先赋值给一个变量拼接好，再一次性 setData 给 web-view 的 src，防止页面重复刷新</li>
<li>从微信客户端 6.7.2 版本开始，navigationStyle: custom 对<web-view>组件无效。也就意味着使用 web-view 时，自带的导航栏无法去掉。</li>
<li>因为导航栏无法去掉，这里就出现了一个巨大的坑。实现全屏效果问题。如果想要实现 H5 页面全屏，就是不滑动，全屏显示完所有内容。这时如果你使用 width:100%;height:100%，你会发现，你页面底部可能会缺失一段。上图:</li>
</ol>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-9488d1d3f38ec3b2?imageMogr2/auto-orient/strip%7CimageView2/2/w/864/format/webp" alt="image"></p>
<p>因为 web-view 是默认铺满全屏的，也就是 web-view 宽高和屏幕宽高一样。然后 H5 页面这是高度 100%，这是相对 web-view 的高度，也是屏幕高度。但是关键问题：<strong>web-view 里 H5 页面是从导航栏下开始渲染的</strong>。这就导致了 H5 页面溢出了屏幕，无法达到全屏效果。</p>
<p><strong>解决方法</strong></p>
<p>这个问题我在前段时间的实际项目碰到过，我们要做个 H5 游戏，要求是全屏，刚开始我也是设置高度 100%。后来发现底部一块不见了。我的解决方法比较粗暴，如果有更好的解决方法，欢迎评论交流。<br>我的解决方法是：通过拼接宽高参数在 H5 页面 url 上，这个宽高是在 web-view 外层计算好的。H5 页面直接读取 url 上的宽高，动态设置页面的宽高。页面高度的计算，根据上图，很显然就是屏幕高度减去导航栏高度。宽度都是一样的，直接是屏幕宽度。</p>
<p>但问题又来了，貌似没有途径获取导航栏高度。而且对于不同机型的手机，导航栏高度不同。经过了对多个机型导航栏跟屏幕高度的比较。发现了一个规律，导航栏高度与屏幕高度、屏幕宽高比有一定的关系。所以根据多个机型就计算出了这个比例。这解决了 95%以上手机的适配问题，只有少数机型适配不是很好。基本实现了全屏效果。具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">onLoad (options) &#123;</span><br><span class="line">    //同步获取屏幕信息，现在用到的是屏幕宽高</span><br><span class="line">    var res = wx.getSystemInfoSync();</span><br><span class="line">    if (res) &#123;</span><br><span class="line">        var widHeight = res.screenHeight;</span><br><span class="line">        //对于大多数手机，屏幕高度/屏幕宽度 = 1.78。此时导航栏占屏幕高度比为0.875</span><br><span class="line">        var raito = 0.875;</span><br><span class="line">        if (res.screenHeight / res.screenWidth &gt; 1.95) &#123;</span><br><span class="line">            //对于全屏手机，这个占比会更高些</span><br><span class="line">            raito = 0.885;</span><br><span class="line">        &#125; else if (res.screenHeight / res.screenWidth &gt; 1.885) &#123;</span><br><span class="line">            raito = 0.88;</span><br><span class="line">        &#125;</span><br><span class="line">        //做兼容处理，只有微信版本库高于6.7.2，有导航栏才去兼容，否则可以直接使用高度100%。res.statusBarHeight是手机顶部状态栏高度</span><br><span class="line">        //如果微信版本号大于6.7.2，有导航栏</span><br><span class="line">        if (util.compareVersion(res.version, &quot;6.7.2&quot;) &gt; 0) &#123;</span><br><span class="line">            widHeight = Math.round(widHeight * raito) + (res.statusBarHeight || 0);</span><br><span class="line">        &#125;</span><br><span class="line">        this.setDate(&#123;</span><br><span class="line">            //将H5页面宽高拼接在url上，赋值给web-view的src即可加载出H5页面</span><br><span class="line">            webview_src: util.joinParams(h5_src, &#123;</span><br><span class="line">                &quot;height&quot;: widHeight,</span><br><span class="line">                &quot;width&quot;: res.screenWidth</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-scroll-view"><a href="#2-2-scroll-view" class="headerlink" title="2.2 scroll-view"></a>2.2 scroll-view</h3><p>当我们要实现一个区域内滑动效果时，在 H5 页面中我们设置<code>overflow-y: scroll</code>即可。但在小程序中，没有该属性。需要用到 scroll-view 标签。具体操作实现我们可以查看文件<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html">scroll-view</a>。</p>
<p>锚点定位在前端开发中会经常用到，在 H5 页面中，我们会在 url 后面加上#来实现锚点定位效果。但是在小程序中这样是不起作用的，因为小程序内渲染页面的容器不是一个浏览器，无法实时监听 Hash 值的变化。但是使用 scroll-view，我们可以实现锚点定位效果。主要是使用 scroll-into-view 属性，具体实现我们直接上代码</p>
<blockquote>
<p>scroll-into-view | String | 值应为某子元素 id（id 不能以数字开头）。设置哪个方向可滚动，则在哪个方向滚动到该元素</p>
</blockquote>
<blockquote>
<p>wxml 文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--toView的值动态变化，当toView为luckydraw时，会定位到id为luckydraw的view</span><br><span class="line">    需要注意的是，这里需要设置高度为屏幕高度--&gt;</span><br><span class="line">    &lt;scroll-view scroll-y scroll-into-view=&quot;&#123;&#123;toView&#125;&#125;&quot;</span><br><span class="line">    scroll-with-animation = &quot;true&quot; style=&quot;height: 100%; white-space:nowrap&quot;&gt;</span><br><span class="line">        &lt;view id=&quot;top&quot;&gt;&lt;/view&gt;</span><br><span class="line">        &lt;view id=&quot;luckydraw&quot;&gt;&lt;/view&gt;</span><br><span class="line">        &lt;view id=&quot;secskill&quot;&gt;&lt;/view&gt;</span><br><span class="line">    &lt;scroll-view&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-canvas"><a href="#2-3-canvas" class="headerlink" title="2.3 canvas"></a>2.3 canvas</h3><p>画布标签，它是原生组件，所以它必须位于屏幕最上边，而且是不能隐藏的。所以如果想要使用 canvas 动态生成分享照片。那你要设置她的宽高和屏幕一样。要不导出为照片时就会失真。因为这个原因，所以生成分享照片还是由服务端实现吧，照片失真太严重了。</p>
<h2 id="3-formid-收集"><a href="#3-formid-收集" class="headerlink" title="3 formid 收集"></a>3 formid 收集</h2><p>给用户发送消息对一个小程序是非常重要的，它可以召唤回用户，导量效果非常明显。我们可以通过模板消息向小程序用户发送消息，但前提是我们得获取到 openid 和 formid。用户登录我们即可获取到用户 openid。而只要用户有点击行为，我们即可<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/form.html">获取 formid</a>。所以说 formid 是很重要的。我们可以提前收集好 formid，在需要的时候给用户推送消息。我们可以给每个 button 都包上 form 标签，只要有用户点击行为都可以收集到 formid.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form bindsubmit=&quot;formSubmit&quot; report-submit=&#x27;true&#x27;&gt;</span><br><span class="line">    &lt;button  formType=&quot;submit&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>我们实现一个 formid 收集系统，为了尽量减少冗余代码和减少对业务的影响，我们的设计是这样的</p>
<ol>
<li>在整个页面的最外层包裹 form 标签，不是每个 button 都包裹一个，这样只要是页面中<code>formType=submit</code>的 button 有点击都能获取到 formid。</li>
<li>formid 保存在全局变量数组中，当小程序切换到后台是一次性发送。</li>
<li>对于需要实时发送消息的，不添加到全局数组中，直接保存在页面变量中。</li>
</ol>
<blockquote>
<p>wxml 文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--在整个页面的最外层包裹form标签，这样就不必对每个button都包裹一个form标签，代码简洁--&gt;</span><br><span class="line">&lt;form bindsubmit=&quot;formSubmit&quot; report-submit=&#x27;true&#x27;&gt;</span><br><span class="line">    &lt;view&gt;页面内容&lt;/view&gt;</span><br><span class="line">    &lt;view&gt;页面内容&lt;/view&gt;</span><br><span class="line">    &lt;button  formType=&quot;submit&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;view&gt;页面内容&lt;/view&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">        &lt;button  formType=&quot;submit&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>page.js 文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//每次用户有点击，都将formid添加到全局数组中</span><br><span class="line">formSubmit(e) &#123;</span><br><span class="line">    //需要实时发送的，不添加</span><br><span class="line">    if(e.target.dataset.sendMsg)&#123;</span><br><span class="line">        formid =  e.detail.formId;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    app.appData.formIdArr.push(e.detail.formId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>app.js</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onHide: function () &#123;</span><br><span class="line">    //小程序切到后台时上传formid</span><br><span class="line">    this.submitFormId();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="4-性能优化相关"><a href="#4-性能优化相关" class="headerlink" title="4 性能优化相关"></a>4 性能优化相关</h2><p>从用户打开小程序到小程序销毁，我们可以想想有哪些地方是可以优化的。首先是打开速度。小程序打开速度直接影响了用户留存。在小程序后台，运维中心-监控告警下有个加载性能监控数据，我们可以看到小程序启动总耗时、下载耗时、首次渲染耗时等加载相关的数据。而这里的打开速度其实就是小程序的启动总耗时。它包括了代码包下载、首次渲染，微信内环境初始化等步凑。在这一步，我们能做的就是<strong>如何加快代码包下载速度和减少首次渲染时间</strong></p>
<p>在小程序呈现给用户之后，接下来就是如何提高用户体验，增强小程序健壮性的问题了。每个程序都有 bug。只是我们没发现而已，尽管在测试阶段，我们进行了详尽的测试。但是在实际生产环境，不同的用户环境，不同的操作路径，随时会触发一些隐藏的 bug。这时如果用户没有向我们报告，我们是无法获知的。所以有必要给我们的小程序<strong>增加错误信息收集</strong>，js 脚本错误，意味着整个程序挂掉了，无法响应用户操作。所以对于运行时的脚本错误，我们应该上报。对出现的 bug 及时修复，增强程序健壮性，提高用户体验。</p>
<p>每个程序都有大量的前后端数据交互，这是通过 http 请求进行的。因此，还有一个错误信息收集就是接口错误信息收集。对那些请求状态码非 2XX、3XX 的，或者请求接口成功了，但是数据不是我们预期的，都可以进行信息采集。</p>
<p>通过对小程序运行时脚本和 http 请求进行监控，我们就可以实时了解我们线上小程序的运行状况，有什么问题可以及时发现，及时修复，极高地提高了用户体验性。</p>
<h3 id="4-1-让小程序更快"><a href="#4-1-让小程序更快" class="headerlink" title="4.1 让小程序更快"></a>4.1 让小程序更快</h3><p>让小程序快，主要因素有两个，代码包下载和首屏渲染。<br>我们来看一个数据：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-59f56fb9a79610ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="image"></p>
<p>前面状态小程序代码大小是 650Kb 左右，这是下载耗时（虽然跟用户网络有关，但这个是全部用户平均时间）是 1.3s 左右。但是经过优化，将代码包降低至 200kb 左右时。下载耗时只有 0.6s 左右。所以说，代码包减少 500kb，下载耗时能减少 0.5s。这个数据还是非常明显的。所以说，在不影响业务逻辑的情况下，我们小程序代码包应该尽可能地小。那么如何降低代码包大小呢？以下有几点可以参考</p>
<ol>
<li><p>因为我们上传代码到微信服务器时，它会将我们的代码进行压缩的，所以用户下载的代码包并不是我们开发时的那个大小。对此，开发时也没必要删空行、删注释这些。在开发工具项目详情中可以看到上次上传大小，这个大小就是用户最终使用的大小。如果觉得微信压缩还不够好，可以通过第三方工具对我们代码进行一次压缩再上传，然后对比效果，有没有更小。这个没有使用过。如果有什么好工具，欢迎推荐。</p>
</li>
<li><p>将静态资源文件上传到我们自己服务器或者 cdn 上。一个小程序，最耗空间的往往是图片文件。所以我们可以抽离出来，图片文件可以异步获取，在小程序启动以后再去获取。这样，代码包就会小很多。</p>
</li>
<li><p>使用分包加载。小程序提供了分包加载功能。如果你的小程序很庞大，可以考虑使用分包加载功能，先加载必要功能代码。这样就可以极大降低代码包大小<br>接下来是首屏渲染，从上图的小程序生命周期可以看出，从加载首页代码到首页完成渲染，这段时间就是白屏时间，也就是首次渲染时间。而小程序在这段时间内，主要工作是：加载首页代码、创建 View 和 AppService 层、初始数据传输、页面渲染。在这四个步骤中，加载首页代码，前面已经说过；创建 View 和 AppService 层，是微信完成的，跟用户手机有关，这不是我们可控的。我们能做的就是减少初始数据传输时间和页面渲染时间。</p>
</li>
<li><p>我们知道 page.js 中的 data 对象在首次渲染时会通过数据管道传到视图层进行页面渲染。所以我们应该控制这个 data 对象的大小。对于与视图渲染无关的数据，不要放在 data 里面，可以设置个全局变量来保存。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">        //与页面渲染有关的数据放这里</span><br><span class="line">        data: &#123;</span><br><span class="line">            goods_list:[]</span><br><span class="line">        &#125;,</span><br><span class="line">        //与页面渲染无关的数据放这里</span><br><span class="line">        _data: &#123;</span><br><span class="line">            timer: null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>页面渲染速度还跟 html 的 dom 结构有关。这一点的优化空间算是非常少了，就是写高质量 html 代码，减少 dom 嵌套，让页面渲染速度快一丢丢。</li>
</ol>
<h3 id="4-2-让小程序更强"><a href="#4-2-让小程序更强" class="headerlink" title="4.2 让小程序更强"></a>4.2 让小程序更强</h3><p>接下来就是给小程序增加错误信息收集，包括 js 脚本错误信息收集和 http 请求错误信息收集。前段时间，在实际工作开发中，为了更好的复用和管理，我把这个错误信息收集功能做成了插件。然而做成插件并没有想象中的那么美好，下面再具体说。</p>
<p><strong>脚本错误收集</strong></p>
<p>对于脚本错误收集，这个相对比较简单，因为在 app.js 中提供了监听错误的 onError 函数</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-0bbdba7dbe77acc9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1118/format/webp" alt="image"></p>
<p>只不过错误信息是包括堆栈等比较详细的错误信息，然后当上传时我们并不需要这么多信息，第一浪费宽带，第二看着累又无用。我们需要的信息是：错误类型、错误信息描述、错误位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">thirdScriptError</span><br><span class="line">aa is not defined;at pages/index/index page test function</span><br><span class="line">ReferenceError: aa is not defined</span><br><span class="line">    at e.test (http://127.0.0.1:62641/appservice/pages/index/index.js:17:3)</span><br><span class="line">    at e.&lt;anonymous&gt; (http://127.0.0.1:62641/appservice/__dev__/WAService.js:16:31500)</span><br><span class="line">    at e.a (http://127.0.0.1:62641/appservice/__dev__/WAService.js:16:26386)</span><br><span class="line">    at J (http://127.0.0.1:62641/appservice/__dev__/WAService.js:16:20800)</span><br><span class="line">    at Function.&lt;anonymous&gt; (http://127.0.0.1:62641/appservice/__dev__/WAService.js:16:22389)</span><br><span class="line">    at http://127.0.0.1:62641/appservice/__dev__/WAService.js:16:27889</span><br><span class="line">    at http://127.0.0.1:62641/appservice/__dev__/WAService.js:6:16777</span><br><span class="line">    at e.(anonymous function) (http://127.0.0.1:62641/appservice/__dev__/WAService.js:4:3403)</span><br><span class="line">    at e (http://127.0.0.1:62641/appservice/appservice?t=1543326089806:1080:20291)</span><br><span class="line">    at r.registerCallback.t (http://127.0.0.1:62641/appservice/appservice?t=1543326089806:1080:20476)</span><br></pre></td></tr></table></figure>

<p>这是错误信息字符串，接下来我们对它进行截取只需要拿我们想要的信息即可。我们发现这个字符串是有规则的。第一行是错误类型，第二行是错误详情和发生的位置，并且是”;”分号分开。所以我们还是很容易就可以拿到我们想要的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//格式化错误信息</span><br><span class="line">function formateErroMsg(errorMsg)&#123;</span><br><span class="line">    //包一层try catch 不要让信息收集影响了业务</span><br><span class="line">    try&#123;</span><br><span class="line">        var detailMsg = &#x27;&#x27;;</span><br><span class="line">        var detailPosition= &#x27;&#x27;;</span><br><span class="line">        var arr = errorMsg.split(&#x27;\n&#x27;)</span><br><span class="line">        if (arr.length &gt; 1) &#123;</span><br><span class="line">            //错误详情和错误位置在第二行并用分好隔开</span><br><span class="line">            var detailArr = arr[1].split(&#x27;;&#x27;)</span><br><span class="line">            detailMsg = detailArr.length &gt; 0 ? detailArr[0] : &#x27;&#x27;;</span><br><span class="line">            if (detailArr.length &gt; 1) &#123;</span><br><span class="line">                detailArr.shift()</span><br><span class="line">                detailPosition = detailArr.join(&#x27;;&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var obj = &#123;</span><br><span class="line">            //错误类型就是第一行</span><br><span class="line">            error_type: arr.length &gt; 0 ? arr[0] : &#x27;&#x27;,</span><br><span class="line">            error_msg: detailMsg,</span><br><span class="line">            error_position: detailPosition</span><br><span class="line">        &#125;;</span><br><span class="line">        return obj</span><br><span class="line">    &#125;catch(e)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到我们想要的信息，就可以发送到我们服务后台，进行数据整理和显示，这个需要服务端配合，就不深入讲了，我们拿到了数据，其他都不是事。</p>
<p><strong>http 请求错误信息收集</strong></p>
<p>对于 http 请求错误信息收集方式，我们尽量不要暴力埋点，每个请求发送前发送后加上我们的埋点。这样工作量太大，也不易维护。因此，我们可以从底层出发，<strong>拦截 wx.request 请求</strong>。使用 Object.defineProperty 对 wx 对象的 request 进行重新定义。具体实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">function rewriteRequest()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        const originRequest = wx.request;</span><br><span class="line">        Object.defineProperty(wx, &#x27;request&#x27;, &#123;</span><br><span class="line">            configurable:true,</span><br><span class="line">            enumerable: true,</span><br><span class="line">            writable: true,</span><br><span class="line">            value: function()&#123;</span><br><span class="line">                let options = arguments[0] || &#123;&#125;;</span><br><span class="line">                //对于发送错误信息的接口不收集，防止死循环</span><br><span class="line">                var regexp = new RegExp(&quot;https://xxxx/error&quot;,&quot;g&quot;);</span><br><span class="line">                if (regexp.test(options.url)) &#123;</span><br><span class="line">                    //这里要执行原来的方法</span><br><span class="line">                    return originRequest.call(this, options)</span><br><span class="line">                &#125;</span><br><span class="line">                //这里拦截请求成功或失败接口，拿到请求后的数据</span><br><span class="line">                [&quot;success&quot;, &quot;fail&quot;].forEach((methodName) =&gt; &#123;</span><br><span class="line">                    let defineMethod = options[methodName];</span><br><span class="line">                    options[methodName] = function()&#123;</span><br><span class="line">                        try&#123;          //在重新定义函数中执行原先的函数，不影响正常逻辑</span><br><span class="line">                            defineMethod &amp;&amp; defineMethod.apply(this, arguments);</span><br><span class="line">                            //开始信息收集</span><br><span class="line">                            let statusCode, result, msg;</span><br><span class="line">                            //请求失败</span><br><span class="line">                            if (methodName == &#x27;fail&#x27;) &#123;</span><br><span class="line">                                statusCode = 0;</span><br><span class="line">                                result = &#x27;fail&#x27;;</span><br><span class="line">                                msg = ( arguments[0] &amp;&amp; arguments[0].errMsg ) || &quot;&quot;</span><br><span class="line">                            &#125;</span><br><span class="line">                            //请求成功，</span><br><span class="line">                            //收集规则为:</span><br><span class="line">                            // 1、 statusCode非2xx,3xx</span><br><span class="line">                            // 2、 statusCode是2xx,3xx，但接口返回result不为ok</span><br><span class="line">                            if (methodName == &#x27;success&#x27;) &#123;</span><br><span class="line">                                let data = arguments[0] || &#123;&#125;;</span><br><span class="line">                                statusCode = data.statusCode || &quot;&quot;;</span><br><span class="line">                                if (data.statusCode &amp;&amp; Number(data.statusCode) &gt;= 200 &amp;&amp; Number(data.statusCode) &lt; 400 ) &#123;</span><br><span class="line">                                    let resData = data.data ? (typeof data.data == &#x27;object&#x27; ? data.data : JSON.parse(data.data)) : &#123;&#125;;</span><br><span class="line">                                    //请求成功，不收集</span><br><span class="line">                                    if (resData.result == &#x27;ok&#x27;) &#123;</span><br><span class="line">                                        return;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    result = resData.result || &quot;&quot;;</span><br><span class="line">                                    msg = resData.msg || &quot;&quot;;</span><br><span class="line">                                &#125;else&#123;</span><br><span class="line">                                    result = &quot;&quot;;</span><br><span class="line">                                    msg = data.data || &quot;&quot;;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            //过滤掉header中的敏感信息</span><br><span class="line">                            if (options.header) &#123;</span><br><span class="line">                                options.header.userid &amp;&amp; (delete options.header.userid)</span><br><span class="line">                            &#125;</span><br><span class="line">                            //过滤掉data中的敏感信息</span><br><span class="line">                            if (options.data) &#123;</span><br><span class="line">                                options.data.userid &amp;&amp; (delete options.data.userid)</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            var collectInfo = &#123;</span><br><span class="line">                                &quot;url&quot;: options.url || &#x27;&#x27;,   //请求地址</span><br><span class="line">                                &quot;method&quot;: options.method || &quot;GET&quot;,  //请求方法</span><br><span class="line">                                &quot;request_header&quot;: JSON.stringify(options.header || &#123;&#125;), //请求头部信息</span><br><span class="line">                                &quot;request_data&quot;: JSON.stringify(options.data || &#123;&#125;), //请求参数</span><br><span class="line">                                &quot;resp_code&quot;: statusCode + &#x27;&#x27;,   //请求状态码</span><br><span class="line">                                &quot;resp_result&quot;: result, //请求返回结果</span><br><span class="line">                                &quot;resp_msg&quot;: msg, //请求返回描述信息</span><br><span class="line">                            &#125;</span><br><span class="line">                            //提交参数与上一次不同，或者参数相同，隔了1s</span><br><span class="line">                            if (JSON.stringify(collectInfo) != lastParams.paramStr || (new Date().getTime() - lastParams.timestamp &gt; 1000)) &#123;</span><br><span class="line">                                //上传错误信息</span><br><span class="line">                                Post.post_error(_miniapp, &#x27;http&#x27;, collectInfo)</span><br><span class="line">                                lastParams.paramStr = JSON.stringify(collectInfo);</span><br><span class="line">                                lastParams.timestamp = new Date().getTime()</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;catch(e)&#123;</span><br><span class="line">                            //console.log(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;)</span><br><span class="line">                return originRequest.call(this, options)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        // Do something when catch error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不使用插件的小程序中，我们可以在使用 wx.request 方法执行上面的代码，对 wx.request 进行拦截，然后其他无需加任何代码就可以收集 http 请求了。<br>上面说了，当我们封装成到插件时，这个就不管用了，因为当使用插件时，小程序不允许我们修改全局变量。所以执行上面代码时会报错。这时，我们退而求其次，只能是在插件中自己封装个方法，这个方法其实就是 wx.request 发送请求，但是在插件中我们就可以拦截 wx.request 了。具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function my_request()&#123;</span><br><span class="line">    //只要执行一次拦截代码即可</span><br><span class="line">    !_isInit &amp;&amp; rewriteRequest();</span><br><span class="line">    return  wx.request(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看下后台数据</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-a5ed578b7aca2063?imageMogr2/auto-orient/strip%7CimageView2/2/w/855/format/webp" alt="image"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9224001-d8b9492d94d3f88d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="image"></p>
<p>持续监控，会帮我们找出很多隐藏的 bug</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>洋洋洒洒写了这么多，或许有些地方说的不太清楚，慢慢锻炼吧。然后后面几点只是挑了重要的讲，我相信有过小程序开发经验的朋友应该没问题。然后有时间再补充和优化了。先到此，有缘看到的朋友，欢迎留言交流。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8F%92%E4%BB%B6-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8F%92%E4%BB%B6-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">微信小程序插件 - 开发教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 13:58:39 / 修改时间：14:01:09" itemprop="dateCreated datePublished" datetime="2022-12-16T13:58:39+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">小程序开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>昨天（2018.3.13），微信小程序发布了重大功能更新，支持插件的使用和开发，个人预计，不超过 2 个月，优质服务的插件将会如雨后春笋般涌现。</p>
<p>这篇文章，我将会带大家，从 0 开始，学习如何开发和使用插件。文章分为 3 个章节：</p>
<ul>
<li>1、什么是微信小程序插件</li>
<li>2、如何开发微信小程序插件</li>
<li>3、如何使用第三方微信小程序插件</li>
</ul>
<blockquote>
<p>备注：为了节省文字内容，我会将“微信小程序插件”简称为“插件”。</p>
</blockquote>
<h2 id="什么是微信小程序插件？"><a href="#什么是微信小程序插件？" class="headerlink" title="什么是微信小程序插件？"></a>什么是微信小程序插件？</h2><p>插件是一组由 js 和自定义组件封装的代码库，插件无法单独使用、也无法预览，必须被其他小程序应用嵌入，才能使用。它和 NPM 的依赖、Maven 的依赖库是一个道理。</p>
<p>不过，插件和 NPM、Maven 依赖管理不同的是：</p>
<ul>
<li>插件拥有独立的 API 接口和域名列表，不被小程序本身的域名列表限制。（NPM 依赖进来的库不能进行第三方数据请求）</li>
<li>插件必须由腾讯审核通过才能使用（NPM 无需腾讯审核）</li>
<li>使用第三方插件必须向第三方申请 （通过 NPM 使用第三方库无需向第三方申请）</li>
</ul>
<p>所以，我觉得：在未来，插件应该会被第三方打包成为服务，而不仅仅只是一个代码库。</p>
<h2 id="如何开发微信小程序插件？"><a href="#如何开发微信小程序插件？" class="headerlink" title="如何开发微信小程序插件？"></a>如何开发微信小程序插件？</h2><p>下载最新的微信小程序开发者工具，（必须是 1.02.1803130 版本以上），打开开发者工具，进入小程序项目，我们会看到“代码片段”标签，如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1616815-c6f3a6b865ae37c2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="image"></p>
<p>点击，右下角的 “创建” 按钮，就可以创建插件了，如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1616815-20d14a6cd6712658?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="image"></p>
<p>插件的 AppId 和之前的微信小程序的 AppId 是同个道理，需要在微信开发者后台新建一个微信小程序插件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1616815-d30a11aca90b571e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="image"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1616815-68a854ff3b5a6afe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="image"></p>
<p>微信小程序插件的名称也必须是独一无二的，申请完毕后就可以获得 插件的 AppId 了。</p>
<p>填写名称和插件 AppID 后，进入小程序项目，如下图显示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1616815-7c686881dbbc0445?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="image"></p>
<p>项目的代码目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── miniprogram</span><br><span class="line">│ ├── app.js</span><br><span class="line">│ ├── app.json</span><br><span class="line">│ └── pages</span><br><span class="line">├── plugin</span><br><span class="line">│ ├── api</span><br><span class="line">│ ├── components</span><br><span class="line">│ ├── index.js</span><br><span class="line">│ └── plugin.json</span><br><span class="line">└── project.config.json</span><br></pre></td></tr></table></figure>

<p>在文件 <code> project.config.json</code> 中，我们看到代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;miniprogramRoot&quot;: &quot;./miniprogram&quot;,</span><br><span class="line">    &quot;pluginRoot&quot;: &quot;./plugin&quot;,</span><br><span class="line">    &quot;compileType&quot;: &quot;plugin&quot;,</span><br><span class="line">    &quot;setting&quot;: &#123;</span><br><span class="line">        &quot;newFeature&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;appid&quot;: &quot;.....&quot;,</span><br><span class="line">    &quot;projectname&quot;: &quot;videoPlayer&quot;,</span><br><span class="line">    &quot;condition&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>miniprogramRoot</strong>：配置小程序的根目录，可以使用小程序来测试编写的插件</li>
<li><strong>pluginRoot</strong>：插件相关代码所在的根目录</li>
<li><strong>compileType</strong>：项目的编译类型，必须配置为 plugin，在上传代码的时候才会以插件的方式上传到腾讯服务器。</li>
</ul>
<p>在 <code>plugin/plugin.json</code> 文件中，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;publicComponents&quot;: &#123;</span><br><span class="line">    &quot;hgPlayer&quot;: &quot;components/player/player&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>publicComponents</strong>：配置的是插件可以给使用的小程序提供哪些组件，一个插件可以定义很多个组件，组件和组件之间相互引用，但是小程序只能使用在 publicComponents 里配置的组件。</p>
</li>
<li><p><strong>main</strong>：定义入口文件，在入口文件 <code>index.js</code> 中定义小程序可以使用插件的那些接口。</p>
</li>
</ul>
<p>在 <code>plugin/index.js</code> 文件中，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var data = require(&#x27;./api/data.js&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  getData: data.getData,</span><br><span class="line">  setData: data.setData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>plugin/index.js</code> 定义了对外抛出接口为 <code>getData</code> 和 <code>setData</code>，小程序在使用这个插件的时候，只能使用到插件提供的这两个接口，插件的其他接口（或方法）小程序无法使用。</p>
<p>做好以上配置后，就可以开始在 <code>plugin/components</code> 编写组件代码了，例如我写了我的播放器组件，代码如下：</p>
<p>player.js：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    myData:[]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>player.wxml:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;section tc&quot;&gt;</span><br><span class="line">  &lt;video id=&quot;myVideo&quot; src=&quot;...&quot;  enable-danmu danmu-btn controls&gt;</span><br><span class="line">  &lt;/video&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p>值得注意的是：</p>
<ol>
<li><p>编写组件是调用 Component() 定义组件代码，和 App() 、Page()一样的道理。</p>
</li>
<li><p>在组件能够调用的微信 API 受限，比如说不能调用 wx.login() 获取用户信息，具体限制在：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/plugin/api-limit.html">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/plugin/api-limit.html</a></p>
</li>
</ol>
<p>代码编写完毕后，注意在 <code>plugin/plugin.json</code> 文件配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;publicComponents&quot;: &#123;</span><br><span class="line">    &quot;hgPlayer&quot;: &quot;components/player/player&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表示使用该插件的小程序，可以使用 hgPlayer 这个组件，组件 hgPlayer 对应的代码是 <code>&quot;components/player/player&quot;</code></p>
<p>配置好后，我就可以上传插件代码到腾讯服务器，进入微信小程序开发者后台提交审核，腾讯审核通过后，第三方小程序就可以使用我们编写的这个插件了。</p>
<h2 id="如何使用第三方插件"><a href="#如何使用第三方插件" class="headerlink" title="如何使用第三方插件"></a>如何使用第三方插件</h2><p>使用第三方插件之前，需要进入微信小程序开发者后台，在第三方服务里添加插件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1616815-d43faf041d0750fd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="image"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1616815-234e52acfda89cda?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="image"></p>
<p>填写第三方插件的 AppId，点击添加按钮，对方账号的 <code>小程序插件 &gt; 申请管理</code> 会出现你的申请，如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1616815-c4abc1566d2dfbb9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="image"></p>
<p>需要第三方同意你的申请后，你就可以开始使用第三方插件了。</p>
<p>使用第三方插件的时候，需要在 我们自己的小程序的 <code>app.json</code> 做如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;pages&quot;: [</span><br><span class="line">    &quot;pages/index/index&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: &#123;</span><br><span class="line">    &quot;myPlugin&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;dev&quot;,</span><br><span class="line">      &quot;provider&quot;: &quot;填写申请通过的插件AppId&quot;</span><br><span class="line">    &#125;，</span><br><span class="line">    &quot;plugin1&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;dev&quot;,</span><br><span class="line">      &quot;provider&quot;: &quot;填写申请通过的插件AppId&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">     &quot;plugin2&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;dev&quot;,</span><br><span class="line">      &quot;provider&quot;: &quot;填写申请通过的插件AppId&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>plugins： 配置的要使用的第三方插件列表。</p>
<p>插件列表配置好后，由于每个插件可能会有多个组件，所以需要我们在每个页面定义要使用到的组件，例如，在 <code>index.js</code> 中要使用 <code>hgPlayer</code> 这个组件，需要在 <code>index.json</code> 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;player&quot;: &quot;plugin://myPlugin/hgPlayer&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&quot;player&quot;: &quot;plugin://myPlugin/hgPlayer&quot;</code> 的含义是：要本页面使用插件 myPlugin 的组件 hgPlayer，同时在本页面的别名为 ：player 。</p>
<p>配置好 <code>index.json</code> 后，就可以在 <code>index.wxml</code> 直接使用了，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;xxxx&quot;&gt;</span><br><span class="line">    &lt;player /&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>到目前为止，我们已经讲完了：</p>
<ul>
<li>1、什么是微信小程序插件</li>
<li>2、如何开发微信小程序插件</li>
<li>3、如何使用第三方微信小程序插件</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E6%B5%85%E8%B0%88%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E6%B5%85%E8%B0%88%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">浅谈支付宝小程序与微信小程序开发的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 13:58:32 / 修改时间：14:00:01" itemprop="dateCreated datePublished" datetime="2022-12-16T13:58:32+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">小程序开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、app-json"><a href="#一、app-json" class="headerlink" title="一、app.json"></a>一、app.json</h2><h3 id="（1）设置小程序通用的的状态栏、导航条、标题、窗口背景色"><a href="#（1）设置小程序通用的的状态栏、导航条、标题、窗口背景色" class="headerlink" title="（1）设置小程序通用的的状态栏、导航条、标题、窗口背景色"></a>（1）设置小程序通用的的状态栏、导航条、标题、窗口背景色</h3><h4 id="支付宝小程序"><a href="#支付宝小程序" class="headerlink" title="支付宝小程序"></a>支付宝小程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;window&quot;: &#123;</span><br><span class="line">    &quot;defaultTitle&quot;: &quot;病案到家&quot;,   //页面标题</span><br><span class="line">    &quot;titleBarColor&quot;: &quot;#1688FB&quot;    //导航栏背景色</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;window&quot;: &#123;</span><br><span class="line">    &quot;backgroundTextStyle&quot;: &quot;light&quot;,//窗口的背景色</span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#1688FB&quot;,//导航栏背景颜色</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;病案到家&quot;,//导航栏标题文字内容</span><br><span class="line">    &quot;navigationBarTextStyle&quot;: &quot;white&quot;//导航栏标题颜色，仅支持 black/white</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="（2）设置-tabBar"><a href="#（2）设置-tabBar" class="headerlink" title="（2）设置 tabBar"></a>（2）设置 tabBar</h3><h4 id="支付宝小程序-1"><a href="#支付宝小程序-1" class="headerlink" title="支付宝小程序"></a>支付宝小程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">    &quot;textColor&quot;: &quot;#333333&quot;,//默认颜色</span><br><span class="line">    &quot;selectedColor&quot;: &quot;#1688FB&quot;,//选中颜色</span><br><span class="line">    &quot;backgroundColor&quot;: &quot;#ffffff&quot;,//背景色</span><br><span class="line">    &quot;items&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;icon&quot;: &quot;/images/indexGrey.png&quot;,</span><br><span class="line">        &quot;activeIcon&quot;: &quot;/images/indexWhite.png&quot;,</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages/homeIndex/homeIndex&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;首页&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;icon&quot;: &quot;/images/personGrey.png&quot;,</span><br><span class="line">        &quot;activeIcon&quot;: &quot;/images/personWhite.png&quot;,</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages/orderList/orderList&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;我的&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="微信小程序-1"><a href="#微信小程序-1" class="headerlink" title="微信小程序"></a>微信小程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">    &quot;color&quot;: &quot;#333333&quot;,</span><br><span class="line">    &quot;selectedColor&quot;: &quot;#1688FB&quot;,</span><br><span class="line">    &quot;backgroundColor&quot;: &quot;#ffffff&quot;,</span><br><span class="line">    &quot;borderStyle&quot;: &quot;#e5e5e5&quot;,</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;iconPath&quot;: &quot;/images/indexGrey.png&quot;,</span><br><span class="line">        &quot;selectedIconPath&quot;: &quot;/images/indexWhite.png&quot;,</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages/homeIndex/homeIndex&quot;,</span><br><span class="line">        &quot;text&quot;: &quot;首页&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;iconPath&quot;: &quot;/images/personGrey.png&quot;,</span><br><span class="line">        &quot;selectedIconPath&quot;: &quot;/images/personWhite.png&quot;,</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages/orderList/orderList&quot;,</span><br><span class="line">        &quot;text&quot;: &quot;我的&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、pages"><a href="#二、pages" class="headerlink" title="二、pages"></a>二、pages</h2><h3 id="（1）文件命名不同"><a href="#（1）文件命名不同" class="headerlink" title="（1）文件命名不同"></a>（1）文件命名不同</h3><h4 id="支付宝小程序-2"><a href="#支付宝小程序-2" class="headerlink" title="支付宝小程序"></a>支付宝小程序</h4><p><img src="https://img-blog.csdnimg.cn/20181120105925562.png" alt="image"></p>
<h4 id="微信小程序-2"><a href="#微信小程序-2" class="headerlink" title="微信小程序"></a>微信小程序</h4><p><img src="https://img-blog.csdnimg.cn/2018112010585493.png" alt="image"></p>
<p><strong>我分别在微信小程序和支付宝小程序建立了页面，区别在于</strong>：</p>
<ol>
<li>支付宝小程序里面的视图层页面文件后缀是“axml”，样式文件后缀是“acss”；</li>
<li>微信小程序里面的视图层页面文件后缀是“wxml”，样式文件后缀是“wxss”。</li>
</ol>
<h3 id="（2）视图层页面-axml-以及-wxml"><a href="#（2）视图层页面-axml-以及-wxml" class="headerlink" title="（2）视图层页面 axml 以及 wxml"></a>（2）视图层页面 axml 以及 wxml</h3><h4 id="1-冒泡事件和非冒泡事件"><a href="#1-冒泡事件和非冒泡事件" class="headerlink" title="1.冒泡事件和非冒泡事件"></a>1.冒泡事件和非冒泡事件</h4><p><strong>支付宝小程序</strong></p>
<p>onTap, catchTap</p>
<p>on 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;weui-btn&quot; onTap=&quot;login&quot; type=&quot;primary&quot;&gt;登录&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<p>bindtap、catchtouchstart</p>
<p>bind 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;weui-btn&quot; bindtap=&#x27;login&#x27; type=&quot;primary&quot;&gt;登录&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-列表渲染"><a href="#2-列表渲染" class="headerlink" title="2.列表渲染"></a>2.列表渲染</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    list: [&#123;</span><br><span class="line">      Title: &#x27;支付宝&#x27;,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      Title: &#x27;微信&#x27;,</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>支付宝小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;block a:for=&quot;&#123;&#123;list&#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;view key=&quot;item-&#123;&#123;index&#125;&#125;&quot; index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;&#123;&#123;item.Title&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:for=&quot;&#123;&#123;list&#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;view wx:key=&quot;this&quot; wx:for-item=&quot;item&quot;&gt;&#123;&#123;item.Title&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-条件渲染"><a href="#3-条件渲染" class="headerlink" title="3.条件渲染"></a>3.条件渲染</h4><p><strong>支付宝小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view a:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 1 &lt;/view&gt;</span><br><span class="line">&lt;view a:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 2 &lt;/view&gt;</span><br><span class="line">&lt;view a:else&gt; 3 &lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 1 &lt;/view&gt;</span><br><span class="line">&lt;view wx:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 2 &lt;/view&gt;</span><br><span class="line">&lt;view wx:else&gt; 3 &lt;/view&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、开发过程中常用到的两个小程序中组件的不同用法"><a href="#三、开发过程中常用到的两个小程序中组件的不同用法" class="headerlink" title="三、开发过程中常用到的两个小程序中组件的不同用法"></a>三、开发过程中常用到的两个小程序中组件的不同用法</h2><h3 id="（1）交互"><a href="#（1）交互" class="headerlink" title="（1）交互"></a>（1）交互</h3><h4 id="1-消息提示框"><a href="#1-消息提示框" class="headerlink" title="1.消息提示框"></a>1.消息提示框</h4><p><strong>支付宝小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my.showToast(&#123;</span><br><span class="line">  type: &#x27;success&#x27;,//默认 none，支持 success / fail / exception / none’。</span><br><span class="line">  content: &#x27;操作成功&#x27;,//文字内容</span><br><span class="line">  duration: 3000,//显示时长，单位为 ms，默认 2000</span><br><span class="line">  success: () =&gt; &#123;</span><br><span class="line">    my.alert(&#123;</span><br><span class="line">      title: &#x27;toast 消失了&#x27;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">my.hideToast()//隐藏弱提示。</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.showToast(&#123;</span><br><span class="line">  title: &#x27;成功&#x27;,//提示的内容</span><br><span class="line">  icon: &#x27;success&#x27;,//success	显示成功图标;loading	显示加载图标;none不显示图标</span><br><span class="line">  duration: 2000</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//icon为“success”“loading”时 title 文本最多显示 7 个汉字长度</span><br><span class="line">wx.hideToast() //隐藏</span><br></pre></td></tr></table></figure>

<h4 id="2-消息提示框"><a href="#2-消息提示框" class="headerlink" title="2.消息提示框"></a>2.消息提示框</h4><p><strong>支付宝小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my.showLoading(&#123;</span><br><span class="line">  content: &#x27;加载中...&#x27;,</span><br><span class="line">  delay: 1000,</span><br><span class="line">&#125;);</span><br><span class="line">my.hideLoading();</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wx.showLoading(&#123;</span><br><span class="line">  title: &#x27;加载中&#x27;,</span><br><span class="line">&#125;)</span><br><span class="line">wx.hideLoading()</span><br></pre></td></tr></table></figure>

<h4 id="3-http-请求"><a href="#3-http-请求" class="headerlink" title="3.http 请求"></a>3.http 请求</h4><p><strong>支付宝小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">my.httpRequest(&#123;</span><br><span class="line">  url: &#x27;http://httpbin.org/post&#x27;,</span><br><span class="line">  method: &#x27;POST&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    from: &#x27;支付宝&#x27;,</span><br><span class="line">    production: &#x27;AlipayJSAPI&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">  headers:&quot;&quot;,//默认 &#123;&#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;&#125;</span><br><span class="line">  dataType: &#x27;json&#x27;,</span><br><span class="line">  success: function(res) &#123;</span><br><span class="line">    my.alert(&#123;content: &#x27;success&#x27;&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: function(res) &#123;</span><br><span class="line">    my.alert(&#123;content: &#x27;fail&#x27;&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete: function(res) &#123;</span><br><span class="line">    my.hideLoading();</span><br><span class="line">    my.alert(&#123;content: &#x27;complete&#x27;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  url: &#x27;test.php&#x27;, //仅为示例，并非真实的接口地址</span><br><span class="line">  data: &#123;</span><br><span class="line">    x: &#x27;&#x27;,</span><br><span class="line">    y: &#x27;&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  header: &#123;</span><br><span class="line">    &#x27;content-type&#x27;: &#x27;application/json&#x27; // 默认值</span><br><span class="line">  &#125;,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    console.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其实微信小程序和支付宝小程序提供的 api 方法大致相同，只是微信小程序是以“wx.”起头，支付宝小程序是以“my.”起头，其余可能只是 api 方法里面字段“text、content、name、title”等命名不同。</p>
<h3 id="（2）选择器"><a href="#（2）选择器" class="headerlink" title="（2）选择器"></a>（2）选择器</h3><h4 id="1-时间选择器"><a href="#1-时间选择器" class="headerlink" title="1.时间选择器"></a>1.时间选择器</h4><p><strong>支付宝小程序</strong></p>
<p>支付宝小程序提供了一个 api，my.datePicker(object)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my.datePicker(&#123;</span><br><span class="line">  format: &#x27;yyyy-MM-dd&#x27;,//返回的日期格式，</span><br><span class="line">  currentDate: &#x27;2012-12-12&#x27;,//初始选择的日期时间，默认当前时间</span><br><span class="line">  startDate: &#x27;2012-12-10&#x27;,//最小日期时间</span><br><span class="line">  endDate: &#x27;2012-12-15&#x27;,//最大日期时间</span><br><span class="line">  success: (res) =&gt; &#123;</span><br><span class="line">    my.alert(&#123;</span><br><span class="line">	  content: res.date,</span><br><span class="line">	&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<p>微信小程序是通过 picker 组件来实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;section&quot;&gt;</span><br><span class="line">  &lt;view class=&quot;section__title&quot;&gt;日期选择器&lt;/view&gt;</span><br><span class="line">  &lt;picker mode=&quot;date&quot; value=&quot;&#123;&#123;date&#125;&#125;&quot; start=&quot;2015-09-01&quot; end=&quot;2017-09-01&quot; bindchange=&quot;bindDateChange&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;picker&quot;&gt;</span><br><span class="line">      当前选择: &#123;&#123;date&#125;&#125;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/picker&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    date: &#x27;2016-09-01&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  bindDateChange: function(e) &#123;</span><br><span class="line">    console.log(&#x27;picker发送选择改变，携带值为&#x27;, e.detail.value)</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      date: e.detail.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-省市区选择器"><a href="#2-省市区选择器" class="headerlink" title="2.省市区选择器"></a>2.省市区选择器</h4><p><strong>支付宝小程序</strong></p>
<p>支付宝小程序提供了一个 api，my.multiLevelSelect(Object)</p>
<p>级联选择功能主要使用在于多级关联数据选择，比如说省市区的信息选择。</p>
<p>1.1、引入一个省市区的 json 格式文件 <a target="_blank" rel="noopener" href="http://blog.shzhaoqi.com/uploads/js/city_json.zip">http://blog.shzhaoqi.com/uploads/js/city_json.zip</a></p>
<p>1.2、在 js 中引入这个文件</p>
<p>1.3、使用 my.multiLevelSelect(Object)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var citysJSON = require(&#x27;../../utils/city.js&#x27;);</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    provinces: &#x27;陕西省&#x27;,</span><br><span class="line">    city: &#x27;西安市&#x27;,</span><br><span class="line">    area: &#x27;碑林区&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  chooseAddress: function () &#123;</span><br><span class="line">    my.multiLevelSelect(&#123;</span><br><span class="line">      title: &#x27;选择省市区&#x27;,//级联选择标题</span><br><span class="line">      list: citysJSON.citys,</span><br><span class="line">      success: (res) =&gt; &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          provinces: res.result[0].name,</span><br><span class="line">          city: res.result[1].name,</span><br><span class="line">          area: res.result[2].name,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<p>微信小程序依然是通过 picker 组件来实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;section&quot;&gt;</span><br><span class="line">  &lt;view class=&quot;section__title&quot;&gt;省市区选择器&lt;/view&gt;</span><br><span class="line">  &lt;picker mode=&quot;region&quot; bindchange=&quot;bindRegionChange&quot; value=&quot;&#123;&#123;region&#125;&#125;&quot; custom-item=&quot;&#123;&#123;customItem&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;picker&quot;&gt;</span><br><span class="line">      当前选择：&#123;&#123;region[0]&#125;&#125;，&#123;&#123;region[1]&#125;&#125;，&#123;&#123;region[2]&#125;&#125;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/picker&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">//custom-item   可为每一列的顶部添加一个自定义的项,可为空</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    region: [&#x27;广东省&#x27;, &#x27;广州市&#x27;, &#x27;海珠区&#x27;],</span><br><span class="line">    customItem: &#x27;全部&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  bindRegionChange: function (e) &#123;</span><br><span class="line">    console.log(&#x27;picker发送选择改变，携带值为&#x27;, e.detail.value)</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      region: e.detail.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="（3）小程序唤起支付"><a href="#（3）小程序唤起支付" class="headerlink" title="（3）小程序唤起支付"></a>（3）小程序唤起支付</h4><p><strong>支付宝小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my.tradePay(&#123;</span><br><span class="line">  tradeNO: &#x27;201711152100110410533667792&#x27;, // 调用统一收单交易创建接口（alipay.trade.create），获得返回字段支付宝交易号trade_no</span><br><span class="line">  success: (res) =&gt; &#123;</span><br><span class="line">    my.alert(&#123;</span><br><span class="line">	  content: JSON.stringify(res),</span><br><span class="line">	&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: (res) =&gt; &#123;</span><br><span class="line">    my.alert(&#123;</span><br><span class="line">	  content: JSON.stringify(res),</span><br><span class="line">	&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wx.requestPayment(&#123;</span><br><span class="line">  timeStamp: &#x27;&#x27;,//时间戳，从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间</span><br><span class="line">  nonceStr: &#x27;&#x27;,//随机字符串，长度为32个字符以下</span><br><span class="line">  package: &#x27;&#x27;,//统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=***</span><br><span class="line">  signType: &#x27;MD5&#x27;,//签名算法</span><br><span class="line">  paySign: &#x27;&#x27;,//签名</span><br><span class="line">  success (res) &#123; &#125;,</span><br><span class="line">  fail (res) &#123; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="（4）电话"><a href="#（4）电话" class="headerlink" title="（4）电话"></a>（4）电话</h4><p><strong>支付宝小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my.makePhoneCall(&#123;</span><br><span class="line">	number: &#x27;400-8097-114&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.makePhoneCall(&#123;</span><br><span class="line">  phoneNumber: &#x27;400-8097-114&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="（5）获取登录凭证（code）"><a href="#（5）获取登录凭证（code）" class="headerlink" title="（5）获取登录凭证（code）"></a>（5）获取登录凭证（code）</h4><p><strong>支付宝小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my.getAuthCode(&#123;</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    if (res.authCode) &#123;</span><br><span class="line">      console.log(res.authCode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>微信小程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    if (res.code) &#123;</span><br><span class="line">      console.log(res.code)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E6%94%B6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E6%94%B6%E9%9B%86/" class="post-title-link" itemprop="url">小程序异常监控收集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 13:58:24 / 修改时间：14:04:10" itemprop="dateCreated datePublished" datetime="2022-12-16T13:58:24+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">小程序开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="web-端与小程序错误监控差异"><a href="#web-端与小程序错误监控差异" class="headerlink" title="web 端与小程序错误监控差异"></a>web 端与小程序错误监控差异</h2><ul>
<li>在 Web 端监测的是页面完整的 url，而小程序端监测的是路由地址；</li>
<li>小程序页面属于 app 内部的页面，使用时已全部加载完毕，因此监控页面性能时不统计页面加载时长等信息，更多的是对页面内请求、资源请求和用户行为的监控；</li>
<li>由于微信官方和小程序代码的要求，集成方式对比 Web 端会相对严格一些。</li>
</ul>
<h2 id="小程序需要监控的数据"><a href="#小程序需要监控的数据" class="headerlink" title="小程序需要监控的数据"></a>小程序需要监控的数据</h2><ul>
<li>JavaScript 异常监控：不论是 Web 端还是小程序端，对 JavaScript 异常的监控都是必要的；</li>
<li>页面内请求监控：对于小程序来说，需要统计发送网络请求的 swan.request() 异常时的请求状态、请求时长、请求地址等；</li>
<li>资源加载监控：当需要下载资源到本地的 swan.downloadFile() 出现异常时，统计加载时间、异常类型、资源地址等；</li>
<li>页面性能监控：访问监控、页面来源及流向监控等，方便更好的对小程序进行运营；</li>
<li>用户数据统计：用户的分布、操作系统及版本、app 版本、IP 地址等，给错误的分析提供更多条件。</li>
</ul>
<h3 id="简单收集"><a href="#简单收集" class="headerlink" title="简单收集"></a>简单收集</h3><ul>
<li>小程序 App()生命周期里提供了 onError 函数，可以通过在 onError 里收集异常信息，具体原理可查看<a target="_blank" rel="noopener" href="https://www.jb51.net/article/142101.htm">JS 实现监控微信小程序的原理</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">      // 监听错误</span><br><span class="line">      onError: function (err) &#123;</span><br><span class="line">          // 上报错误</span><br><span class="line">          swan.request(&#123;</span><br><span class="line">          url: &quot;https://url&quot;, // 自行定义报告服务器</span><br><span class="line">          method: &quot;POST&quot;,</span><br><span class="line">          errMsg: err</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="用户操作路径收集"><a href="#用户操作路径收集" class="headerlink" title="用户操作路径收集"></a>用户操作路径收集</h3><p>一些较隐蔽的错误如果只有错误栈信息，排查起来会比较难，如果有用户操作的路径，在排查时就方便多了。</p>
<ul>
<li>暴力打点方法收集<br/><br>优点：简单直接<br/><br>缺点：污染业务代码，造成较多垃圾代码</li>
<li>函数劫持<br>需要在 App 函数中的 onLaunch、onShow、onHide 生命周期插入监控代码，通过重写 App 生命周期函数来实现。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">App = function(app) &#123;</span><br><span class="line">      [&quot;onLaunch&quot;, &quot;onShow&quot;, &quot;onHide&quot;].forEach(methodName =&gt; &#123;</span><br><span class="line">          app[methodName] = function(options) &#123;</span><br><span class="line">          // 构造访问日志对象</span><br><span class="line">          var breadcrumb = &#123;</span><br><span class="line">              type: &quot;function&quot;,</span><br><span class="line">              time: utils.now(),</span><br><span class="line">              belong: &quot;App&quot;, // 来源</span><br><span class="line">              method: methodName,</span><br><span class="line">              path: options &amp;&amp; options.path, // 页面路径</span><br><span class="line">              query: options &amp;&amp; options.query, // 页面参数</span><br><span class="line">              scene: options &amp;&amp; options.scene // 场景编号</span><br><span class="line">          &#125;;</span><br><span class="line">          self.pushToBreadcrumb(breadcrumb); // 把执行对象加入到面包屑中</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>但是这样写，会把用户自定义的内容给覆盖掉，所以还需要把用户定义的函数和监控代码合并。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var originApp = App // 保存原对象</span><br><span class="line">App = function(app) &#123;</span><br><span class="line">    // .... 此处省略监控代码</span><br><span class="line">    // .... 此处省略监控代码</span><br><span class="line">    originApp(app) // 执行用户定义的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小程序性能监控插件"><a href="#小程序性能监控插件" class="headerlink" title="小程序性能监控插件"></a>小程序性能监控插件</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.fundebug.com/">Fundebug</a> 提供网站、微信小程序和小游戏的 bug 监控服务,例如：API 的一些函数调用情况、监控函数调用的参数、收集 HTTP 请求错误的 body、监控某些特定的自定义函数等。</li>
<li><a target="_blank" rel="noopener" href="https://www.frontjs.com/">FrontJS</a> 的小程序错误监控相比于微信小程序后台的数据监控，增加了对于错误的统计和产生错误的相关用户分析，FrontJS 可以收集精细到 console.log 级别的任何 JavaScript 异常信息并提供 stack trace 信息；对于任何一条错误信息或访问，它都会统计到该用户 IP、屏幕分辨率、DPR、操作系统类型和微信版本，方便更有针对性的去调试出现的错误。</li>
<li><a target="_blank" rel="noopener" href="http://dp.baidu.com/">百度数据统计分析展示平台</a> 提供对 web 页面的性能、访问点击、js 异常、浏览器新特性、跨站资源、XSS 漏洞、自定义事件、Native 性能检测服务，对 百度小程序 的支持还需进一步调研。</li>
</ul>
<h2 id="白屏监控"><a href="#白屏监控" class="headerlink" title="白屏监控"></a>白屏监控</h2><p>用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。</p>
<h3 id="白屏时间"><a href="#白屏时间" class="headerlink" title="白屏时间"></a>白屏时间</h3><p>页面完全空白的时间，web 可以在页面的 head 底部添加的 JS 代码用来做白屏时间的标记。</p>
<h3 id="微信-web-资源离线存储"><a href="#微信-web-资源离线存储" class="headerlink" title="微信 web 资源离线存储"></a>微信 web 资源离线存储</h3><p>通过使用微信离线存储，Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有 Web App 累计最多可缓存 5M 的资源。这个设计有点类似 HTML5 的 Application Cache。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">小程序实现原理解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 13:58:17 / 修改时间：14:03:39" itemprop="dateCreated datePublished" datetime="2022-12-16T13:58:17+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">小程序开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为一名前端开发，如果你还停留在应用开发层面，那你就 OUT 了，快来跟我一起探讨下小程序框架本身底层实现的一些技术细节吧，让我们从小程序的运行机制来深度了解小程序。<br>小程序是基于 WEB 规范，采用 HTML,CSS 和 JS 等搭建的一套框架，微信官方给它们取了一个很牛逼的名字：WXML,WXSS，但本质上还是在整个 WEB 体系之下构建的。<br>WXML，个人猜测在取这个名字的是微信的 Xml，说到底就是 xml 的一个子集。WXML 采用微信自定义的少量标签 WXSS，大家可以理解为就是自定义的 CSS。实现逻辑部分的 JS 还是通用的 ES 规范，并且 runtime 还是 Webview（IOS WKWEBVIEW, ANDROID X5）。</p>
<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><h3 id="小程序目录结构"><a href="#小程序目录结构" class="headerlink" title="小程序目录结构"></a>小程序目录结构</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjEzNTU5ODQ3?x-oss-process=image/format,png" alt="image"></p>
<p>一个完整的小程序主要由以下几部分组成：</p>
<ul>
<li>一个入口文件：app.js</li>
<li>一个全局样式：app.wxss</li>
<li>一个全局配置：app.json</li>
<li>页面：pages 下，每个页面再按文件夹划分，每个页面 4 个文件</li>
<li>视图：wxml，wxss</li>
<li>逻辑：js，json（页面配置，不是必须）</li>
</ul>
<p>注：pages 里面还可以再根据模块划分子目录，孙子目录，只需要在 app.json 里注册时填写路径就行。</p>
<h3 id="小程序打包"><a href="#小程序打包" class="headerlink" title="小程序打包"></a>小程序打包</h3><p>开发完成后，我们就可以通过这里可视化的按钮，点击直接打包上传发布，审核通过后用户就可以搜索到了。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjEzOTI0NjE0?x-oss-process=image/format,png" alt="image"></p>
<p>那么打包怎么实现的呢？<br>这就涉及到这个编辑器的实现原理和方式了，它本身也是基于 WEB 技术体系实现的，nwjs+react，nwjs 是什么：简单是说就是 node+webkit，node 提供给我们本地 api 能力，而 webkit 提供给我们 web 能力，两者结合就能让我们使用 JS+HTML 实现本地应用程序。<br>既然有 nodejs，那上面的打包选项里的功能就好实现了。<br>ES6 转 ES5：引入 babel-core 的 node 包<br>CSS 补全：引入 postcss 和 autoprefixer 的 node 包（postcss 和 autoprefixer 的原理看这里）<br>代码压缩：引入 uglifyjs 的 node 包</p>
<p>注：在 android 上使用的 x5 内核，对 ES6 的支持不好，要兼容的话，要么使用 ES5 的语法或者引入 babel-polyfill 兼容库。</p>
<h3 id="打包后的目录结构"><a href="#打包后的目录结构" class="headerlink" title="打包后的目录结构"></a>打包后的目录结构</h3><p>小程序打包后的结构如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjE0MzMzMDA3?x-oss-process=image/format,png" alt="image"></p>
<p>所有的小程序基本都最后都被打成上面的结构</p>
<ol>
<li>WAService.js 框架 JS 库，提供逻辑层基础的 API 能力</li>
<li>WAWebview.js 框架 JS 库，提供视图层基础的 API 能力</li>
<li>WAConsole.js 框架 JS 库，控制台</li>
<li>app-config.js 小程序完整的配置，包含我们通过 app.json 里的所有配置，综合了默认配置型</li>
<li>app-service.js 我们自己的 JS 代码，全部打包到这个文件</li>
<li>page-frame.html 小程序视图的模板文件，所有的页面都使用此加载渲染，且所有的 WXML 都拆解为 JS 实现打包到这里</li>
<li>pages 所有的页面，这个不是我们之前的 wxml 文件了，主要是处理 WXSS 转换，使用 js 插入到 header 区域。</li>
</ol>
<h2 id="小程序架构"><a href="#小程序架构" class="headerlink" title="小程序架构"></a>小程序架构</h2><p>微信小程序的框架包含两部分 View 视图层、App Service 逻辑层，View 层用来渲染页面结构，AppService 层用来逻辑处理、数据请求、接口调用，它们在两个进程（两个 Webview）里运行。<br>视图层和逻辑层通过系统层的 JSBridage 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。</p>
<p>小程序架构图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjE1NzI0ODkx?x-oss-process=image/format,png" alt="image"></p>
<p>小程序启动时会从 CDN 下载小程序的完整包，一般是数字命名的,如：_-2082693788_4.wxapkg</p>
<h3 id="小程序技术实现"><a href="#小程序技术实现" class="headerlink" title="小程序技术实现"></a>小程序技术实现</h3><p>小程序的 UI 视图和逻辑处理是用多个 webview 实现的，逻辑处理的 JS 代码全部加载到一个 Webview 里面，称之为 AppService，整个小程序只有一个，并且整个生命周期常驻内存，而所有的视图（wxml 和 wxss）都是单独的 Webview 来承载，称之为 AppView。所以一个小程序打开至少就会有 2 个 webview 进程，正是因为每个视图都是一个独立的 webview 进程，考虑到性能消耗，小程序不允许打开超过 5 个层级的页面，当然同是也是为了体验更好。</p>
<h3 id="AppService"><a href="#AppService" class="headerlink" title="AppService"></a>AppService</h3><p>可以理解 AppService 即一个简单的页面，主要功能是负责逻辑处理部分的执行，底层提供一个 WAService.js 的文件来提供各种 api 接口，主要是以下几个部分：<br>消息通信封装为 WeixinJSBridge（开发环境为 window.postMessage, IOS 下为 WKWebview 的 window.webkit.messageHandlers.invokeHandler.postMessage，android 下用 WeixinJSCore.invokeHandler）</p>
<ol>
<li>日志组件 Reporter 封装</li>
<li>wx 对象下面的 api 方法</li>
<li>全局的 App,Page,getApp,getCurrentPages 等全局方法</li>
<li>还有就是对 AMD 模块规范的实现</li>
</ol>
<p>然后整个页面就是加载一堆 JS 文件，包括小程序配置 config，上面的 WAService.js（调试模式下有 asdebug.js），剩下就是我们自己写的全部的 js 文件，一次性都加载。</p>
<h3 id="在开发环境下"><a href="#在开发环境下" class="headerlink" title="在开发环境下"></a>在开发环境下</h3><ol>
<li>页面模板：app.nw&#x2F;app&#x2F;dist&#x2F;weapp&#x2F;tpl&#x2F;appserviceTpl.js</li>
<li>配置信息，是直接写入一个 js 变量，__wxConfig。</li>
<li>其他配置</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjIwNDE5NDIz?x-oss-process=image/format,png" alt="image"></p>
<h3 id="线上环境"><a href="#线上环境" class="headerlink" title="线上环境"></a>线上环境</h3><p>而在上线后是应用部分会打包为 2 个文件，名称 app-config.json 和 app-service.js，然后微信会打开 webview 去加载。线上部分应该是微信自身提供了相应的模板文件，在压缩包里没有找到。</p>
<ol>
<li>WAService.js（底层支持）</li>
<li>app-config.json（应用配置）</li>
<li>app-service.js（应用逻辑）</li>
</ol>
<p>然后运行在 JavaScriptCore 引擎里面。</p>
<h3 id="AppView"><a href="#AppView" class="headerlink" title="AppView"></a>AppView</h3><p>这里可以理解为 h5 的页面，提供 UI 渲染，底层提供一个 WAWebview.js 来提供底层的功能,具体如下：</p>
<ol>
<li>消息通信封装为 WeixinJSBridge（开发环境为 window.postMessage, IOS 下为 WKWebview 的 window.webkit.messageHandlers.invokeHandler.postMessage，android 下用 WeixinJSCore.invokeHandler）</li>
<li>日志组件 Reporter 封装</li>
<li>wx 对象下的 api，这里的 api 跟 WAService 里的还不太一样，有几个跟那边功能差不多，但是大部分都是处理 UI 显示相关的方法</li>
<li>小程序组件实现和注册</li>
<li>VirtualDOM，Diff 和 Render UI 实现</li>
<li>页面事件触发</li>
</ol>
<p>在此基础上，AppView 有一个 html 模板文件，通过这个模板文件加载具体的页面，这个模板主要就一个方法，$gwx，主要是返回指定 page 的 VirtualDOM，而在打包的时候，会事先把所有页面的 WXML 转换为 ViirtualDOM 放到模板文件里，而微信自己写了 2 个工具 wcc（把 WXML 转换为 VirtualDOM）和 wcsc（把 WXSS 转换为一个 JS 字符串的形式通过 style 标签 append 到 header 里）。</p>
<h3 id="Service-和-View-通信"><a href="#Service-和-View-通信" class="headerlink" title="Service 和 View 通信"></a>Service 和 View 通信</h3><p>使用消息 publish 和 subscribe 机制实现两个 Webview 之间的通信，实现方式就是统一封装一个 WeixinJSBridge 对象，而不同的环境封装的接口不一样，具体实现的技术如下：</p>
<h3 id="windows-环境"><a href="#windows-环境" class="headerlink" title="windows 环境"></a>windows 环境</h3><p>通过 window.postMessage 实现（使用 chrome 扩展的接口注入一个 contentScript.js，它封装了 postMessage 方法，实现 webview 之间的通信，并且它也通过 chrome.runtime.connect 方式，也提供了直接操作 chrome native 原生方法的接口）<br>发送消息：window.postMessage(data, ‘*’);，&#x2F;&#x2F; data 里指定 webviewID<br>接收消息：window.addEventListener(‘message’, messageHandler); &#x2F;&#x2F; 消息处理并分发，同样支持调用 nwjs 的原生能力。<br>在 contentScript 里面看到一句话，证实了 appservice 也是通过一个 webview 实现的，实现原理上跟 view 一样，只是处理的业务逻辑不一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;webframe&#x27; === b ? postMessageToWebPage(a) : &#x27;appservice&#x27; === b &amp;&amp; postMessageToWebPage(a)</span><br></pre></td></tr></table></figure>

<h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h3><p>通过 WKWebview 的 window.webkit.messageHandlers.NAME.postMessage 实现，微信 navite 代码里实现了两个 handler 消息处理器：<br>invokeHandler: 调用原生能力<br>publishHandler: 消息分发</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjIxMzU1MzAz?x-oss-process=image/format,png" alt="image"></p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>通过 WeixinJSCore.invokeHandler 实现，这个 WeixinJSCore 是微信提供给 JS 调用的接口（native 实现）<br>invokeHandler: 调用原生能力<br>publishHandler: 消息分发</p>
<h3 id="微信组件"><a href="#微信组件" class="headerlink" title="微信组件"></a>微信组件</h3><p>在 WAWebview.js 里有个对象叫 exparser，它完整的实现小程序里的组件，看具体的实现方式，思路上跟 w3c 的 web components 规范神似，但是具体实现上是不一样的，我们使用的所有组件，都会被提前注册好，在 Webview 里渲染的时候进行替换组装。<br>exparser 有个核心方法：<br>registerBehavior: 注册组件的一些基础行为，供组件继承<br>registerElement：注册组件，跟我们交互接口主要是属性和事件</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjIxNTU5OTYx?x-oss-process=image/format,png" alt="image"></p>
<p>组件触发事件（带上 webviewID），调用 WeixinJSBridge 的接口，publish 到 native，然后 native 再分发到 AppService 层指定 webviewID 的 Page 注册事件处理方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小程序底层还是基于 Webview 来实现的，并没有发明创造新技术，整个框架体系，比较清晰和简单，基于 Web 规范，保证现有技能价值的最大化，只需了解框架规范即可使用已有 Web 技术进行开发。易于理解和开发。</p>
<p><strong>MSSM</strong>：对逻辑和 UI 进行了完全隔离，这个跟当前流行的 react，angular，vue 有本质的区别，小程序逻辑和 UI 完全运行在 2 个独立的 Webview 里面，而后面这几个框架还是运行在一个 webview 里面的，如果你想，还是可以直接操作 dom 对象，进行 ui 渲染的。</p>
<p><strong>组件机制</strong>：引入组件化机制，但是不完全基于组件开发，跟 vue 一样大部分 UI 还是模板化渲染，引入组件机制能更好的规范开发模式，也更方便升级和维护。</p>
<p><strong>多种节制</strong>：不能同时打开超过 5 个窗口，打包文件不能大于 1M，dom 对象不能大于 16000 个等，这些都是为了保证更好的体验。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/mpvue%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/mpvue%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" class="post-title-link" itemprop="url">mpvue使用手册</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 13:58:04 / 修改时间：14:34:58" itemprop="dateCreated datePublished" datetime="2022-12-16T13:58:04+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">小程序开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用手册"><a href="#使用手册" class="headerlink" title="使用手册"></a>使用手册</h2><p>mpvue 继承自 Vue.js，其技术规范和语法特点与 Vue.js 保持一致。</p>
<p>本文档适用于有一定 Vue.js 使用经验的开发者。我们默认你已经掌握 Vue.js 技术体系，如果你是新手，你可能需要先熟悉 Vue.js 官方文档。</p>
<h2 id="五分钟教程"><a href="#五分钟教程" class="headerlink" title="五分钟教程"></a>五分钟教程</h2><p>通过 Vue.js 命令行工具 vue-cli，你只需在终端窗口输入几条简单命令，即可快速创建和启动一个带热重载、保存时静态检查、内置代码构建功能的小程序项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">$ npm install --global vue-cli</span><br><span class="line"></span><br><span class="line"># 创建一个基于 mpvue-quickstart 模板的新项目</span><br><span class="line">$ vue init mpvue/mpvue-quickstart my-project</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">$ cd my-project</span><br><span class="line">$ npm install</span><br><span class="line"># 启动构建</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure>

<p>接下来，你只需要启动微信开发者工具，引入项目即可预览到你的第一个 mpvue 小程序。</p>
<h2 id="框架原理"><a href="#框架原理" class="headerlink" title="框架原理"></a>框架原理</h2><ul>
<li>mpvue 保留了 vue.runtime 核心方法，无缝继承了 Vue.js 的基础能力</li>
<li>mpvue-template-compiler 提供了将 vue 的模板语法转换到小程序的 wxml 语法的能力</li>
<li>修改了 vue 的建构配置，使之构建出符合小程序项目结构的代码格式： json&#x2F;wxml&#x2F;wxss&#x2F;js 文件</li>
</ul>
<h2 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h2><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html">支持 官方文档：Vue 实例</a>，同时我们做了一些修改，来适应小程序的独特加载逻辑。</p>
<h2 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h2><p>同 vue，不同的是我们会在小程序 onReady 后，再去触发 vue mounted 生命周期，详细的 vue 生命周期文档请看<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">生命周期钩子</a></p>
<ul>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>mounted</li>
<li>beforeUpdate</li>
<li>updated</li>
<li>activated</li>
<li>deactivated</li>
<li>beforeDestroy</li>
<li>destroyed</li>
</ul>
<p>除了 Vue 本身的生命周期外，mpvue 还兼容了小程序生命周期，这部分生命周期钩子的来源于<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html">微信小程序的 Page</a>， 除特殊情况外，不建议使用小程序的生命周期钩子。</p>
<p><strong>app 部分</strong>：</p>
<ul>
<li>onLaunch，初始化</li>
<li>onShow，当小程序启动，或从后台进入前台显示</li>
<li>onHide，当小程序从前台进入后台</li>
</ul>
<p><strong>page 部分</strong>：</p>
<ul>
<li>onLoad，监听页面加载</li>
<li>onShow，监听页面显示</li>
<li>onReady，监听页面初次渲染完成</li>
<li>onHide，监听页面隐藏</li>
<li>onUnload，监听页面卸载</li>
<li>onPullDownRefresh，监听用户下拉动作</li>
<li>onReachBottom，页面上拉触底事件的处理函数</li>
<li>onShareAppMessage，用户点击右上角分享</li>
<li>onPageScroll，页面滚动</li>
<li>onTabItemTap, 当前是 tab 页时，点击 tab 时触发 （mpvue 0.0.16 支持）<br>用法示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    // `this` 指向 vm 实例</span><br><span class="line">    console.log(&#x27;a is: &#x27; + this.a)</span><br><span class="line">  &#125;,</span><br><span class="line">  onShow () &#123;</span><br><span class="line">    // `this` 指向 vm 实例</span><br><span class="line">    console.log(&#x27;a is: &#x27; + this.a, &#x27;小程序触发的 onshow&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// =&gt; &quot;a is: 1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong>：</p>
<ol>
<li><p>不要在选项属性或回调上使用箭头函数，比如 created: () &#x3D;&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue &#x3D;&gt; this.myMethod())。因为箭头函数是和父级上下文绑定在一起的，this 不会是如你做预期的 Vue 实例，且 this.a 或 this.myMethod 也会是未定义的。</p>
</li>
<li><p>微信小程序的页面的 query 参数是通过 onLoad 获取的，mpvue 对此进行了优化，直接通过 this.$root.$mp.query 获取相应的参数数据，其调用需要在 onLoad 生命周期触发之后使用，比如 onShow 等，具体生命周期调用顺序，见下图。</p>
</li>
</ol>
<h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><blockquote>
<p>你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p>
</blockquote>
<p>生命周期的调用关系和顺序图。</p>
<p><img src="http://mpvue.com/assets/img/lifecycle.a8762770.jpg" alt="image"></p>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>几乎全支持 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/syntax.html">官方文档：模板语法</a>，下面讲下不支持的情况。</p>
<h3 id="不支持-纯-HTML"><a href="#不支持-纯-HTML" class="headerlink" title="不支持 纯-HTML"></a>不支持 纯-HTML</h3><p>小程序里所有的 BOM／DOM 都不能用，也就是说 v-html 指令不能用。</p>
<h3 id="不支持部分复杂的-JavaScript-渲染表达式"><a href="#不支持部分复杂的-JavaScript-渲染表达式" class="headerlink" title="不支持部分复杂的 JavaScript 渲染表达式"></a>不支持部分复杂的 JavaScript 渲染表达式</h3><p>我们会把 template 中的 <code>&#123;&#123;&#125;&#125;</code> 双花括号的部分，直接编码到 wxml 文件中，由于微信小程序的能力限制(<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/data.html">数据绑定</a>)，所以无法支持复杂的 JavaScript 表达式。</p>
<p>目前可以使用的有 <code>+ - * % ?: ! == === &gt; &lt; [] .</code>，剩下的还待完善。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这种就不支持，建议写 computed --&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 但写在 @event 里面的表达式是都支持的，因为这部分的计算放在了 vdom 里面 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in list&quot;&gt;</span><br><span class="line">        &lt;div @click=&quot;clickHandle(item, index, $event)&quot;&gt;&#123;&#123; item.value &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h3 id="不支持过滤器"><a href="#不支持过滤器" class="headerlink" title="不支持过滤器"></a>不支持过滤器</h3><p>渲染部分会转成 wxml ，wxml 不支持过滤器，所以这部分功能不支持。</p>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>支持 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/computed.html">官方文档：计算属性</a>。</p>
<h2 id="不支持函数"><a href="#不支持函数" class="headerlink" title="不支持函数"></a>不支持函数</h2><p>不支持在 template 内使用 methods 中的函数。</p>
<p>#Class 与 Style 绑定<br>为节约性能，我们将 Class 与 Style 的表达式通过 compiler 硬编码到 wxml 中，支持语法和转换效果如下：</p>
<p>class 支持的语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p :class=&quot;&#123; active: isActive &#125;&quot;&gt;111&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;222&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;static&quot; :class=&quot;[activeClass, errorClass]&quot;&gt;333&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;static&quot; v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;444&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;static&quot; v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;555&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>将分别被转换成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;_p &#123;&#123;[isActive ? &#x27;active&#x27; : &#x27;&#x27;]&#125;&#125;&quot;&gt;111&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;_p static &#123;&#123;[isActive ? &#x27;active&#x27; : &#x27;&#x27;, hasError ? &#x27;text-danger&#x27; : &#x27;&#x27;]&#125;&#125;&quot;&gt;222&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;_p static &#123;&#123;[activeClass, errorClass]&#125;&#125;&quot;&gt;333&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;_p static &#123;&#123;[isActive ? activeClass : &#x27;&#x27;, errorClass]&#125;&#125;&quot;&gt;444&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;_p static &#123;&#123;[[isActive ? &#x27;active&#x27; : &#x27;&#x27;], errorClass]&#125;&#125;&quot;&gt;555&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p>style 支持的语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;666&lt;/p&gt;</span><br><span class="line">&lt;p v-bind:style=&quot;[&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;]&quot;&gt;777&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>将分别被转换成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;_p&quot; style=&quot; &#123;&#123;&#x27;color:&#x27; + activeColor + &#x27;;&#x27; + &#x27;font-size:&#x27; + fontSize + &#x27;px&#x27; + &#x27;;&#x27;&#125;&#125;&quot;&gt;666&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;_p&quot; style=&quot; &#123;&#123;&#x27;color:&#x27; + activeColor + &#x27;;&#x27; + &#x27;font-size:&#x27; + fontSize + &#x27;px&#x27; + &#x27;;&#x27;&#125;&#125;&quot;&gt;777&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p>不支持 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/class-and-style.html">官方文档：Class 与 Style 绑定</a> 中的 classObject 和 styleObject 语法。</p>
<p>最佳实践见上文支持的语法，<strong>从性能考虑，建议不要过度依赖此</strong>。</p>
<p>此外还可以用 computed 方法生成 class 或者 style 字符串，插入到页面中，举例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 支持 --&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot; :class=&quot;computedClassStr&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot; :class=&quot;&#123;active: isActive&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 不支持 --&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot; :class=&quot;computedClassObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                isActive: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            computedClassStr () &#123;</span><br><span class="line">                return this.isActive ? &#x27;active&#x27; : &#x27;&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            computedClassObject () &#123;</span><br><span class="line">                return &#123; active: this.isActive &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h3><p>暂不支持在组件上使用 Class 与 Style 绑定</p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>全支持 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/conditional.html">官方文档：条件渲染</a></p>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p>全支持 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html">官方文档：列表渲染</a></p>
<p>只是需要注意一点，<strong>嵌套列表渲染，必须指定不同的索引！</strong></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在这种嵌套循环的时候， index 和 itemIndex 这种索引是必须指定，且别名不能相同，正确的写法如下 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul v-for=&quot;(card, index) in list&quot;&gt;</span><br><span class="line">        &lt;li v-for=&quot;(item, itemIndex) in card&quot;&gt;</span><br><span class="line">            &#123;&#123;item.value&#125;&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h2><p>几乎全支持啦<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/events.html"> 官方文档：事件处理器</a></p>
<p>我们引入了 Vue.js 的虚拟 DOM ，在前文模版中绑定的事件会被挂在到 vnode 上，同时我们的 compiler 在 wxml 上绑定了小程序的事件，并做了相应的映射，所以你在真实点击的时候通过 runtime 中 handleProxy 通过事件类型分发到 vnode 的事件上，同 Vue 在 WEB 的机制一样，所以可以做到无损支持。同时还顺便支持了自定义事件和 $emit 机制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 事件映射表，左侧为 WEB 事件，右侧为 小程序 对应事件</span><br><span class="line">&#123;</span><br><span class="line">    click: &#x27;tap&#x27;,</span><br><span class="line">    touchstart: &#x27;touchstart&#x27;,</span><br><span class="line">    touchmove: &#x27;touchmove&#x27;,</span><br><span class="line">    touchcancel: &#x27;touchcancel&#x27;,</span><br><span class="line">    touchend: &#x27;touchend&#x27;,</span><br><span class="line">    tap: &#x27;tap&#x27;,</span><br><span class="line">    longtap: &#x27;longtap&#x27;,</span><br><span class="line">    input: &#x27;input&#x27;,</span><br><span class="line">    change: &#x27;change&#x27;,</span><br><span class="line">    submit: &#x27;submit&#x27;,</span><br><span class="line">    blur: &#x27;blur&#x27;,</span><br><span class="line">    focus: &#x27;focus&#x27;,</span><br><span class="line">    reset: &#x27;reset&#x27;,</span><br><span class="line">    confirm: &#x27;confirm&#x27;,</span><br><span class="line">    columnchange: &#x27;columnchange&#x27;,</span><br><span class="line">    linechange: &#x27;linechange&#x27;,</span><br><span class="line">    error: &#x27;error&#x27;,</span><br><span class="line">    scrolltoupper: &#x27;scrolltoupper&#x27;,</span><br><span class="line">    scrolltolower: &#x27;scrolltolower&#x27;,</span><br><span class="line">    scroll: &#x27;scroll&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 input 和 textarea 中 change 事件会被转为 blur 事件。</p>
<p><strong>踩坑注意</strong>：</p>
<ul>
<li>列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将 bind 改为@ @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在 handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 &lt;map @regionchange&#x3D;”functionName” @end&#x3D;”functionName” @begin&#x3D;”functionName”&gt;</map></li>
<li>小程序能力所致，bind 和 catch 事件同时绑定时候，只会触发 bind ,catch 不会被触发，要避免踩坑。</li>
<li>事件修饰符<ul>
<li>.stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！</li>
<li>.prevent 可以直接干掉，因为小程序里没有什么默认事件，比如 submit 并不会跳转页面</li>
<li>.capture 支持 1.0.9</li>
<li>.self 没有可以判断的标识</li>
<li>.once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑</li>
</ul>
</li>
<li>其他 键值修饰符 等在小程序中压根没键盘，所以。。。</li>
</ul>
<h2 id="表单控件绑定"><a href="#表单控件绑定" class="headerlink" title="表单控件绑定"></a>表单控件绑定</h2><p>几乎全支持 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/forms.html">官方文档：表单控件绑定</a>，不支持的还没测出来，之所以说几乎，是因为 WEB 表单这么复杂，谁特么知道会出什么奇怪的特性。</p>
<p>建议开发过程中直接使用 [微信小程序：表单组件]<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/button.html">https://mp.weixin.qq.com/debug/wxadoc/dev/component/button.html</a>) 。用法示例：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Meituan-Dianping/mpvue/issues/58">select 组件用 picker 组件进行代替</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;picker @change=&quot;bindPickerChange&quot; :value=&quot;index&quot; :range=&quot;array&quot;&gt;</span><br><span class="line">      &lt;view class=&quot;picker&quot;&gt;</span><br><span class="line">        当前选择：&#123;&#123;array[index]&#125;&#125;</span><br><span class="line">      &lt;/view&gt;</span><br><span class="line">    &lt;/picker&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      index: 0,</span><br><span class="line">      array: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    bindPickerChange (e) &#123;</span><br><span class="line">      console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/Meituan-Dianping/mpvue/issues/66">表单元素 radio 用 radio-group 组件进行代替</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;radio-group class=&quot;radio-group&quot; @change=&quot;radioChange&quot;&gt;</span><br><span class="line">      &lt;label class=&quot;radio&quot; v-for=&quot;(item, index) in items&quot; :key=&quot;item.name&quot;&gt;</span><br><span class="line">        &lt;radio :value=&quot;item.name&quot; :checked=&quot;item.checked&quot;/&gt; &#123;&#123;item.value&#125;&#125;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/radio-group&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      items: [</span><br><span class="line">        &#123;name: &#x27;USA&#x27;, value: &#x27;美国&#x27;&#125;,</span><br><span class="line">        &#123;name: &#x27;CHN&#x27;, value: &#x27;中国&#x27;, checked: &#x27;true&#x27;&#125;,</span><br><span class="line">        &#123;name: &#x27;BRA&#x27;, value: &#x27;巴西&#x27;&#125;,</span><br><span class="line">        &#123;name: &#x27;JPN&#x27;, value: &#x27;日本&#x27;&#125;,</span><br><span class="line">        &#123;name: &#x27;ENG&#x27;, value: &#x27;英国&#x27;&#125;,</span><br><span class="line">        &#123;name: &#x27;TUR&#x27;, value: &#x27;法国&#x27;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    radioChange (e) &#123;</span><br><span class="line">      console.log(&#x27;radio发生change事件，携带value值为：&#x27;, e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="Vue-组件"><a href="#Vue-组件" class="headerlink" title="Vue 组件"></a>Vue 组件</h3><p>组件是整个 Vue.js 中最复杂的部分，当然要支持 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components.html">官方文档：组件</a> 。</p>
<p><strong>有且只能使用单文件组件（.vue 组件）的形式进行支持</strong>。其他的诸如：动态组件，自定义 render，和<code>&lt;script type=&quot;text/x-template&quot;&gt;</code> 字符串模版等都不支持。原因很简单，因为我们要预编译出 wxml。</p>
<p>如果未来小程序支持了动态增删改查 wxml 节点信息，那我们就能做到全支持。</p>
<p>详细的不支持列表：</p>
<ul>
<li>暂不支持在组件引用时，在组件上定义 click 等原生事件、v-show（可用 v-if 代替）和 class style 等样式属性(例：<card class="class-name"> </card> 样式是不会生效的)，因为编译到 wxml，小程序不会生成节点，建议写在内部顶级元素上。</li>
<li>Slot（scoped 暂时还没做支持）</li>
<li>动态组件</li>
<li>异步组件</li>
<li>inline-template</li>
<li>X-Templates</li>
<li>keep-alive</li>
<li>transition</li>
<li>class</li>
<li>style</li>
</ul>
<h3 id="小程序组件"><a href="#小程序组件" class="headerlink" title="小程序组件"></a>小程序组件</h3><p>mpvue 可以支持小程序的原生组件，比如： picker,map 等，需要注意的是原生组件上的事件绑定，需要以 vue 的事件绑定语法来绑定，如 bindchange&#x3D;”eventName” 事件，需要写成 @change&#x3D;”eventName”</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;picker mode=&quot;date&quot; :value=&quot;date&quot; start=&quot;2015-09-01&quot; end=&quot;2017-09-01&quot; @change=&quot;bindDateChange&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;picker&quot;&gt;</span><br><span class="line">      当前选择: &#123;&#123;date&#125;&#125;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/picker&gt;</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript-支持"><a href="#TypeScript-支持" class="headerlink" title="TypeScript 支持"></a>TypeScript 支持</h2><p>目前 mpvue-loader 是可以支持 TypeScript 选项的，配置方法在此。具体 Demo 可以见 mpvue-ts-demo</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-精简-data-数据"><a href="#1-精简-data-数据" class="headerlink" title="1. 精简 data 数据"></a>1. 精简 data 数据</h3><p>冗余数据不要挂在 data 里，所有在 data&#x2F;props&#x2F;computed 中的数据，每次变更都会从微信小程序的 JSCore 进程，通过 setData 序列化成字符串后发送到 JSRender 进程。所以，如果你的数据量巨大的时候，会导致页面非常卡顿。</p>
<h3 id="2-优化长列表性能"><a href="#2-优化长列表性能" class="headerlink" title="2. 优化长列表性能"></a>2. 优化长列表性能</h3><p>一般情况下这种页面会有大量的数据，除了遵从上面的建议外还有额外的建议。</p>
<ul>
<li>避免在 v-for 中嵌套子组件，这样可以优化大部分 setData 时的冗余数据。</li>
<li>通过实践发现 wx:if 和 hidden 的优化肉眼不可见，所以或许可以试试直接通过样式 display 来展示和隐藏。</li>
<li>如果列表过长，强烈建议产品思考更好的展示形态。比如只展示热门，多余的折叠等形式。<blockquote>
<p>注：我们对其进行了专门优化，最佳实践时和原生小程序代码的性能相差无几。</p>
</blockquote>
</li>
</ul>
<h3 id="3-合理使用双向绑定-mpvue-建议使用-v-model-lazy-绑定方式以优化性能，此外-v-model-在老基础库下输入框输入时可能存在光标重设的问题。"><a href="#3-合理使用双向绑定-mpvue-建议使用-v-model-lazy-绑定方式以优化性能，此外-v-model-在老基础库下输入框输入时可能存在光标重设的问题。" class="headerlink" title="3. 合理使用双向绑定 mpvue 建议使用 v-model.lazy 绑定方式以优化性能，此外 v-model 在老基础库下输入框输入时可能存在光标重设的问题。"></a>3. 合理使用双向绑定 mpvue 建议使用 v-model.lazy 绑定方式以优化性能，此外 v-model 在老基础库下输入框输入时可能存在光标重设的问题。</h3><h3 id="4-谨慎选择直接使用小程序的-API-如果你有小程序和-H5-复用代码的需要，业务代码需要保持对-WEB-Vue-js-的兼容性。此时我们不建议在代码中直接调用小程序-API，更好的选择是通过桥接适配层屏蔽两端差异。"><a href="#4-谨慎选择直接使用小程序的-API-如果你有小程序和-H5-复用代码的需要，业务代码需要保持对-WEB-Vue-js-的兼容性。此时我们不建议在代码中直接调用小程序-API，更好的选择是通过桥接适配层屏蔽两端差异。" class="headerlink" title="4. 谨慎选择直接使用小程序的 API 如果你有小程序和 H5 复用代码的需要，业务代码需要保持对 WEB Vue.js 的兼容性。此时我们不建议在代码中直接调用小程序 API，更好的选择是通过桥接适配层屏蔽两端差异。"></a>4. 谨慎选择直接使用小程序的 API 如果你有小程序和 H5 复用代码的需要，业务代码需要保持对 WEB Vue.js 的兼容性。此时我们不建议在代码中直接调用小程序 API，更好的选择是通过桥接适配层屏蔽两端差异。</h3><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1-如何获取小程序在-page-onLoad-时候传递的-options"><a href="#1-如何获取小程序在-page-onLoad-时候传递的-options" class="headerlink" title="1. 如何获取小程序在 page onLoad 时候传递的 options"></a>1. 如何获取小程序在 page onLoad 时候传递的 options</h3><p>在所有 页面 的组件内可以通过 this.$root.$mp.query 进行获取。</p>
<h3 id="2-如何获取小程序在-app-onLaunch-x2F-onShow-时候传递的-options"><a href="#2-如何获取小程序在-app-onLaunch-x2F-onShow-时候传递的-options" class="headerlink" title="2. 如何获取小程序在 app onLaunch&#x2F;onShow 时候传递的 options"></a>2. 如何获取小程序在 app onLaunch&#x2F;onShow 时候传递的 options</h3><p>在所有的组件内可以通过 this.$root.$mp.appOptions 进行获取。</p>
<h3 id="3-如何捕获-app-的-onError"><a href="#3-如何捕获-app-的-onError" class="headerlink" title="3. 如何捕获 app 的 onError"></a>3. 如何捕获 app 的 onError</h3><p>由于 onError 并不是完整意义的生命周期，所以只提供一个捕获错误的方法，在 app 的根组件上添加名为 onError 的回调函数即可。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">   // 只有 app 才会有 onLaunch 的生命周期</span><br><span class="line">   onLaunch () &#123;</span><br><span class="line">       // ...</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   // 捕获 app error</span><br><span class="line">   onError (err) &#123;</span><br><span class="line">       console.log(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mpvue-框架使用场景汇总"><a href="#mpvue-框架使用场景汇总" class="headerlink" title="mpvue 框架使用场景汇总"></a>mpvue 框架使用场景汇总</h2><p>mpvue 作为一个前端开发框架，提供了一整套解决方案。但开发者面临的实际情况可能更加复杂，我们整理了 mpvue 可能的使用场景，在这些场景下，我们为你提供了一些建议。</p>
<p>首先，mpvue 小程序框架包含如下内容：</p>
<ul>
<li>运行时 JS SDK</li>
<li>初始化模板项目（包含推荐的目录结构，webpack 构建，代码检查配置等）</li>
<li>项目构建所需的 npm 依赖（已经包含在项目模板中，无需手动引入）</li>
</ul>
<h2 id="开发者可能会面对的四种典型场景"><a href="#开发者可能会面对的四种典型场景" class="headerlink" title="开发者可能会面对的四种典型场景"></a>开发者可能会面对的四种典型场景</h2><ul>
<li>单独以 mpvue 框架构建小程序</li>
<li>mpvue 框架为主，同时使用其它框架（原生开发方式或 wepy 等）</li>
<li>已经使用其它框架，引入 mpvue 做部分模块的开发</li>
<li>只使用 mpvue 的 JS SDK，自定义构建策略</li>
</ul>
<p>针对上述不同场景，mpvue 框架需要提供的方案和建议如下</p>
<ul>
<li>单独以 mpvue 框架构建小程序<ul>
<li>推荐的方式，无需额外支持。通过框架提供的项目初始化工具初始化项目即可，已经包含完整的构建策略，代码组织方式等.</li>
</ul>
</li>
<li>mpvue 框架为主，同时使用其它框架（原生开发方式或 wepy 等）<ul>
<li>第三方框架和 mpvue 做分块构建。可能的方案是：不同框架各自的构建策略做好边界分离，最终通过单一入口聚合到一起。或者更简单的，拆成多个子项目，最终输出到同一目录，目标代码符合小程序规范即可。</li>
</ul>
</li>
<li>已经使用其它框架，引入 mpvue 做部分模块的开发<ul>
<li>mpvue 提供轻量的模块构建工具支持部分构建。对已有小程序项目接入 mpvue 来说，渐进的方式会是乐于接受的，可以先让一部分功能通过 mpvue 编写。此类场景，不再适合通过模板项目初始化项目结构，开发者可以参考模板项目中的代码编写方式，通过我们单独准备的构建工具，定制好构建任务即可。</li>
</ul>
</li>
<li>只使用 mpvue 的 JS SDK，自定义构建策略<ul>
<li>需要开发者自定义 webpack 构建策略。 框架本身不建议开发者这么使用。但对于高阶的开发者，这是可能的方案。此时，开发者可以参考我们模板项目中的构建策略即可，我们目前只提供 webpack 构建方案。对于其它构建，我们暂不支持。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">前端代码开发规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 11:13:17 / 修改时间：11:20:40" itemprop="dateCreated datePublished" datetime="2022-12-16T11:13:17+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">前端算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前端-JS-项目开发规范"><a href="#前端-JS-项目开发规范" class="headerlink" title="前端 JS 项目开发规范"></a>前端 JS 项目开发规范</h2><p>规范的目的是为了编写高质量的代码，让你的团队成员每天的心情都是愉悦的，大家在一起是快乐的。</p>
<p>引自《阿里规约》的开头片段：</p>
<p>—-现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。</p>
<h2 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h2><h3 id="一-命名规范"><a href="#一-命名规范" class="headerlink" title="(一)命名规范"></a>(一)命名规范</h3><h4 id="1-1-1-项目命名"><a href="#1-1-1-项目命名" class="headerlink" title="1.1.1 项目命名"></a>1.1.1 项目命名</h4><p>全部采用小写方式， 以中划线分隔。</p>
<p>正例：<code>mall-management-system</code></p>
<p>反例：<code>mall_management-system / mallManagementSystem</code></p>
<h4 id="1-1-2-目录命名"><a href="#1-1-2-目录命名" class="headerlink" title="1.1.2 目录命名"></a>1.1.2 目录命名</h4><p>全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数</p>
<p>正例： <code>scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc</code></p>
<p>反例： <code>script / style / demo_scripts / demoStyles / imgs / docs</code></p>
<p>【特殊】VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名</p>
<p>正例： <code>head-search / page-loading / authorized / notice-icon</code></p>
<p>反例： <code>HeadSearch / PageLoading</code></p>
<p>【特殊】VUE 的项目中除 components 组件目录外的所有目录也使用 kebab-case 命名<br>正例： <code>page-one / shopping-car / user-management</code></p>
<p>反例： <code>ShoppingCar / UserManagement</code></p>
<h4 id="1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名"><a href="#1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名" class="headerlink" title="1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名"></a>1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</h4><p>全部采用小写方式， 以中划线分隔</p>
<p>正例： <code>render-dom.js / signup.css / index.html / company-logo.png</code></p>
<p>反例： <code>renderDom.js / UserManagement.html</code></p>
<h4 id="1-1-4-命名严谨性"><a href="#1-1-4-命名严谨性" class="headerlink" title="1.1.4 命名严谨性"></a>1.1.4 命名严谨性</h4><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用</p>
<p>正例：<code>henan / luoyang / rmb</code> 等国际通用的名称，可视同英文。</p>
<p>反例：<code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code></p>
<p>杜绝完全不规范的缩写，避免望文不知义：</p>
<p>反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</p>
<h3 id="二-HTML-规范-（Vue-Template-同样适用）"><a href="#二-HTML-规范-（Vue-Template-同样适用）" class="headerlink" title="(二)HTML 规范 （Vue Template 同样适用）"></a>(二)HTML 规范 （Vue Template 同样适用）</h3><h4 id="1-2-1-HTML-类型"><a href="#1-2-1-HTML-类型" class="headerlink" title="1.2.1 HTML 类型"></a>1.2.1 HTML 类型</h4><p>推荐使用 HTML5 的文档类型声明： .<br>（建议使用 text&#x2F;html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application&#x2F;xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p>
<ul>
<li>规定字符编码</li>
<li>IE 兼容模式</li>
<li>规定字符编码</li>
<li>doctype 大写<br>正例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Page title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot; /&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-缩进"><a href="#1-2-2-缩进" class="headerlink" title="1.2.2 缩进"></a>1.2.2 缩进</h4><p>缩进使用 2 个空格（一个 tab）</p>
<p>嵌套的节点应该缩进。</p>
<h4 id="1-2-3-分块注释"><a href="#1-2-3-分块注释" class="headerlink" title="1.2.3 分块注释"></a>1.2.3 分块注释</h4><p>在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式</p>
<p>…</p>
<h4 id="1-2-4-语义化标签"><a href="#1-2-4-语义化标签" class="headerlink" title="1.2.4 语义化标签"></a>1.2.4 语义化标签</h4><p>HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签</p>
<p>正例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;&lt;/header&gt;</span><br><span class="line">&lt;footer&gt;&lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<p>反例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-5-引号"><a href="#1-2-5-引号" class="headerlink" title="1.2.5 引号"></a>1.2.5 引号</h4><p>使用双引号(“”) 而不是单引号(‘’) 。</p>
<p>正例： “”</p>
<p>反例： ‘’</p>
<h3 id="三-CSS-规范"><a href="#三-CSS-规范" class="headerlink" title="(三) CSS 规范"></a>(三) CSS 规范</h3><h4 id="1-3-1-命名"><a href="#1-3-1-命名" class="headerlink" title="1.3.1 命名"></a>1.3.1 命名</h4><ul>
<li>类名使用小写字母，以中划线分隔</li>
<li>id 采用驼峰式命名</li>
<li>scss 中的变量、函数、混合、placeholder 采用驼峰式命名<br>ID 和 class 的名称总是使用可以反映元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</li>
</ul>
<p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.fw-800 &#123;</span><br><span class="line">  font-weight: 800;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.red &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.heavy &#123;</span><br><span class="line">  font-weight: 800;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.important &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-选择器"><a href="#1-3-2-选择器" class="headerlink" title="1.3.2 选择器"></a>1.3.2 选择器</h4><p>1)css 选择器中避免使用标签名<br>从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。</p>
<p>2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。</p>
<p>不推荐:</p>
<p><code>.content .title &#123;   font-size: 2rem; &#125;</code></p>
<p>推荐:</p>
<p><code>.content &gt; .title &#123;   font-size: 2rem; &#125;</code></p>
<h4 id="1-3-3-尽量使用缩写属性"><a href="#1-3-3-尽量使用缩写属性" class="headerlink" title="1.3.3 尽量使用缩写属性"></a>1.3.3 尽量使用缩写属性</h4><p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border-top-style: none;</span><br><span class="line">font-family: palatino, georgia, serif;</span><br><span class="line">font-size: 100%;</span><br><span class="line">line-height: 1.6;</span><br><span class="line">padding-bottom: 2em;</span><br><span class="line">padding-left: 1em;</span><br><span class="line">padding-right: 1em;</span><br><span class="line">padding-top: 0;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-top: 0;</span><br><span class="line">font: 100%/1.6 palatino, georgia, serif;</span><br><span class="line">padding: 0 1em 2em;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-4-每个选择器及属性独占一行"><a href="#1-3-4-每个选择器及属性独占一行" class="headerlink" title="1.3.4 每个选择器及属性独占一行"></a>1.3.4 每个选择器及属性独占一行</h4><p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button&#123;</span><br><span class="line">  width:100px;height:50px;color:#fff;background:#00a0e9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button&#123;</span><br><span class="line">  width:100px;</span><br><span class="line">  height:50px;</span><br><span class="line">  color:#fff;</span><br><span class="line">  background:#00a0e9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-5-省略-0-后面的单位"><a href="#1-3-5-省略-0-后面的单位" class="headerlink" title="1.3.5 省略 0 后面的单位"></a>1.3.5 省略 0 后面的单位</h4><p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  padding-bottom: 0px;</span><br><span class="line">  margin: 0em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  padding-bottom: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-6-避免使用-ID-选择器及全局标签选择器防止污染全局样式"><a href="#1-3-6-避免使用-ID-选择器及全局标签选择器防止污染全局样式" class="headerlink" title="1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式"></a>1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式</h4><p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#header&#123;</span><br><span class="line">  padding-bottom: 0px;</span><br><span class="line">  margin: 0em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.header&#123;</span><br><span class="line">  padding-bottom: 0px;</span><br><span class="line">  margin: 0em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-LESS-规范"><a href="#四-LESS-规范" class="headerlink" title="(四) LESS 规范"></a>(四) LESS 规范</h3><h4 id="1-4-1-代码组织"><a href="#1-4-1-代码组织" class="headerlink" title="1.4.1 代码组织"></a>1.4.1 代码组织</h4><p>1)将公共 less 文件放置在<code>style/less/common</code>文件夹<br>例:<code>// color.less,common.less</code></p>
<p>2)按以下顺序组织</p>
<ul>
<li>1、@import;</li>
<li>2、变量声明;</li>
<li>3、样式声明;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;mixins/size.less&quot;;</span><br><span class="line"></span><br><span class="line">@default-text-color: #333;</span><br><span class="line"></span><br><span class="line">.page &#123;</span><br><span class="line">  width: 960px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-避免嵌套层级过多"><a href="#1-4-2-避免嵌套层级过多" class="headerlink" title="1.4.2 避免嵌套层级过多"></a>1.4.2 避免嵌套层级过多</h4><p>将嵌套深度限制在 3 级。对于超过 4 级的嵌套，给予重新评估。这可以避免出现过于详实的 CSS 选择器。<br>避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于 20 行的嵌套规则出现</p>
<p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line">  .title&#123;</span><br><span class="line">    .name&#123;</span><br><span class="line">       color:#fff</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.main-title&#123;</span><br><span class="line">   .name&#123;</span><br><span class="line">      color:#fff</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-Javascript-规范"><a href="#五-Javascript-规范" class="headerlink" title="(五) Javascript 规范"></a>(五) Javascript 规范</h3><h4 id="1-5-1-命名"><a href="#1-5-1-命名" class="headerlink" title="1.5.1 命名"></a>1.5.1 命名</h4><ol>
<li><p>采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束<br>反例： <code>_name / name_ / name$</code></p>
</li>
<li><p>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。<br>正例： <code>localValue / getHttpMessage() / inputUserId</code></p>
</li>
</ol>
<p><strong>其中 method 方法命名必须是 动词 或者 动词+名词 形式</strong></p>
<p>正例：<code>saveShopCarData /openShopCarInfoDialog</code></p>
<p>反例：<code>save / open / show / go</code></p>
<p><strong>特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）</strong></p>
<p><code>add / update / delete / detail / get</code></p>
<p><strong>附： 函数方法常用的动词:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">get 获取/set 设置,</span><br><span class="line">add 增加/remove 删除</span><br><span class="line">create 创建/destory 移除</span><br><span class="line">start 启动/stop 停止</span><br><span class="line">open 打开/close 关闭,</span><br><span class="line">read 读取/write 写入</span><br><span class="line">load 载入/save 保存,</span><br><span class="line">create 创建/destroy 销毁</span><br><span class="line">begin 开始/end 结束,</span><br><span class="line">backup 备份/restore 恢复</span><br><span class="line">import 导入/export 导出,</span><br><span class="line">split 分割/merge 合并</span><br><span class="line">inject 注入/extract 提取,</span><br><span class="line">attach 附着/detach 脱离</span><br><span class="line">bind 绑定/separate 分离,</span><br><span class="line">view 查看/browse 浏览</span><br><span class="line">edit 编辑/modify 修改,</span><br><span class="line">select 选取/mark 标记</span><br><span class="line">copy 复制/paste 粘贴,</span><br><span class="line">undo 撤销/redo 重做</span><br><span class="line">insert 插入/delete 移除,</span><br><span class="line">add 加入/append 添加</span><br><span class="line">clean 清理/clear 清除,</span><br><span class="line">index 索引/sort 排序</span><br><span class="line">find 查找/search 搜索,</span><br><span class="line">increase 增加/decrease 减少</span><br><span class="line">play 播放/pause 暂停,</span><br><span class="line">launch 启动/run 运行</span><br><span class="line">compile 编译/execute 执行,</span><br><span class="line">debug 调试/trace 跟踪</span><br><span class="line">observe 观察/listen 监听,</span><br><span class="line">build 构建/publish 发布</span><br><span class="line">input 输入/output 输出,</span><br><span class="line">encode 编码/decode 解码</span><br><span class="line">encrypt 加密/decrypt 解密,</span><br><span class="line">compress 压缩/decompress 解压缩</span><br><span class="line">pack 打包/unpack 解包,</span><br><span class="line">parse 解析/emit 生成</span><br><span class="line">connect 连接/disconnect 断开,</span><br><span class="line">send 发送/receive 接收</span><br><span class="line">download 下载/upload 上传,</span><br><span class="line">refresh 刷新/synchronize 同步</span><br><span class="line">update 更新/revert 复原,</span><br><span class="line">lock 锁定/unlock 解锁</span><br><span class="line">check out 签出/check in 签入,</span><br><span class="line">submit 提交/commit 交付</span><br><span class="line">push 推/pull 拉,</span><br><span class="line">expand 展开/collapse 折叠</span><br><span class="line">begin 起始/end 结束,</span><br><span class="line">start 开始/finish 完成</span><br><span class="line">enter 进入/exit 退出,</span><br><span class="line">abort 放弃/quit 离开</span><br><span class="line">obsolete 废弃/depreciate 废旧,</span><br><span class="line">collect 收集/aggregate 聚集</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>正例： <code>MAX_STOCK_COUNT</code></li>
</ol>
<p>反例： <code>MAX_COUNT</code></p>
<h4 id="1-5-2-代码格式"><a href="#1-5-2-代码格式" class="headerlink" title="1.5.2 代码格式"></a>1.5.2 代码格式</h4><ol>
<li>使用 2 个空格进行缩进<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (x &lt; y) &#123;</span><br><span class="line">  x += 10;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  x += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。<br>说明：任何情形，没有必要插入多个空行进行隔开。</li>
</ol>
<h4 id="1-5-3-字符串"><a href="#1-5-3-字符串" class="headerlink" title="1.5.3 字符串"></a>1.5.3 字符串</h4><p>统一使用单引号(‘’)，不使用双引号(“”)。这在创建 HTML 字符串非常有好处：</p>
<p>正例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;foo&#x27;;</span><br><span class="line">let testDiv = &#x27;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<p>反例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;foo&quot;;</span><br><span class="line">let testDiv = &quot;&lt;div id=&#x27;test&#x27;&gt;&lt;/div&gt;&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-4-对象声明"><a href="#1-5-4-对象声明" class="headerlink" title="1.5.4 对象声明"></a>1.5.4 对象声明</h4><p>1)使用字面值创建对象<br>正例：<code> let user = &#123;&#125;;</code></p>
<p>反例： <code>let user = new Object();</code></p>
<ol start="2">
<li>使用字面量来代替对象构造器<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  age: 0,</span><br><span class="line">  name: 1,</span><br><span class="line">  city: 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var user = new Object();</span><br><span class="line">user.age = 0;</span><br><span class="line">user.name = 0;</span><br><span class="line">user.city = 0;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-5-使用-ES6-7"><a href="#1-5-5-使用-ES6-7" class="headerlink" title="1.5.5 使用 ES6,7"></a>1.5.5 使用 ES6,7</h4><p>必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</p>
<p>必须强制使用 ES6, ES7 的新语法，比如箭头函数、await&#x2F;async ， 解构， let ， for…of 等等</p>
<h4 id="1-5-6-括号"><a href="#1-5-6-括号" class="headerlink" title="1.5.6 括号"></a>1.5.6 括号</h4><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (condition) doSomething();</span><br></pre></td></tr></table></figure>

<h4 id="1-5-7-undefined-判断"><a href="#1-5-7-undefined-判断" class="headerlink" title="1.5.7 undefined 判断"></a>1.5.7 undefined 判断</h4><p>永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof person === &#x27;undefined&#x27;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (person === undefined) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-8-条件判断和循环最多三层"><a href="#1-5-8-条件判断和循环最多三层" class="headerlink" title="1.5.8 条件判断和循环最多三层"></a>1.5.8 条件判断和循环最多三层</h4><p>条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。</p>
<h4 id="1-5-9-this-的转换命名"><a href="#1-5-9-this-的转换命名" class="headerlink" title="1.5.9 this 的转换命名"></a>1.5.9 this 的转换命名</h4><p>对上下文 this 的引用只能使用’self’来命名</p>
<h4 id="1-5-10-慎用-console-log"><a href="#1-5-10-慎用-console-log" class="headerlink" title="1.5.10 慎用 console.log"></a>1.5.10 慎用 console.log</h4><p>因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能</p>
<h2 id="二、Vue-项目规范"><a href="#二、Vue-项目规范" class="headerlink" title="二、Vue 项目规范"></a>二、Vue 项目规范</h2><h3 id="一-Vue-编码基础"><a href="#一-Vue-编码基础" class="headerlink" title="(一) Vue 编码基础"></a>(一) Vue 编码基础</h3><p>vue 项目规范以 Vue 官方规范 （<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/style-guide/%EF%BC%89">https://cn.vuejs.org/v2/style-guide/）</a> 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</p>
<p>请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</p>
<h4 id="2-1-1-组件规范"><a href="#2-1-1-组件规范" class="headerlink" title="2.1.1. 组件规范"></a>2.1.1. 组件规范</h4><ol>
<li>组件名为多个单词。<br>组件名应该始终是多个单词组成（大于等于 2），且命名规范为 KebabCase 格式。<br>这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</li>
</ol>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;TodoItem&#x27;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Todo&#x27;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;todo-item&#x27;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>组件文件名为 pascal-case 格式<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- my-component.vue</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- myComponent.vue</span><br><span class="line">|- MyComponent.vue</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>基础组件文件名为 base 开头，使用完整单词而不是缩写。<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- base-button.vue</span><br><span class="line">|- base-table.vue</span><br><span class="line">|- base-icon.vue</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- MyButton.vue</span><br><span class="line">|- VueTable.vue</span><br><span class="line">|- Icon.vue</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- todo-list.vue</span><br><span class="line">|- todo-list-item.vue</span><br><span class="line">|- todo-list-item-button.vue</span><br><span class="line">|- user-profile-options.vue （完整单词）</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoItem.vue</span><br><span class="line">|- TodoButton.vue</span><br><span class="line">|- UProfOpts.vue （使用了缩写）</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span><br><span class="line">&lt;MyComponent /&gt;</span><br><span class="line">&lt;Row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/Row&gt;</span><br><span class="line">反例：</span><br><span class="line"></span><br><span class="line">&lt;my-component /&gt; &lt;row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/row&gt;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>组件的 data 必须是一个函数<br>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。</li>
</ol>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#x27;jack&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &#x27;jack&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Prop 定义应该尽量详细</li>
</ol>
<ul>
<li>必须使用 camelCase 驼峰命名</li>
<li>必须指定类型</li>
<li>必须加上注释，表明其含义</li>
<li>必须加上 required 或者 default，两者二选其一</li>
<li>如果有业务需要，必须加上 validator 验证<br>正例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  // 组件状态，用于控制组件的颜色</span><br><span class="line">   status: &#123;</span><br><span class="line">     type: String,</span><br><span class="line">     required: true,</span><br><span class="line">     validator: function (value) &#123;</span><br><span class="line">       return [</span><br><span class="line">         &#x27;succ&#x27;,</span><br><span class="line">         &#x27;info&#x27;,</span><br><span class="line">         &#x27;error&#x27;</span><br><span class="line">       ].indexOf(value) !== -1</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">    // 用户级别，用于显示皇冠个数</span><br><span class="line">   userLevel：&#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>为组件样式设置作用域<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用 `scoped` 特性 --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .btn-close &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;!-- 没有使用 `scoped` 特性 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .btn-close &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>如果特性元素较多，应该主动换行。<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class="line">    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class="line">    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class="line"> /&gt;</span><br><span class="line">反例：</span><br><span class="line"></span><br><span class="line">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-模板中使用简单的表达式"><a href="#2-1-2-模板中使用简单的表达式" class="headerlink" title="2.1.2. 模板中使用简单的表达式"></a>2.1.2. 模板中使用简单的表达式</h4><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; normalizedFullName &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 复杂表达式已经移入一个计算属性</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedFullName: function () &#123;</span><br><span class="line">    return this.fullName.split(&#x27; &#x27;).map(function (word) &#123;</span><br><span class="line">      return word[0].toUpperCase() + word.slice(1)</span><br><span class="line">    &#125;).join(&#x27; &#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">       &#123;&#123;</span><br><span class="line">          fullName.split(&#x27; &#x27;).map(function (word) &#123;</span><br><span class="line">             return word[0].toUpperCase() + word.slice(1)</span><br><span class="line">           &#125;).join(&#x27; &#x27;)</span><br><span class="line">        &#125;&#125;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-指令都使用缩写形式"><a href="#2-1-3-指令都使用缩写形式" class="headerlink" title="2.1.3 指令都使用缩写形式"></a>2.1.3 指令都使用缩写形式</h4><p>指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  @input=&quot;onInput&quot;</span><br><span class="line">  @focus=&quot;onFocus&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-on:input=&quot;onInput&quot;</span><br><span class="line">  @focus=&quot;onFocus&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-标签顺序保持一致"><a href="#2-1-4-标签顺序保持一致" class="headerlink" title="2.1.4 标签顺序保持一致"></a>2.1.4 标签顺序保持一致</h4><p>单文件组件应该总是让标签顺序保持为 &#96;</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;...&lt;/template&gt;</span><br><span class="line">&lt;script&gt;...&lt;/script&gt;</span><br><span class="line">&lt;style&gt;...&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;...&lt;/template&gt;</span><br><span class="line">&lt;style&gt;...&lt;/style&gt;</span><br><span class="line">&lt;script&gt;...&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-必须为-v-for-设置键值-key"><a href="#2-1-5-必须为-v-for-设置键值-key" class="headerlink" title="2.1.5 必须为 v-for 设置键值 key"></a>2.1.5 必须为 v-for 设置键值 key</h4><h4 id="2-1-6-v-show-与-v-if-选择"><a href="#2-1-6-v-show-与-v-if-选择" class="headerlink" title="2.1.6 v-show 与 v-if 选择"></a>2.1.6 v-show 与 v-if 选择</h4><p>如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</p>
<h4 id="2-1-7-script-标签内部结构顺序"><a href="#2-1-7-script-标签内部结构顺序" class="headerlink" title="2.1.7 script 标签内部结构顺序"></a>2.1.7 script 标签内部结构顺序</h4><p>components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</p>
<h4 id="2-1-8-Vue-Router-规范"><a href="#2-1-8-Vue-Router-规范" class="headerlink" title="2.1.8 Vue Router 规范"></a>2.1.8 Vue Router 规范</h4><ol>
<li>页面跳转数据传递使用路由参数<br>页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。</li>
</ol>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let id = &#x27;123&#x27;;</span><br><span class="line">this.$router.push(&#123; name: &#x27;userCenter&#x27;, query: &#123; id: id &#125; &#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用路由懒加载（延迟加载）机制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/uploadAttachment&#x27;,</span><br><span class="line">    name: &#x27;uploadAttachment&#x27;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#x27;上传附件&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () =&gt; import(&#x27;@/view/components/uploadAttachment/index.vue&#x27;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>router 中的命名规范<br>path、childrenPoints 命名规范采用 kebab-case 命名规范（尽量 vue 文件的目录结构保持一致，因为目录、文件名都是 kebab-case，这样很方便找到对应的文件）</li>
</ol>
<p>name 命名规范采用 KebabCase 命名规范且和 component 组件名保持一致！（因为要保持 keep-alive 特性，keep-alive 按照 component 的 name 进行缓存，所以两者必须高度保持一致）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 动态加载</span><br><span class="line">export const reload = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/reload&#x27;,</span><br><span class="line">    name: &#x27;reload&#x27;,</span><br><span class="line">    component: Main,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#x27;动态加载&#x27;,</span><br><span class="line">      icon: &#x27;icon iconfont&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/reload/smart-reload-list&#x27;,</span><br><span class="line">        name: &#x27;SmartReloadList&#x27;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          title: &#x27;SmartReload&#x27;,</span><br><span class="line">          childrenPoints: [</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#x27;查询&#x27;,</span><br><span class="line">              name: &#x27;smart-reload-search&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#x27;执行reload&#x27;,</span><br><span class="line">              name: &#x27;smart-reload-update&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#x27;查看执行结果&#x27;,</span><br><span class="line">              name: &#x27;smart-reload-result&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        component: () =&gt;</span><br><span class="line">          import(&#x27;@/views/reload/smart-reload/smart-reload-list.vue&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>router 中的 path 命名规范<br>path 除了采用 kebab-case 命名规范以外，必须以 &#x2F; 开头，即使是 children 里的 path 也要以 &#x2F; 开头。如下示例</li>
</ol>
<p>目的：</p>
<p>经常有这样的场景：某个页面有问题，要立刻找到这个 vue 文件，如果不用以&#x2F;开头，path 为 parent 和 children 组成的，可能经常需要在 router 文件里搜索多次才能找到，而如果以&#x2F;开头，则能立刻搜索到对应的组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/file&#x27;,</span><br><span class="line">    name: &#x27;File&#x27;,</span><br><span class="line">    component: Main,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#x27;文件服务&#x27;,</span><br><span class="line">      icon: &#x27;ios-cloud-upload&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/file/file-list&#x27;,</span><br><span class="line">        name: &#x27;FileList&#x27;,</span><br><span class="line">        component: () =&gt; import(&#x27;@/views/file/file-list.vue&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/file/file-add&#x27;,</span><br><span class="line">        name: &#x27;FileAdd&#x27;,</span><br><span class="line">        component: () =&gt; import(&#x27;@/views/file/file-add.vue&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/file/file-update&#x27;,</span><br><span class="line">        name: &#x27;FileUpdate&#x27;,</span><br><span class="line">        component: () =&gt; import(&#x27;@/views/file/file-update.vue&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二-Vue-项目目录规范"><a href="#二-Vue-项目目录规范" class="headerlink" title="(二) Vue 项目目录规范"></a>(二) Vue 项目目录规范</h3><h4 id="2-2-1-基础"><a href="#2-2-1-基础" class="headerlink" title="2.2.1 基础"></a>2.2.1 基础</h4><p>vue 项目中的所有命名一定要与后端命名统一。</p>
<p>比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！</p>
<h4 id="2-2-2-使用-Vue-cli-脚手架"><a href="#2-2-2-使用-Vue-cli-脚手架" class="headerlink" title="2.2.2 使用 Vue-cli 脚手架"></a>2.2.2 使用 Vue-cli 脚手架</h4><p>使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。</p>
<h4 id="2-2-3-目录说明"><a href="#2-2-3-目录说明" class="headerlink" title="2.2.3 目录说明"></a>2.2.3 目录说明</h4><p>目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">src                               源码目录</span><br><span class="line">|-- api                              所有api接口</span><br><span class="line">|-- assets                           静态资源，images, icons, styles等</span><br><span class="line">|-- components                       公用组件</span><br><span class="line">|-- config                           配置信息</span><br><span class="line">|-- constants                        常量信息，项目所有Enum, 全局常量等</span><br><span class="line">|-- directives                       自定义指令</span><br><span class="line">|-- filters                          过滤器，全局工具</span><br><span class="line">|-- datas                            模拟数据，临时存放</span><br><span class="line">|-- lib                              外部引用的插件存放及修改文件</span><br><span class="line">|-- mock                             模拟接口，临时存放</span><br><span class="line">|-- plugins                          插件，全局使用</span><br><span class="line">|-- router                           路由，统一管理</span><br><span class="line">|-- store                            vuex, 统一管理</span><br><span class="line">|-- themes                           自定义样式主题</span><br><span class="line">|-- views                            视图目录</span><br><span class="line">|   |-- role                             role模块名</span><br><span class="line">|   |-- |-- role-list.vue                    role列表页面</span><br><span class="line">|   |-- |-- role-add.vue                     role新建页面</span><br><span class="line">|   |-- |-- role-update.vue                  role更新页面</span><br><span class="line">|   |-- |-- index.less                      role模块样式</span><br><span class="line">|   |-- |-- components                      role模块通用组件文件夹</span><br><span class="line">|   |-- employee                         employee模块</span><br></pre></td></tr></table></figure>

<ol>
<li>api 目录</li>
</ol>
<ul>
<li>文件、变量命名要与后端保持一致。</li>
<li>此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。</li>
<li>api 中的方法名字要与后端 api url 尽量保持语义高度一致性。</li>
<li>对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。<br>正例：</li>
</ul>
<p>后端 url： EmployeeController.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/employee/add</span><br><span class="line">/employee/delete/&#123;id&#125;</span><br><span class="line">/employee/update</span><br></pre></td></tr></table></figure>

<p>前端： employee.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 添加员工</span><br><span class="line">addEmployee: (data) =&gt; &#123;</span><br><span class="line">    return postAxios(&#x27;/employee/add&#x27;, data)</span><br><span class="line">&#125;,</span><br><span class="line">// 更新员工信息</span><br><span class="line">updateEmployee: (data) =&gt; &#123;</span><br><span class="line">    return postAxios(&#x27;/employee/update&#x27;, data)</span><br><span class="line">&#125;,</span><br><span class="line">// 删除员工</span><br><span class="line">deleteEmployee: (employeeId) =&gt; &#123;</span><br><span class="line">    return postAxios(&#x27;/employee/delete/&#x27; + employeeId)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>assets 目录<br>assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|assets</span><br><span class="line">|-- icons</span><br><span class="line">|-- images</span><br><span class="line">|   |-- background-color.png</span><br><span class="line">|   |-- upload-header.png</span><br><span class="line">|-- styles</span><br><span class="line">3) components 目录</span><br><span class="line">此目录应按照组件进行目录划分，目录命名为 KebabCase，组件命名规则也为 KebabCase</span><br><span class="line"></span><br><span class="line">|components</span><br><span class="line">|-- error-log</span><br><span class="line">|   |-- index.vue</span><br><span class="line">|   |-- index.less</span><br><span class="line">|-- markdown-editor</span><br><span class="line">|   |-- index.vue</span><br><span class="line">|   |-- index.js</span><br><span class="line">|-- kebab-case</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>constants 目录<br>此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件(<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/vue-enum">https://www.npmjs.com/package/vue-enum</a>)</li>
</ol>
<p>目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|constants</span><br><span class="line">|-- index.js</span><br><span class="line">|-- role.js</span><br><span class="line">|-- employee.js</span><br></pre></td></tr></table></figure>

<p>例子： employee.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">export const EMPLOYEE_STATUS = &#123;</span><br><span class="line">  NORMAL: &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    desc: &#x27;正常&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  DISABLED: &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    desc: &#x27;禁用&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  DELETED: &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    desc: &#x27;已删除&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const EMPLOYEE_ACCOUNT_TYPE = &#123;</span><br><span class="line">  QQ: &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    desc: &#x27;QQ登录&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  WECHAT: &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    desc: &#x27;微信登录&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  DINGDING: &#123;</span><br><span class="line">    value: 3,</span><br><span class="line">    desc: &#x27;钉钉登录&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  USERNAME: &#123;</span><br><span class="line">    value: 4,</span><br><span class="line">    desc: &#x27;用户名密码登录&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  EMPLOYEE_STATUS,</span><br><span class="line">  EMPLOYEE_ACCOUNT_TYPE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>router 与 store 目录<br>这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。</li>
</ol>
<p>router 尽量按照 views 中的结构保持一致</p>
<p>store 按照业务进行拆分不同的 js 文件</p>
<ol start="6">
<li>views 目录</li>
</ol>
<ul>
<li>命名要与后端、router、api 等保持一致</li>
<li>components 中组件要使用 PascalCase 规则</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|-- views                            视图目录</span><br><span class="line">|   |-- role                             role模块名</span><br><span class="line">|   |   |-- role-list.vue                    role列表页面</span><br><span class="line">|   |   |-- role-add.vue                     role新建页面</span><br><span class="line">|   |   |-- role-update.vue                  role更新页面</span><br><span class="line">|   |   |-- index.less                      role模块样式</span><br><span class="line">|   |   |-- components                      role模块通用组件文件夹</span><br><span class="line">|   |   |   |-- role-header.vue                        role头部组件</span><br><span class="line">|   |   |   |-- role-modal.vue                         role弹出框组件</span><br><span class="line">|   |-- employee                         employee模块</span><br><span class="line">|   |-- behavior-log                      行为日志log模块</span><br><span class="line">|   |-- code-generator                    代码生成器模块</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-注释说明"><a href="#2-2-4-注释说明" class="headerlink" title="2.2.4 注释说明"></a>2.2.4 注释说明</h4><p>整理必须加注释的地方</p>
<ul>
<li>公共组件使用说明</li>
<li>api 目录的接口 js 文件必须加注释</li>
<li>store 中的 state, mutation, action 等必须加注释</li>
<li>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释</li>
<li>vue 文件的 methods，每个 method 必须添加注释</li>
<li>vue 文件的 data, 非常见单词要加注释</li>
</ul>
<h4 id="2-2-5-其他"><a href="#2-2-5-其他" class="headerlink" title="2.2.5 其他"></a>2.2.5 其他</h4><ol>
<li><p>尽量不要手动操作 DOM<br>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。</p>
</li>
<li><p>删除无用代码<br>因使用了 git&#x2F;svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%8E%8210%E9%81%93%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%8E%8210%E9%81%93%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">前端大厂10道经典面试题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 11:13:08 / 修改时间：11:20:17" itemprop="dateCreated datePublished" datetime="2022-12-16T11:13:08+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">前端算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、写一个-js-函数，实现对一个数字每-3-位加一个逗号，如输入-100000，-输出-100-000（不考虑负数，小数）—百度前端面试题"><a href="#1、写一个-js-函数，实现对一个数字每-3-位加一个逗号，如输入-100000，-输出-100-000（不考虑负数，小数）—百度前端面试题" class="headerlink" title="1、写一个 js 函数，实现对一个数字每 3 位加一个逗号，如输入 100000， 输出 100,000（不考虑负数，小数）—百度前端面试题"></a>1、写一个 js 函数，实现对一个数字每 3 位加一个逗号，如输入 100000， 输出 100,000（不考虑负数，小数）—百度前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let arr = []</span><br><span class="line">function main(num) &#123;</span><br><span class="line">    if (num === null) return</span><br><span class="line">    let n = parseInt(num).toString()</span><br><span class="line">    s(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function s(num) &#123;</span><br><span class="line">    if (num.length &gt; 3) &#123;</span><br><span class="line">        arr[arr.length] = num.slice(-3)</span><br><span class="line">        s(num.slice(0, -3))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        arr[arr.length] = num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main(123456789)</span><br><span class="line"></span><br><span class="line">console.log(arr.reverse().join(&quot;,&quot;))</span><br></pre></td></tr></table></figure>

<p>解题思路<br>本题是 js 实现 number.toLocaleString()方法，面试题做了简化不考虑负数小数，此题主要是考数据类型及字符串操作，答案不唯一。</p>
<p>按现实思路解题，现实中添加千位分隔符是从后到前，每 3 位添加逗号，所以这里输入数据转换成字符串后，利用 slice 方法的输入负数参数从后取的特点，从后取三位数字保存在数组中，并把取剩后的数据递归重复取值，直到数据不足 3 位，把剩下一起存入数组中。</p>
<p>这时数组中按顺序保存从后到前的分割数据。实例中数组是[‘789’,’456’,’123’]。通过 reverse 方法倒序输出，并通过 join 方法添加逗号。</p>
<h2 id="2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题"><a href="#2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题" class="headerlink" title="2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题"></a>2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">//     let n = s.length;</span><br><span class="line">//     let set = new Set();</span><br><span class="line">//     let ans = 0, i = 0, j = 0;</span><br><span class="line">//     while (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">//         if (!set.has(s[j])) &#123;</span><br><span class="line">//             set.add(s[j++]);</span><br><span class="line">//             ans = Math.max(ans, j - i);</span><br><span class="line">//         &#125; else &#123;</span><br><span class="line">//             set.delete(s[i++]);</span><br><span class="line">//         &#125;</span><br><span class="line">//     &#125;</span><br><span class="line">//     return ans;</span><br><span class="line">// &#125;;</span><br><span class="line"></span><br><span class="line">//时间复杂度：O(2n) = O(n)O(2n)=O(n)，在最糟糕的情况下，每个字符将被 ii 和 jj 访问两次。</span><br><span class="line">//空间复杂度：O(min(m, n))O(min(m,n))，与之前的方法相同。滑动窗口法需要 O(k)O(k) 的空间，其中 kk 表示 Set 的大小。而Set的大小取决于字符串 nn 的大小以及字符集/字母 mm 的大小。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function StrLen(str) &#123;</span><br><span class="line">    let result = 1    //最终要返回的结果的初始值</span><br><span class="line">    let norepeatStr = &#x27;&#x27; //用于存放无重复字符串</span><br><span class="line">    let len = str.length</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        //charAt()获取的是字符串索引对应的具体字符</span><br><span class="line">        let specStr = str.charAt(i)</span><br><span class="line">        //indexOf()查找的是某个字符第一次出现并返回这个索引值，若没有这个字符，返回-1</span><br><span class="line">        let index = norepeatStr.indexOf(specStr)</span><br><span class="line">        if (index === -1) &#123;</span><br><span class="line">            //将遍历得到的字符（未重复）拼接在norepeatStr后面</span><br><span class="line">            norepeatStr = norepeatStr + specStr</span><br><span class="line">            result = result &lt; norepeatStr.length ? norepeatStr.length : result</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //若遇到重复的字符，那么将已出现在norepeatStr里的字符删除，并将新的（重复的添加到末尾）</span><br><span class="line">            norepeatStr = norepeatStr.substr(index + 1) + specStr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(StrLen(abbbcbd))</span><br></pre></td></tr></table></figure>

<p>解题思路<br>这题的要点就是无重复字符的理解。首先字符串内字符位置是固定的，我们要采用顺序循环的方式解题，然后就是理解无重复字符的含义，把当前字符串分割，每个小分割内不能出现重复的字符。也就是说分割的字符串是不会互相叠加重复的，每当该段分割的下一个字符与该段分割内字符相同，当即重新开始分割字符。</p>
<p>所以解题时需要一个存储当前分割片段的对象，用来比较下一个字符。并取这个分割片段的长度，与每个分割片段的最大长度比较即可。本题主要考的是题面的理解，以及字符串方法的运用，需要熟练地运用才能快速解题。</p>
<h2 id="3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题"><a href="#3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题" class="headerlink" title="3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题"></a>3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">    let a = &#x27;333333333333333333333333333&#x27;</span><br><span class="line">    let b = &#x27;9999999999999999999&#x27;</span><br><span class="line">    let n1 = a.length</span><br><span class="line">    let n2 = b.length</span><br><span class="line">    for (let i = 0; i &lt; Math.max(n1, n2) - Math.min(n1, n2); i ++) &#123;</span><br><span class="line">        if (n1 &gt; n2) b = &#x27;0&#x27; + b</span><br><span class="line">        if (n2 &gt; n1) a = &#x27;0&#x27; + a</span><br><span class="line">    &#125;</span><br><span class="line">    a = a.split(&#x27;&#x27;).reverse()</span><br><span class="line">    b = b.split(&#x27;&#x27;).reverse()</span><br><span class="line">    //split()基于指定的分隔符将一个字符串分割成多个子字符串并将结果放在一个数组中</span><br><span class="line">    //reverse()反转数组项的顺序（加法计算顺序）</span><br><span class="line">    //现在a，b数组中存储着相同个数的大数字的逆顺序拆解</span><br><span class="line"></span><br><span class="line">    let n = Math.max(n1, n2)</span><br><span class="line">    let result = Array.apply(this, Array(n)).map((item, i) =&gt; &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;)</span><br><span class="line">    //生成一个长度为n的每个元素都为0的数组（用来保存最终结果）</span><br><span class="line"></span><br><span class="line">    for (let k = 0; k &lt; n; k ++) &#123;</span><br><span class="line">        let temp = parseInt(a[k]) + parseInt(b[k])</span><br><span class="line">        if (temp &gt; 9) &#123;</span><br><span class="line">            result[k] += temp - 10</span><br><span class="line">            result[k+1] = 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result[k] += temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把ab数组中的数字相加减，注意进位</span><br><span class="line"></span><br><span class="line">    console.log(result.reverse().join(&#x27;&#x27;).toString())</span><br><span class="line">    //将数组项基于指定的分隔符以字符串输出</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>解题思路<br>首先了解超出存储范围的大数字概念，每种数据类型可存储数据量都是存在范围的</p>
<p>数字类型的范围：</p>
<p>Number.MAX_VALUE &#x3D; 1.7976931348623157e+308</p>
<p>Number.MIN_VALUE &#x3D; 5e-324</p>
<p>整数类型的范围：-2-53-253</p>
<p>当超出这个范围，为了避免数据丢失，就要采用其他手段进行运算。在参考答案中，运用数组的方式解决这个问题。首先两个大整数要存储在数组中，要先保证位数对齐，我们比较字符串长度把低位数的大整数字符串前面添加相应的 0 占位， 并逆排序。创建一个新的数组保存运算结果，将两个大整数按从后到前的顺序进行相加减，这里注意进位。把得到的数组反转到正常顺序即可。</p>
<h2 id="4、任意数组的全排列组合—阿里巴巴前端面试题"><a href="#4、任意数组的全排列组合—阿里巴巴前端面试题" class="headerlink" title="4、任意数组的全排列组合—阿里巴巴前端面试题"></a>4、任意数组的全排列组合—阿里巴巴前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;hello&#x27;,&#x27;world&#x27;];</span><br><span class="line">var count = 1;</span><br><span class="line">function getStr(a)&#123;</span><br><span class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">		// indexOf 是es6数组的方法,如果不存在返回-1，存在返回下标</span><br><span class="line">		if(a.indexOf(arr[i])&lt;0)&#123;</span><br><span class="line"></span><br><span class="line">			//数组 a 中不存在 arr[i],将arr[i]添加到数组末尾</span><br><span class="line">			a.push(arr[i]);</span><br><span class="line"></span><br><span class="line">			if(a.length==arr.length)&#123;</span><br><span class="line">				console.log(count++ + &#x27;: &#x27; +a.join(&quot;&quot;));</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				//结束一次for循环  进行了4次递归 getStr([&#x27;foo&#x27;]) getStr([&#x27;bar&#x27;]) getStr([&#x27;hello&#x27;]) getStr([&#x27;world&#x27;])</span><br><span class="line">				getStr(a);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			//一定从数组 a 中删除arr[i],进行下次循环，如果不删除就只能获得一种结果了</span><br><span class="line">			a.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">getStr([])</span><br></pre></td></tr></table></figure>

<p>解题思路<br>本题做法不唯一，这里采用了把多项数组逐步两两相乘的方式，第一次先取二维数组前两项组合，把组合的结果在与第三项组合以此类推。这种递归做法简单易懂，把复杂的多项问题简化成两项问题的逐渐递增。</p>
<h2 id="5、公司最近新研发了一种产品，共生产了-n-件。有-m-个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题"><a href="#5、公司最近新研发了一种产品，共生产了-n-件。有-m-个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题" class="headerlink" title="5、公司最近新研发了一种产品，共生产了 n 件。有 m 个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题"></a>5、公司最近新研发了一种产品，共生产了 n 件。有 m 个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let n = 3</span><br><span class="line">let m = 4</span><br><span class="line">let arr = [2, 8, 10, 7]</span><br><span class="line">let key = 0, max = 0</span><br><span class="line">arr = arr.sort( (a, b) =&gt; &#123;</span><br><span class="line">    return a - b   //升序</span><br><span class="line">&#125;)</span><br><span class="line">if (n &lt; m) &#123;</span><br><span class="line">    arr = arr.slice(m - n)  //截取出价高的人</span><br><span class="line">&#125;</span><br><span class="line">for (let i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    if (max &lt; arr[i] * (arr.length - i)) &#123;</span><br><span class="line">        max = arr[i] * (arr.length - i)</span><br><span class="line">        key = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(key)</span><br></pre></td></tr></table></figure>

<p>解题思路<br>本题是京东的业务演变题，首先要理清思路。本题中，固定出价，以及出价低于产品的顾客会被拒绝购买是解题核心。</p>
<p>条件中已知产品总个数，顾客出价。这里有个小陷阱，会出现 N&lt;M 供不应求的情况，要特殊考虑。依据题目，我们首先需要对顾客出价排序，这里按升序排列。当供不应求出现时，我们截取出价高的顾客。然后把每个顾客的出价当做最终售价循环，得出最大化利润下的售价。</p>
<h2 id="6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题"><a href="#6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题" class="headerlink" title="6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题"></a>6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let s = &#x27;asdaaaaaad&#x27;</span><br><span class="line">let count = 0, char = &#x27;&#x27;         //count出现次数 char字符</span><br><span class="line">let arr = []        // 储存去重后字符</span><br><span class="line">function foo(str) &#123;         // 去重</span><br><span class="line">    return r = str.split(&quot;&quot;).filter(function (element, index, self) &#123;</span><br><span class="line">        return self.indexOf(element) === index     // 输出第一次出现的字符</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr = foo(s)</span><br><span class="line">for (let i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    let n = (s.split(arr[i])).length - 1           //出现次数</span><br><span class="line">    if (count &lt; n) &#123;</span><br><span class="line">        count = n</span><br><span class="line">        char = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;count:&quot; + count + &quot;,char:&quot; + char)</span><br></pre></td></tr></table></figure>

<p>解题思路<br>计算出全部字符出现次数，并留下最大的。首先利用 filter()与 indexOf()的方法连用字符串去重，再将得到的作为索引，利用 split()分割字符串，得到字符出现次数，比较得出结果。</p>
<h2 id="7、”123456789876543212345678987654321…”的第-n-位是什么？—小米面试题"><a href="#7、”123456789876543212345678987654321…”的第-n-位是什么？—小米面试题" class="headerlink" title="7、”123456789876543212345678987654321…”的第 n 位是什么？—小米面试题"></a>7、”123456789876543212345678987654321…”的第 n 位是什么？—小米面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let k = &quot;1234567898765432&quot;  //最小循环节</span><br><span class="line">function getNum(n) &#123;</span><br><span class="line">    console.log(k.charAt(n % k.length - 1))</span><br><span class="line">&#125;</span><br><span class="line">getNum(20)</span><br></pre></td></tr></table></figure>

<p>解题思路<br>这道题的答案不唯一，这里可以利用数学中最小循环节的概念解题，找到最小循环节后，利用余数查找第 n 位数字。</p>
<h2 id="8、请编写一个-JavaScript-函数-parseQueryString，它的用途是把-URL-参数解析为一个对象—淘宝面试题"><a href="#8、请编写一个-JavaScript-函数-parseQueryString，它的用途是把-URL-参数解析为一个对象—淘宝面试题" class="headerlink" title="8、请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象—淘宝面试题"></a>8、请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象—淘宝面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function parseQueryString(url) &#123;</span><br><span class="line">  var pos = url.indexOf(&quot;?&quot;)</span><br><span class="line">  var obj = &#123;&#125;</span><br><span class="line">  if (pos != -1) &#123;</span><br><span class="line">    var urlString=url.slice(pos+1)</span><br><span class="line">    var urlArr = urlString.split(&quot;&amp;&quot;)</span><br><span class="line">    var keyValue = []</span><br><span class="line">    for (var i = 0; i &lt; urlArr.length; i++) &#123;</span><br><span class="line">      keyValue = urlArr[i].split(&quot;=&quot;)</span><br><span class="line">      obj[keyValue[0]]=keyValue[1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解题思路<br>淘宝这道题是很常用的场景题，这里需要处理好分段次序，首先把？分离，然后按&amp;分割最后按&#x3D;分割，主要考察字符串的函数运用以及对象的创建。</p>
<h2 id="9、如果给定的字符串是回文，返回-true，反之，返回-false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是-palindrome-回文-。—网易前端面试题"><a href="#9、如果给定的字符串是回文，返回-true，反之，返回-false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是-palindrome-回文-。—网易前端面试题" class="headerlink" title="9、如果给定的字符串是回文，返回 true，反之，返回 false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是 palindrome(回文)。—网易前端面试题"></a>9、如果给定的字符串是回文，返回 true，反之，返回 false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是 palindrome(回文)。—网易前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function palindrome(str) &#123;</span><br><span class="line">    let str1 = str.replace(/[^0-9a-zA-Z]/g,&quot;&quot;).toLowerCase()  // 去掉标点符号，转化成小写，比较参数一</span><br><span class="line">    let str2 = str1.split(&quot;&quot;).reverse().join(&quot;&quot;)   // 翻转字符串，比较参数二</span><br><span class="line">    if (str1 === str2) &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125; else return false</span><br><span class="line">&#125;</span><br><span class="line">console.log(palindrome(&quot;aBc,./1d42--==EFG0 00 h0 &#x27;;00gfE&#x27; ./.24d 1cBA&quot;)) // 输出结果：true</span><br></pre></td></tr></table></figure>

<p>解题思路<br>去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。</p>
<h2 id="10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题"><a href="#10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题" class="headerlink" title="10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题"></a>10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function titleCase(str) &#123;</span><br><span class="line">    let aStr = str.toLowerCase().split(&quot; &quot;)   // 转小写，分割成字符串数组</span><br><span class="line">    for (let i = 0; i &lt; aStr.length; i ++) &#123;</span><br><span class="line">        aStr[i] = aStr[i][0].toUpperCase() + aStr[i].slice(1) // 重新组合字符串元素</span><br><span class="line">    &#125;</span><br><span class="line">    let oString = aStr.join(&quot; &quot;)  //转成字符串</span><br><span class="line">    return oString</span><br><span class="line">&#125;</span><br><span class="line">console.log(titleCase(&quot;I&#x27;m a title Case&quot;)) // 输出结果为 I&#x27;m A Title Case</span><br></pre></td></tr></table></figure>

<p>解题思路<br>字符串转化成小写；<br>分割成字符串数组；<br>新组合字符串元素&#x3D;首字母转大写+其余小写。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/guochangxindeGH/LeetCode/tree/master/Algorithms/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB">代码 github 地址</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Chen"
      src="/images/portal.jpg">
  <p class="site-author-name" itemprop="name">Bruce Chen</p>
  <div class="site-description" itemprop="description">It's better to burn out than to fade away.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1440429303&auto=1&height=66"></iframe>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jschentt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jschentt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jschentt@gmail.com" title="E-Mail → mailto:jschentt@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/BruceCh56742806" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;BruceCh56742806" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/jinsheng.chen.5439" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;jinsheng.chen.5439" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
  </div>





      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
