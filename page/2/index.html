<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="It&#39;s better to burn out than to fade away.">
<meta property="og:type" content="website">
<meta property="og:title" content="Bruce Chen&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Bruce Chen&#39;s Blog">
<meta property="og:description" content="It&#39;s better to burn out than to fade away.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Bruce Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Bruce Chen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
    <a target="_blank" rel="noopener" href="https://github.com/jschentt" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bruce Chen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">quick notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">35</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/HTTP%E5%B8%B8%E7%94%A8%E7%9A%8414%E7%A7%8D%E7%8A%B6%E6%80%81%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/HTTP%E5%B8%B8%E7%94%A8%E7%9A%8414%E7%A7%8D%E7%8A%B6%E6%80%81%E7%A0%81/" class="post-title-link" itemprop="url">HTTP常用的14种状态码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:42:56" itemprop="dateCreated datePublished" datetime="2022-10-24T16:42:56+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误。</p>
<p>状态码的类别：</p>
<table>
<thead>
<tr>
<th>~</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h2 id="2XX——表明请求被正常处理了"><a href="#2XX——表明请求被正常处理了" class="headerlink" title="2XX——表明请求被正常处理了"></a>2XX——表明请求被正常处理了</h2><p>1、200 OK：<strong>请求已正常处理</strong>。</p>
<p>2、204 No Content：<strong>请求处理成功，但没有任何资源可以返回给客户端</strong>，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
<p>3、206 Partial Content：<strong>是对资源某一部分的请求</strong>，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<h2 id="3XX——表明浏览器需要执行某些特殊的处理以正确处理请求"><a href="#3XX——表明浏览器需要执行某些特殊的处理以正确处理请求" class="headerlink" title="3XX——表明浏览器需要执行某些特殊的处理以正确处理请求"></a>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</h2><p>4、301 Moved Permanently：<strong>资源的 uri 已更新，你也更新下你的书签引用吧。永久性重定向</strong>，请求的资源已经被分配了新的 URI，以后应使用资源现在所指的 URI。</p>
<p>5、302 Found：<strong>资源的 URI 已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向</strong>。和 301 相似，但 302 代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。</p>
<p>6、303 See Other：<strong>资源的 URI 已更新，你是否能临时按新的 URI 访问</strong>。该状态码表示由于请求对应的资源存在着另一个 URL，应使用 GET 方法定向获取请求的资源。303 状态码和 302 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。</p>
<p>当 301,302,303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。</p>
<p>7、304 Not Modified：<strong>资源已找到，但未符合条件请求</strong>。该状态码表示客户端发送附带条件的请求时（采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回 304.。</p>
<p>8、307 Temporary Redirect：<strong>临时重定向</strong>。与 302 有相同的含义。</p>
<h2 id="4XX——表明客户端是发生错误的原因所在。"><a href="#4XX——表明客户端是发生错误的原因所在。" class="headerlink" title="4XX——表明客户端是发生错误的原因所在。"></a>4XX——表明客户端是发生错误的原因所在。</h2><p>9、400 Bad Request：<strong>服务器端无法理解客户端发送的请求</strong>，请求报文中可能存在语法错误。</p>
<p>10、401 Unauthorized：<strong>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证，DIGEST 认证）的认证信息。</strong></p>
<p>11、403 Forbidden：<strong>不允许访问那个资源</strong>。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权 IP 等）</p>
<p>12、404 Not Found：<strong>服务器上没有请求的资源</strong>。路径错误等。</p>
<h2 id="5XX——服务器本身发生错误"><a href="#5XX——服务器本身发生错误" class="headerlink" title="5XX——服务器本身发生错误"></a>5XX——服务器本身发生错误</h2><p>13、500 Internal Server Error：<strong>貌似内部资源出故障了</strong>。该状态码表明服务器端在执行请求时发生了错误。也有可能是 web 应用存在 bug 或某些临时故障。</p>
<p>14、503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/XSS-%E5%92%8C-CSRF-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%8C%BA%E5%88%AB%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/XSS-%E5%92%8C-CSRF-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%8C%BA%E5%88%AB%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">XSS 和 CSRF 详解及区别解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:42:34" itemprop="dateCreated datePublished" datetime="2022-10-24T16:42:34+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>cross site script，跨站脚本攻击（关键字：脚本）。为了与 css 冲突取名为 xss！<br>XSS 攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在 url 中输入、在评论框中输入），向你的页面注入脚本（可能是 js、hmtl 代码块等）。<br>恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p>
<p><strong>最后导致的结果可能是</strong>：</p>
<ul>
<li>盗用 Cookie</li>
<li>破坏页面的正常结构，插入广告等恶意内容</li>
<li>D-doss 攻击</li>
</ul>
<h3 id="XSS-的攻击方式"><a href="#XSS-的攻击方式" class="headerlink" title="XSS 的攻击方式"></a>XSS 的攻击方式</h3><p>1、反射型（临时，非持久型）<br>发出请求时，XSS 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，所以叫反射型 XSS。<br>客户端提交，服务器解析后响应，到客户端再执行</p>
<p>2、存储型（持久型）<br>存储型 XSS 和反射型 XSS 的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等）。<br>比如先通过对一个攻击 url 进行编码(来绕过 xss filter)，然后提交该 web server(存储在 web server 中), 然后用户在浏览页面时，如果点击该 url，就会触发一个 XSS 攻击。当然用户点击该 url 时，也可能会触发一个 CSRF(Cross site request forgery)攻击。</p>
<p>以上两种服务端参与</p>
<p>3、DOM based XSS<br>基于 DOM 的 XSS，也就是 web server 不参与，仅仅涉及到浏览器的 XSS。比如根据用户的输入来动态构造一个 DOM 节点，如果没有对用户的输入进行过滤，那么也就导致 XSS 攻击的产生。过滤可以考虑采用 esapi4js。</p>
<p><strong>预防</strong>：<br>简而言之：转义+过滤（<strong>输入过滤，输出转义</strong>）</p>
<p>1、在 cookie 中设置了 HttpOnly 属性，那么通过 js 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击</p>
<p><strong>过滤</strong>：</p>
<p>移除用户输入的和事件相关的属性。如 onerror 可以自动触发攻击，还有 onclick 等。（总而言是，过滤掉一些不安全的内容）</p>
<p>移除用户输入的 Style 节点、Script 节点、Iframe 节点。（尤其是 Script 节点，它可是支持跨域的呀，一定要移除）。</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>用户登录 A 网站产生 cookie，此时再访问 B（危险），B 要求访问 A，并发起一个请求</p>
<p>此时，B（危险）就利用用户的权限在 A 进行了操作。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1627906-03e225c2ab2d1d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="image"></p>
<p>如何预防：<br>1、Token 验证：（用的最多）</p>
<p>（1）服务器发送给客户端一个 token；</p>
<p>（2）客户端提交的表单中带着这个 token。</p>
<p>（3）如果这个 token 不合法，那么服务器拒绝这个请求。</p>
<p>2、隐藏令牌：<br>把 token 隐藏在 http 的 head 头中。</p>
<p>响应头</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1627906-d8c2ef9a7b0c95c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1130/format/webp" alt="image"></p>
<p>请求头</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1627906-59051e4a8516f9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/998/format/webp" alt="image"></p>
<p>ps：方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p>
<h2 id="CSRF-和-XSS-的区别"><a href="#CSRF-和-XSS-的区别" class="headerlink" title="CSRF 和 XSS 的区别"></a>CSRF 和 XSS 的区别</h2><p>面试官还可能喜欢问二者的区别。</p>
<p>区别一：</p>
<p>CSRF：需要用户先登录网站 A，获取 cookie。<br>XSS：不需要登录。<br>区别二：（原理的区别）</p>
<p>CSRF：是利用网站 A 本身的漏洞，去请求网站 A 的 api。<br>XSS：是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E9%87%8D%E7%BB%98%EF%BC%88redraw%E6%88%96repaint%EF%BC%89%E4%B8%8E%E9%87%8D%E6%8E%92%EF%BC%88reflow%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/%E9%87%8D%E7%BB%98%EF%BC%88redraw%E6%88%96repaint%EF%BC%89%E4%B8%8E%E9%87%8D%E6%8E%92%EF%BC%88reflow%EF%BC%89/" class="post-title-link" itemprop="url">重绘（redraw或repaint）与重排（reflow）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:41:53" itemprop="dateCreated datePublished" datetime="2022-10-24T16:41:53+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>浏览器运行机制图：</p>
<p><img src="https://images2017.cnblogs.com/blog/1209205/201710/1209205-20171010151938027-587388886.png" alt="image"></p>
<h2 id="浏览器的运行机制：layout：布局；"><a href="#浏览器的运行机制：layout：布局；" class="headerlink" title="浏览器的运行机制：layout：布局；"></a>浏览器的运行机制：layout：布局；</h2><p>1、<strong>构建 DOM 树（parse）</strong>：渲染引擎解析 HTML 文档，首先将标签转换成 DOM 树中的 DOM node（包括 js 生成的标签）生成内容树（Content Tree&#x2F;DOM Tree）；</p>
<p>2、<strong>构建渲染树（construct）</strong>：解析对应的 CSS 样式文件信息（包括 js 生成的样式和外部 css 文件），而这些文件信息以及 HTML 中可见的指令（如<code>&lt;b&gt;&lt;/b&gt;</code>），构建渲染树（Rendering Tree&#x2F;Frame Tree）；</p>
<p>3、<strong>布局渲染树（reflow&#x2F;layout）</strong>：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；</p>
<p>4、<strong>绘制渲染树（paint&#x2F;repaint）</strong>：遍历渲染树，使用 UI 后端层来绘制每个节点。</p>
<h2 id="重绘（repaint-或-redraw）："><a href="#重绘（repaint-或-redraw）：" class="headerlink" title="重绘（repaint 或 redraw）："></a>重绘（repaint 或 redraw）：</h2><p>当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。</p>
<p>重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>
<p>触发重绘的条件：改变元素外观属性。如：color，background-color 等。</p>
<p>注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。</p>
<h2 id="重排（重构-x2F-回流-x2F-reflow）："><a href="#重排（重构-x2F-回流-x2F-reflow）：" class="headerlink" title="重排（重构&#x2F;回流&#x2F;reflow）："></a>重排（重构&#x2F;回流&#x2F;reflow）：</h2><p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>
<p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，<strong>重排必定会引发重绘，但重绘不一定会引发重排</strong>。</p>
<p>触发重排的条件：任何页面布局和几何属性的改变都会触发重排，比如：</p>
<p>1、页面渲染初始化；(无法避免)</p>
<p>2、添加或删除可见的 DOM 元素；</p>
<p>3、元素位置的改变，或者使用动画；</p>
<p>4、元素尺寸的改变——大小，外边距，边框；</p>
<p>5、浏览器窗口尺寸的变化（resize 事件发生时）；</p>
<p>6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；</p>
<p>7、读取某些元素属性：（offsetLeft&#x2F;Top&#x2F;Height&#x2F;Width,　 clientTop&#x2F;Left&#x2F;Width&#x2F;Height,　 scrollTop&#x2F;Left&#x2F;Width&#x2F;Height,　 width&#x2F;height,　 getComputedStyle(),　 currentStyle(IE)　)</p>
<h2 id="重绘重排的代价：耗时，导致浏览器卡慢。"><a href="#重绘重排的代价：耗时，导致浏览器卡慢。" class="headerlink" title="重绘重排的代价：耗时，导致浏览器卡慢。"></a>重绘重排的代价：耗时，导致浏览器卡慢。</h2><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>1、浏览器自己的优化：浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
<p>2、我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的 DOM 和样式的修改。并减少对 style 样式的请求。</p>
<p>（1）直接改变元素的 className</p>
<p>（2）display：none；先设置元素为 display：none；然后进行页面布局等操作；设置完成后将元素设置为 display：block；这样的话就只引发两次重绘和重排；</p>
<p>（3）不要经常访问浏览器的 flush 队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流；</p>
<p>（4）使用 cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</p>
<p>（5）将需要多次重排的元素，position 属性设为 absolute 或 fixed，元素脱离了文档流，它的变化不会影响到其他元素；</p>
<p>（6）如果需要创建多个 DOM 节点，可以使用 DocumentFragment 创建完后一次性的加入 document；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">var li = document.createElement(&#x27;li&#x27;);</span><br><span class="line">li.innerHTML = &#x27;apple&#x27;;</span><br><span class="line">fragment.appendChild(li);</span><br><span class="line"></span><br><span class="line">var li = document.createElement(&#x27;li&#x27;);</span><br><span class="line">li.innerHTML = &#x27;watermelon&#x27;;</span><br><span class="line">fragment.appendChild(li);</span><br><span class="line"></span><br><span class="line">document.getElementById(&#x27;fruit&#x27;).appendChild(fragment);</span><br></pre></td></tr></table></figure>

<p>（7）尽量不要使用 table 布局。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E8%AF%A6%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84Event-Loop%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/%E8%AF%A6%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84Event-Loop%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">详解JavaScript中的Event Loop（事件循环）机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:41:28" itemprop="dateCreated datePublished" datetime="2022-10-24T16:41:28+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://pic4.zhimg.com/v2-0b35a3df0b2e2712839ce551062e6d7f_1440w.jpg?source=172ae18b" alt="image"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，javascript 从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。</p>
<p>单线程意味着，javascript 代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p>
<p>而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 I&#x2F;O 事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p>
<p>单线程是必要的，也是 javascript 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 dom 操作。试想一下 如果 javascript 是多线程的，那么当两个线程同时对 dom 进行一项操作，例如一个向其添加事件，而另一个删除了这个 dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p>
<p>当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了 javascript 的效率，因此开发出了 web worker 技术。这项技术号称让 javascript 成为一门多线程语言。</p>
<p>然而，使用 web worker 技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行 I&#x2F;O 操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了 javascript 语言的单线程本质。</p>
<p>可以预见，未来的 javascript 也会一直是一门单线程的语言。</p>
<p>话说回来，前面提到 javascript 的另一个特点是“非阻塞”，那么 javascript 引擎到底是如何实现的这一点呢？答案就是今天这篇文章的主角——event loop（事件循环）。</p>
<p>注：虽然 nodejs 中也存在与传统浏览器环境下的相似的事件循环。然而两者间却有着诸多不同，故把两者分开，单独解释。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="浏览器环境下-js-引擎的事件循环机制"><a href="#浏览器环境下-js-引擎的事件循环机制" class="headerlink" title="浏览器环境下 js 引擎的事件循环机制"></a>浏览器环境下 js 引擎的事件循环机制</h3><h4 id="1-执行栈与事件队列"><a href="#1-执行栈与事件队列" class="headerlink" title="1.执行栈与事件队列"></a>1.执行栈与事件队列</h4><p>当 javascript 代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p>
<p>我们知道，当我们调用一个方法的时候，js 会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的 this 对象。 而当一系列方法被依次调用的时候，因为 js 是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p>
<p>当一个脚本第一次执行的时候，js 引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么 js 会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js 会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p>
<p>下面这个图片非常直观的展示了这个过程，其中的 global 就是初次运行脚本时向执行栈中加入的代码：</p>
<p><img src="https://pic2.zhimg.com/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.webp" alt="image"></p>
<p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p>
<p>以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送 ajax 请求数据）执行后会如何呢？前文提过，js 的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。</p>
<p>js 引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js 会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p>
<p>这里还有一张图来展示这个过程：</p>
<p><img src="https://pic4.zhimg.com/80/v2-da078fa3eadf3db4bf455904ae06f84b_720w.jpg" alt="image"></p>
<p>图中的 stack 表示我们所说的执行栈，web apis 则是代表一些异步事件，而 callback queue 即事件队列。</p>
<h4 id="2-macro-task-与-micro-task"><a href="#2-macro-task-与-micro-task" class="headerlink" title="2.macro task 与 micro task"></a>2.macro task 与 micro task</h4><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p>
<p>以下事件属于宏任务：</p>
<ul>
<li><code>setInterval()</code></li>
<li><code>setTimeout()</code></li>
</ul>
<p>以下事件属于微任务</p>
<ul>
<li><code>new Promise()</code></li>
<li><code>new MutaionObserver()</code></li>
</ul>
<p>前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回调加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p>
<p>我们只需记住<strong>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p>
<p>这样就能解释下面这段代码的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    resolve(3)</span><br><span class="line">&#125;).then(function(val)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="node-环境下的事件循环机制"><a href="#node-环境下的事件循环机制" class="headerlink" title="node 环境下的事件循环机制"></a>node 环境下的事件循环机制</h3><h4 id="1-与浏览器环境有何不同"><a href="#1-与浏览器环境有何不同" class="headerlink" title="1.与浏览器环境有何不同?"></a>1.与浏览器环境有何不同?</h4><p>在 node 中，事件循环表现出的状态与浏览器中大致相同。不同的是 node 中有一套自己的模型。node 中事件循环的实现是依靠的 libuv 引擎。我们知道 node 选择 chrome v8 引擎作为 js 解释器，v8 引擎将 js 代码分析后去调用对应的 node api，而这些 api 最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 node 中的事件循环存在于 libuv 引擎中。</p>
<h4 id="2-事件循环模型"><a href="#2-事件循环模型" class="headerlink" title="2.事件循环模型"></a>2.事件循环模型</h4><p>下面是一个 libuv 引擎中的事件循环的模型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure>

<p>注：模型中的每一个方块代表事件循环的一个阶段</p>
<p>这个模型是 node 官网上的一篇文章中给出的，我下面的解释也都来源于这篇文章。我会在文末把文章地址贴出来，有兴趣的朋友可以亲自看看原文。</p>
<h3 id="3-事件循环各阶段详解"><a href="#3-事件循环各阶段详解" class="headerlink" title="3.事件循环各阶段详解"></a>3.事件循环各阶段详解</h3><p>从上面这个模型中，我们可以大致分析出 node 中的事件循环的顺序：</p>
<p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I&#x2F;O 事件回调阶段(I&#x2F;O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段…</p>
<p>以上各阶段的名称是根据我个人理解的翻译，为了避免错误和歧义，下面解释的时候会用英文来表示这些阶段。</p>
<p>这些阶段大致的功能如下：</p>
<ul>
<li>timers: 这个阶段执行定时器队列中的回调如 <code>setTimeout()</code> 和 <code>setInterval()</code>。</li>
<li>I&#x2F;O callbacks: 这个阶段执行几乎所有的回调。但是不包括 close 事件，定时器和<code>setImmediate()</code>的回调。</li>
<li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li>
<li>poll: 等待新的 I&#x2F;O 事件，node 在一些特殊情况下会阻塞在这里。</li>
<li>check: <code>setImmediate()</code>的回调会在这个阶段执行。</li>
<li>close callbacks: 例如<code>socket.on(&#39;close&#39;, ...)</code>这种 close 事件的回调。<br>下面我们来按照代码第一次进入 libuv 引擎后的顺序来详细解说这些阶段：</li>
</ul>
<h4 id="poll-阶段"><a href="#poll-阶段" class="headerlink" title="poll 阶段"></a>poll 阶段</h4><p>当个 v8 引擎将 js 代码解析后传入 libuv 引擎后，循环首先进入 poll 阶段。poll 阶段的执行逻辑如下： 先查看 poll queue 中是否有事件，有任务就按先进先出的顺序依次执行回调。 当 queue 为空时，会检查是否有 setImmediate()的 callback，如果有就进入 check 阶段执行这些 callback。但同时也会检查是否有到期的 timer，如果有，就把这些到期的 timer 的 callback 按照调用顺序放到 timer queue 中，之后循环会进入 timer 阶段执行 queue 中的 callback。 这两者的顺序是不固定的，受到代码运行的环境的影响。如果两者的 queue 都是空的，那么 loop 会在 poll 阶段停留，直到有一个 i&#x2F;o 事件返回，循环会进入 i&#x2F;o callback 阶段并立即执行这个事件的 callback。</p>
<p>值得注意的是，poll 阶段在执行 poll queue 中的回调时实际上不会无限的执行下去。有两种情况 poll 阶段会终止执行 poll queue 中的下一个回调：1.所有回调执行完毕。2.执行数超过了 node 的限制。</p>
<h4 id="check-阶段"><a href="#check-阶段" class="headerlink" title="check 阶段"></a>check 阶段</h4><p>check 阶段专门用来执行 setImmediate()方法的回调，当 poll 阶段进入空闲状态，并且 setImmediate queue 中有 callback 时，事件循环进入这个阶段。</p>
<h4 id="close-阶段"><a href="#close-阶段" class="headerlink" title="close 阶段"></a>close 阶段</h4><p>当一个 socket 连接或者一个 handle 被突然关闭时（例如调用了 socket.destroy()方法），close 事件会被发送到这个阶段执行回调。否则事件会用 process.nextTick（）方法发送出去。</p>
<h4 id="timer-阶段"><a href="#timer-阶段" class="headerlink" title="timer 阶段"></a>timer 阶段</h4><p>这个阶段以先进先出的方式执行所有到期的 timer 加入 timer 队列里的 callback，一个 timer callback 指得是一个通过 setTimeout 或者 setInterval 函数设置的回调函数。</p>
<h4 id="I-x2F-O-callback-阶段"><a href="#I-x2F-O-callback-阶段" class="headerlink" title="I&#x2F;O callback 阶段"></a>I&#x2F;O callback 阶段</h4><p>如上文所言，这个阶段主要执行大部分 I&#x2F;O 事件的回调，包括一些为操作系统执行的回调。例如一个 TCP 连接生错误时，系统需要执行回调来获得这个错误的报告。</p>
<h3 id="4-process-nextTick-setTimeout-与-setImmediate-的区别与使用场景"><a href="#4-process-nextTick-setTimeout-与-setImmediate-的区别与使用场景" class="headerlink" title="4.process.nextTick,setTimeout 与 setImmediate 的区别与使用场景"></a>4.process.nextTick,setTimeout 与 setImmediate 的区别与使用场景</h3><p>在 node 中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval 与之相同）与 setImmediate</p>
<p>这三者间存在着一些非常不同的区别：</p>
<h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h4><p>尽管没有提及，但是实际上 node 中存在着一个特殊的队列，即 nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，但是这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查 nextTick queue 中是否有任务，如果有，那么会先清空这个队列。与执行 poll queue 中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用 process.nextTick()方法会导致 node 进入一个死循环。。直到内存泄漏。</p>
<p>那么何时使用这个方法比较合适呢？下面有一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer(() =&gt; &#123;&#125;).listen(8080);</span><br><span class="line"></span><br><span class="line">server.on(&#x27;listening&#x27;, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子中当，当 listen 方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发 listening 事件并执行其回调。然而，这时候<code>on(&#39;listening)</code>还没有将 callback 设置好，自然没有 callback 可以执行。为了避免出现这种情况，node 会在 listen 事件中使用<code>process.nextTick()</code>方法，确保事件在回调函数绑定后被触发。</p>
<h4 id="setTimeout-和-setImmediate"><a href="#setTimeout-和-setImmediate" class="headerlink" title="setTimeout()和 setImmediate()"></a>setTimeout()和 setImmediate()</h4><p>在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。</p>
<p><code>setTimeout()</code>方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node 会在可以执行 timer 回调的第一时间去执行你所设定的任务。</p>
<p><code>setImmediate()</code>方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即 poll 阶段之后。有趣的是，这个名字的意义和之前提到过的<code>process.nextTick()</code>方法才是最匹配的。node 的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的 node 程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。</p>
<p><code>setTimeout()</code>和不设置时间间隔的<code>setImmediate()</code>表现上及其相似。猜猜下面这段代码的结果是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timeout&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;immediate&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>实际上，答案是不一定。没错，就连 node 的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个 I&#x2F;O 事件的回调中。下面这段代码的顺序永远是固定的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;timeout&#x27;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;immediate&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>答案永远是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>

<p>因为在 I&#x2F;O 事件的回调中，<code>setImmediate</code>方法的回调永远在 timer 的回调前执行。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>javascript 的事件循环是这门语言中非常重要且基础的概念。清楚的了解了事件循环的执行顺序和每一个阶段的特点，可以使我们对一段异步代码的执行顺序有一个清晰的认识，从而减少代码运行的不确定性。合理的使用各种延迟事件的方法，有助于代码更好的按照其优先级去执行。这篇文章期望用最易理解的方式和语言准确描述事件循环这个复杂过程，但由于作者自己水平有限，文章中难免出现疏漏。如果您发现了文章中的一些问题，欢迎在留言中提出，我会尽量回复这些评论，把错误更正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E5%8E%9F%E7%90%86%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E5%8E%9F%E7%90%86%E7%AF%87/" class="post-title-link" itemprop="url">Tree-Shaking性能优化实践 - 原理篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:41:00" itemprop="dateCreated datePublished" datetime="2022-10-24T16:41:00+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-什么是-Tree-shaking"><a href="#一-什么是-Tree-shaking" class="headerlink" title="一. 什么是 Tree-shaking"></a>一. 什么是 Tree-shaking</h2><p><img src="https://pic4.zhimg.com/80/v2-8b075867835d03be30338855aaea126b_720w.jpg" alt="image"></p>
<p>先来看一下 Tree-shaking 原始的本意</p>
<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP.FK1leNlztl80mibxa-uu8QHaEM?w=322&h=183&c=7&o=5&dpr=1.25&pid=1.7" alt="image"></p>
<p>上图形象的解释了 Tree-shaking 的本意，本文所说的前端中的 tree-shaking 可以理解为通过工具”摇”我们的 JS 文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p>
<p><img src="https://pic4.zhimg.com/80/v2-d415073437f0ce3c2349717b4e13a9fb_720w.jpg" alt="image"></p>
<p>Tree-shaking 较早由 Rich_Harris 的 rollup 实现，后来，webpack2 也增加了 tree-shaking 的功能。其实在更早，google closure compiler 也做过类似的事情。三个工具的效果和使用各不相同，使用方法可以通过官网文档去了解，三者的效果对比，后文会详细介绍。</p>
<h2 id="二-tree-shaking-的原理"><a href="#二-tree-shaking-的原理" class="headerlink" title="二. tree-shaking 的原理"></a>二. tree-shaking 的原理</h2><p><img src="https://pic2.zhimg.com/80/v2-ff9d9ea4b5313771471c2796a6741d91_720w.jpg" alt="image"></p>
<p>Tree-shaking 的本质是消除无用的 js 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 DCE（dead code elimination）。</p>
<p>Tree-shaking 是 DCE 的一种新的实现，Javascript 同传统的编程语言不同的是，javascript 绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对 javascript 来说更有意义。</p>
<p>Tree-shaking 和传统的 DCE 的方法又不太一样，传统的 DCE 消灭不可能执行的代码，而 Tree-shaking 更关注于消除没有用到的代码。下面详细介绍一下 DCE 和 Tree-shaking。</p>
<h3 id="（1）先来看一下-DCE-消除大法"><a href="#（1）先来看一下-DCE-消除大法" class="headerlink" title="（1）先来看一下 DCE 消除大法"></a>（1）先来看一下 DCE 消除大法</h3><p><img src="https://pic3.zhimg.com/80/v2-18129c123fbaebba27ac786c856abfd2_720w.jpg" alt="image"></p>
<p>Dead Code 一般具有以下几个特征</p>
<ul>
<li>代码不会被执行，不可到达</li>
<li>代码执行的结果不会被用到</li>
<li>代码只会影响死变量（只写不读）</li>
</ul>
<p>下面红框标示的代码就属于死码，满足以上特征</p>
<p><img src="https://pic4.zhimg.com/80/v2-e7063073c59b49906e6aa9cefac1281f_720w.jpg" alt="image"></p>
<p>传统编译型的语言中，都是由编译器将 Dead Code 从 AST（抽象语法树）中删除，那 javascript 中是由谁做 DCE 呢？</p>
<p>首先肯定不是浏览器做 DCE，因为当我们的代码送到浏览器，那还谈什么消除无法执行的代码来优化呢，所以肯定是送到浏览器之前的步骤进行优化。</p>
<p>其实也不是上面提到的三个工具，rollup，webpack，cc 做的，而是著名的代码压缩优化工具 uglify，uglify 完成了 javascript 的 DCE，下面通过一个实验来验证一下。</p>
<blockquote>
<p>以下所有的示例代码都能在 github 中找到</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack">https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack</a></p>
<p><strong>分别用 rollup 和 webpack 将图 4 中的代码进行打包</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-87a1817d027f5e000b80ada132e11b33_720w.jpg" alt="image"></p>
<p>中间是 rollup 打包的结果，右边是 webpack 打包的结果</p>
<p>可以发现，rollup 将无用的代码 foo 函数和 unused 函数消除了，但是仍然保留了不会执行到的代码，而 webpack 完整的保留了所有的无用代码和不会执行到的代码。</p>
<p><strong>分别用 rollup + uglify 和 webpack + uglify 将图 4 中的代码进行打包</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-cd8913573d1862aa0799b28ca84e048d_720w.jpg" alt="image"></p>
<p>中间是配置文件，右侧是结果</p>
<p>可以看到右侧最终打包结果中都去除了无法执行到的代码，结果符合我们的预期。</p>
<h3 id="2-再来看一下-Tree-shaking-消除大法"><a href="#2-再来看一下-Tree-shaking-消除大法" class="headerlink" title="(2) 再来看一下 Tree-shaking 消除大法"></a>(2) 再来看一下 Tree-shaking 消除大法</h3><p>前面提到了 tree-shaking 更关注于无用模块的消除，消除那些引用了但并没有被使用的模块。</p>
<p>先思考一个问题，为什么 tree-shaking 是最近几年流行起来了？而前端模块化概念已经有很多年历史了，其实 tree-shaking 的消除原理是依赖于 ES6 的模块特性。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e56729aa4ee3efa34ebbfe8ec02d9583_720w.jpg" alt="image"></p>
<p>ES6 module 特点：</p>
<ul>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串常量</li>
<li>import binding 是 immutable 的<br>ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础。</li>
</ul>
<p>所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6 之前的模块化，比如我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。</p>
<p>这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。</p>
<p>我们还是通过例子来详细了解一下</p>
<p>面向过程编程函数和面向对象编程是 javascript 最常用的编程模式和代码组织方式，从这两个方面来实验：</p>
<ul>
<li>函数消除实验</li>
<li>类消除实验</li>
</ul>
<p><strong>先看下函数消除实验</strong></p>
<p>utils 中 get 方法没有被使用到，我们期望的是 get 方法最终被消除。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0ab75edb6d645a574fca0f7cfed6eaf2_720w.jpg" alt="image"></p>
<p>注意，uglify 目前不会跨文件去做 DCE，所以上面这种情况，uglify 是不能优化的。</p>
<p><strong>先看看 rollup 的打包结果</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-c6212005445fa180a103ff7c8b26c234_720w.jpg" alt="image"></p>
<p>完全符合预期，最终结果中没有 get 方法</p>
<p><strong>再看看 webpack 的结果</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-19c1884f6deaeab166036df5dc7af121_720w.jpg" alt="image"></p>
<p>也符合预期，最终结果中没有 get 方法</p>
<p>可以看到 rollup 打包的结果比 webpack 更优化</p>
<blockquote>
<p>函数消除实验中，rollup 和 webpack 都通过，符合预期</p>
</blockquote>
<p><strong>再来看下类消除实验</strong></p>
<p>增加了对 menu.js 的引用，但其实代码中并没有用到 menu 的任何方法和变量，所以我们的期望是，最终代码中 menu.js 里的内容被消除</p>
<p><img src="https://pic2.zhimg.com/80/v2-eb682abb2e27a72ce2ab031ad94cdc09_720w.jpg" alt="image"></p>
<p><img src="https://pic1.zhimg.com/80/v2-7aab6ee6e04416d34a30208d3a8125ac_720w.jpg" alt="image"></p>
<p>rollup 打包结果</p>
<p><img src="https://pic2.zhimg.com/80/v2-559f5911b18e201ca7407277ecdd3911_720w.jpg" alt="image"></p>
<p>包中竟然包含了 menu.js 的全部代码</p>
<p><strong>webpack 打包结果</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-444d7415f84a373778702747372d2370_720w.jpg" alt="image"></p>
<p>包中竟然也包含了 menu.js 的全部代码</p>
<blockquote>
<p>类消除实验中，rollup，webpack 全军覆没，都没有达到预期</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-b796932873b2f5b217a1fdd00212c376_720w.jpg" alt="image"></p>
<p>这跟我们想象的完全不一样啊？为什么呢？无用的类不能消除，这还能叫做 tree-shaking 吗？我当时一度怀疑自己的 demo 有问题，后来各种网上搜索，才明白 demo 没有错。</p>
<p>下面摘取了 rollup 核心贡献者的的一些回答：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a04ef2070513c5a4d90966c8e80df0ca_720w.jpg" alt="image"></p>
<ul>
<li>rollup 只处理函数和顶层的 import&#x2F;export 变量，不能把没用到的类的方法消除掉</li>
<li>javascript 动态语言的特性使得静态分析比较困难</li>
<li>图 7 下部分的代码就是副作用的一个例子，如果静态分析的时候删除 run 或者 jump，程序运行时就可能报错，那就本末倒置了，我们的目的是优化，肯定不能影响执行</li>
</ul>
<p>再举个例子说明下为什么不能消除 menu.js，比如下面这个场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Menu.prototype.show = function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.unique = function() &#123;</span><br><span class="line">    // 将 array 中的重复元素去除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Menu;</span><br></pre></td></tr></table></figure>

<p>如果删除 menu.js，那 Array 的扩展也会被删除，就会影响功能。那也许你会问，难道 rollup，webpack 不能区分是定义 Menu 的 proptotype 还是定义 Array 的 proptotype 吗？当然如果代码写成上面这种形式是可以区分的，如果我写成这样呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Menu.prototype.show = function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = &#x27;Arr&#x27; + &#x27;ay&#x27;</span><br><span class="line">var b</span><br><span class="line">if(a == &#x27;Array&#x27;) &#123;</span><br><span class="line">    b = Array</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    b = Menu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.prototype.unique = function() &#123;</span><br><span class="line">    // 将 array 中的重复元素去除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Menu;</span><br></pre></td></tr></table></figure>

<p>这种代码，静态分析是分析不了的，就算能静态分析代码，想要正确完全的分析也比较困难。</p>
<p>更多关于副作用的讨论，可以看这个</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rollup/rollup/issues/349">https://github.com/rollup/rollup/issues/349</a></p>
<p><img src="https://pic3.zhimg.com/80/v2-0417d8e35bd25ec6fb184b2c378d65e6_720w.jpg" alt="image"></p>
<blockquote>
<p>tree-shaking 对函数效果较好</p>
</blockquote>
<p>函数的副作用相对较少，顶层函数相对来说更容易分析，加上 babel 默认都是”use strict”严格模式，减少顶层函数的动态访问的方式，也更容易分析</p>
<p>我们开始说的三个工具，rollup 和 webpack 表现不理想，那 closure compiler 又如何呢？</p>
<p>将示例中的代码用 cc 打包后得到的结果如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-91bc794a87ea5c35f2981ebb55b9b44b_720w.jpg" alt="image"></p>
<p>天啊，这不就是我们要的结果吗？完美消除所有无用代码的结果，输出的结果非常性感</p>
<blockquote>
<p>closure compiler， tree-shaking 的结果完美！</p>
</blockquote>
<p>可是不能高兴得太早，能得到这么完美结果是需要条件的，那就是 cc 的侵入式约束规范。必须在代码里添加这样的代码，看红线框标示的</p>
<p><img src="https://pic2.zhimg.com/80/v2-6346776acfa7b0c50a331afd22d260ad_720w.jpg" alt="image"></p>
<p>google 定义一整套注解规范 Annotating JavaScript for the Closure Compiler，想更多了解的，可以去看下官网。</p>
<p>侵入式这个就让人很不爽，google Closure Compiler 是 java 写的，和我们基于 node 的各种构建库不可能兼容（不过目前好像已经有 nodejs 版 Closure Compiler），Closure Compiler 使用起来也比较麻烦，所以虽然效果很赞，但比较难以应用到项目中，迁移成本较大。</p>
<p><strong>说了这么多，总结一下：</strong></p>
<p>三大工具的 tree-shaking 对于无用代码，无用模块的消除，都是有限的，有条件的。closure compiler 是最好的，但与我们日常的基于 node 的开发流很难兼容。</p>
<p><img src="https://pic1.zhimg.com/80/v2-f74aabd0006d76162998f04ac09c87ac_720w.jpg" alt="image"></p>
<p>tree-shaking 对 web 意义重大，是一个极致优化的理想世界，是前端进化的又一个终极理想。</p>
<p>理想是美好的，但目前还处在发展阶段，还比较困难，有各个方面的，甚至有目前看来无法解</p>
<p>决的问题，但还是应该相信新技术能带来更好的前端世界。</p>
<p>但优化是一种态度，不因小而不为，不因艰而不攻。</p>
<h2 id="三、Tree-Shaking-的工作原理"><a href="#三、Tree-Shaking-的工作原理" class="headerlink" title="三、Tree-Shaking 的工作原理"></a>三、Tree-Shaking 的工作原理</h2><p>Tree-shaking （树摇）最早是由 Rollup 实现，是一种采用删除不需要的额外代码的方式优化代码体积的技术，webpack2 借鉴了这个特性也增加了 tree-shaking 的功能。</p>
<p>tree-shaking 只能在静态 modules 下工作，在 ES6 之前我们使用 CommonJS 规范引入模块，具体采用 require()的方式动态引入模块，这个特性可以通过判断条件解决按需加载的优化问题，具体如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let module;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(condition) &#123;</span><br><span class="line"></span><br><span class="line">    module =  require(&quot;HellowModule&quot;) ;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">    module = requitre(&#x27;BeyModule&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 CommonJS 规范无法确定在实际运行前需要或者不需要某些模块，所以 CommonJS 不适合 tree-shaking 机制。</p>
<p>在 JavaScript 模块化方案中，只有 ES6 的模块方案：import()引入模块的方式采用静态导入，可以采用一次导入所有的依赖包再根据条件判断的方式，获取不需要的包，然后执行删除操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import hello from &quot;Hellow&quot;;</span><br><span class="line"></span><br><span class="line">import bey from &quot;Bey&quot;;</span><br><span class="line"></span><br><span class="line">import other from &quot;Other&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(condition) &#123;</span><br><span class="line"></span><br><span class="line">    // hello</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // bey</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Tree-shaking 的实现原理</strong></p>
<p><strong>利用 ES6 模块特性：</strong></p>
<ul>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串常量</li>
<li>import binding 是 immutable 的，引入的模块不能再进行修改</li>
</ul>
<p><strong>代码删除：</strong></p>
<ul>
<li>uglify：判断程序流，判断变量是否被使用和引用，进而删除代码</li>
</ul>
<p>实现原理可以简单的概况：</p>
<ol>
<li>ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块</li>
<li>静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E8%AF%95%E7%8E%A9NodeJS%E5%A4%9A%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/%E8%AF%95%E7%8E%A9NodeJS%E5%A4%9A%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">试玩NodeJS多进程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:39:40" itemprop="dateCreated datePublished" datetime="2022-10-24T16:39:40+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>NodeJS 的 JavaScript 运行在单个进程的单个线程上，一个 JavaScript 执行进程只能利用一个 CPU 核心，而如今大多数 CPU 均为多核 CPU，为了充分利用 CPU 资源，Node 提供了 child_process 和 cluster 模块来实现多进程以及进程管理。本文将根据 Master-Worker 模式，搭建一个简单的服务器集群来充分利用多核 CPU 资源，探索进程间通信、负载均衡、进程重启等知识。</p>
<p>下图是 Master-Worker 模式，进程分为 master 进程和 worker 进程，master 进程负责调度或管理 worker 进程，worker 进程则负责具体的业务处理。在服务器层面，worker 可以是一个服务进程，负责处理来自客户端的请求，多个 worker 便相当于多个服务器，从而构成一个服务器集群。master 则是负责创建 worker，将来自客户端的请求分配到各个服务器上去处理，并监控 worker 的运行状态以及进行管理等操作。</p>
<p><img src="https://img-blog.csdn.net/20180411162337266?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p>本文将从 child_process 模块开始，熟悉该模块的基本用法。后面再继续进入 cluster 模块的学习。本文所用的代码示例可以从该仓库中找到–【<a target="_blank" rel="noopener" href="https://github.com/hongchh/nodejs-demo/tree/master/multi-process">multi-process</a>】。</p>
<h2 id="一、child-process"><a href="#一、child-process" class="headerlink" title="一、child_process"></a>一、child_process</h2><h3 id="1-1、Hello-world"><a href="#1-1、Hello-world" class="headerlink" title="1.1、Hello world"></a>1.1、Hello world</h3><p>child_process 模块提供了 spawn()、exec()、execFile()、fork()这 4 个方法用于创建子进程，本文将使用 fork()方法来创建子进程，fork()方法只需指定要执行的 JavaScript 文件模块，即可创建 Node 的子进程。下面是简单的 HelloWorld 示例，master 进程根据 CPU 数量创建出相应数量的 worker 进程，worker 进程中利用进程 ID 来标记自己。</p>
<p>以下是 master 进程代码，文件名为 master.js。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class="line">const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">  childProcess.fork(&#x27;./worker.js&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#x27;Master: Hello world.&#x27;)</span><br></pre></td></tr></table></figure>

<p>以下是 worker 进程的代码，文件名为 worker.js。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;Worker-&#x27; + process.pid + &#x27;: Hello world.&#x27;)</span><br></pre></td></tr></table></figure>

<p>执行<code>node master.js</code>，得到如下结果，master 创建 4 个 worker 后输出 HelloWorld 信息，每个 worker 也分别输出自己的 HelloWorld 信息。</p>
<p><img src="https://img-blog.csdn.net/201804111624180?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<h3 id="1-2、父子进程间的通信"><a href="#1-2、父子进程间的通信" class="headerlink" title="1.2、父子进程间的通信"></a>1.2、父子进程间的通信</h3><p>创建 worker 之后，接下来实现 master 和 worker 之间的通信。Node 父子进程之间可以通过<code>on(&#39;message&#39;)</code>和<code>send()</code>来实现通信，<code>on(&#39;message&#39;)</code>其实是监听 message 事件，当该进程收到其他进程发送的消息时，便会触发 message 事件。<code>send()</code>方法则是用于向其他进程发送信息。master 进程中调用<code>child_process</code>的<code>fork()</code>方法后会得到一个子进程的实例，通过这个实例可以监听来自子进程的消息或者向子进程发送消息。worker 进程则通过 process 对象接口监听来自父进程的消息或者向父进程发送消息。</p>
<p><img src="https://img-blog.csdn.net/20180411162446285?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p>下面是简单示例，master 创建 worker 之后，向 worker 发送信息，worker 在收到 master 的信息后将信息输出，并回复 master。master 收到回复后输出信息。</p>
<p><strong>master.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class="line">const worker = childProcess.fork(&#x27;./worker.js&#x27;)</span><br><span class="line"></span><br><span class="line">worker.send(&#x27;Hello world.&#x27;)</span><br><span class="line"></span><br><span class="line">worker.on(&#x27;message&#x27;, (msg) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;[Master] Received message from worker: &#x27; + msg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>worker.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#x27;message&#x27;, (msg) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;[Worker] Received message from master: &#x27; + msg)</span><br><span class="line">  process.send(&#x27;Hi master.&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行<code>node master.js</code>，结果如下，master 和 worker 可以正常通信。</p>
<p><img src="https://img-blog.csdn.net/20180411162506991?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<h3 id="1-3、Master-分发请求给-Worker-处理"><a href="#1-3、Master-分发请求给-Worker-处理" class="headerlink" title="1.3、Master 分发请求给 Worker 处理"></a>1.3、Master 分发请求给 Worker 处理</h3><p>进程通信时使用到的<code>send()</code>方法，除了发送普通的对象之外，还可以用于发送句柄。句柄是一种引用，可以用来标识资源，例如通过句柄可以标识一个 socket 对象、一个 server 对象等。利用句柄传递，可以实现请求的分发。master 进程创建一个 TCP 服务器监听特定端口，收到客户端的请求后，会得到一个 socket 对象，通过这个 socket 对象可以跟客户端进行通信从而处理客户端的请求。master 进程可以通过句柄传递将该 socket 对象发送给 worker 进程，让 worker 进程去处理请求。该模式的结构图如下，在 master 上还可以通过特定的算法实现负载均衡，将客户端的请求均衡地分发给 worker 去处理。</p>
<p><img src="https://img-blog.csdn.net/20180411162530412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p>下面是一个简单示例。master 创建 TCP 服务器并监听 8080 端口，收到请求后将请求分发给 worker 处理。worker 收到 master 发来的 socket 以后，通过 socket 对客户端进行响应。为方便看到请求的处理情况，worker 给出的响应内容会说明该请求是被哪个 worker 处理。</p>
<p><strong>master.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class="line">const net = require(&#x27;net&#x27;)</span><br><span class="line">const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class="line"></span><br><span class="line">// 创建工作进程</span><br><span class="line">let workers = []</span><br><span class="line">let cur = 0</span><br><span class="line">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">  workers.push(childProcess.fork(&#x27;./worker.js&#x27;))</span><br><span class="line">  console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建TCP服务器</span><br><span class="line">const server = net.createServer()</span><br><span class="line"></span><br><span class="line">// 服务器收到请求后分发给工作进程去处理</span><br><span class="line">// 通过轮转方式实现工作进程的负载均衡</span><br><span class="line">server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class="line">  workers[cur].send(&#x27;socket&#x27;, socket)</span><br><span class="line">  cur = Number.parseInt((cur + 1) % cpuNum)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;TCP server: 127.0.0.1:8080&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>worker.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#x27;message&#x27;, (msg, socket) =&gt; &#123;</span><br><span class="line">  if (msg === &#x27;socket&#x27; &amp;&amp; socket) &#123;</span><br><span class="line">    // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class="line">    &#125;, 10)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了访问 TCP 服务器进行实验，这里需要写一个简单的 TCP 客户端，代码如下。该客户端会创建 10 个 TCP 连接，得到服务器响应之后将响应的内容进行输出。</p>
<p><strong>tcp_client.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&#x27;net&#x27;)</span><br><span class="line">const maxConnectCount = 10</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; maxConnectCount; ++i) &#123;</span><br><span class="line">  net.createConnection(&#123;</span><br><span class="line">    port: 8080,</span><br><span class="line">    host: &#x27;127.0.0.1&#x27;</span><br><span class="line">  &#125;).on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class="line">    console.log(data.toString())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先执行<code>node master.js</code>启动服务器，然后执行 node tcp_client.js 启动客户端。得到的结果如下，10 个请求被分发到不同服务器上进行处理，并且可以看到 master 中的轮转分发请求起到了作用，实现了简单的负载均衡。</p>
<p><img src="https://img-blog.csdn.net/20180411162556605?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<h3 id="1-4、Worker-监听同一个端口"><a href="#1-4、Worker-监听同一个端口" class="headerlink" title="1.4、Worker 监听同一个端口"></a>1.4、Worker 监听同一个端口</h3><p>前面说过，<code>send()</code>方法可以传递句柄，通过传递句柄，我们除了发送 socket 对象之外，还可以直接发送一个 server 对象。我们可以在 master 进程中创建一个 TCP 服务器，将服务器对象直接发送给 worker 进程，让 worker 去监听端口并处理请求。这样的话，master 和 worker 进程都会监听相同端口，当客户端发起请求时，请求可能被 master 接收，也可能被 worker 接收。而 master 不负责处理业务，如果请求被 master 接收到，由于 master 上没有处理业务的逻辑，请求将无法得到处理。因此可以实现为如下图所示的模式，master 将 TCP 服务器发送给 worker 使得所有 worker 监听同一个端口以后，master 关闭对端口的监听。这样便只有 worker 在监听同一端口，请求将会都被 worker 进行处理，与 master 无关。</p>
<p><img src="https://img-blog.csdn.net/20180411162619227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p>这种模式下，多个进程监听相同端口，当网络请求到来时，会进行抢占式调度，只有一个进程会抢到连接然后进行服务。因此，可以确保每个请求都会被特定的 worker 处理，而不是一个请求同时被多个 worker 处理。但由于是抢占式的调度，不能够保证每个 worker 的负载均衡。可能由于处理不同业务时 CPU 和 IO 繁忙度的不同导致进程抢到的请求数量不同，形成负载不均衡的情况。</p>
<p>下面是简单示例。</p>
<p><strong>master.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class="line">const net = require(&#x27;net&#x27;)</span><br><span class="line">const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class="line"></span><br><span class="line">// 创建工作进程</span><br><span class="line">let workers = []</span><br><span class="line">let cur = 0</span><br><span class="line">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">  workers.push(childProcess.fork(&#x27;./worker.js&#x27;))</span><br><span class="line">  console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建TCP服务器</span><br><span class="line">const server = net.createServer()</span><br><span class="line"></span><br><span class="line">server.listen(8080, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;TCP server: 127.0.0.1:8080&#x27;)</span><br><span class="line">  // 监听端口后将服务器句柄发送给工作进程</span><br><span class="line">  for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">    workers[i].send(&#x27;server&#x27;, server)</span><br><span class="line">  &#125;</span><br><span class="line">  // 关闭主线程服务器的端口监听</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>worker.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#x27;message&#x27;, (msg, server) =&gt; &#123;</span><br><span class="line">  if (msg === &#x27;server&#x27; &amp;&amp; server) &#123;</span><br><span class="line">    server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class="line">      // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class="line">      &#125;, 10)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>继续使用之前的<code>tcp_client</code>来进行实验，先执行<code>node master.js</code>启动服务器，然后执行<code>node tcp_client.js</code>启动客户端。得到结果如下，请求可以被不同的 worker 进程处理，但由于 worker 进程是抢占式地为请求进行服务，所以不一定能实现每个 worker 的负载均衡。</p>
<p><img src="https://img-blog.csdn.net/20180411162643242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<h3 id="1-5、进程重启"><a href="#1-5、进程重启" class="headerlink" title="1.5、进程重启"></a>1.5、进程重启</h3><p>worker 进程可能因为某些异常情况而退出，为了提高集群的稳定性，master 进程需要监听子进程的存活状态，当子进程退出之后，master 进程要及时重启新的子进程。在 Node 中，子进程退出时，会在父进程中触发 exit 事件。父进程只需通过监听该事件便可知道子进程是否退出，并在退出的时候做出相应的处理。下面是在之前的监听同一端口模式下，增加了进程重启功能。进程重启时，master 进程需要重新传递 server 对象给新的 worker 进程，因此不能关闭 master 进程上的 server，否则在进程重启时 server 被关闭，得到的句柄将为空，无法正常传递。master 进程的 server 不关闭，会导致 master 进程也监听端口，会有部分请求被 master 进程接收，为了让着部分请求能够得到处理，可以在 master 进程添加处理业务的代码。由于 master 也参与了业务处理，业务处理进程的数量增加 1 个，所以 worker 进程可以少创建 1 个。这也就是下面简单示例中的做法。</p>
<p>这种实现方式使得 master 既进行进程管理又参与了业务处理，如果要保持 master 只负责进程管理而不涉及业务处理，可以采取另外一种实现方式：master 接收到请求后，按照前面 1.3 节的做法将请求转发给 worker 进行处理，这样 master 将继续只负责对 worker 进程的管理。</p>
<p><strong>master.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class="line">const net = require(&#x27;net&#x27;)</span><br><span class="line">const cpuNum = require(&#x27;os&#x27;).cpus().length - 1</span><br><span class="line"></span><br><span class="line">// 创建工作进程</span><br><span class="line">let workers = []</span><br><span class="line">let cur = 0</span><br><span class="line">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">  workers.push(childProcess.fork(&#x27;./worker.js&#x27;))</span><br><span class="line">  console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建TCP服务器</span><br><span class="line">const server = net.createServer()</span><br><span class="line"></span><br><span class="line">// 由于master进程也会监听端口。因此需要对请求做出处理</span><br><span class="line">server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class="line">  // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    socket.end(&#x27;Request handled by master&#x27;)</span><br><span class="line">  &#125;, 10)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;TCP server: 127.0.0.1:8080&#x27;)</span><br><span class="line">  // 监听端口后将服务器句柄发送给工作进程</span><br><span class="line">  for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">    workers[i].send(&#x27;server&#x27;, server)</span><br><span class="line">    // 工作进程退出后重启</span><br><span class="line">    workers[i].on(&#x27;exit&#x27;, ((i) =&gt; &#123;</span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        console.log(&#x27;Worker-&#x27; + workers[i].pid + &#x27; exited&#x27;)</span><br><span class="line">        workers[i] = childProcess.fork(&#x27;./worker.js&#x27;)</span><br><span class="line">        console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class="line">        workers[i].send(&#x27;server&#x27;, server)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(i))</span><br><span class="line">  &#125;</span><br><span class="line">  // 关闭主线程服务器的端口监听</span><br><span class="line">  // server.close()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>worker.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#x27;message&#x27;, (msg, server) =&gt; &#123;</span><br><span class="line">  if (msg === &#x27;server&#x27; &amp;&amp; server) &#123;</span><br><span class="line">    server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class="line">      // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class="line">      &#125;, 10)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行<code>node master.js</code>启动服务器后，可以通过任务管理器直接杀掉进程来模拟进程异常退出。可以看到 worker 进程退出后，master 能够发现并及时创建新的 worker 进程。任务管理器中的 Node 进程数量恢复原样。</p>
<p><img src="https://img-blog.csdn.net/20180411162706612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p><img src="https://img-blog.csdn.net/20180411162725201?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p>执行<code>node tcp_client.js</code>启动客户端，客户端发出的连接请求被处理的情况如下，同样地，由于监听同一端口，进程之间采取抢占式服务，不一定保障负载均衡。</p>
<p><img src="https://img-blog.csdn.net/20180411162742587?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<h3 id="1-6、处理-HTTP-服务"><a href="#1-6、处理-HTTP-服务" class="headerlink" title="1.6、处理 HTTP 服务"></a>1.6、处理 HTTP 服务</h3><p>前面的示例所使用的是 TCP 服务器，如果要处理 HTTP 请求，需要使用 HTTP 服务器。而 HTTP 其实是基于 TCP 的，发送 HTTP 请求的时候同样也会发起 TCP 连接。只需要对前面的 TCP 服务器进行一点小改动便可以支持 HTTP 了。在进程中新增 HTTP 服务器，当 TCP 服务器收到请求时，把请求提交给 HTTP 服务器处理即可。下面是 worker 进程的改动示例。</p>
<p><strong>worker.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line">const httpServer = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;)</span><br><span class="line">    res.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class="line">  &#125;, 10)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.on(&#x27;message&#x27;, (msg, server) =&gt; &#123;</span><br><span class="line">  if (msg === &#x27;server&#x27; &amp;&amp; server) &#123;</span><br><span class="line">    server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class="line">      // 提交给HTTP服务器处理</span><br><span class="line">      httpServer.emit(&#x27;connection&#x27;, socket)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180411162802792?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<h2 id="二、cluster"><a href="#二、cluster" class="headerlink" title="二、cluster"></a>二、cluster</h2><p>前面简单描述了使用 child_process 实现单机 Node 集群的做法，需要处理挺多的细节。Node 提供了 cluster 模块，该模块提供了更完善的 API，除了能够实现多进程充分利用 CPU 资源以外，还能够帮助我们更好地进行进程管理和处理进程的健壮性问题。下面是简单示例，if 条件语句判断当前进程是 master 还是 worker，master 进程会执行 if 语句块包含的代码，而 worker 进程则执行 else 语句块包含的代码。master 进程中，利用 cluster 模块创建了与 CPU 数量相应的 worker 进程，并通过监听 cluster 的 online 事件来判断 worker 的创建成功。在 worker 进程退出后，会触发 master 进程中 cluster 模块上的 exit 事件，通过监听该事件可以了解 worker 进程的退出情况并及时 fork 新的 worker。最后，worker 进程中只需创建服务器监听端口，对客户端请求做出处理即可。（这里设置相同端口 8080 之后，所有 worker 都将监听同一个端口）</p>
<p><strong>server.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const cluster = require(&#x27;cluster&#x27;)</span><br><span class="line"></span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">    cluster.fork()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建进程完成后输出提示信息</span><br><span class="line">  cluster.on(&#x27;online&#x27;, (worker) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Create worker-&#x27; + worker.process.pid)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 子进程退出后重启</span><br><span class="line">  cluster.on(&#x27;exit&#x27;, (worker, code, signal) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;[Master] worker &#x27; + worker.process.pid + &#x27; died with code: &#x27; + code + &#x27;, and signal: &#x27; + signal)</span><br><span class="line">    cluster.fork()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  const net = require(&#x27;net&#x27;)</span><br><span class="line">  net.createServer().on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class="line">    // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class="line">    &#125;, 10)</span><br><span class="line">  &#125;).listen(8080)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>node server.js</code>启动服务器，继续按照之前的做法，利用任务管理器杀死进程，可以看到在进程被杀后 master 能够及时启动新的 worker。</p>
<p><img src="https://img-blog.csdn.net/2018041116282181?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p>继续运行 tcp_client，可以看到服务器能够正常处理请求。</p>
<p><img src="https://img-blog.csdn.net/20180411162838577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>利用<code>child_process</code>和<code>cluster</code>模块能够很好地实现<code>Master-Worker</code>模式多进程架构，实现单机服务器集群，充分利用了多核 CPU 资源。通过进程通信能够实现进程管理、重启以及负载均衡，从而提高集群的稳定性和健壮性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/merge%E5%92%8Crebase%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/merge%E5%92%8Crebase%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">merge和rebase的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:39:14" itemprop="dateCreated datePublished" datetime="2022-10-24T16:39:14+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我从用 git 就一直用 rebase，但是新的公司需要用 merge 命令，我不是很明白，所以查了一些资料，总结了下面的内容，如果有什么不妥的地方，还望指正，我一定虚心学习。</p>
<h2 id="merge-和-rebase"><a href="#merge-和-rebase" class="headerlink" title="merge 和 rebase"></a>merge 和 rebase</h2><p>标题上的两个命令：merge 和 rebase 都是用来合并分支的。</p>
<p><strong>这里不解释 rebase 命令，以及两个命令的原理</strong>，详细解释参考<a target="_blank" rel="noopener" href="http://gitbook.liuhui998.com/4_2.html">这里</a>。</p>
<p>下面的内容主要说的是两者在实际操作中的区别。</p>
<h2 id="什么是分支"><a href="#什么是分支" class="headerlink" title="什么是分支"></a>什么是分支</h2><p>分支就是便于多人在同一项目中的协作开发。比方说：每个人开发不同的功能，在各自的分支开发过程中互不影响，完成后都提交到 develop 分支。极大的提高了开发的效率。</p>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>每个人创建一个分支进行开发，当开发完成，需要合并到 develop 分支的时候，就需要用到合并的命令。</p>
<h2 id="什么是冲突"><a href="#什么是冲突" class="headerlink" title="什么是冲突"></a>什么是冲突</h2><p>合并的时候，有可能会产生冲突。</p>
<p>冲突的产生是因为在合并的时候，不同分支修改了相同的位置。所以在合并的时候 git 不知道那个到底是你想保留的，所以就提出疑问（冲突提醒）让你自己手动选择想要保留的内容，从而解决冲突。</p>
<h2 id="merge-和-rebase-的区别"><a href="#merge-和-rebase-的区别" class="headerlink" title="merge 和 rebase 的区别"></a>merge 和 rebase 的区别</h2><ol>
<li>采用 merge 和 rebase 后，git log 的区别，<strong>merge 命令不会保留 merge 的分支的 commit</strong>：</li>
<li><img src="https://images2015.cnblogs.com/blog/759200/201608/759200-20160806092734215-279978821.png" alt="image"></li>
</ol>
<p>处理冲突的方式：</p>
<ul>
<li>（一股脑）使用<code>merge</code>命令合并分支，解决完冲突，执行<code>git add .</code>和<code>git commit -m&#39;fix conflict</code>‘。这个时候会产生一个 commit。</li>
<li>（交互式）使用 rebase 命令合并分支，解决完冲突，执行<code>git add .</code>和<code>git rebase --continue</code>，不会产生额外的 commit。这样的好处是，‘干净’，分支上不会有无意义的解决分支的 commit；坏处，如果合并的分支中存在多个 commit，需要重复处理多次冲突。</li>
</ul>
<ol start="3">
<li><code>git pull</code>和<code>git pull --rebase</code>区别：<code>git pull</code>做了两个操作分别是‘获取’和合并。所以加了 rebase 就是以 rebase 的方式进行合并分支，默认为 merge。</li>
</ol>
<h2 id="git-merge-和-git-merge-no-ff的区别"><a href="#git-merge-和-git-merge-no-ff的区别" class="headerlink" title="git merge 和 git merge --no-ff的区别"></a><code>git merge</code> 和 <code>git merge --no-ff</code>的区别</h2><p>1、我自己尝试 merge 命令后，发现：merge 时并没有产生一个 commit。不是说 merge 时会产生一个 merge commit 吗？</p>
<p>注意：只有在冲突的时候，解决完冲突才会自动产生一个 commit。</p>
<p>如果想在没有冲突的情况下也自动生成一个 commit，记录此次合并就可以用：git merge –no-ff 命令，下面用一张图来表示两者的区别：</p>
<p><img src="https://images2015.cnblogs.com/blog/759200/201608/759200-20160806092744747-1816899042.png" alt="image"></p>
<p>2、如果不加 –no-ff 则被合并的分支之前的 commit 都会被抹去，只会保留一个解决冲突后的 merge commit。</p>
<h2 id="如何选择合并分支的方式"><a href="#如何选择合并分支的方式" class="headerlink" title="如何选择合并分支的方式"></a>如何选择合并分支的方式</h2><p>我的理解：主要是看哪个命令用的熟练，能够有效的管理自己的代码；还有就是团队用的是哪种方式。</p>
<p>我对于 rebase 比较熟悉，所以我一般都用<code>rebase</code>，但是现在的公司用的是<code>merge --no-ff</code>命令合并分支。所以，我在工作上就用 merge，个人项目就用 rebase。</p>
<p>也可以两者结合：</p>
<p>获取远程项目中最新代码时：<code>git pull --rebase</code>，这个是隐性的合并远程分支的代码不会产生额外的 commit（但是如果存在冲突的 commit 太多就像上面说的，需要处理很多遍冲突）。</p>
<p>合并到分支的时候：<code>git merge --no-ff</code>，自动一个<code>merge commit</code>，便于管理（这看管理人员怎么认为了）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看懂上面的两幅图就行了。</p>
<ol>
<li>commit log 的区别</li>
<li>处理冲突的方式</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/git%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9B%9E%E6%BB%9A%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/git%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9B%9E%E6%BB%9A%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">git如何正确回滚代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:38:45" itemprop="dateCreated datePublished" datetime="2022-10-24T16:38:45+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>git 如何正确回滚代码</p>
</blockquote>
<h2 id="方法一，删除远程分支再提交"><a href="#方法一，删除远程分支再提交" class="headerlink" title="方法一，删除远程分支再提交"></a>方法一，删除远程分支再提交</h2><h3 id="①-首先保证当前工作区是干净的，并且和远程分支代码一致"><a href="#①-首先保证当前工作区是干净的，并且和远程分支代码一致" class="headerlink" title="① 首先保证当前工作区是干净的，并且和远程分支代码一致"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git co currentBranch</span><br><span class="line">$ git pull origin currentBranch</span><br><span class="line">$ git co ./</span><br></pre></td></tr></table></figure>

<h3 id="②-备份当前分支（如有必要）"><a href="#②-备份当前分支（如有必要）" class="headerlink" title="② 备份当前分支（如有必要）"></a>② 备份当前分支（如有必要）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch currentBranchBackUp</span><br></pre></td></tr></table></figure>

<h3 id="③-恢复到指定的-commit-hash"><a href="#③-恢复到指定的-commit-hash" class="headerlink" title="③ 恢复到指定的 commit hash"></a>③ 恢复到指定的 commit hash</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard resetVersionHash //将当前branch的HEAD指针指向commit hash</span><br></pre></td></tr></table></figure>

<p><img src="http://gtms04.alicdn.com/tps/i4/TB1Q0yyLpXXXXXpXXXXPw.CWFXX-632-320.png" alt="image"></p>
<h3 id="④-删除当前分支的远程分支"><a href="#④-删除当前分支的远程分支" class="headerlink" title="④ 删除当前分支的远程分支"></a>④ 删除当前分支的远程分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :currentBranch</span><br><span class="line">$ //或者这么写git push origin --delete currentBranch</span><br></pre></td></tr></table></figure>

<h3 id="⑤-把当前分支提交到远程"><a href="#⑤-把当前分支提交到远程" class="headerlink" title="⑤ 把当前分支提交到远程"></a>⑤ 把当前分支提交到远程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin currentBranch</span><br></pre></td></tr></table></figure>

<h2 id="方法二，强制-push-远程分支"><a href="#方法二，强制-push-远程分支" class="headerlink" title="方法二，强制 push 远程分支"></a>方法二，强制 push 远程分支</h2><h3 id="①-首先保证当前工作区是干净的，并且和远程分支代码一致-1"><a href="#①-首先保证当前工作区是干净的，并且和远程分支代码一致-1" class="headerlink" title="① 首先保证当前工作区是干净的，并且和远程分支代码一致"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><h3 id="②-备份当前分支（如有必要）-1"><a href="#②-备份当前分支（如有必要）-1" class="headerlink" title="② 备份当前分支（如有必要）"></a>② 备份当前分支（如有必要）</h3><h3 id="③-恢复到指定的-commit-hash-1"><a href="#③-恢复到指定的-commit-hash-1" class="headerlink" title="③ 恢复到指定的 commit hash"></a>③ 恢复到指定的 commit hash</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard resetVersionHash</span><br></pre></td></tr></table></figure>

<h3 id="④-把当前分支强制提交到远程"><a href="#④-把当前分支强制提交到远程" class="headerlink" title="④ 把当前分支强制提交到远程"></a>④ 把当前分支强制提交到远程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -f origin currentBranch</span><br></pre></td></tr></table></figure>

<h2 id="方法三，从回滚位置生成新的-commit-hash"><a href="#方法三，从回滚位置生成新的-commit-hash" class="headerlink" title="方法三，从回滚位置生成新的 commit hash"></a>方法三，从回滚位置生成新的 commit hash</h2><h3 id="①-首先保证当前工作区是干净的，并且和远程分支代码一致-2"><a href="#①-首先保证当前工作区是干净的，并且和远程分支代码一致-2" class="headerlink" title="① 首先保证当前工作区是干净的，并且和远程分支代码一致"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><h4 id="②-备份当前分支（如有必要）-2"><a href="#②-备份当前分支（如有必要）-2" class="headerlink" title="② 备份当前分支（如有必要）"></a>② 备份当前分支（如有必要）</h4><h3 id="③-使用-git-revert-恢复到指定的-commit-hash，当前分支恢复到-a-gt-3-版本（见下图）"><a href="#③-使用-git-revert-恢复到指定的-commit-hash，当前分支恢复到-a-gt-3-版本（见下图）" class="headerlink" title="③ 使用 git revert 恢复到指定的 commit hash，当前分支恢复到 a&gt;3 版本（见下图）"></a>③ 使用 git revert 恢复到指定的 commit hash，当前分支恢复到 a&gt;3 版本（见下图）</h3><h4 id="a）此方法会产生一条多余的-commit-hash-amp-log，其实-1c0ce98-和-01592eb-内容上是一致的"><a href="#a）此方法会产生一条多余的-commit-hash-amp-log，其实-1c0ce98-和-01592eb-内容上是一致的" class="headerlink" title="a）此方法会产生一条多余的 commit hash&amp;log，其实 1c0ce98 和 01592eb 内容上是一致的"></a>a）此方法会产生一条多余的 commit hash&amp;log，其实 1c0ce98 和 01592eb 内容上是一致的</h4><h4 id="b）git-revert-是以要回滚的-commit-hash-1c0ce98-为基础，新生成一个-commit-hash-01592eb"><a href="#b）git-revert-是以要回滚的-commit-hash-1c0ce98-为基础，新生成一个-commit-hash-01592eb" class="headerlink" title="b）git revert 是以要回滚的 commit hash(1c0ce98)为基础，新生成一个 commit hash(01592eb)"></a>b）git revert 是以要回滚的 commit hash(1c0ce98)为基础，新生成一个 commit hash(01592eb)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert resetVersionHash</span><br></pre></td></tr></table></figure>

<p><img src="http://gtms04.alicdn.com/tps/i4/TB1VdurLpXXXXcuXXXX_mKs_XXX-873-308.png" alt="image"></p>
<h3 id="④-提交远程分支"><a href="#④-提交远程分支" class="headerlink" title="④ 提交远程分支"></a>④ 提交远程分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin currentBranch</span><br></pre></td></tr></table></figure>

<h2 id="方法四，从回滚位置生成新的分支-merge"><a href="#方法四，从回滚位置生成新的分支-merge" class="headerlink" title="方法四，从回滚位置生成新的分支 merge"></a>方法四，从回滚位置生成新的分支 merge</h2><h3 id="①-首先保证当前工作区是干净的，并且和远程分支代码一致-3"><a href="#①-首先保证当前工作区是干净的，并且和远程分支代码一致-3" class="headerlink" title="① 首先保证当前工作区是干净的，并且和远程分支代码一致"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><h3 id="②-备份当前分支（如有必要）-3"><a href="#②-备份当前分支（如有必要）-3" class="headerlink" title="② 备份当前分支（如有必要）"></a>② 备份当前分支（如有必要）</h3><h3 id="③-把当前工作区的-HEAD-指针指向回滚的-commit-hash-注意不是-branch-的-HEAD-指针"><a href="#③-把当前工作区的-HEAD-指针指向回滚的-commit-hash-注意不是-branch-的-HEAD-指针" class="headerlink" title="③ 把当前工作区的 HEAD 指针指向回滚的 commit hash(注意不是 branch 的 HEAD 指针)"></a>③ 把当前工作区的 HEAD 指针指向回滚的 commit hash(注意不是 branch 的 HEAD 指针)</h3><p><strong>Notice:这个时候工作区 HEAD 没有指向分支，称为匿名分支 detached HEAD</strong>。</p>
<p>这个时候提交 commit 后无法保存状态，git 中的任何提交必须是在当前工作区 HEAD 所在分支的 HEAD 上进行 push hash 入栈，所以 HEAD 必须是属于某个分支的 HEAD 位置，提交才生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git co resetVersionHash</span><br></pre></td></tr></table></figure>

<h3 id="④-以该-commit-hash-创建一个新的分支"><a href="#④-以该-commit-hash-创建一个新的分支" class="headerlink" title="④ 以该 commit hash 创建一个新的分支"></a>④ 以该 commit hash 创建一个新的分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git co -b newRevertedHash</span><br></pre></td></tr></table></figure>

<h3 id="⑤-切换到当前分支，合并-newRevertedHash。"><a href="#⑤-切换到当前分支，合并-newRevertedHash。" class="headerlink" title="⑤ 切换到当前分支，合并 newRevertedHash。"></a>⑤ 切换到当前分支，合并 newRevertedHash。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git co currentBranch</span><br><span class="line">$ git merge newRevertedHash</span><br></pre></td></tr></table></figure>

<h3 id="⑥-进行代码-diff，完成代码回滚，push-到远程-currentBranch"><a href="#⑥-进行代码-diff，完成代码回滚，push-到远程-currentBranch" class="headerlink" title="⑥ 进行代码 diff，完成代码回滚，push 到远程 currentBranch"></a>⑥ 进行代码 diff，完成代码回滚，push 到远程 currentBranch</h3><p><strong>Notice: 也可以直接 hotfix，从要回滚的地方直接重新打包一个新 tag 包，发版本 hotFixVersion 即可。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E6%B5%85%E6%9E%90koa%E7%9A%84%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/%E6%B5%85%E6%9E%90koa%E7%9A%84%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">浅析koa的洋葱模型实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:38:08" itemprop="dateCreated datePublished" datetime="2022-10-24T16:38:08+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>koa 被认为是第二代 node web framework，它最大的特点就是独特的中间件流程控制，是一个典型的洋葱模型。koa 和 koa2 中间件的思路是一样的，但是实现方式有所区别，koa2 在 node7.6 之后更是可以直接用 async&#x2F;await 来替代 generator 使用中间件，本文以最后一种情况举例。</p>
<h2 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h2><p>下面两张图是网上找的，很清晰的表明了一个请求是如何经过中间件最后生成响应的，这种模式中开发和使用中间件都是非常方便的</p>
<p><img src="https://segmentfault.com/img/bV6DZG?w=478&h=435" alt="image"></p>
<p><img src="https://segmentfault.com/img/bV6D5Z?w=470&h=411" alt="image"></p>
<p>来看一个 koa2 的 demo:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&#x27;koa&#x27;);</span><br><span class="line"></span><br><span class="line">const app = new Koa();</span><br><span class="line">const PORT = 3000;</span><br><span class="line"></span><br><span class="line">// #1</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    await next();</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;);</span><br><span class="line">// #2</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    await next();</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(PORT);</span><br><span class="line">console.log(`http://localhost:$&#123;PORT&#125;`);</span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://localhost:3000，控制台打印：">http://localhost:3000，控制台打印：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>怎么样，是不是有一点点感觉了。当程序运行到 await next()的时候就会暂停当前程序，进入下一个中间件，处理完之后才会在回过头来继续处理。也就是说，当一个请求进入，#1 会被第一个和最后一个经过，#2 则是被第二和倒数第二个经过，依次类推。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>koa 的实现有几个最重要的点</p>
<ol>
<li>context 的保存和传递</li>
<li>中间件的管理和 next 的实现</li>
</ol>
<p>翻看源码我们发现<br>app.listen 使用了 this.callback()来生成 node 的 httpServer 的回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">    debug(&#x27;listen&#x27;);</span><br><span class="line">    const server = http.createServer(this.callback());</span><br><span class="line">    return server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那就再来看 this.callback</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">    const fn = compose(this.middleware);</span><br><span class="line"></span><br><span class="line">    if (!this.listeners(&#x27;error&#x27;).length) this.on(&#x27;error&#x27;, this.onerror);</span><br><span class="line"></span><br><span class="line">    const handleRequest = (req, res) =&gt; &#123;</span><br><span class="line">      const ctx = this.createContext(req, res);</span><br><span class="line">      return this.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用 compose 处理了一下 this.middleware，创建了 ctx 并赋值为 createContext 的返回值，最后返回了 handleRequest。</p>
<p>this.middleware 看起来应该是中间件的集合，查了下代码，果不其然：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.middleware = [];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">    if (typeof fn !== &#x27;function&#x27;) throw new TypeError(&#x27;middleware must be a function!&#x27;);</span><br><span class="line">    if (isGeneratorFunction(fn)) &#123;</span><br><span class="line">      deprecate(&#x27;Support for generators will be removed in v3. &#x27; +</span><br><span class="line">                &#x27;See the documentation for examples of how to convert old middleware &#x27; +</span><br><span class="line">                &#x27;https://github.com/koajs/koa/blob/master/docs/migration.md&#x27;);</span><br><span class="line">      fn = convert(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    debug(&#x27;use %s&#x27;, fn._name || fn.name || &#x27;-&#x27;);</span><br><span class="line">    this.middleware.push(fn);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛开兼容和判断，这段代码只做了一件事：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">    this.middleware.push(fn);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来当我们 app.use 的时候，只是把方法存在了一个数组里。<br>那么 compose 又是什么呢。跟踪源码可以看到 compose 来自 koa-compose 模块，代码也不多：（去掉了一些不影响主逻辑的判断）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function compose (middleware) &#123;</span><br><span class="line">  return function (context, next) &#123;</span><br><span class="line">    // last called middleware #</span><br><span class="line">    let index = -1</span><br><span class="line">    return dispatch(0)</span><br><span class="line"></span><br><span class="line">    function dispatch (i) &#123;</span><br><span class="line">      if (i &lt;= index) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;))</span><br><span class="line">      index = i</span><br><span class="line">      let fn = middleware[i]</span><br><span class="line">      if (i === middleware.length) fn = next</span><br><span class="line">      if (!fn) return Promise.resolve()</span><br><span class="line">      try &#123;</span><br><span class="line">        return Promise.resolve(fn(context, function next () &#123;</span><br><span class="line">          return dispatch(i + 1)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        return Promise.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较关键的就是这个 dispatch 函数了，它将遍历整个 middleware，然后将 context 和 dispatch(i + 1)传给 middleware 中的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return Promise.resolve(fn(context, function next () &#123;</span><br><span class="line">      return dispatch(i + 1)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>这段代码就很巧妙的实现了两点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 将`context`一路传下去给中间件</span><br><span class="line"></span><br><span class="line">2. 将`middleware`中的下一个中间件`fn`作为未来`next`的返回值</span><br></pre></td></tr></table></figure>

<p>这两点也是洋葱模型实现的核心。<br>再往下看代码实际上就没有太多花样了。<br>createContext 和 handleRequest 做的事实际上是把 ctx 和中间件进行绑定，也就是第一次调用 compose 返回值的地方。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">createContext(req, res) &#123;</span><br><span class="line">   const context = Object.create(this.context);</span><br><span class="line">   const request = context.request = Object.create(this.request);</span><br><span class="line">   const response = context.response = Object.create(this.response);</span><br><span class="line">   context.app = request.app = response.app = this;</span><br><span class="line">   context.req = request.req = response.req = req;</span><br><span class="line">   context.res = request.res = response.res = res;</span><br><span class="line">   request.ctx = response.ctx = context;</span><br><span class="line">   request.response = response;</span><br><span class="line">   response.request = request;</span><br><span class="line">   context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">   context.cookies = new Cookies(req, res, &#123;</span><br><span class="line">     keys: this.keys,</span><br><span class="line">     secure: request.secure</span><br><span class="line">   &#125;);</span><br><span class="line">   request.ip = request.ips[0] || req.socket.remoteAddress || &#x27;&#x27;;</span><br><span class="line">   context.accept = request.accept = accepts(req);</span><br><span class="line">   context.state = &#123;&#125;;</span><br><span class="line">   return context;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">   const res = ctx.res;</span><br><span class="line">   res.statusCode = 404;</span><br><span class="line">   const onerror = err =&gt; ctx.onerror(err);</span><br><span class="line">   const handleResponse = () =&gt; respond(ctx);</span><br><span class="line">   onFinished(res, onerror);</span><br><span class="line">   return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAautoTry%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8C%87%E5%AE%9A%E9%94%99%E8%AF%AF%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E6%AC%A1%E6%95%B0%EF%BC%8C%E6%9C%80%E7%BB%88%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAautoTry%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8C%87%E5%AE%9A%E9%94%99%E8%AF%AF%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E6%AC%A1%E6%95%B0%EF%BC%8C%E6%9C%80%E7%BB%88%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/" class="post-title-link" itemprop="url">封装一个autoTry函数，指定错误情况下重复执行次数，最终返回结果</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:37:27" itemprop="dateCreated datePublished" datetime="2022-10-24T16:37:27+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、封装-autoTry-函数"><a href="#一、封装-autoTry-函数" class="headerlink" title="一、封装 autoTry 函数"></a>一、封装 autoTry 函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line"></span><br><span class="line">    function foo(params) &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            JSON.parse(&#x27;&#123;&#123;&#x27;);</span><br><span class="line">            return resolve(params);</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            return reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ========doing======</span><br><span class="line">    function autoTry(fn, times) &#123;</span><br><span class="line">      const retry = (params) =&gt; new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        fn(params).then(</span><br><span class="line">          (response) =&gt; &#123; resolve(response) &#125;</span><br><span class="line">        ).catch(e =&gt; &#123;</span><br><span class="line">          console.log(&#x27;retrying: &#x27; + new Date(), e)</span><br><span class="line">          if (times &gt; 1) &#123;</span><br><span class="line">            times -= 1</span><br><span class="line">            retry()</span><br><span class="line">          &#125; else &#123; reject(e) &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return retry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ========test======</span><br><span class="line">    func = autoTry(foo, 3);</span><br><span class="line">    func(&#123; a: 1, b: 2 &#125;).then((res) =&gt; &#123;</span><br><span class="line">      console.log(`结果：$&#123;JSON.stringify(res)&#125;`);</span><br><span class="line">    &#125;, (error) =&gt; &#123;</span><br><span class="line">      console.log(error)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="二、一个-n-个大小写字母组成的字符串按-ascii-码从小到大排序-查找字符串中第-k-个最小-ascii-码的字母输出该字母所在字符串位置索引"><a href="#二、一个-n-个大小写字母组成的字符串按-ascii-码从小到大排序-查找字符串中第-k-个最小-ascii-码的字母输出该字母所在字符串位置索引" class="headerlink" title="二、一个 n 个大小写字母组成的字符串按 ascii 码从小到大排序 查找字符串中第 k 个最小 ascii 码的字母输出该字母所在字符串位置索引"></a>二、一个 n 个大小写字母组成的字符串按 ascii 码从小到大排序 查找字符串中第 k 个最小 ascii 码的字母输出该字母所在字符串位置索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function lookup(str,key)&#123;</span><br><span class="line">  if(typeof str !=&#x27;string&#x27;||key&lt;1)return -1;</span><br><span class="line">  let value = str.split(&quot;&quot;).sort()[key-1];</span><br><span class="line">  return str.indexOf(value);</span><br><span class="line">&#125;</span><br><span class="line">console.log(lookup(&#x27;asasdskdjdfgnsdkfnmsASDdf&#x27;,5)+1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let getIndexChar = (str,index)=&gt;&#123;</span><br><span class="line">    let sortChar = []</span><br><span class="line">    for(let i=0;i&lt;str.length;i++) &#123;</span><br><span class="line">        sortChar.push(str.charCodeAt(i))</span><br><span class="line">    &#125;</span><br><span class="line">    sortChar = sortChar.sort((a,b)=&gt;&#123;</span><br><span class="line">        return a-b</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    let indexCode = -1</span><br><span class="line">    for(let i=0;i&lt;str.length;i++) &#123;</span><br><span class="line">        if(str[i].charCodeAt(0)==sortChar[index]) &#123;</span><br><span class="line">            indexCode = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return indexCode</span><br><span class="line">&#125;</span><br><span class="line">getIndexChar(&#x27;asdEQW&#x27;,1) //4</span><br></pre></td></tr></table></figure>

<h2 id="三、ts-工具函数"><a href="#三、ts-工具函数" class="headerlink" title="三、ts 工具函数"></a>三、ts 工具函数</h2><p><strong>1、实现一个 ts 的工具函数 GetOnlyFnProps<T> ，提取泛型类型 T 中字段类型是函数的工具函数，其中 T 属于一个对象。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type GetOnlyFnKeys&lt;T extends object&gt; = &#123;</span><br><span class="line"> [Key in keyof T]: T[K] extends Function ? K : never</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type GetOnlyFnProps&lt;T extends object&gt; = &#123;</span><br><span class="line"> [K in GetOnlyFnKeys&lt;T&gt;]: T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现一个 ts 的工具函数 UnGenericPromise<T> ，提取 Promise 中的泛型类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type UnGenericPromise&lt;T extends Promise&lt;any&gt;&gt; = T extends Promise&lt;infer U&gt; ? U : never</span><br></pre></td></tr></table></figure>

<h2 id="四、分页加载"><a href="#四、分页加载" class="headerlink" title="四、分页加载"></a>四、分页加载</h2><p><strong>h5_demo</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123;PREFIX_URL ,request ,TITLE&#125; from &#x27;../../common&#x27;;</span><br><span class="line">import DetailedList from &quot;../../components/movie/DetailedListComponent&quot;;</span><br><span class="line">import Loading from &#x27;../../components/common/LoadingComponent&#x27;;</span><br><span class="line"></span><br><span class="line">const PS = 5;</span><br><span class="line">class FilmList extends Component &#123;</span><br><span class="line">    constructor(...args) &#123;</span><br><span class="line">        super(...args);</span><br><span class="line">        document.title = &#x27;艾米电影推荐&#x27;;</span><br><span class="line">        this.stgId = localStorage.getItem(&quot;stgId&quot;) || &quot;&quot;;</span><br><span class="line">        this.id = this.props.match.params.id;</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            listData: &quot;&quot;,</span><br><span class="line">            page: 1,</span><br><span class="line">            pageSize: PS,</span><br><span class="line">            hasMore: false,</span><br><span class="line">            desc:&#x27;&#x27;,</span><br><span class="line">            loading:true,</span><br><span class="line">            display:&#x27;none&#x27;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    async componentWillMount() &#123;</span><br><span class="line">        // console.log(&quot;片单ID--&gt;&quot;, this.id);</span><br><span class="line">        await this.getList();</span><br><span class="line">    &#125;</span><br><span class="line">    async getList(page=1) &#123;</span><br><span class="line">        let url = `$&#123;PREFIX_URL&#125;movie_client/list`+</span><br><span class="line">            `?stgId=$&#123;this.stgId&#125;&amp;movieListId=$&#123;this.id&#125;&amp;page=$&#123;page&#125;&amp;pageSize=$&#123;this.state.pageSize&#125;`;</span><br><span class="line">        let res = await request(url);</span><br><span class="line">        if (res &amp;&amp; res.success) &#123;</span><br><span class="line">            document.title = res.title;</span><br><span class="line">            let listData = &quot;&quot;;</span><br><span class="line">            if (page === 1) &#123;</span><br><span class="line">                listData = res.data;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                listData = this.state.listData;</span><br><span class="line">                listData = listData.concat(res.data);</span><br><span class="line">            &#125;</span><br><span class="line">            await this.setState(&#123;</span><br><span class="line">                listData,</span><br><span class="line">                loading:false,</span><br><span class="line">                display:&#x27;block&#x27;,</span><br><span class="line">                desc:res.desc,</span><br><span class="line">                page:res.page.current,</span><br><span class="line">                hasMore: res.page.current &lt; res.page.pages</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    async componentWillUnmount () &#123;</span><br><span class="line">        document.title = TITLE;</span><br><span class="line">    &#125;</span><br><span class="line">    async refresh () &#123;</span><br><span class="line">        await this.setState(&#123;page: 1&#125;);</span><br><span class="line">        await this.getList(1);</span><br><span class="line">    &#125;</span><br><span class="line">    async loadMore() &#123;</span><br><span class="line">        await this.setState(&#123;page: this.state.page + 1&#125;);</span><br><span class="line">        await this.getList(this.state.page);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;page-movie-detailed-list&quot;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    !!this.state.listData &amp;&amp;</span><br><span class="line">                    &lt;DetailedList</span><br><span class="line">                        refresh=&#123;this.refresh.bind(this)&#125;</span><br><span class="line">                        loadMore=&#123;this.loadMore.bind(this)&#125;</span><br><span class="line">                        hasMore=&#123;this.state.hasMore&#125;</span><br><span class="line">                        listData=&#123;this.state.listData&#125;</span><br><span class="line">                        desc=&#123;this.state.desc&#125;</span><br><span class="line">                        style=&#123;&#123;&#x27;display&#x27;:this.state.display&#125;&#125;/&gt;&#125;</span><br><span class="line">                &#123;this.state.loading ? &lt;Loading/&gt; : &#x27;&#x27; &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default FilmList;</span><br></pre></td></tr></table></figure>

<p><strong>PC_demo</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Button, Col, message as Message, Row, Icon &#125; from &#x27;antd&#x27;</span><br><span class="line">import &#123; Link &#125; from &#x27;react-router-dom&#x27;</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import MessageListFilter, &#123; IMessageListFilter &#125; from &#x27;./components/MessageListFilter&#x27;</span><br><span class="line">import MessageListTable from &#x27;./components/MessageListTable&#x27;</span><br><span class="line">import MessageService from &#x27;../../../service/driverManage/MessageService&#x27;</span><br><span class="line"></span><br><span class="line">export default class MessageList extends React.Component &#123;</span><br><span class="line">  // public constructor(props: any)&#123;</span><br><span class="line">  //   super(props)</span><br><span class="line">  // &#125;</span><br><span class="line">  public state = &#123;</span><br><span class="line">    filterProps: &#123;</span><br><span class="line">      filter: &#123;</span><br><span class="line">        beginCreatedTime: &#x27;&#x27;,</span><br><span class="line">        endCreatedTime: &#x27;&#x27;, // 日期</span><br><span class="line">        sendStatus: &#x27;-1&#x27;, //发送状态</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    tableProps: &#123;</span><br><span class="line">      page: &#123;</span><br><span class="line">        current: 1,</span><br><span class="line">        pageSize: 10,</span><br><span class="line">        total: 0,</span><br><span class="line">      &#125;,</span><br><span class="line">      data: [],</span><br><span class="line">    &#125;,</span><br><span class="line">    searching: false,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public componentDidMount() &#123;</span><br><span class="line">    this.reSearch()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public filterChange = (params: IMessageListFilter) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      filterProps: &#123;</span><br><span class="line">        filter: &#123;</span><br><span class="line">          ...this.state.filterProps.filter,</span><br><span class="line">          ...params,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public search = async () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      searching: true,</span><br><span class="line">    &#125;)</span><br><span class="line">    const &#123; code, message, data &#125; = await MessageService.pageMessageList(&#123;</span><br><span class="line">      ...this.state.filterProps.filter,</span><br><span class="line">      ...&#123;</span><br><span class="line">        sendStatus:</span><br><span class="line">          this.state.filterProps.filter.sendStatus !== &#x27;-1&#x27;</span><br><span class="line">            ? this.state.filterProps.filter.sendStatus</span><br><span class="line">            : null,</span><br><span class="line">      &#125;,</span><br><span class="line">      pageNum: this.state.tableProps.page.current,</span><br><span class="line">      pageSize: this.state.tableProps.page.pageSize,</span><br><span class="line">    &#125;)</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      searching: false,</span><br><span class="line">    &#125;)</span><br><span class="line">    if (code !== 200) &#123;</span><br><span class="line">      Message.error(message)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    const &#123; current, pageSize &#125; = this.state.tableProps.page</span><br><span class="line">    let rows = []</span><br><span class="line">    rows =</span><br><span class="line">      data.rows &amp;&amp; data.rows.length</span><br><span class="line">        ? data.rows.map((item: any, index: number) =&gt; &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">              ...item,</span><br><span class="line">              num: (current - 1) * pageSize + index + 1,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        : []</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      tableProps: &#123;</span><br><span class="line">        page: &#123;</span><br><span class="line">          ...this.state.tableProps.page,</span><br><span class="line">          total: data.total,</span><br><span class="line">        &#125;,</span><br><span class="line">        data: rows,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public reSearch = () =&gt; &#123;</span><br><span class="line">    const &#123; tableProps &#125; = this.state</span><br><span class="line">    const &#123;</span><br><span class="line">      page: &#123; pageSize, total &#125;,</span><br><span class="line">    &#125; = tableProps</span><br><span class="line"></span><br><span class="line">    this.setState(</span><br><span class="line">      &#123;</span><br><span class="line">        tableProps: &#123;</span><br><span class="line">          ...tableProps,</span><br><span class="line">          page: &#123;</span><br><span class="line">            pageSize,</span><br><span class="line">            total,</span><br><span class="line">            current: 1,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        this.search()</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public pageChange = (page: object) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      tableProps: &#123;</span><br><span class="line">        ...this.state.tableProps,</span><br><span class="line">        page,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    this.search()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public getDetail = (params: any) =&gt; &#123;</span><br><span class="line">    ;(this.props as any).history.push(&#x27;messageDetail&#x27;, &#123; id: 6, type: 0 &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  public render() &#123;</span><br><span class="line">    const &#123; filterProps, tableProps, searching &#125; = this.state</span><br><span class="line">    return (</span><br><span class="line">      &lt;section&gt;</span><br><span class="line">        &lt;MessageListFilter</span><br><span class="line">          loading=&#123;searching&#125;</span><br><span class="line">          &#123;...filterProps&#125;</span><br><span class="line">          onChange=&#123;this.filterChange&#125;</span><br><span class="line">          onSearch=&#123;this.reSearch&#125;</span><br><span class="line">        &gt;&lt;/MessageListFilter&gt;</span><br><span class="line">        &lt;Row style=&#123;&#123; marginBottom: &#x27;10px&#x27; &#125;&#125;&gt;</span><br><span class="line">          &lt;Col&gt;</span><br><span class="line">            &lt;Button type=&quot;primary&quot;&gt;</span><br><span class="line">              &lt;Link to=&#123;`/fast/message/messageCreate`&#125;&gt;</span><br><span class="line">                &lt;Icon type=&quot;plus&quot; /&gt;</span><br><span class="line">                &lt;span style=&#123;&#123; marginLeft: &#x27;8px&#x27; &#125;&#125;&gt;新建推送&lt;/span&gt;</span><br><span class="line">              &lt;/Link&gt;</span><br><span class="line">            &lt;/Button&gt;</span><br><span class="line">          &lt;/Col&gt;</span><br><span class="line">        &lt;/Row&gt;</span><br><span class="line">        &lt;MessageListTable</span><br><span class="line">          &#123;...tableProps&#125;</span><br><span class="line">          onPagechange=&#123;this.pageChange&#125;</span><br><span class="line">          getDetail=&#123;this.getDetail&#125;</span><br><span class="line">          onSearch=&#123;this.search&#125;</span><br><span class="line">          loading=&#123;searching&#125;</span><br><span class="line">        &gt;&lt;/MessageListTable&gt;</span><br><span class="line">      &lt;/section&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Button, Table, Col, Modal, message as Message &#125; from &#x27;antd&#x27;</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123; PaginationConf &#125; from &#x27;../../../../config/antd/PaginationConf&#x27;</span><br><span class="line">import &#123; Link &#125; from &#x27;react-router-dom&#x27;</span><br><span class="line">import MessageService from &#x27;../../../../service/driverManage/MessageService&#x27;</span><br><span class="line">export interface IMessageTable &#123;</span><br><span class="line">  num: string | number</span><br><span class="line">  creatTime: string</span><br><span class="line">  driverName: string</span><br><span class="line">  driverPhoneNum: string</span><br><span class="line">  receiptType: number</span><br><span class="line">  receipt: number | string</span><br><span class="line">  output: number | string</span><br><span class="line">  banace: number | string</span><br><span class="line">&#125;</span><br><span class="line">export interface IProps &#123;</span><br><span class="line">  data: IMessageTable[]</span><br><span class="line">  page: &#123;</span><br><span class="line">    current: number</span><br><span class="line">    pageSize: number</span><br><span class="line">    total: number</span><br><span class="line">  &#125;</span><br><span class="line">  onPagechange?: (page: &#123; current: number; pageSize: number; total: number &#125;) =&gt; void</span><br><span class="line">  getDetail: (param: any) =&gt; void</span><br><span class="line">  onSearch: () =&gt; void</span><br><span class="line">  loading: boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123; confirm &#125; = Modal</span><br><span class="line">class MessageListTable extends React.Component&lt;IProps&gt; &#123;</span><br><span class="line">  public constructor(props: IProps) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    ;(this as any).columns = [</span><br><span class="line">      &#123;</span><br><span class="line">        title: &#x27;序号&#x27;,</span><br><span class="line">        dataIndex: &#x27;num&#x27;,</span><br><span class="line">        align: &#x27;center&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: &#x27;发送时间&#x27;,</span><br><span class="line">        dataIndex: &#x27;sendTime&#x27;,</span><br><span class="line">        align: &#x27;center&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: &#x27;发送范围&#x27;,</span><br><span class="line">        dataIndex: &#x27;sendScope&#x27;,</span><br><span class="line">        align: &#x27;center&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: &#x27;消息中心&#x27;,</span><br><span class="line">        dataIndex: &#x27;canIntoMessageCenter&#x27;,</span><br><span class="line">        align: &#x27;center&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: &#x27;标题&#x27;,</span><br><span class="line">        dataIndex: &#x27;title&#x27;,</span><br><span class="line">        align: &#x27;center&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: &#x27;操作人&#x27;,</span><br><span class="line">        dataIndex: &#x27;createdBy&#x27;,</span><br><span class="line">        align: &#x27;center&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: &#x27;创建时间&#x27;,</span><br><span class="line">        dataIndex: &#x27;createdTime&#x27;,</span><br><span class="line">        align: &#x27;center&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: &#x27;发送状态&#x27;,</span><br><span class="line">        dataIndex: &#x27;sendStatus&#x27;,</span><br><span class="line">        align: &#x27;center&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: &#x27;操作&#x27;,</span><br><span class="line">        align: &#x27;center&#x27;,</span><br><span class="line">        render(row: any) &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &#123;row.canCancelSend ? (</span><br><span class="line">                &lt;Col&gt;</span><br><span class="line">                  &lt;Button</span><br><span class="line">                    type=&quot;primary&quot;</span><br><span class="line">                    onClick=&#123;() =&gt; &#123;</span><br><span class="line">                      cancel(row)</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                  &gt;</span><br><span class="line">                    取消发送</span><br><span class="line">                  &lt;/Button&gt;</span><br><span class="line">                  &#123;new Date(row.sendTime).getTime() - new Date().getTime() &gt; 5 * 60 * 60 * 1000 ? (</span><br><span class="line">                    &lt;Button type=&quot;primary&quot; style=&#123;&#123; marginLeft: &#x27;5px&#x27; &#125;&#125;&gt;</span><br><span class="line">                      &lt;Link to=&#123;`/fast/message/messageUpdate/$&#123;row.id&#125;`&#125;&gt;查看&lt;/Link&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                  ) : (</span><br><span class="line">                    &lt;Button type=&quot;primary&quot; style=&#123;&#123; marginLeft: &#x27;5px&#x27; &#125;&#125;&gt;</span><br><span class="line">                      &lt;Link to=&#123;`/fast/message/messageDetail/$&#123;row.id&#125;`&#125;&gt;查看&lt;/Link&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                  )&#125;</span><br><span class="line">                &lt;/Col&gt;</span><br><span class="line">              ) : (</span><br><span class="line">                &lt;Button type=&quot;primary&quot;&gt;</span><br><span class="line">                  &lt;Link to=&#123;`/fast/message/messageDetail/$&#123;row.id&#125;`&#125;&gt;查看&lt;/Link&gt;</span><br><span class="line">                &lt;/Button&gt;</span><br><span class="line">              )&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">    function cancel(row: any) &#123;</span><br><span class="line">      const &#123; onSearch &#125; = props</span><br><span class="line">      if (new Date(row.sendTime).getTime() - new Date().getTime() &gt; 5 * 60 * 60 * 1000) &#123;</span><br><span class="line">        confirm(&#123;</span><br><span class="line">          title: &#x27;提示&#x27;,</span><br><span class="line">          content: &#x27;是否确认取消&#x27;,</span><br><span class="line">          async onOk() &#123;</span><br><span class="line">            const &#123; code, message &#125; = await MessageService.messageCancel(row.id)</span><br><span class="line">            if (code !== 200) &#123;</span><br><span class="line">              Message.error(message)</span><br><span class="line">              return</span><br><span class="line">            &#125;</span><br><span class="line">            Message.success(&#x27;取消成功&#x27;)</span><br><span class="line">            onSearch()</span><br><span class="line">          &#125;,</span><br><span class="line">          onCancel() &#123;</span><br><span class="line">            return</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Modal.info(&#123;</span><br><span class="line">          title: &#x27;提示&#x27;,</span><br><span class="line">          content: &lt;div&gt;距离预计发送时间不到5分钟 禁止取消&lt;/div&gt;,</span><br><span class="line">          okText: &#x27;关闭&#x27;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public render() &#123;</span><br><span class="line">    const &#123; data, page, onPagechange, loading &#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">      &lt;section&gt;</span><br><span class="line">        &lt;Table</span><br><span class="line">          dataSource=&#123;data&#125;</span><br><span class="line">          loading=&#123;loading&#125;</span><br><span class="line">          // @ts-ignore</span><br><span class="line">          columns=&#123;this.columns&#125;</span><br><span class="line">          rowKey=&#123;&#x27;id&#x27;&#125;</span><br><span class="line">          size=&#123;&#x27;middle&#x27;&#125;</span><br><span class="line">          // scroll=&#123;&#123; x: 2500 &#125;&#125;</span><br><span class="line">          pagination=&#123;&#123;</span><br><span class="line">            ...PaginationConf,</span><br><span class="line">            ...this.props.page,</span><br><span class="line">            onChange: (toCurrent, pageSize) =&gt; &#123;</span><br><span class="line">              page.current = toCurrent</span><br><span class="line">              page.pageSize = pageSize as number</span><br><span class="line"></span><br><span class="line">              if (onPagechange) &#123;</span><br><span class="line">                onPagechange(page)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            onShowSizeChange: (current, toPageSize) =&gt; &#123;</span><br><span class="line">              page.current = current</span><br><span class="line">              page.pageSize = toPageSize</span><br><span class="line"></span><br><span class="line">              if (onPagechange) &#123;</span><br><span class="line">                onPagechange(page)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            showTotal: (total: number) =&gt; `共计 $&#123;total&#125; 条`,</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;&lt;/Table&gt;</span><br><span class="line">      &lt;/section&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; MessageListTable &#125;</span><br><span class="line">export default MessageListTable</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Chen"
      src="/images/portal.jpg">
  <p class="site-author-name" itemprop="name">Bruce Chen</p>
  <div class="site-description" itemprop="description">It's better to burn out than to fade away.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1440429303&auto=1&height=66"></iframe>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jschentt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jschentt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jschentt@gmail.com" title="E-Mail → mailto:jschentt@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/BruceCh56742806" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;BruceCh56742806" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/jinsheng.chen.5439" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;jinsheng.chen.5439" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
  </div>





      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
