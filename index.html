<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="It&#39;s better to burn out than to fade away.">
<meta property="og:type" content="website">
<meta property="og:title" content="Bruce Chen&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Bruce Chen&#39;s Blog">
<meta property="og:description" content="It&#39;s better to burn out than to fade away.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Bruce Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Bruce Chen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
    <a target="_blank" rel="noopener" href="https://github.com/jschentt" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bruce Chen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">quick notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">35</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">前端代码开发规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 11:13:17 / 修改时间：11:20:40" itemprop="dateCreated datePublished" datetime="2022-12-16T11:13:17+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">前端算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前端-JS-项目开发规范"><a href="#前端-JS-项目开发规范" class="headerlink" title="前端 JS 项目开发规范"></a>前端 JS 项目开发规范</h2><p>规范的目的是为了编写高质量的代码，让你的团队成员每天的心情都是愉悦的，大家在一起是快乐的。</p>
<p>引自《阿里规约》的开头片段：</p>
<p>—-现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。</p>
<h2 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h2><h3 id="一-命名规范"><a href="#一-命名规范" class="headerlink" title="(一)命名规范"></a>(一)命名规范</h3><h4 id="1-1-1-项目命名"><a href="#1-1-1-项目命名" class="headerlink" title="1.1.1 项目命名"></a>1.1.1 项目命名</h4><p>全部采用小写方式， 以中划线分隔。</p>
<p>正例：<code>mall-management-system</code></p>
<p>反例：<code>mall_management-system / mallManagementSystem</code></p>
<h4 id="1-1-2-目录命名"><a href="#1-1-2-目录命名" class="headerlink" title="1.1.2 目录命名"></a>1.1.2 目录命名</h4><p>全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数</p>
<p>正例： <code>scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc</code></p>
<p>反例： <code>script / style / demo_scripts / demoStyles / imgs / docs</code></p>
<p>【特殊】VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名</p>
<p>正例： <code>head-search / page-loading / authorized / notice-icon</code></p>
<p>反例： <code>HeadSearch / PageLoading</code></p>
<p>【特殊】VUE 的项目中除 components 组件目录外的所有目录也使用 kebab-case 命名<br>正例： <code>page-one / shopping-car / user-management</code></p>
<p>反例： <code>ShoppingCar / UserManagement</code></p>
<h4 id="1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名"><a href="#1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名" class="headerlink" title="1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名"></a>1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</h4><p>全部采用小写方式， 以中划线分隔</p>
<p>正例： <code>render-dom.js / signup.css / index.html / company-logo.png</code></p>
<p>反例： <code>renderDom.js / UserManagement.html</code></p>
<h4 id="1-1-4-命名严谨性"><a href="#1-1-4-命名严谨性" class="headerlink" title="1.1.4 命名严谨性"></a>1.1.4 命名严谨性</h4><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用</p>
<p>正例：<code>henan / luoyang / rmb</code> 等国际通用的名称，可视同英文。</p>
<p>反例：<code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code></p>
<p>杜绝完全不规范的缩写，避免望文不知义：</p>
<p>反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</p>
<h3 id="二-HTML-规范-（Vue-Template-同样适用）"><a href="#二-HTML-规范-（Vue-Template-同样适用）" class="headerlink" title="(二)HTML 规范 （Vue Template 同样适用）"></a>(二)HTML 规范 （Vue Template 同样适用）</h3><h4 id="1-2-1-HTML-类型"><a href="#1-2-1-HTML-类型" class="headerlink" title="1.2.1 HTML 类型"></a>1.2.1 HTML 类型</h4><p>推荐使用 HTML5 的文档类型声明： .<br>（建议使用 text&#x2F;html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application&#x2F;xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p>
<ul>
<li>规定字符编码</li>
<li>IE 兼容模式</li>
<li>规定字符编码</li>
<li>doctype 大写<br>正例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Page title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot; /&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-缩进"><a href="#1-2-2-缩进" class="headerlink" title="1.2.2 缩进"></a>1.2.2 缩进</h4><p>缩进使用 2 个空格（一个 tab）</p>
<p>嵌套的节点应该缩进。</p>
<h4 id="1-2-3-分块注释"><a href="#1-2-3-分块注释" class="headerlink" title="1.2.3 分块注释"></a>1.2.3 分块注释</h4><p>在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式</p>
<p>…</p>
<h4 id="1-2-4-语义化标签"><a href="#1-2-4-语义化标签" class="headerlink" title="1.2.4 语义化标签"></a>1.2.4 语义化标签</h4><p>HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签</p>
<p>正例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;&lt;/header&gt;</span><br><span class="line">&lt;footer&gt;&lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<p>反例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-5-引号"><a href="#1-2-5-引号" class="headerlink" title="1.2.5 引号"></a>1.2.5 引号</h4><p>使用双引号(“”) 而不是单引号(‘’) 。</p>
<p>正例： “”</p>
<p>反例： ‘’</p>
<h3 id="三-CSS-规范"><a href="#三-CSS-规范" class="headerlink" title="(三) CSS 规范"></a>(三) CSS 规范</h3><h4 id="1-3-1-命名"><a href="#1-3-1-命名" class="headerlink" title="1.3.1 命名"></a>1.3.1 命名</h4><ul>
<li>类名使用小写字母，以中划线分隔</li>
<li>id 采用驼峰式命名</li>
<li>scss 中的变量、函数、混合、placeholder 采用驼峰式命名<br>ID 和 class 的名称总是使用可以反映元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</li>
</ul>
<p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.fw-800 &#123;</span><br><span class="line">  font-weight: 800;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.red &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.heavy &#123;</span><br><span class="line">  font-weight: 800;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.important &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-选择器"><a href="#1-3-2-选择器" class="headerlink" title="1.3.2 选择器"></a>1.3.2 选择器</h4><p>1)css 选择器中避免使用标签名<br>从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。</p>
<p>2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。</p>
<p>不推荐:</p>
<p><code>.content .title &#123;   font-size: 2rem; &#125;</code></p>
<p>推荐:</p>
<p><code>.content &gt; .title &#123;   font-size: 2rem; &#125;</code></p>
<h4 id="1-3-3-尽量使用缩写属性"><a href="#1-3-3-尽量使用缩写属性" class="headerlink" title="1.3.3 尽量使用缩写属性"></a>1.3.3 尽量使用缩写属性</h4><p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border-top-style: none;</span><br><span class="line">font-family: palatino, georgia, serif;</span><br><span class="line">font-size: 100%;</span><br><span class="line">line-height: 1.6;</span><br><span class="line">padding-bottom: 2em;</span><br><span class="line">padding-left: 1em;</span><br><span class="line">padding-right: 1em;</span><br><span class="line">padding-top: 0;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-top: 0;</span><br><span class="line">font: 100%/1.6 palatino, georgia, serif;</span><br><span class="line">padding: 0 1em 2em;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-4-每个选择器及属性独占一行"><a href="#1-3-4-每个选择器及属性独占一行" class="headerlink" title="1.3.4 每个选择器及属性独占一行"></a>1.3.4 每个选择器及属性独占一行</h4><p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button&#123;</span><br><span class="line">  width:100px;height:50px;color:#fff;background:#00a0e9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button&#123;</span><br><span class="line">  width:100px;</span><br><span class="line">  height:50px;</span><br><span class="line">  color:#fff;</span><br><span class="line">  background:#00a0e9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-5-省略-0-后面的单位"><a href="#1-3-5-省略-0-后面的单位" class="headerlink" title="1.3.5 省略 0 后面的单位"></a>1.3.5 省略 0 后面的单位</h4><p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  padding-bottom: 0px;</span><br><span class="line">  margin: 0em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  padding-bottom: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-6-避免使用-ID-选择器及全局标签选择器防止污染全局样式"><a href="#1-3-6-避免使用-ID-选择器及全局标签选择器防止污染全局样式" class="headerlink" title="1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式"></a>1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式</h4><p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#header&#123;</span><br><span class="line">  padding-bottom: 0px;</span><br><span class="line">  margin: 0em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.header&#123;</span><br><span class="line">  padding-bottom: 0px;</span><br><span class="line">  margin: 0em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-LESS-规范"><a href="#四-LESS-规范" class="headerlink" title="(四) LESS 规范"></a>(四) LESS 规范</h3><h4 id="1-4-1-代码组织"><a href="#1-4-1-代码组织" class="headerlink" title="1.4.1 代码组织"></a>1.4.1 代码组织</h4><p>1)将公共 less 文件放置在<code>style/less/common</code>文件夹<br>例:<code>// color.less,common.less</code></p>
<p>2)按以下顺序组织</p>
<ul>
<li>1、@import;</li>
<li>2、变量声明;</li>
<li>3、样式声明;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;mixins/size.less&quot;;</span><br><span class="line"></span><br><span class="line">@default-text-color: #333;</span><br><span class="line"></span><br><span class="line">.page &#123;</span><br><span class="line">  width: 960px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-避免嵌套层级过多"><a href="#1-4-2-避免嵌套层级过多" class="headerlink" title="1.4.2 避免嵌套层级过多"></a>1.4.2 避免嵌套层级过多</h4><p>将嵌套深度限制在 3 级。对于超过 4 级的嵌套，给予重新评估。这可以避免出现过于详实的 CSS 选择器。<br>避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于 20 行的嵌套规则出现</p>
<p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line">  .title&#123;</span><br><span class="line">    .name&#123;</span><br><span class="line">       color:#fff</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.main-title&#123;</span><br><span class="line">   .name&#123;</span><br><span class="line">      color:#fff</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-Javascript-规范"><a href="#五-Javascript-规范" class="headerlink" title="(五) Javascript 规范"></a>(五) Javascript 规范</h3><h4 id="1-5-1-命名"><a href="#1-5-1-命名" class="headerlink" title="1.5.1 命名"></a>1.5.1 命名</h4><ol>
<li><p>采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束<br>反例： <code>_name / name_ / name$</code></p>
</li>
<li><p>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。<br>正例： <code>localValue / getHttpMessage() / inputUserId</code></p>
</li>
</ol>
<p><strong>其中 method 方法命名必须是 动词 或者 动词+名词 形式</strong></p>
<p>正例：<code>saveShopCarData /openShopCarInfoDialog</code></p>
<p>反例：<code>save / open / show / go</code></p>
<p><strong>特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）</strong></p>
<p><code>add / update / delete / detail / get</code></p>
<p><strong>附： 函数方法常用的动词:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">get 获取/set 设置,</span><br><span class="line">add 增加/remove 删除</span><br><span class="line">create 创建/destory 移除</span><br><span class="line">start 启动/stop 停止</span><br><span class="line">open 打开/close 关闭,</span><br><span class="line">read 读取/write 写入</span><br><span class="line">load 载入/save 保存,</span><br><span class="line">create 创建/destroy 销毁</span><br><span class="line">begin 开始/end 结束,</span><br><span class="line">backup 备份/restore 恢复</span><br><span class="line">import 导入/export 导出,</span><br><span class="line">split 分割/merge 合并</span><br><span class="line">inject 注入/extract 提取,</span><br><span class="line">attach 附着/detach 脱离</span><br><span class="line">bind 绑定/separate 分离,</span><br><span class="line">view 查看/browse 浏览</span><br><span class="line">edit 编辑/modify 修改,</span><br><span class="line">select 选取/mark 标记</span><br><span class="line">copy 复制/paste 粘贴,</span><br><span class="line">undo 撤销/redo 重做</span><br><span class="line">insert 插入/delete 移除,</span><br><span class="line">add 加入/append 添加</span><br><span class="line">clean 清理/clear 清除,</span><br><span class="line">index 索引/sort 排序</span><br><span class="line">find 查找/search 搜索,</span><br><span class="line">increase 增加/decrease 减少</span><br><span class="line">play 播放/pause 暂停,</span><br><span class="line">launch 启动/run 运行</span><br><span class="line">compile 编译/execute 执行,</span><br><span class="line">debug 调试/trace 跟踪</span><br><span class="line">observe 观察/listen 监听,</span><br><span class="line">build 构建/publish 发布</span><br><span class="line">input 输入/output 输出,</span><br><span class="line">encode 编码/decode 解码</span><br><span class="line">encrypt 加密/decrypt 解密,</span><br><span class="line">compress 压缩/decompress 解压缩</span><br><span class="line">pack 打包/unpack 解包,</span><br><span class="line">parse 解析/emit 生成</span><br><span class="line">connect 连接/disconnect 断开,</span><br><span class="line">send 发送/receive 接收</span><br><span class="line">download 下载/upload 上传,</span><br><span class="line">refresh 刷新/synchronize 同步</span><br><span class="line">update 更新/revert 复原,</span><br><span class="line">lock 锁定/unlock 解锁</span><br><span class="line">check out 签出/check in 签入,</span><br><span class="line">submit 提交/commit 交付</span><br><span class="line">push 推/pull 拉,</span><br><span class="line">expand 展开/collapse 折叠</span><br><span class="line">begin 起始/end 结束,</span><br><span class="line">start 开始/finish 完成</span><br><span class="line">enter 进入/exit 退出,</span><br><span class="line">abort 放弃/quit 离开</span><br><span class="line">obsolete 废弃/depreciate 废旧,</span><br><span class="line">collect 收集/aggregate 聚集</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>正例： <code>MAX_STOCK_COUNT</code></li>
</ol>
<p>反例： <code>MAX_COUNT</code></p>
<h4 id="1-5-2-代码格式"><a href="#1-5-2-代码格式" class="headerlink" title="1.5.2 代码格式"></a>1.5.2 代码格式</h4><ol>
<li>使用 2 个空格进行缩进<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (x &lt; y) &#123;</span><br><span class="line">  x += 10;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  x += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。<br>说明：任何情形，没有必要插入多个空行进行隔开。</li>
</ol>
<h4 id="1-5-3-字符串"><a href="#1-5-3-字符串" class="headerlink" title="1.5.3 字符串"></a>1.5.3 字符串</h4><p>统一使用单引号(‘’)，不使用双引号(“”)。这在创建 HTML 字符串非常有好处：</p>
<p>正例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;foo&#x27;;</span><br><span class="line">let testDiv = &#x27;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<p>反例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;foo&quot;;</span><br><span class="line">let testDiv = &quot;&lt;div id=&#x27;test&#x27;&gt;&lt;/div&gt;&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-4-对象声明"><a href="#1-5-4-对象声明" class="headerlink" title="1.5.4 对象声明"></a>1.5.4 对象声明</h4><p>1)使用字面值创建对象<br>正例：<code> let user = &#123;&#125;;</code></p>
<p>反例： <code>let user = new Object();</code></p>
<ol start="2">
<li>使用字面量来代替对象构造器<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  age: 0,</span><br><span class="line">  name: 1,</span><br><span class="line">  city: 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var user = new Object();</span><br><span class="line">user.age = 0;</span><br><span class="line">user.name = 0;</span><br><span class="line">user.city = 0;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-5-使用-ES6-7"><a href="#1-5-5-使用-ES6-7" class="headerlink" title="1.5.5 使用 ES6,7"></a>1.5.5 使用 ES6,7</h4><p>必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</p>
<p>必须强制使用 ES6, ES7 的新语法，比如箭头函数、await&#x2F;async ， 解构， let ， for…of 等等</p>
<h4 id="1-5-6-括号"><a href="#1-5-6-括号" class="headerlink" title="1.5.6 括号"></a>1.5.6 括号</h4><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (condition) doSomething();</span><br></pre></td></tr></table></figure>

<h4 id="1-5-7-undefined-判断"><a href="#1-5-7-undefined-判断" class="headerlink" title="1.5.7 undefined 判断"></a>1.5.7 undefined 判断</h4><p>永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof person === &#x27;undefined&#x27;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (person === undefined) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-8-条件判断和循环最多三层"><a href="#1-5-8-条件判断和循环最多三层" class="headerlink" title="1.5.8 条件判断和循环最多三层"></a>1.5.8 条件判断和循环最多三层</h4><p>条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。</p>
<h4 id="1-5-9-this-的转换命名"><a href="#1-5-9-this-的转换命名" class="headerlink" title="1.5.9 this 的转换命名"></a>1.5.9 this 的转换命名</h4><p>对上下文 this 的引用只能使用’self’来命名</p>
<h4 id="1-5-10-慎用-console-log"><a href="#1-5-10-慎用-console-log" class="headerlink" title="1.5.10 慎用 console.log"></a>1.5.10 慎用 console.log</h4><p>因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能</p>
<h2 id="二、Vue-项目规范"><a href="#二、Vue-项目规范" class="headerlink" title="二、Vue 项目规范"></a>二、Vue 项目规范</h2><h3 id="一-Vue-编码基础"><a href="#一-Vue-编码基础" class="headerlink" title="(一) Vue 编码基础"></a>(一) Vue 编码基础</h3><p>vue 项目规范以 Vue 官方规范 （<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/style-guide/%EF%BC%89">https://cn.vuejs.org/v2/style-guide/）</a> 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</p>
<p>请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</p>
<h4 id="2-1-1-组件规范"><a href="#2-1-1-组件规范" class="headerlink" title="2.1.1. 组件规范"></a>2.1.1. 组件规范</h4><ol>
<li>组件名为多个单词。<br>组件名应该始终是多个单词组成（大于等于 2），且命名规范为 KebabCase 格式。<br>这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</li>
</ol>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;TodoItem&#x27;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Todo&#x27;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;todo-item&#x27;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>组件文件名为 pascal-case 格式<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- my-component.vue</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- myComponent.vue</span><br><span class="line">|- MyComponent.vue</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>基础组件文件名为 base 开头，使用完整单词而不是缩写。<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- base-button.vue</span><br><span class="line">|- base-table.vue</span><br><span class="line">|- base-icon.vue</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- MyButton.vue</span><br><span class="line">|- VueTable.vue</span><br><span class="line">|- Icon.vue</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- todo-list.vue</span><br><span class="line">|- todo-list-item.vue</span><br><span class="line">|- todo-list-item-button.vue</span><br><span class="line">|- user-profile-options.vue （完整单词）</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoItem.vue</span><br><span class="line">|- TodoButton.vue</span><br><span class="line">|- UProfOpts.vue （使用了缩写）</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span><br><span class="line">&lt;MyComponent /&gt;</span><br><span class="line">&lt;Row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/Row&gt;</span><br><span class="line">反例：</span><br><span class="line"></span><br><span class="line">&lt;my-component /&gt; &lt;row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/row&gt;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>组件的 data 必须是一个函数<br>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。</li>
</ol>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#x27;jack&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &#x27;jack&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Prop 定义应该尽量详细</li>
</ol>
<ul>
<li>必须使用 camelCase 驼峰命名</li>
<li>必须指定类型</li>
<li>必须加上注释，表明其含义</li>
<li>必须加上 required 或者 default，两者二选其一</li>
<li>如果有业务需要，必须加上 validator 验证<br>正例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  // 组件状态，用于控制组件的颜色</span><br><span class="line">   status: &#123;</span><br><span class="line">     type: String,</span><br><span class="line">     required: true,</span><br><span class="line">     validator: function (value) &#123;</span><br><span class="line">       return [</span><br><span class="line">         &#x27;succ&#x27;,</span><br><span class="line">         &#x27;info&#x27;,</span><br><span class="line">         &#x27;error&#x27;</span><br><span class="line">       ].indexOf(value) !== -1</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">    // 用户级别，用于显示皇冠个数</span><br><span class="line">   userLevel：&#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>为组件样式设置作用域<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用 `scoped` 特性 --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .btn-close &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;!-- 没有使用 `scoped` 特性 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .btn-close &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>如果特性元素较多，应该主动换行。<br>正例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class="line">    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class="line">    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class="line"> /&gt;</span><br><span class="line">反例：</span><br><span class="line"></span><br><span class="line">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-模板中使用简单的表达式"><a href="#2-1-2-模板中使用简单的表达式" class="headerlink" title="2.1.2. 模板中使用简单的表达式"></a>2.1.2. 模板中使用简单的表达式</h4><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; normalizedFullName &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 复杂表达式已经移入一个计算属性</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedFullName: function () &#123;</span><br><span class="line">    return this.fullName.split(&#x27; &#x27;).map(function (word) &#123;</span><br><span class="line">      return word[0].toUpperCase() + word.slice(1)</span><br><span class="line">    &#125;).join(&#x27; &#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">       &#123;&#123;</span><br><span class="line">          fullName.split(&#x27; &#x27;).map(function (word) &#123;</span><br><span class="line">             return word[0].toUpperCase() + word.slice(1)</span><br><span class="line">           &#125;).join(&#x27; &#x27;)</span><br><span class="line">        &#125;&#125;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-指令都使用缩写形式"><a href="#2-1-3-指令都使用缩写形式" class="headerlink" title="2.1.3 指令都使用缩写形式"></a>2.1.3 指令都使用缩写形式</h4><p>指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  @input=&quot;onInput&quot;</span><br><span class="line">  @focus=&quot;onFocus&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-on:input=&quot;onInput&quot;</span><br><span class="line">  @focus=&quot;onFocus&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-标签顺序保持一致"><a href="#2-1-4-标签顺序保持一致" class="headerlink" title="2.1.4 标签顺序保持一致"></a>2.1.4 标签顺序保持一致</h4><p>单文件组件应该总是让标签顺序保持为 &#96;</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;...&lt;/template&gt;</span><br><span class="line">&lt;script&gt;...&lt;/script&gt;</span><br><span class="line">&lt;style&gt;...&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;...&lt;/template&gt;</span><br><span class="line">&lt;style&gt;...&lt;/style&gt;</span><br><span class="line">&lt;script&gt;...&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-必须为-v-for-设置键值-key"><a href="#2-1-5-必须为-v-for-设置键值-key" class="headerlink" title="2.1.5 必须为 v-for 设置键值 key"></a>2.1.5 必须为 v-for 设置键值 key</h4><h4 id="2-1-6-v-show-与-v-if-选择"><a href="#2-1-6-v-show-与-v-if-选择" class="headerlink" title="2.1.6 v-show 与 v-if 选择"></a>2.1.6 v-show 与 v-if 选择</h4><p>如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</p>
<h4 id="2-1-7-script-标签内部结构顺序"><a href="#2-1-7-script-标签内部结构顺序" class="headerlink" title="2.1.7 script 标签内部结构顺序"></a>2.1.7 script 标签内部结构顺序</h4><p>components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</p>
<h4 id="2-1-8-Vue-Router-规范"><a href="#2-1-8-Vue-Router-规范" class="headerlink" title="2.1.8 Vue Router 规范"></a>2.1.8 Vue Router 规范</h4><ol>
<li>页面跳转数据传递使用路由参数<br>页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。</li>
</ol>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let id = &#x27;123&#x27;;</span><br><span class="line">this.$router.push(&#123; name: &#x27;userCenter&#x27;, query: &#123; id: id &#125; &#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用路由懒加载（延迟加载）机制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/uploadAttachment&#x27;,</span><br><span class="line">    name: &#x27;uploadAttachment&#x27;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#x27;上传附件&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () =&gt; import(&#x27;@/view/components/uploadAttachment/index.vue&#x27;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>router 中的命名规范<br>path、childrenPoints 命名规范采用 kebab-case 命名规范（尽量 vue 文件的目录结构保持一致，因为目录、文件名都是 kebab-case，这样很方便找到对应的文件）</li>
</ol>
<p>name 命名规范采用 KebabCase 命名规范且和 component 组件名保持一致！（因为要保持 keep-alive 特性，keep-alive 按照 component 的 name 进行缓存，所以两者必须高度保持一致）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 动态加载</span><br><span class="line">export const reload = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/reload&#x27;,</span><br><span class="line">    name: &#x27;reload&#x27;,</span><br><span class="line">    component: Main,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#x27;动态加载&#x27;,</span><br><span class="line">      icon: &#x27;icon iconfont&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/reload/smart-reload-list&#x27;,</span><br><span class="line">        name: &#x27;SmartReloadList&#x27;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          title: &#x27;SmartReload&#x27;,</span><br><span class="line">          childrenPoints: [</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#x27;查询&#x27;,</span><br><span class="line">              name: &#x27;smart-reload-search&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#x27;执行reload&#x27;,</span><br><span class="line">              name: &#x27;smart-reload-update&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#x27;查看执行结果&#x27;,</span><br><span class="line">              name: &#x27;smart-reload-result&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        component: () =&gt;</span><br><span class="line">          import(&#x27;@/views/reload/smart-reload/smart-reload-list.vue&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>router 中的 path 命名规范<br>path 除了采用 kebab-case 命名规范以外，必须以 &#x2F; 开头，即使是 children 里的 path 也要以 &#x2F; 开头。如下示例</li>
</ol>
<p>目的：</p>
<p>经常有这样的场景：某个页面有问题，要立刻找到这个 vue 文件，如果不用以&#x2F;开头，path 为 parent 和 children 组成的，可能经常需要在 router 文件里搜索多次才能找到，而如果以&#x2F;开头，则能立刻搜索到对应的组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/file&#x27;,</span><br><span class="line">    name: &#x27;File&#x27;,</span><br><span class="line">    component: Main,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#x27;文件服务&#x27;,</span><br><span class="line">      icon: &#x27;ios-cloud-upload&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/file/file-list&#x27;,</span><br><span class="line">        name: &#x27;FileList&#x27;,</span><br><span class="line">        component: () =&gt; import(&#x27;@/views/file/file-list.vue&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/file/file-add&#x27;,</span><br><span class="line">        name: &#x27;FileAdd&#x27;,</span><br><span class="line">        component: () =&gt; import(&#x27;@/views/file/file-add.vue&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/file/file-update&#x27;,</span><br><span class="line">        name: &#x27;FileUpdate&#x27;,</span><br><span class="line">        component: () =&gt; import(&#x27;@/views/file/file-update.vue&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二-Vue-项目目录规范"><a href="#二-Vue-项目目录规范" class="headerlink" title="(二) Vue 项目目录规范"></a>(二) Vue 项目目录规范</h3><h4 id="2-2-1-基础"><a href="#2-2-1-基础" class="headerlink" title="2.2.1 基础"></a>2.2.1 基础</h4><p>vue 项目中的所有命名一定要与后端命名统一。</p>
<p>比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！</p>
<h4 id="2-2-2-使用-Vue-cli-脚手架"><a href="#2-2-2-使用-Vue-cli-脚手架" class="headerlink" title="2.2.2 使用 Vue-cli 脚手架"></a>2.2.2 使用 Vue-cli 脚手架</h4><p>使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。</p>
<h4 id="2-2-3-目录说明"><a href="#2-2-3-目录说明" class="headerlink" title="2.2.3 目录说明"></a>2.2.3 目录说明</h4><p>目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">src                               源码目录</span><br><span class="line">|-- api                              所有api接口</span><br><span class="line">|-- assets                           静态资源，images, icons, styles等</span><br><span class="line">|-- components                       公用组件</span><br><span class="line">|-- config                           配置信息</span><br><span class="line">|-- constants                        常量信息，项目所有Enum, 全局常量等</span><br><span class="line">|-- directives                       自定义指令</span><br><span class="line">|-- filters                          过滤器，全局工具</span><br><span class="line">|-- datas                            模拟数据，临时存放</span><br><span class="line">|-- lib                              外部引用的插件存放及修改文件</span><br><span class="line">|-- mock                             模拟接口，临时存放</span><br><span class="line">|-- plugins                          插件，全局使用</span><br><span class="line">|-- router                           路由，统一管理</span><br><span class="line">|-- store                            vuex, 统一管理</span><br><span class="line">|-- themes                           自定义样式主题</span><br><span class="line">|-- views                            视图目录</span><br><span class="line">|   |-- role                             role模块名</span><br><span class="line">|   |-- |-- role-list.vue                    role列表页面</span><br><span class="line">|   |-- |-- role-add.vue                     role新建页面</span><br><span class="line">|   |-- |-- role-update.vue                  role更新页面</span><br><span class="line">|   |-- |-- index.less                      role模块样式</span><br><span class="line">|   |-- |-- components                      role模块通用组件文件夹</span><br><span class="line">|   |-- employee                         employee模块</span><br></pre></td></tr></table></figure>

<ol>
<li>api 目录</li>
</ol>
<ul>
<li>文件、变量命名要与后端保持一致。</li>
<li>此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。</li>
<li>api 中的方法名字要与后端 api url 尽量保持语义高度一致性。</li>
<li>对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。<br>正例：</li>
</ul>
<p>后端 url： EmployeeController.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/employee/add</span><br><span class="line">/employee/delete/&#123;id&#125;</span><br><span class="line">/employee/update</span><br></pre></td></tr></table></figure>

<p>前端： employee.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 添加员工</span><br><span class="line">addEmployee: (data) =&gt; &#123;</span><br><span class="line">    return postAxios(&#x27;/employee/add&#x27;, data)</span><br><span class="line">&#125;,</span><br><span class="line">// 更新员工信息</span><br><span class="line">updateEmployee: (data) =&gt; &#123;</span><br><span class="line">    return postAxios(&#x27;/employee/update&#x27;, data)</span><br><span class="line">&#125;,</span><br><span class="line">// 删除员工</span><br><span class="line">deleteEmployee: (employeeId) =&gt; &#123;</span><br><span class="line">    return postAxios(&#x27;/employee/delete/&#x27; + employeeId)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>assets 目录<br>assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|assets</span><br><span class="line">|-- icons</span><br><span class="line">|-- images</span><br><span class="line">|   |-- background-color.png</span><br><span class="line">|   |-- upload-header.png</span><br><span class="line">|-- styles</span><br><span class="line">3) components 目录</span><br><span class="line">此目录应按照组件进行目录划分，目录命名为 KebabCase，组件命名规则也为 KebabCase</span><br><span class="line"></span><br><span class="line">|components</span><br><span class="line">|-- error-log</span><br><span class="line">|   |-- index.vue</span><br><span class="line">|   |-- index.less</span><br><span class="line">|-- markdown-editor</span><br><span class="line">|   |-- index.vue</span><br><span class="line">|   |-- index.js</span><br><span class="line">|-- kebab-case</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>constants 目录<br>此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件(<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/vue-enum">https://www.npmjs.com/package/vue-enum</a>)</li>
</ol>
<p>目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|constants</span><br><span class="line">|-- index.js</span><br><span class="line">|-- role.js</span><br><span class="line">|-- employee.js</span><br></pre></td></tr></table></figure>

<p>例子： employee.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">export const EMPLOYEE_STATUS = &#123;</span><br><span class="line">  NORMAL: &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    desc: &#x27;正常&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  DISABLED: &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    desc: &#x27;禁用&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  DELETED: &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    desc: &#x27;已删除&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const EMPLOYEE_ACCOUNT_TYPE = &#123;</span><br><span class="line">  QQ: &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    desc: &#x27;QQ登录&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  WECHAT: &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    desc: &#x27;微信登录&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  DINGDING: &#123;</span><br><span class="line">    value: 3,</span><br><span class="line">    desc: &#x27;钉钉登录&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  USERNAME: &#123;</span><br><span class="line">    value: 4,</span><br><span class="line">    desc: &#x27;用户名密码登录&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  EMPLOYEE_STATUS,</span><br><span class="line">  EMPLOYEE_ACCOUNT_TYPE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>router 与 store 目录<br>这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。</li>
</ol>
<p>router 尽量按照 views 中的结构保持一致</p>
<p>store 按照业务进行拆分不同的 js 文件</p>
<ol start="6">
<li>views 目录</li>
</ol>
<ul>
<li>命名要与后端、router、api 等保持一致</li>
<li>components 中组件要使用 PascalCase 规则</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|-- views                            视图目录</span><br><span class="line">|   |-- role                             role模块名</span><br><span class="line">|   |   |-- role-list.vue                    role列表页面</span><br><span class="line">|   |   |-- role-add.vue                     role新建页面</span><br><span class="line">|   |   |-- role-update.vue                  role更新页面</span><br><span class="line">|   |   |-- index.less                      role模块样式</span><br><span class="line">|   |   |-- components                      role模块通用组件文件夹</span><br><span class="line">|   |   |   |-- role-header.vue                        role头部组件</span><br><span class="line">|   |   |   |-- role-modal.vue                         role弹出框组件</span><br><span class="line">|   |-- employee                         employee模块</span><br><span class="line">|   |-- behavior-log                      行为日志log模块</span><br><span class="line">|   |-- code-generator                    代码生成器模块</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-注释说明"><a href="#2-2-4-注释说明" class="headerlink" title="2.2.4 注释说明"></a>2.2.4 注释说明</h4><p>整理必须加注释的地方</p>
<ul>
<li>公共组件使用说明</li>
<li>api 目录的接口 js 文件必须加注释</li>
<li>store 中的 state, mutation, action 等必须加注释</li>
<li>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释</li>
<li>vue 文件的 methods，每个 method 必须添加注释</li>
<li>vue 文件的 data, 非常见单词要加注释</li>
</ul>
<h4 id="2-2-5-其他"><a href="#2-2-5-其他" class="headerlink" title="2.2.5 其他"></a>2.2.5 其他</h4><ol>
<li><p>尽量不要手动操作 DOM<br>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。</p>
</li>
<li><p>删除无用代码<br>因使用了 git&#x2F;svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%8E%8210%E9%81%93%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%8E%8210%E9%81%93%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">前端大厂10道经典面试题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 11:13:08 / 修改时间：11:20:17" itemprop="dateCreated datePublished" datetime="2022-12-16T11:13:08+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">前端算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、写一个-js-函数，实现对一个数字每-3-位加一个逗号，如输入-100000，-输出-100-000（不考虑负数，小数）—百度前端面试题"><a href="#1、写一个-js-函数，实现对一个数字每-3-位加一个逗号，如输入-100000，-输出-100-000（不考虑负数，小数）—百度前端面试题" class="headerlink" title="1、写一个 js 函数，实现对一个数字每 3 位加一个逗号，如输入 100000， 输出 100,000（不考虑负数，小数）—百度前端面试题"></a>1、写一个 js 函数，实现对一个数字每 3 位加一个逗号，如输入 100000， 输出 100,000（不考虑负数，小数）—百度前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let arr = []</span><br><span class="line">function main(num) &#123;</span><br><span class="line">    if (num === null) return</span><br><span class="line">    let n = parseInt(num).toString()</span><br><span class="line">    s(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function s(num) &#123;</span><br><span class="line">    if (num.length &gt; 3) &#123;</span><br><span class="line">        arr[arr.length] = num.slice(-3)</span><br><span class="line">        s(num.slice(0, -3))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        arr[arr.length] = num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main(123456789)</span><br><span class="line"></span><br><span class="line">console.log(arr.reverse().join(&quot;,&quot;))</span><br></pre></td></tr></table></figure>

<p>解题思路<br>本题是 js 实现 number.toLocaleString()方法，面试题做了简化不考虑负数小数，此题主要是考数据类型及字符串操作，答案不唯一。</p>
<p>按现实思路解题，现实中添加千位分隔符是从后到前，每 3 位添加逗号，所以这里输入数据转换成字符串后，利用 slice 方法的输入负数参数从后取的特点，从后取三位数字保存在数组中，并把取剩后的数据递归重复取值，直到数据不足 3 位，把剩下一起存入数组中。</p>
<p>这时数组中按顺序保存从后到前的分割数据。实例中数组是[‘789’,’456’,’123’]。通过 reverse 方法倒序输出，并通过 join 方法添加逗号。</p>
<h2 id="2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题"><a href="#2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题" class="headerlink" title="2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题"></a>2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">//     let n = s.length;</span><br><span class="line">//     let set = new Set();</span><br><span class="line">//     let ans = 0, i = 0, j = 0;</span><br><span class="line">//     while (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">//         if (!set.has(s[j])) &#123;</span><br><span class="line">//             set.add(s[j++]);</span><br><span class="line">//             ans = Math.max(ans, j - i);</span><br><span class="line">//         &#125; else &#123;</span><br><span class="line">//             set.delete(s[i++]);</span><br><span class="line">//         &#125;</span><br><span class="line">//     &#125;</span><br><span class="line">//     return ans;</span><br><span class="line">// &#125;;</span><br><span class="line"></span><br><span class="line">//时间复杂度：O(2n) = O(n)O(2n)=O(n)，在最糟糕的情况下，每个字符将被 ii 和 jj 访问两次。</span><br><span class="line">//空间复杂度：O(min(m, n))O(min(m,n))，与之前的方法相同。滑动窗口法需要 O(k)O(k) 的空间，其中 kk 表示 Set 的大小。而Set的大小取决于字符串 nn 的大小以及字符集/字母 mm 的大小。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function StrLen(str) &#123;</span><br><span class="line">    let result = 1    //最终要返回的结果的初始值</span><br><span class="line">    let norepeatStr = &#x27;&#x27; //用于存放无重复字符串</span><br><span class="line">    let len = str.length</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        //charAt()获取的是字符串索引对应的具体字符</span><br><span class="line">        let specStr = str.charAt(i)</span><br><span class="line">        //indexOf()查找的是某个字符第一次出现并返回这个索引值，若没有这个字符，返回-1</span><br><span class="line">        let index = norepeatStr.indexOf(specStr)</span><br><span class="line">        if (index === -1) &#123;</span><br><span class="line">            //将遍历得到的字符（未重复）拼接在norepeatStr后面</span><br><span class="line">            norepeatStr = norepeatStr + specStr</span><br><span class="line">            result = result &lt; norepeatStr.length ? norepeatStr.length : result</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //若遇到重复的字符，那么将已出现在norepeatStr里的字符删除，并将新的（重复的添加到末尾）</span><br><span class="line">            norepeatStr = norepeatStr.substr(index + 1) + specStr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(StrLen(abbbcbd))</span><br></pre></td></tr></table></figure>

<p>解题思路<br>这题的要点就是无重复字符的理解。首先字符串内字符位置是固定的，我们要采用顺序循环的方式解题，然后就是理解无重复字符的含义，把当前字符串分割，每个小分割内不能出现重复的字符。也就是说分割的字符串是不会互相叠加重复的，每当该段分割的下一个字符与该段分割内字符相同，当即重新开始分割字符。</p>
<p>所以解题时需要一个存储当前分割片段的对象，用来比较下一个字符。并取这个分割片段的长度，与每个分割片段的最大长度比较即可。本题主要考的是题面的理解，以及字符串方法的运用，需要熟练地运用才能快速解题。</p>
<h2 id="3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题"><a href="#3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题" class="headerlink" title="3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题"></a>3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">    let a = &#x27;333333333333333333333333333&#x27;</span><br><span class="line">    let b = &#x27;9999999999999999999&#x27;</span><br><span class="line">    let n1 = a.length</span><br><span class="line">    let n2 = b.length</span><br><span class="line">    for (let i = 0; i &lt; Math.max(n1, n2) - Math.min(n1, n2); i ++) &#123;</span><br><span class="line">        if (n1 &gt; n2) b = &#x27;0&#x27; + b</span><br><span class="line">        if (n2 &gt; n1) a = &#x27;0&#x27; + a</span><br><span class="line">    &#125;</span><br><span class="line">    a = a.split(&#x27;&#x27;).reverse()</span><br><span class="line">    b = b.split(&#x27;&#x27;).reverse()</span><br><span class="line">    //split()基于指定的分隔符将一个字符串分割成多个子字符串并将结果放在一个数组中</span><br><span class="line">    //reverse()反转数组项的顺序（加法计算顺序）</span><br><span class="line">    //现在a，b数组中存储着相同个数的大数字的逆顺序拆解</span><br><span class="line"></span><br><span class="line">    let n = Math.max(n1, n2)</span><br><span class="line">    let result = Array.apply(this, Array(n)).map((item, i) =&gt; &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;)</span><br><span class="line">    //生成一个长度为n的每个元素都为0的数组（用来保存最终结果）</span><br><span class="line"></span><br><span class="line">    for (let k = 0; k &lt; n; k ++) &#123;</span><br><span class="line">        let temp = parseInt(a[k]) + parseInt(b[k])</span><br><span class="line">        if (temp &gt; 9) &#123;</span><br><span class="line">            result[k] += temp - 10</span><br><span class="line">            result[k+1] = 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result[k] += temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把ab数组中的数字相加减，注意进位</span><br><span class="line"></span><br><span class="line">    console.log(result.reverse().join(&#x27;&#x27;).toString())</span><br><span class="line">    //将数组项基于指定的分隔符以字符串输出</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>解题思路<br>首先了解超出存储范围的大数字概念，每种数据类型可存储数据量都是存在范围的</p>
<p>数字类型的范围：</p>
<p>Number.MAX_VALUE &#x3D; 1.7976931348623157e+308</p>
<p>Number.MIN_VALUE &#x3D; 5e-324</p>
<p>整数类型的范围：-2-53-253</p>
<p>当超出这个范围，为了避免数据丢失，就要采用其他手段进行运算。在参考答案中，运用数组的方式解决这个问题。首先两个大整数要存储在数组中，要先保证位数对齐，我们比较字符串长度把低位数的大整数字符串前面添加相应的 0 占位， 并逆排序。创建一个新的数组保存运算结果，将两个大整数按从后到前的顺序进行相加减，这里注意进位。把得到的数组反转到正常顺序即可。</p>
<h2 id="4、任意数组的全排列组合—阿里巴巴前端面试题"><a href="#4、任意数组的全排列组合—阿里巴巴前端面试题" class="headerlink" title="4、任意数组的全排列组合—阿里巴巴前端面试题"></a>4、任意数组的全排列组合—阿里巴巴前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;hello&#x27;,&#x27;world&#x27;];</span><br><span class="line">var count = 1;</span><br><span class="line">function getStr(a)&#123;</span><br><span class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">		// indexOf 是es6数组的方法,如果不存在返回-1，存在返回下标</span><br><span class="line">		if(a.indexOf(arr[i])&lt;0)&#123;</span><br><span class="line"></span><br><span class="line">			//数组 a 中不存在 arr[i],将arr[i]添加到数组末尾</span><br><span class="line">			a.push(arr[i]);</span><br><span class="line"></span><br><span class="line">			if(a.length==arr.length)&#123;</span><br><span class="line">				console.log(count++ + &#x27;: &#x27; +a.join(&quot;&quot;));</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				//结束一次for循环  进行了4次递归 getStr([&#x27;foo&#x27;]) getStr([&#x27;bar&#x27;]) getStr([&#x27;hello&#x27;]) getStr([&#x27;world&#x27;])</span><br><span class="line">				getStr(a);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			//一定从数组 a 中删除arr[i],进行下次循环，如果不删除就只能获得一种结果了</span><br><span class="line">			a.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">getStr([])</span><br></pre></td></tr></table></figure>

<p>解题思路<br>本题做法不唯一，这里采用了把多项数组逐步两两相乘的方式，第一次先取二维数组前两项组合，把组合的结果在与第三项组合以此类推。这种递归做法简单易懂，把复杂的多项问题简化成两项问题的逐渐递增。</p>
<h2 id="5、公司最近新研发了一种产品，共生产了-n-件。有-m-个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题"><a href="#5、公司最近新研发了一种产品，共生产了-n-件。有-m-个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题" class="headerlink" title="5、公司最近新研发了一种产品，共生产了 n 件。有 m 个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题"></a>5、公司最近新研发了一种产品，共生产了 n 件。有 m 个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let n = 3</span><br><span class="line">let m = 4</span><br><span class="line">let arr = [2, 8, 10, 7]</span><br><span class="line">let key = 0, max = 0</span><br><span class="line">arr = arr.sort( (a, b) =&gt; &#123;</span><br><span class="line">    return a - b   //升序</span><br><span class="line">&#125;)</span><br><span class="line">if (n &lt; m) &#123;</span><br><span class="line">    arr = arr.slice(m - n)  //截取出价高的人</span><br><span class="line">&#125;</span><br><span class="line">for (let i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    if (max &lt; arr[i] * (arr.length - i)) &#123;</span><br><span class="line">        max = arr[i] * (arr.length - i)</span><br><span class="line">        key = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(key)</span><br></pre></td></tr></table></figure>

<p>解题思路<br>本题是京东的业务演变题，首先要理清思路。本题中，固定出价，以及出价低于产品的顾客会被拒绝购买是解题核心。</p>
<p>条件中已知产品总个数，顾客出价。这里有个小陷阱，会出现 N&lt;M 供不应求的情况，要特殊考虑。依据题目，我们首先需要对顾客出价排序，这里按升序排列。当供不应求出现时，我们截取出价高的顾客。然后把每个顾客的出价当做最终售价循环，得出最大化利润下的售价。</p>
<h2 id="6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题"><a href="#6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题" class="headerlink" title="6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题"></a>6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let s = &#x27;asdaaaaaad&#x27;</span><br><span class="line">let count = 0, char = &#x27;&#x27;         //count出现次数 char字符</span><br><span class="line">let arr = []        // 储存去重后字符</span><br><span class="line">function foo(str) &#123;         // 去重</span><br><span class="line">    return r = str.split(&quot;&quot;).filter(function (element, index, self) &#123;</span><br><span class="line">        return self.indexOf(element) === index     // 输出第一次出现的字符</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr = foo(s)</span><br><span class="line">for (let i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    let n = (s.split(arr[i])).length - 1           //出现次数</span><br><span class="line">    if (count &lt; n) &#123;</span><br><span class="line">        count = n</span><br><span class="line">        char = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;count:&quot; + count + &quot;,char:&quot; + char)</span><br></pre></td></tr></table></figure>

<p>解题思路<br>计算出全部字符出现次数，并留下最大的。首先利用 filter()与 indexOf()的方法连用字符串去重，再将得到的作为索引，利用 split()分割字符串，得到字符出现次数，比较得出结果。</p>
<h2 id="7、”123456789876543212345678987654321…”的第-n-位是什么？—小米面试题"><a href="#7、”123456789876543212345678987654321…”的第-n-位是什么？—小米面试题" class="headerlink" title="7、”123456789876543212345678987654321…”的第 n 位是什么？—小米面试题"></a>7、”123456789876543212345678987654321…”的第 n 位是什么？—小米面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let k = &quot;1234567898765432&quot;  //最小循环节</span><br><span class="line">function getNum(n) &#123;</span><br><span class="line">    console.log(k.charAt(n % k.length - 1))</span><br><span class="line">&#125;</span><br><span class="line">getNum(20)</span><br></pre></td></tr></table></figure>

<p>解题思路<br>这道题的答案不唯一，这里可以利用数学中最小循环节的概念解题，找到最小循环节后，利用余数查找第 n 位数字。</p>
<h2 id="8、请编写一个-JavaScript-函数-parseQueryString，它的用途是把-URL-参数解析为一个对象—淘宝面试题"><a href="#8、请编写一个-JavaScript-函数-parseQueryString，它的用途是把-URL-参数解析为一个对象—淘宝面试题" class="headerlink" title="8、请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象—淘宝面试题"></a>8、请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象—淘宝面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function parseQueryString(url) &#123;</span><br><span class="line">  var pos = url.indexOf(&quot;?&quot;)</span><br><span class="line">  var obj = &#123;&#125;</span><br><span class="line">  if (pos != -1) &#123;</span><br><span class="line">    var urlString=url.slice(pos+1)</span><br><span class="line">    var urlArr = urlString.split(&quot;&amp;&quot;)</span><br><span class="line">    var keyValue = []</span><br><span class="line">    for (var i = 0; i &lt; urlArr.length; i++) &#123;</span><br><span class="line">      keyValue = urlArr[i].split(&quot;=&quot;)</span><br><span class="line">      obj[keyValue[0]]=keyValue[1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解题思路<br>淘宝这道题是很常用的场景题，这里需要处理好分段次序，首先把？分离，然后按&amp;分割最后按&#x3D;分割，主要考察字符串的函数运用以及对象的创建。</p>
<h2 id="9、如果给定的字符串是回文，返回-true，反之，返回-false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是-palindrome-回文-。—网易前端面试题"><a href="#9、如果给定的字符串是回文，返回-true，反之，返回-false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是-palindrome-回文-。—网易前端面试题" class="headerlink" title="9、如果给定的字符串是回文，返回 true，反之，返回 false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是 palindrome(回文)。—网易前端面试题"></a>9、如果给定的字符串是回文，返回 true，反之，返回 false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是 palindrome(回文)。—网易前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function palindrome(str) &#123;</span><br><span class="line">    let str1 = str.replace(/[^0-9a-zA-Z]/g,&quot;&quot;).toLowerCase()  // 去掉标点符号，转化成小写，比较参数一</span><br><span class="line">    let str2 = str1.split(&quot;&quot;).reverse().join(&quot;&quot;)   // 翻转字符串，比较参数二</span><br><span class="line">    if (str1 === str2) &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125; else return false</span><br><span class="line">&#125;</span><br><span class="line">console.log(palindrome(&quot;aBc,./1d42--==EFG0 00 h0 &#x27;;00gfE&#x27; ./.24d 1cBA&quot;)) // 输出结果：true</span><br></pre></td></tr></table></figure>

<p>解题思路<br>去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。</p>
<h2 id="10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题"><a href="#10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题" class="headerlink" title="10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题"></a>10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function titleCase(str) &#123;</span><br><span class="line">    let aStr = str.toLowerCase().split(&quot; &quot;)   // 转小写，分割成字符串数组</span><br><span class="line">    for (let i = 0; i &lt; aStr.length; i ++) &#123;</span><br><span class="line">        aStr[i] = aStr[i][0].toUpperCase() + aStr[i].slice(1) // 重新组合字符串元素</span><br><span class="line">    &#125;</span><br><span class="line">    let oString = aStr.join(&quot; &quot;)  //转成字符串</span><br><span class="line">    return oString</span><br><span class="line">&#125;</span><br><span class="line">console.log(titleCase(&quot;I&#x27;m a title Case&quot;)) // 输出结果为 I&#x27;m A Title Case</span><br></pre></td></tr></table></figure>

<p>解题思路<br>字符串转化成小写；<br>分割成字符串数组；<br>新组合字符串元素&#x3D;首字母转大写+其余小写。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/guochangxindeGH/LeetCode/tree/master/Algorithms/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB">代码 github 地址</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">数据结构有哪些，常用数据结构详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 11:12:58 / 修改时间：11:19:57" itemprop="dateCreated datePublished" datetime="2022-12-16T11:12:58+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">前端算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数据结构大致包含以下几种存储结构：</p>
<ul>
<li>线性表，还可细分为顺序表、链表、栈和队列；</li>
<li>树结构，包括普通树，二叉树，线索二叉树等；</li>
<li>图存储结构；</li>
</ul>
<p>下面对各种数据结构做详细讲解。</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表结构存储的数据往往是可以依次排列的，就像小朋友手拉手，每位学生的前面和后面都仅有一个小朋友和他拉手，具备这种“一对一”关系的数据就可以使用线性表来存储。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH151411.gif" alt="image"></p>
<p>例如，存储类似 {1,3,5,7,9} 这样的数据时，各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（除首元素和尾元素），因此可以使用线性表存储。</p>
<p>线性表并不是一种具体的存储结构，它包含顺序存储结构和链式存储结构，是顺序表和链表的统称。</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表，简单地理解，就是常用的数组，只是换了个名字而已，例如使用顺序表存储 {1,3,5,7,9}，如图 1 所示：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181118/1-1Q11QI9559D.gif" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于顺序表结构的底层实现借助的就是数组，因此对于初学者来说，可以把顺序表完全等价为数组，但实则不是这样。数据结构是研究数据存储方式的一门学科，它囊括的都是各种存储结构，而数组只是各种编程语言中的基本数据类型，并不属于数据结构的范畴。</span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>我们知道，使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的，如图 1 所示。</p>
<p>链表则完全不同，使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。</p>
<p>为了给各个数据块建立“依次排列”的关系，链表给各数据块增设一个指针，每个数据块的指针都指向下一个数据块（最后一个数据块的指针指向 NULL），就如同一个个小学生都伸手去拉住下一个小学生的手，这样，看似毫无关系的数据块就建立了“依次排列”的关系，也就形成了链表，如图 2 所示：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH334H1.gif" alt="image"></p>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p>栈和队列隶属于线性表，是特殊的线性表，因为它们对线性表中元素的进出做了明确的要求。</p>
<p>栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH634D9.gif" alt="image"></p>
<p>栈结构如图 3 所示，像一个木桶，栈中含有 3 个元素，分别是 A、B 和 C，从在栈中的状态可以看出 A 最先进的栈，然后 B 进栈，最后 C 进栈。根据“先进后出”的原则，3 个元素出栈的顺序应该是：C 最先出栈，然后 B 出栈，最后才是 A 出栈。</p>
<p>队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181118/1-1Q11QHIJO.gif" alt="image"></p>
<p>队列结构如图 4 所示，队列中有 3 个元素，分别是 A、B 和 C，从在队列中的状态可以看出是 A 先进队列，然后 B 进，最后 C 进。根据“先进先出”的原则，3 个元素出队列的顺序应该是 A 最先出队列，然后 B 出，最后 C 出。</p>
<h2 id="树存储结构"><a href="#树存储结构" class="headerlink" title="树存储结构"></a>树存储结构</h2><p>树存储结构适合存储具有“一对多”关系的数据。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181118/1-1Q11QJJ0142.gif" alt="image"></p>
<p>如图 5 所示，其中张平只有一个父亲，但他却有两（多）个孩子，这就是“一对多”的关系，满足这种关系的数据可以使用树存储结构。</p>
<h2 id="图存储结构"><a href="#图存储结构" class="headerlink" title="图存储结构"></a>图存储结构</h2><p>图存储结构适合存储具有“多对多”关系的数据。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181118/1-1Q11QIFS44.gif" alt="image"></p>
<p>如图 6 所示，从 V1 可以到达 V2、V3、V4，同样，从 V2、V3、V4 也可以到达 V1，这就是“多对多”的关系，满足这种关系的数据可以使用图存储结构。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/JavaScript%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/JavaScript%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">JavaScript——链表相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 11:12:49 / 修改时间：11:19:32" itemprop="dateCreated datePublished" datetime="2022-12-16T11:12:49+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">前端算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>例如：</p>
<p>输入：a-&gt;b-&gt;c-&gt;d-&gt;e</p>
<p>输出：a&lt;-b&lt;-c&lt;-d&lt;-e</p>
<p>反转链表示意图如下，链表的最后一个元素 next 指向 null。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408161404713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3OTU0NjQz,size_16,color_FFFFFF,t_70" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*function ListNode(x)&#123;</span><br><span class="line">    this.val = x;</span><br><span class="line">    this.next = null;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">function isEmptyObject(obj) &#123;// 判断输入参数链表是否为空</span><br><span class="line">  for (var name in obj) &#123;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ReverseList(pHead) &#123;</span><br><span class="line">    if (isEmptyObject(pHead)) &#123;// 调用链表是否为空函数</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var pre = null;//链表的最后一个元素</span><br><span class="line">    var next = null;//初始化next为null，下面再赋值</span><br><span class="line">    while (pHead != null) &#123;//pHead移动，直至到链表最后一个元素，指向null，结束循环</span><br><span class="line">        next = pHead.next;//pHead.next值先赋给next，以免覆盖，next移动</span><br><span class="line">        pHead.next = pre;//改变pHead指向，给pHead.next赋值，指向null</span><br><span class="line">        pre = pHead;//pre移动</span><br><span class="line">        pHead = next;//pHead移动</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单链表是否有环"><a href="#单链表是否有环" class="headerlink" title="单链表是否有环"></a>单链表是否有环</h2><ol>
<li>创建哈希表,不过会占⽤较⼤的空间,不是最佳⽅法.( 时间复杂度 O(n) )</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function judge(list)&#123;</span><br><span class="line">  var set =new Set();</span><br><span class="line">  while(list)&#123;</span><br><span class="line">    if(set.has(list))&#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">    set.add(list)</span><br><span class="line">    list=list.next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>给节点添加 visited 访问标记 (时间复杂度 O(n)), 不需要额外的空间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function LinkedList()&#123;</span><br><span class="line">  var Node=function()&#123;</span><br><span class="line">    this.element=element;</span><br><span class="line">    this.next=null;</span><br><span class="line">    this.visited=0; //访问标记</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function judge(list)&#123;</span><br><span class="line">  while(list)&#123;</span><br><span class="line">    if(list.visited==1)&#123;</span><br><span class="line">     return true</span><br><span class="line">    &#125;</span><br><span class="line">    list.visited=1</span><br><span class="line">    list=list.next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>快慢指针法,设定快指针 fast,慢指针 slow,每次循环快指针 fast 移动两个位置,慢指针移动⼀个位置<br>(时间复杂度 O(n)) 需要额外的空间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function judge(list)&#123;</span><br><span class="line">  var fast=list.next.next,</span><br><span class="line">  slow=list.next;</span><br><span class="line">  while(fast)&#123;</span><br><span class="line">    if(fast===slow)&#123;</span><br><span class="line">          return true</span><br><span class="line">    &#125;</span><br><span class="line">    fast=fast.next.next</span><br><span class="line">    slow=slow.next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">常用算法总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 11:12:39 / 修改时间：11:19:08" itemprop="dateCreated datePublished" datetime="2022-12-16T11:12:39+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">前端算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="迭代算法-Iteration"><a href="#迭代算法-Iteration" class="headerlink" title="迭代算法(Iteration)"></a>迭代算法(Iteration)</h2><h2 id="递归算法-Recursion"><a href="#递归算法-Recursion" class="headerlink" title="递归算法(Recursion)"></a>递归算法(Recursion)</h2><ul>
<li>二叉树的遍历算法</li>
</ul>
<h2 id="回溯算法-Backtrack"><a href="#回溯算法-Backtrack" class="headerlink" title="回溯算法(Backtrack)"></a>回溯算法(Backtrack)</h2><ul>
<li>八皇后问题</li>
</ul>
<h2 id="深度优先-Depth-First-Search-DFS"><a href="#深度优先-Depth-First-Search-DFS" class="headerlink" title="深度优先(Depth First Search, DFS)"></a>深度优先(Depth First Search, DFS)</h2><ul>
<li>全排列问题</li>
</ul>
<h2 id="广度优先-Breadth-First-Search-BFS"><a href="#广度优先-Breadth-First-Search-BFS" class="headerlink" title="广度优先(Breadth First Search, BFS)"></a>广度优先(Breadth First Search, BFS)</h2><p><strong>类型</strong></p>
<ul>
<li>不需要确定当前深度</li>
<li>需要确定当前深度</li>
</ul>
<h2 id="动态规划-Dynamic-Programming-DP"><a href="#动态规划-Dynamic-Programming-DP" class="headerlink" title="动态规划(Dynamic Programming, DP)"></a>动态规划(Dynamic Programming, DP)</h2><ul>
<li>斐波那契数列</li>
<li>爬楼梯问题</li>
<li>背包问题</li>
<li>最长公共子序列</li>
<li>最优二叉搜索树</li>
</ul>
<h2 id="分治算法-二分法-Binary-Algorithm"><a href="#分治算法-二分法-Binary-Algorithm" class="headerlink" title="分治算法(二分法, Binary Algorithm)"></a>分治算法(二分法, Binary Algorithm)</h2><ul>
<li>二分排序</li>
<li>二分查找</li>
</ul>
<h2 id="贪心算法-Greedy-Algorithm"><a href="#贪心算法-Greedy-Algorithm" class="headerlink" title="贪心算法(Greedy Algorithm)"></a>贪心算法(Greedy Algorithm)</h2><ul>
<li>霍夫曼编码</li>
</ul>
<h2 id="滑动窗口-Slipping-Window"><a href="#滑动窗口-Slipping-Window" class="headerlink" title="滑动窗口(Slipping Window)"></a>滑动窗口(Slipping Window)</h2><h2 id="双指针-Double-Pointer"><a href="#双指针-Double-Pointer" class="headerlink" title="双指针(Double Pointer)"></a>双指针(Double Pointer)</h2><h2 id="位运算-Bit"><a href="#位运算-Bit" class="headerlink" title="位运算(Bit)"></a>位运算(Bit)</h2><p>要点</p>
<ul>
<li>异或运算（xor）</li>
<li>任何数与 0 做异或运算，结果仍为原来的数。即：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a⊕0=a</span><br></pre></td></tr></table></figure>

<ul>
<li>任何数和其自身做异或运算，结果为 0。即：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a⊕a=0</span><br></pre></td></tr></table></figure>

<ul>
<li>异或运算满足交换律和结合律。即：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a⊕b=b⊕a</span><br><span class="line">a⊕b⊕c=a⊕(b⊕c)</span><br></pre></td></tr></table></figure>

<h2 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h2><ul>
<li>搜索&#x2F;排序算法</li>
<li>快速排序</li>
<li>希尔排序</li>
<li>插入排序</li>
<li>拓扑排序</li>
<li>二分排序</li>
<li>堆排序</li>
</ul>
<h2 id="关于链表-List"><a href="#关于链表-List" class="headerlink" title="关于链表(List)"></a>关于链表(List)</h2><ul>
<li>单向链表</li>
<li>双向链表</li>
<li>广义表</li>
</ul>
<h2 id="关于树-Tree"><a href="#关于树-Tree" class="headerlink" title="关于树(Tree)"></a>关于树(Tree)</h2><ul>
<li>二叉树遍历<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
</li>
<li>二叉搜索树</li>
<li>红黑树</li>
<li>kd 树</li>
<li>B 树</li>
<li>堆</li>
<li>极大堆</li>
</ul>
<h2 id="关于图-Graph"><a href="#关于图-Graph" class="headerlink" title="关于图(Graph)"></a>关于图(Graph)</h2><ul>
<li>最小生成树</li>
<li>最短路径问题</li>
</ul>
<h2 id="关于栈、队列、散列表-queue-stack-hashlist"><a href="#关于栈、队列、散列表-queue-stack-hashlist" class="headerlink" title="关于栈、队列、散列表(queue, stack, hashlist)"></a>关于栈、队列、散列表(queue, stack, hashlist)</h2><ul>
<li>栈对于二叉树层序遍历的实现</li>
<li>最大优先级队列</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">前端面试中的常见的算法问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 10:50:20 / 修改时间：11:18:36" itemprop="dateCreated datePublished" datetime="2022-12-16T10:50:20+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">前端算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Q1-判断一个单词是否是回文？"><a href="#Q1-判断一个单词是否是回文？" class="headerlink" title="Q1 判断一个单词是否是回文？"></a>Q1 判断一个单词是否是回文？</h2><blockquote>
<p>回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider .</p>
</blockquote>
<p>很多人拿到这样的题目非常容易想到用 for 将字符串颠倒字母顺序然后匹配就行了。其实重要的考察的就是对于 reverse 的实现。其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function checkPalindrom(str) &#123;</span><br><span class="line">    return str == str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q2-去掉一组整型数组重复的值"><a href="#Q2-去掉一组整型数组重复的值" class="headerlink" title="Q2 去掉一组整型数组重复的值"></a>Q2 去掉一组整型数组重复的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如输入: [1,13,24,11,11,14,1,2]</span><br><span class="line">输出: [1,13,24,11,14,2]</span><br><span class="line">需要去掉重复的11 和 1 这两个元素。</span><br></pre></td></tr></table></figure>

<p>这道问题出现在诸多的前端面试题中，主要考察个人对 Object 的使用，利用 key 来进行筛选。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* unique an array</span><br><span class="line">**/</span><br><span class="line">let unique = function(arr) &#123;</span><br><span class="line">  let hashTable = &#123;&#125;;</span><br><span class="line">  let data = [];</span><br><span class="line">  for(let i=0,l=arr.length;i&lt;l;i++) &#123;</span><br><span class="line">    if(!hashTable[arr[i]]) &#123;</span><br><span class="line">      hashTable[arr[i]] = true;</span><br><span class="line">      data.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = unique;</span><br></pre></td></tr></table></figure>

<h2 id="Q3-统计一个字符串出现最多的字母"><a href="#Q3-统计一个字符串出现最多的字母" class="headerlink" title="Q3 统计一个字符串出现最多的字母"></a>Q3 统计一个字符串出现最多的字母</h2><p>给出一段英文连续的英文字符串，找出重复出现次数最多的字母</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入 ： afjghdfraaaasdenas</span><br><span class="line"></span><br><span class="line">输出 ： a</span><br></pre></td></tr></table></figure>

<p>前面出现过去重的算法，这里需要是统计重复次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function findMaxDuplicateChar(str) &#123;</span><br><span class="line">  if(str.length == 1) &#123;</span><br><span class="line">    return str;</span><br><span class="line">  &#125;</span><br><span class="line">  let charObj = &#123;&#125;;</span><br><span class="line">  for(let i=0;i&lt;str.length;i++) &#123;</span><br><span class="line">    if(!charObj[str.charAt(i)]) &#123;</span><br><span class="line">      charObj[str.charAt(i)] = 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      charObj[str.charAt(i)] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let maxChar = &#x27;&#x27;,</span><br><span class="line">      maxValue = 1;</span><br><span class="line">  for(var k in charObj) &#123;</span><br><span class="line">    if(charObj[k] &gt;= maxValue) &#123;</span><br><span class="line">      maxChar = k;</span><br><span class="line">      maxValue = charObj[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return maxChar;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = findMaxDuplicateChar;</span><br></pre></td></tr></table></figure>

<h2 id="Q4-排序算法"><a href="#Q4-排序算法" class="headerlink" title="Q4 排序算法"></a>Q4 排序算法</h2><p>如果抽到算法题目的话，应该大多都是比较开放的题目，不限定算法的实现，但是一定要求掌握其中的几种，所以冒泡排序，这种较为基础并且便于理解记忆的算法一定需要熟记于心。冒泡排序算法就是依次比较大小，小的的大的进行位置上的交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    for(let i = 0,l=arr.length;i&lt;l-1;i++) &#123;</span><br><span class="line">        for(let j = i+1;j&lt;l;j++) &#123;</span><br><span class="line">          if(arr[i]&gt;arr[j]) &#123;</span><br><span class="line">                let tem = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = tem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = bubbleSort;</span><br></pre></td></tr></table></figure>

<p>除了冒泡排序外，其实还有很多诸如 插入排序,快速排序，希尔排序等。每一种排序算法都有各自的特点。全部掌握也不需要，但是心底一定要熟悉几种算法。 比如快速排序，其效率很高，而其基本原理如图(来自 wiki)：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="image"></p>
<p>算法参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line"></span><br><span class="line">    if(arr.length&lt;=1) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let leftArr = [];</span><br><span class="line">    let rightArr = [];</span><br><span class="line">    let q = arr[0];</span><br><span class="line">    for(let i = 1,l=arr.length; i&lt;l; i++) &#123;</span><br><span class="line">        if(arr[i]&gt;q) &#123;</span><br><span class="line">            rightArr.push(arr[i]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            leftArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [].concat(quickSort(leftArr),[q],quickSort(rightArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = quickSort;</span><br></pre></td></tr></table></figure>

<p>安利大家一个学习的地址，通过动画演示算法的实现。<br><a target="_blank" rel="noopener" href="http://math.hws.edu/eck/jsdemo/sortlab.html">HTML5 Canvas Demo: Sorting Algorithms</a></p>
<h2 id="Q5-不借助临时变量，进行两个整数的交换"><a href="#Q5-不借助临时变量，进行两个整数的交换" class="headerlink" title="Q5 不借助临时变量，进行两个整数的交换"></a>Q5 不借助临时变量，进行两个整数的交换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 a = 2, b = 4 输出 a = 4, b =2</span><br></pre></td></tr></table></figure>

<p>这种问题非常巧妙，需要大家跳出惯有的思维，利用 a , b 进行置换。</p>
<p>主要是利用 + - 去进行运算，类似 a &#x3D; a + ( b - a) 实际上等同于最后 的 a &#x3D; b;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function swap(a , b) &#123;</span><br><span class="line">  b = b - a;</span><br><span class="line">  a = a + b;</span><br><span class="line">  b = a - b;</span><br><span class="line">  return [a,b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = swap;</span><br></pre></td></tr></table></figure>

<h2 id="Q6-使用-canvas-绘制一个有限度的斐波那契数列的曲线？"><a href="#Q6-使用-canvas-绘制一个有限度的斐波那契数列的曲线？" class="headerlink" title="Q6 使用 canvas 绘制一个有限度的斐波那契数列的曲线？"></a>Q6 使用 canvas 绘制一个有限度的斐波那契数列的曲线？</h2><p><img src="http://img1.vued.vanthink.cn/vued90edf7b944ec479ee8b4203cf56e158d.png" alt="image"></p>
<p>数列长度限定在 9.</p>
<p>斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列主要考察递归的调用。我们一般都知道定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fibo[i] = fibo[i-1]+fibo[i-2];</span><br></pre></td></tr></table></figure>

<p>生成斐波那契数组的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getFibonacci(n) &#123;</span><br><span class="line">  var fibarr = [];</span><br><span class="line">  var i = 0;</span><br><span class="line">  while(i&lt;n) &#123;</span><br><span class="line">    if(i&lt;=1) &#123;</span><br><span class="line">      fibarr.push(i);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      fibarr.push(fibarr[i-1] + fibarr[i-2])</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return fibarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩余的工作就是利用 canvas arc 方法进行曲线绘制了</p>
<p><a target="_blank" rel="noopener" href="http://codepen.io/Jack_Pu/pen/LRaxZB">DEMO</a></p>
<h2 id="Q7-找出下列正数组的最大差值比如"><a href="#Q7-找出下列正数组的最大差值比如" class="headerlink" title="Q7 找出下列正数组的最大差值比如:"></a>Q7 找出下列正数组的最大差值比如:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入 [10,5,11,7,8,9]</span><br><span class="line"></span><br><span class="line">输出 6</span><br></pre></td></tr></table></figure>

<p>这是通过一道题目去测试对于基本的数组的最大值的查找，很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getMaxProfit(arr) &#123;</span><br><span class="line"></span><br><span class="line">    var minPrice = arr[0];</span><br><span class="line">    var maxProfit = 0;</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var currentPrice = arr[i];</span><br><span class="line"></span><br><span class="line">        minPrice = Math.min(minPrice, currentPrice);</span><br><span class="line"></span><br><span class="line">        var potentialProfit = currentPrice - minPrice;</span><br><span class="line"></span><br><span class="line">        maxProfit = Math.max(maxProfit, potentialProfit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q8-随机生成指定长度的字符串"><a href="#Q8-随机生成指定长度的字符串" class="headerlink" title="Q8 随机生成指定长度的字符串"></a>Q8 随机生成指定长度的字符串</h2><p>实现一个算法，随机生成指定长度的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如给定 长度 8  输出 4ldkfg9j</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function randomString(n) &#123;</span><br><span class="line">  let str = &#x27;abcdefghijklmnopqrstuvwxyz9876543210&#x27;;</span><br><span class="line">  let tmp = &#x27;&#x27;,</span><br><span class="line">      i = 0,</span><br><span class="line">      l = str.length;</span><br><span class="line">  for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    tmp += str.charAt(Math.floor(Math.random() * l));</span><br><span class="line">  &#125;</span><br><span class="line">  return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = randomString;</span><br></pre></td></tr></table></figure>

<h2 id="Q9-实现类似-getElementsByClassName-的功能"><a href="#Q9-实现类似-getElementsByClassName-的功能" class="headerlink" title="Q9 实现类似 getElementsByClassName 的功能"></a>Q9 实现类似 getElementsByClassName 的功能</h2><p>自己实现一个函数，查找某个 DOM 节点下面的包含某个 class 的所有 DOM 节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供 DOM 查找函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function queryClassName(node, name) &#123;</span><br><span class="line">  var starts = &#x27;(^|[ \n\r\t\f])&#x27;,</span><br><span class="line">       ends = &#x27;([ \n\r\t\f]|$)&#x27;;</span><br><span class="line">  var array = [],</span><br><span class="line">        regex = new RegExp(starts + name + ends),</span><br><span class="line">        elements = node.getElementsByTagName(&quot;*&quot;),</span><br><span class="line">        length = elements.length,</span><br><span class="line">        i = 0,</span><br><span class="line">        element;</span><br><span class="line"></span><br><span class="line">    while (i &lt; length) &#123;</span><br><span class="line">        element = elements[i];</span><br><span class="line">        if (regex.test(element.className)) &#123;</span><br><span class="line">            array.push(element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q10-使用-JS-实现二叉查找树-Binary-Search-Tree"><a href="#Q10-使用-JS-实现二叉查找树-Binary-Search-Tree" class="headerlink" title="Q10 使用 JS 实现二叉查找树(Binary Search Tree)"></a>Q10 使用 JS 实现二叉查找树(Binary Search Tree)</h2><p>一般叫全部写完的概率比较少，但是重点考察你对它的理解和一些基本特点的实现。 二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。</li>
</ul>
<p><img src="http://img1.vued.vanthink.cn/vued95685e8f89199babd6273a93651ecd8b.png" alt="image"></p>
<p>在写的时候需要足够理解二叉搜素树的特点，需要先设定好每个节点的数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">  constructor(data, left, right) &#123;</span><br><span class="line">    this.data = data;</span><br><span class="line">    this.left = left;</span><br><span class="line">    this.right = right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树是有节点构成，由根节点逐渐延生到各个子节点，因此它具备基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">class BinarySearchTree &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.root = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insert(data) &#123;</span><br><span class="line">    let n = new Node(data, null, null);</span><br><span class="line">    if (!this.root) &#123;</span><br><span class="line">      return this.root = n;</span><br><span class="line">    &#125;</span><br><span class="line">    let currentNode = this.root;</span><br><span class="line">    let parent = null;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      parent = currentNode;</span><br><span class="line">      if (data &lt; currentNode.data) &#123;</span><br><span class="line">        currentNode = currentNode.left;</span><br><span class="line">        if (currentNode === null) &#123;</span><br><span class="line">          parent.left = n;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        currentNode = currentNode.right;</span><br><span class="line">        if (currentNode === null) &#123;</span><br><span class="line">          parent.right = n;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove(data) &#123;</span><br><span class="line">    this.root = this.removeNode(this.root, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeNode(node, data) &#123;</span><br><span class="line">    if (node == null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (data == node.data) &#123;</span><br><span class="line">      // no children node</span><br><span class="line">      if (node.left == null &amp;&amp; node.right == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (node.left == null) &#123;</span><br><span class="line">        return node.right;</span><br><span class="line">      &#125;</span><br><span class="line">      if (node.right == null) &#123;</span><br><span class="line">        return node.left;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let getSmallest = function(node) &#123;</span><br><span class="line">        if(node.left === null &amp;&amp; node.right == null) &#123;</span><br><span class="line">          return node;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.left != null) &#123;</span><br><span class="line">          return node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right !== null) &#123;</span><br><span class="line">          return getSmallest(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      let temNode = getSmallest(node.right);</span><br><span class="line">      node.data = temNode.data;</span><br><span class="line">      node.right = this.removeNode(temNode.right,temNode.data);</span><br><span class="line">      return node;</span><br><span class="line"></span><br><span class="line">    &#125; else if (data &lt; node.data) &#123;</span><br><span class="line">      node.left = this.removeNode(node.left,data);</span><br><span class="line">      return node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      node.right = this.removeNode(node.right,data);</span><br><span class="line">      return node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find(data) &#123;</span><br><span class="line">    var current = this.root;</span><br><span class="line">    while (current != null) &#123;</span><br><span class="line">      if (data == current.data) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      if (data &lt; current.data) &#123;</span><br><span class="line">        current = current.left;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        current = current.right</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return current.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = BinarySearchTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Q11-数组全排列"><a href="#Q11-数组全排列" class="headerlink" title="Q11 数组全排列"></a>Q11 数组全排列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;hello&#x27;,&#x27;world&#x27;];</span><br><span class="line">var count = 1;</span><br><span class="line">function getStr(a)&#123;</span><br><span class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">		// indexOf 是es6数组的方法,如果不存在返回-1，存在返回下标</span><br><span class="line">		if(a.indexOf(arr[i])&lt;0)&#123;</span><br><span class="line"></span><br><span class="line">			//数组 a 中不存在 arr[i],将arr[i]添加到数组末尾</span><br><span class="line">			a.push(arr[i]);</span><br><span class="line"></span><br><span class="line">			if(a.length==arr.length)&#123;</span><br><span class="line">				console.log(count++ + &#x27;: &#x27; +a.join(&quot;&quot;));</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				//结束一次for循环  进行了4次递归 getStr([&#x27;foo&#x27;]) getStr([&#x27;bar&#x27;]) getStr([&#x27;hello&#x27;]) getStr([&#x27;world&#x27;])</span><br><span class="line">				getStr(a);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			//一定从数组 a 中删除arr[i],进行下次循环，如果不删除就只能获得一种结果了</span><br><span class="line">			a.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">getStr([])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除去注释只用了 15 行代码，通过上面的方法 我们实现了单个数组全排<br><a target="_blank" rel="noopener" href="http://www.lingchenliang.com/post/134.html">更多方法阅读</a></p>
<h2 id="Q12-最大连续子序列和"><a href="#Q12-最大连续子序列和" class="headerlink" title="Q12 最大连续子序列和"></a>Q12 最大连续子序列和</h2><blockquote>
<p>思路： 比较若干个连续</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 6, -1, 5, 4, -7, 2, 3];</span><br><span class="line">var maxSum = arr[0],</span><br><span class="line">	sum = arr[0];</span><br><span class="line">for(var i=1;i&lt;arr.length;i++) &#123;</span><br><span class="line">	if(sum&lt; 0) &#123;</span><br><span class="line">		sum = arr[i];</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		sum += arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	if (sum &gt; maxSum) &#123;</span><br><span class="line">		maxSum = sum;</span><br><span class="line">	&#125;</span><br><span class="line"> 	console.log(sum, maxSum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(maxSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function maxSeq(arr) &#123;</span><br><span class="line">    var sum=arr[0], maxSum = arr[0]</span><br><span class="line"></span><br><span class="line">    for(var i=1; i&lt; arr.length; i++) &#123;</span><br><span class="line">        if (sum &lt; 0) &#123;</span><br><span class="line">            sum = arr[i]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sum += arr[i]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sum &gt; maxSum) &#123;</span><br><span class="line">            msxSum = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q13-DOM-遍历深度优先和广度优先算法"><a href="#Q13-DOM-遍历深度优先和广度优先算法" class="headerlink" title="Q13 DOM 遍历深度优先和广度优先算法"></a>Q13 DOM 遍历深度优先和广度优先算法</h2><h3 id="1-深度优先"><a href="#1-深度优先" class="headerlink" title="1. 深度优先"></a>1. 深度优先</h3><p><img src="https://img-blog.csdnimg.cn/20191227181534979.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">let arr = []</span><br><span class="line">function deepTraversal(node) &#123;</span><br><span class="line">  if(!node) return;</span><br><span class="line">  arr.push(node)</span><br><span class="line">  for (var i = 0; i&lt; node.children.length; i++) &#123;</span><br><span class="line">    deepTraversal(node.children[i])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 非递归</span><br><span class="line">let arr =[]</span><br><span class="line">function deepTraversal(node) &#123;</span><br><span class="line">  if(!node) return;</span><br><span class="line">  var stack = [node];</span><br><span class="line">  while (stack.length) &#123;</span><br><span class="line">    var item = stack.shift();</span><br><span class="line">    arr.push(item);</span><br><span class="line">    var children = item.children;</span><br><span class="line">    for (var i = children.length - 1; i &gt;= 0 ; i--) &#123;</span><br><span class="line">      stack.unshift(children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-广度优先"><a href="#2-广度优先" class="headerlink" title="2. 广度优先"></a>2. 广度优先</h3><p><img src="https://img-blog.csdnimg.cn/2019122718211761.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">let nodes = []; //nodes可放函数中</span><br><span class="line">let i = 0;</span><br><span class="line">function wideTraversal(node) &#123;</span><br><span class="line">  if (node) &#123;</span><br><span class="line">    nodes.push(node);</span><br><span class="line">    wideTraversal(node.nextElementSibling);</span><br><span class="line">    node = nodes[i++];</span><br><span class="line">    wideTraversal(node.firstElementChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">wideTraversal(rootElement);</span><br><span class="line">console.log(nodes);</span><br><span class="line"></span><br><span class="line">let nodes = [rootElement]; //nodes可放函数中</span><br><span class="line">let stack = []</span><br><span class="line">function wideTraversal(node) &#123;</span><br><span class="line">  if (node) &#123;</span><br><span class="line">    for(var i =0; i&lt; node.children.length; i++) &#123;</span><br><span class="line">      nodes.push(node.children[i]);</span><br><span class="line">      stack.push(node.children[i])</span><br><span class="line">    &#125;</span><br><span class="line">    wideTraversal(stack.shift())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">wideTraversal(rootElement);</span><br><span class="line"></span><br><span class="line">// 非递归  先进先出</span><br><span class="line">let arr = [];</span><br><span class="line">let stack = [rootElement]</span><br><span class="line">function wideTraversal(node) &#123;</span><br><span class="line">  while(stack.length) &#123;</span><br><span class="line">    let item = stack.shift()</span><br><span class="line">    arr.push(item)</span><br><span class="line">    for (var i = 0; i &lt; item.children.length;i++) &#123;</span><br><span class="line">      stack.push(item.children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">wideTraversal(rootElement);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="Q14-JS-洗牌算法"><a href="#Q14-JS-洗牌算法" class="headerlink" title="Q14 JS 洗牌算法"></a>Q14 JS 洗牌算法</h2><p>塔罗牌</p>
<p>举例来说，我们有一个如下图所示的数组，数组长度为 9，数组内元素的值顺次分别是 1~9：</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/yrpGxAD5lVSqbjgJL7E1BPzC83gibLVIHoa9RjVrBUFdCfoSJUsVXhs4CNROkszm8eibymxzR60nra3UOJwavWYg/640?wx_fmt=png" alt="image"></p>
<p>从上面这个数组入手，我们要做的就是打乱数组内元素的顺序：</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/yrpGxAD5lVSqbjgJL7E1BPzC83gibLVIHR4BDaN36lLZU1BPDTjkvHqqo9aiaK1icRd7Y7riaofelVqiabdF8y6wHKA/640?wx_fmt=png" alt="image"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.shuffle = function () &#123;</span><br><span class="line">    let input = this;</span><br><span class="line">    for (let i = input.length - 1; i&gt;= 0; i--) &#123;</span><br><span class="line">        let randomIndex = Math.floor(Math.random() * (i + 1));</span><br><span class="line">        let itemAtIndex = input[randomIndex];</span><br><span class="line">        input[randomIndex] = input[i];</span><br><span class="line">        input[i] = itemAtIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    return input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们创建了一个 shuffle() 方法，该方法用于随机排列数组内的元素。</p>
<p>此外，我们将该方法挂载在了 Array 对象的原型下面，所以任何数组都可以直接调用该方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let tempArray = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</span><br><span class="line">tempArray.shuffle();</span><br></pre></td></tr></table></figure>

<h2 id="Q15-假设现在有两个函数-function-A-和-function-B-，现在希望创建一个新的函数-function-C-，新函数的逻辑是将自己接收到的前两个参数传给函数-A，剩余所有参数传给函数-B，请用原生-javascript-实现函数-C"><a href="#Q15-假设现在有两个函数-function-A-和-function-B-，现在希望创建一个新的函数-function-C-，新函数的逻辑是将自己接收到的前两个参数传给函数-A，剩余所有参数传给函数-B，请用原生-javascript-实现函数-C" class="headerlink" title="Q15 假设现在有两个函数 function A()和 function B()，现在希望创建一个新的函数 function C()，新函数的逻辑是将自己接收到的前两个参数传给函数 A，剩余所有参数传给函数 B，请用原生 javascript 实现函数 C"></a>Q15 假设现在有两个函数 function A()和 function B()，现在希望创建一个新的函数 function C()，新函数的逻辑是将自己接收到的前两个参数传给函数 A，剩余所有参数传给函数 B，请用原生 javascript 实现函数 C</h2><p>举例：</p>
<p>如果调用函数 C：C[a,b,c,d,e]</p>
<p>相当于调用函数 A 和函数 B：A(a,b),B(c,d,e)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">     var a_args=Array.prototype.slice.call(arguments,0,2);</span><br><span class="line">     var b_args=Array.prototype.slice.call(arguments,2);</span><br><span class="line">     A.apply(this,a_args);</span><br><span class="line">     B.apply(this,b_args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function C(...s)&#123;</span><br><span class="line">      A.call(this,s[0],s[1]);</span><br><span class="line">      B.apply(this,s.slice(2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function C(...s)&#123;</span><br><span class="line">      A.apply(this,s.slice(0,2));</span><br><span class="line">      B.apply(this,s.slice(2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function C()&#123;</span><br><span class="line">   A(arguments[0],arguments[1]);</span><br><span class="line">   B(Array.prototype.slice.call(arguments,2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function C(a1,a2,...args) &#123;</span><br><span class="line">    A(a1,a2)</span><br><span class="line">    B(...args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Array.prototype.slice 表示数组的原型中的 slice 方法。这个 slice 方法返回的是一个 Array 类型的对象。可以把类数组对象转化成真正的数组，与 Array.from 类似。</p>
<h2 id="Q16-请实现以下-template-方法，用于模板解析"><a href="#Q16-请实现以下-template-方法，用于模板解析" class="headerlink" title="Q16 请实现以下 template 方法，用于模板解析"></a>Q16 请实现以下 template 方法，用于模板解析</h2><p>var compiled &#x3D; template(“hello &lt;%&#x3D;user%&gt;!”);<br>compiled({“user”:”world”}); &#x3D;&gt; hello world!</p>
<p>var compiled &#x3D; template(“welocm to &lt;%&#x3D;location%&gt;!”);<br>compiled({“location”:”CVTE”}); &#x3D;&gt; welcom to CVTE!;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function template(source)&#123;</span><br><span class="line">   var temp=source;</span><br><span class="line">   return function(obj)&#123;</span><br><span class="line">       for(var prop in obj)&#123;</span><br><span class="line">              var tpl=&quot;&lt;%=&quot;+prop+&quot;%&gt;&quot;;</span><br><span class="line">              temp=temp.replace(tpl,obj[prop]);</span><br><span class="line">       &#125;</span><br><span class="line">       console.log(temp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Q17-写一个函数，将传进去的数组按深度展开"><a href="#Q17-写一个函数，将传进去的数组按深度展开" class="headerlink" title="Q17 写一个函数，将传进去的数组按深度展开"></a>Q17 写一个函数，将传进去的数组按深度展开</h2><p>例子：<br>list:[1,2,[3,4],[5,6,[7,8],9],10,11]<br/><br>depth 等于 1 时输出<br/><br>depth &#x3D; 1 :[1,2,3,4,5,6,[7,8],9,10,11]</p>
<p>depth 等于 2 时输出<br/><br>depth &#x3D; 2 :[1,2,3,4,5,6,7,8,9,10,11]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function flattern(array,num = 0) &#123;</span><br><span class="line">	var newArray = array;</span><br><span class="line">	for(let i = 0; i &lt; num; i ++) &#123;</span><br><span class="line">		newArray = [].concat(...newArray)</span><br><span class="line">	&#125;</span><br><span class="line">	return newArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flattern([1,2,3,[4,5,[6,7]]],2))</span><br></pre></td></tr></table></figure>

<h2 id="Q18-实现一个简单的模板引擎"><a href="#Q18-实现一个简单的模板引擎" class="headerlink" title="Q18 实现一个简单的模板引擎"></a>Q18 实现一个简单的模板引擎</h2><p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let template = &#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;;</span><br><span class="line">let data = &#123;</span><br><span class="line">  name: &#x27;姓名&#x27;,</span><br><span class="line">  age: 18</span><br><span class="line">&#125;</span><br><span class="line">render(template, data); // 我是姓名，年龄18，性别undefined</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">方法1：先将模板与数据中均存在的属性替换掉，再将数据中不存在模板中存在的属性设置为undefined</span><br><span class="line">function render(template, data) &#123;</span><br><span class="line">	for(let key in data) &#123;</span><br><span class="line">		if(template.indexOf(key)) &#123;</span><br><span class="line">			var reg =new RegExp(&quot;&#123;&#123;&quot; + key + &quot;&#125;&#125;&quot;,&quot;g&quot;);</span><br><span class="line">			template = template.replace(reg,data[key])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template = template.replace(/\&#123;\&#123;(\w+)\&#125;\&#125;/g,&#x27;undefined&#x27;)</span><br><span class="line"></span><br><span class="line">	return template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法2 迭代，一个一个替换，注意exec匹配到的第一项是匹配字符串，第二项为分组内的字符串[&#123;&#123;name&#125;&#125;,name]</span><br><span class="line">function render(template, data) &#123;</span><br><span class="line">  const reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/; // 模板字符串正则</span><br><span class="line">  if (reg.test(template)) &#123; // 判断模板里是否有模板字符串</span><br><span class="line">    const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段</span><br><span class="line">    template = template.replace(reg, data[name]); // 将第一个模板字符串渲染</span><br><span class="line">    return render(template, data); // 递归的渲染并返回渲染后的结构</span><br><span class="line">  &#125;</span><br><span class="line">  return template; // 如果模板没有模板字符串直接返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q19-动态规划"><a href="#Q19-动态规划" class="headerlink" title="Q19 动态规划"></a>Q19 动态规划</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。例如，给定三角形：</p>
<p>[[2],[3,4],[6,5,7],[4,1,8,3]]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p>
<p>动态规划我个人的理解是：能将一个大问题分解为一个个小问题，并且这些小问题之间有共性能重复调用。那么如何判断这道题是否可以用到动态规划，首先从底往上看，[6,5,7]对应的最小路径很明显可以看出分别是[1,1,3]，那么后两层的最短路径是[7,6,10]，再往上看[3,4]的最短路径也能明显看出是[9,10]，那么 2 对应的最短路径很明显就是 11。其实从这里就能看出每层分析判断的逻辑是一致的。js 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const minimumTotal = triangle =&gt; &#123;</span><br><span class="line">    // es6方法填充数组</span><br><span class="line">    const dp = Array.of(...triangle[triangle.length - 1])</span><br><span class="line">	for (let i = dp.length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        for (let j = 0; j &lt; triangle[i].length; j++) &#123;</span><br><span class="line">            // 状态转移方程</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j + 1]) + triangle[i][j]</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/JavaScript%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/JavaScript%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/" class="post-title-link" itemprop="url">JavaScript变量提升和函数提升</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:45:01" itemprop="dateCreated datePublished" datetime="2022-10-24T16:45:01+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-变量提升"><a href="#1-变量提升" class="headerlink" title="1. 变量提升"></a>1. 变量提升</h2><p>通常 JS 引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。(注：当前流行的 JS 引擎大都对源码进行了编译，由于引擎的不同，编译形式也会有所差异，我们这里说的预编译和提升其实是抽象出来的、易于理解的概念)</p>
<p>下面的代码中，我们在函数中声明了一个变量，不过这个变量声明是在 if 语句块中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function hoistVariable() &#123;</span><br><span class="line">    if (!foo) &#123;</span><br><span class="line">        var foo = 5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(foo); // 5</span><br><span class="line">&#125;</span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure>

<p>运行代码，我们会发现 foo 的值是 5，初学者可能对此不甚理解，如果外层作用域也存在一个 foo 变量，就更加困惑了，该不会是打印外层作用域中的 foo 变量吧？答案是：不会，如果当前作用域中存在此变量声明，无论它在什么地方声明，引用此变量时就会在当前作用域中查找，不会去外层作用域了。</p>
<p>那么至于说打印结果，这要提到预编译机制了，经过一次预编译之后，上面的代码逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 预编译之后</span><br><span class="line">function hoistVariable() &#123;</span><br><span class="line">    var foo;</span><br><span class="line"></span><br><span class="line">    if (!foo) &#123;</span><br><span class="line">        foo = 5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(foo); // 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure>

<p>是的，引擎将变量声明提升到了函数顶部，初始值为 undefined，自然，if 语句块就会被执行，foo 变量赋值为 5，下面的打印也就是预期的结果了。</p>
<p>类似的，还有下面一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo = 3;</span><br><span class="line"></span><br><span class="line">function hoistVariable() &#123;</span><br><span class="line">    var foo = foo || 5;</span><br><span class="line"></span><br><span class="line">    console.log(foo); // 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure>

<p>foo || 5 这个表达式的结果是 5 而不是 3，虽然外层作用域有个 foo 变量，但函数内是不会去引用的，因为预编译之后的代码逻辑是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var foo = 3;</span><br><span class="line"></span><br><span class="line">// 预编译之后</span><br><span class="line">function hoistVariable() &#123;</span><br><span class="line">    var foo;</span><br><span class="line"></span><br><span class="line">    foo = foo || 5;</span><br><span class="line"></span><br><span class="line">    console.log(foo); // 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure>

<p>如果当前作用域中声明了多个同名变量，那么根据我们的推断，它们的同一个标识符会被提升至作用域顶部，其他部分按顺序执行，比如下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function hoistVariable() &#123;</span><br><span class="line">    var foo = 3;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        var foo = 5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(foo); // 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure>

<p>由于 JavaScript 没有块作用域，只有全局作用域和函数作用域，所以预编译之后的代码逻辑为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 预编译之后</span><br><span class="line">function hoistVariable() &#123;</span><br><span class="line">    var foo;</span><br><span class="line"></span><br><span class="line">    foo = 3;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        foo = 5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(foo); // 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure>

<h2 id="2-函数提升"><a href="#2-函数提升" class="headerlink" title="2. 函数提升"></a>2. 函数提升</h2><p>相信大家对下面这段代码都不陌生，实际开发当中也很常见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function hoistFunction() &#123;</span><br><span class="line">    foo(); // output: I am hoisted</span><br><span class="line"></span><br><span class="line">    function foo() &#123;</span><br><span class="line">        console.log(&#x27;I am hoisted&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure>

<p>为什么函数可以在声明之前就可以调用，并且跟变量声明不同的是，它还能得到正确的结果，其实引擎是把函数声明整个地提升到了当前作用域的顶部，预编译之后的代码逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 预编译之后</span><br><span class="line">function hoistFunction() &#123;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        console.log(&#x27;I am hoisted&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo(); // output: I am hoisted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure>

<p>相似的，如果在同一个作用域中存在多个同名函数声明，后面出现的将会覆盖前面的函数声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function hoistFunction() &#123;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        console.log(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo(); // output: 2</span><br><span class="line"></span><br><span class="line">    function foo() &#123;</span><br><span class="line">        console.log(2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure>

<p>对于函数，除了使用上面的函数声明，更多时候，我们会使用函数表达式，下面是函数声明和函数表达式的对比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(&#x27;function declaration&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 匿名函数表达式</span><br><span class="line">var foo = function() &#123;</span><br><span class="line">    console.log(&#x27;anonymous function expression&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 具名函数表达式</span><br><span class="line">var foo = function bar() &#123;</span><br><span class="line">    console.log(&#x27;named function expression&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，匿名函数表达式，其实是将一个不带名字的函数声明赋值给了一个变量，而具名函数表达式，则是带名字的函数赋值给一个变量，需要注意到是，这个函数名只能在此函数内部使用。我们也看到了，其实函数表达式可以通过变量访问，所以也存在变量提升同样的效果。</p>
<p>那么当函数声明遇到函数表达式时，会有什么样的结果呢，先看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function hoistFunction() &#123;</span><br><span class="line">    foo(); // 2</span><br><span class="line"></span><br><span class="line">    var foo = function() &#123;</span><br><span class="line">        console.log(1);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    foo(); // 1</span><br><span class="line"></span><br><span class="line">    function foo() &#123;</span><br><span class="line">        console.log(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo(); // 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure>

<p>运行后我们会发现，输出的结果依次是 2 1 1，为什么会有这样的结果呢？</p>
<p>因为 JavaScript 中的函数是一等公民，函数声明的优先级最高，会被提升至当前作用域最顶端，所以第一次调用时实际执行了下面定义的函数声明，然后第二次调用时，由于前面的函数表达式与之前的函数声明同名，故将其覆盖，以后的调用也将会打印同样的结果。上面的过程经过预编译之后，代码逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 预编译之后</span><br><span class="line">function hoistFunction() &#123;</span><br><span class="line">    var foo;</span><br><span class="line"></span><br><span class="line">    foo = function foo() &#123;</span><br><span class="line">        console.log(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo(); // 2</span><br><span class="line"></span><br><span class="line">    foo = function() &#123;</span><br><span class="line">        console.log(1);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    foo(); // 1</span><br><span class="line"></span><br><span class="line">    foo(); // 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure>

<p>我们也不难理解，下面的函数和变量重名时，会如何执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var foo = 3;</span><br><span class="line"></span><br><span class="line">function hoistFunction() &#123;</span><br><span class="line">    console.log(foo); // function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    foo = 5;</span><br><span class="line"></span><br><span class="line">    console.log(foo); // 5</span><br><span class="line"></span><br><span class="line">    function foo() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br><span class="line">console.log(foo);     // 3</span><br></pre></td></tr></table></figure>

<p>我们可以看到，函数声明被提升至作用域最顶端，然后被赋值为 5，而外层的变量并没有被覆盖，经过预编译之后，上面代码的逻辑是这样的：</p>
<p>&#x2F;&#x2F; 预编译之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var foo = 3;</span><br><span class="line"></span><br><span class="line">function hoistFunction() &#123;</span><br><span class="line">   var foo;</span><br><span class="line"></span><br><span class="line">   foo = function foo() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   console.log(foo); // function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   foo = 5;</span><br><span class="line"></span><br><span class="line">   console.log(foo); // 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br><span class="line">console.log(foo);    // 3</span><br></pre></td></tr></table></figure>

<p>所以，函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行，这一点要牢记。</p>
<h2 id="3-为什么要进行提升"><a href="#3-为什么要进行提升" class="headerlink" title="3. 为什么要进行提升"></a>3. 为什么要进行提升</h2><p>关于为什么进行变量提升和函数提升，这个问题一直没有明确的答案，不过最近读到 Dmitry Soshnikov 之前的一篇文章时，多少了解了一些，下面是 Dmitry Soshnikov 早些年的 twitter，他也对这个问题十分感兴趣：</p>
<p><img src="https://images2015.cnblogs.com/blog/317749/201609/317749-20160927084830453-161910040.png" alt="image"></p>
<p>然后 Jeremy Ashkenas 想让 Brendan Eich 聊聊这个话题：</p>
<p><img src="https://images2015.cnblogs.com/blog/317749/201609/317749-20160927085003891-1035941947.png" alt="image"></p>
<p>最后，Brendan Eich 给出了答案：</p>
<p><img src="https://images2015.cnblogs.com/blog/317749/201609/317749-20160927085032422-1936451758.png" alt="image"></p>
<p>大致的意思就是：由于第一代 JS 虚拟机中的抽象纰漏导致的，编译器将变量放到了栈槽内并编入索引，然后在（当前作用域的）入口处将变量名绑定到了栈槽内的变量。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。）</p>
<p>然后，Dmitry Soshnikov 又提到了函数提升，他提到了相互递归（就是 A 函数内会调用到 B 函数，而 B 函数也会调用到 A 函数）：</p>
<p><img src="https://images2015.cnblogs.com/blog/317749/201609/317749-20160928082258078-892410645.png" alt="image"></p>
<p>随后 Brendan Eich 很热心的又给出了答案：</p>
<p><img src="https://images2015.cnblogs.com/blog/317749/201609/317749-20160928082526438-697971926.png" alt="image"></p>
<p>Brendan Eich 很确定的说，函数提升就是为了解决相互递归的问题，大体上可以解决像 ML 语言这样自下而上的顺序问题。</p>
<p>这里简单阐述一下相互递归，下面两个函数分别在自己的函数体内调用了对方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 验证偶数</span><br><span class="line">function isEven(n) &#123;</span><br><span class="line">    if (n === 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return isOdd(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(isEven(2)); // true</span><br><span class="line"></span><br><span class="line">// 验证奇数</span><br><span class="line">function isOdd(n) &#123;</span><br><span class="line">    if (n === 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isEven(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有函数提升，而是按照自下而上的顺序，当 isEven 函数被调用时，isOdd 函数还未声明，所以当 isEven 内部无法调用 isOdd 函数。所以 Brendan Eich 设计了函数提升这一形式，将函数提升至当前作用域的顶部：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 验证偶数</span><br><span class="line">function isEven(n) &#123;</span><br><span class="line">    if (n === 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return isOdd(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证奇数</span><br><span class="line">function isOdd(n) &#123;</span><br><span class="line">    if (n === 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isEven(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(isEven(2)); // true</span><br></pre></td></tr></table></figure>

<p>这样一来，问题就迎刃而解了。</p>
<p>最后，Brendan Eich 还对变量提升和函数提升做了总结：<br><img src="https://images2015.cnblogs.com/blog/317749/201609/317749-20160928084223719-96754371.png" alt="image"><br>大概是说，变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。</p>
<p>至此，关于变量提升和函数提升，相信大家已经明白其中的真相了。</p>
<h2 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. 最佳实践</h2><p>理解变量提升和函数提升可以使我们更了解这门语言，更好地驾驭它，但是在开发中，我们不应该使用这些技巧，而是要规范我们的代码，做到可读性和可维护性。</p>
<p>具体的做法是：无论变量还是函数，都必须先声明后使用。下面举了简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;Scott&#x27;;</span><br><span class="line">var sayHello = function(guest) &#123;</span><br><span class="line">    console.log(name, &#x27;says hello to&#x27;, guest);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var i;</span><br><span class="line">var guest;</span><br><span class="line">var guests = [&#x27;John&#x27;, &#x27;Tom&#x27;, &#x27;Jack&#x27;];</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; guests.length; i++) &#123;</span><br><span class="line">    guest = guests[i];</span><br><span class="line"></span><br><span class="line">    // do something on guest</span><br><span class="line"></span><br><span class="line">    sayHello(guest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果对于新的项目，可以使用 let 替换 var，会变得更可靠，可维护性更高：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let name = &#x27;Scott&#x27;;</span><br><span class="line">let sayHello = function(guest) &#123;</span><br><span class="line">    console.log(name, &#x27;says hello to&#x27;, guest);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let guests = [&#x27;John&#x27;, &#x27;Tom&#x27;, &#x27;Jack&#x27;];</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; guests.length; i++) &#123;</span><br><span class="line">    let guest = guests[i];</span><br><span class="line"></span><br><span class="line">    // do something on guest</span><br><span class="line"></span><br><span class="line">    sayHello(guest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，ES6 中的 class 声明也存在提升，不过它和 let、const 一样，被约束和限制了，其规定，如果再声明位置之前引用，则是不合法的，会抛出一个异常。</p>
<p>所以，无论是早期的代码，还是 ES6 中的代码，我们都需要遵循一点，先声明，后使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E4%BB%8B%E7%BB%8D%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E5%B9%B6%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/%E4%BB%8B%E7%BB%8D%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E5%B9%B6%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">介绍防抖与节流的原理，并动手实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:44:38" itemprop="dateCreated datePublished" datetime="2022-10-24T16:44:38+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const debounce = (fn,delay) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 介绍防抖函数原理，并实现</span><br><span class="line"></span><br><span class="line">  // your code</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const throttle = (fn,delay = 500) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 介绍节流函数原理，并实现</span><br><span class="line"></span><br><span class="line">   // your code</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-防抖函数"><a href="#1-防抖函数" class="headerlink" title="1)防抖函数"></a>1)防抖函数</h2><h3 id="防抖函数原理"><a href="#防抖函数原理" class="headerlink" title="防抖函数原理:"></a>防抖函数原理:</h3><p>在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景:"></a>适用场景:</h3><p>1.按钮提交场景:防止多次提交按钮，只执行最后提交的一次。</p>
<p>2.服务端验证场景:表单验证需要服务端配合，只执行—段连续的输入事件的最后一次，还有搜索联想词功能类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 手写简化版实现</span><br><span class="line"></span><br><span class="line">const debounce = (fn,delay) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  let timer = null;</span><br><span class="line"></span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    clearTimeout(timer);</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      fn.apply(this,args);</span><br><span class="line"></span><br><span class="line">    &#125;,delay)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-节流函数"><a href="#2-节流函数" class="headerlink" title="2)节流函数"></a>2)节流函数</h2><h3 id="节流函数原理"><a href="#节流函数原理" class="headerlink" title="节流函数原理:"></a>节流函数原理:</h3><p>规定在一个单位时间内，只能触发—次函数。如果这个单位时间内触发多次函数，只有一次生效。防抖是延迟执行，而节流是间隔执行，函数节流即每隔一段时间就执行一次。</p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景:"></a>适用场景:</h3><p>1.拖拽场景:固定时间内只执行一次，防止超高频次触发位置变动</p>
<p>⒉ 缩放场景:监控浏览器 resize</p>
<p>3.动画场景:避免短时间内多次触发动画引起性能问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 手写简化版实现</span><br><span class="line"></span><br><span class="line">// ①定时器实现</span><br><span class="line"></span><br><span class="line">const throttle = (fn,delay = 500) =&gt;&#123;</span><br><span class="line"></span><br><span class="line">  let flag = true;</span><br><span class="line"></span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    if(!flag) return;</span><br><span class="line"></span><br><span class="line">    flag = false;</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      fn.apply(this,args);</span><br><span class="line"></span><br><span class="line">      flag = true;</span><br><span class="line"></span><br><span class="line">    &#125;,delay);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ②时间戳实现</span><br><span class="line"></span><br><span class="line">const throttle = (fn,delay = 500) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  let preTime = Date.now();</span><br><span class="line"></span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const nowTime = Date.now();</span><br><span class="line"></span><br><span class="line">    if(nowTime - preTime &gt;= delay)&#123;</span><br><span class="line"></span><br><span class="line">          preTime = Date.now();</span><br><span class="line"></span><br><span class="line">          fn.apply(this,args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/HTTP%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB-HTTPS%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/HTTP%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB-HTTPS%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">HTTP各版本的区别&HTTPS请求过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:44:14" itemprop="dateCreated datePublished" datetime="2022-10-24T16:44:14+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HTTP-各版本的区别"><a href="#HTTP-各版本的区别" class="headerlink" title="HTTP 各版本的区别"></a>HTTP 各版本的区别</h2><h3 id="什么是-HTTP-和-HTTPS？"><a href="#什么是-HTTP-和-HTTPS？" class="headerlink" title="什么是 HTTP 和 HTTPS？"></a>什么是 HTTP 和 HTTPS？</h3><p>HTTP 是浏览器与服务器之间以明文的方式传送内容的一种互联网通信协议。</p>
<p>HTTPS 是在 HTTP 的基础上主要基于 SPDF 协议结合 SSL&#x2F;TLS 加密协议，客户端依靠证书验证服务器身份传递加密信息的通信协议。</p>
<ul>
<li>1991 年　　 HTTP&#x2F;0.9 仅支持 GET 请求，不支持请求头</li>
<li>1996 年　　 HTTP&#x2F;1.0 默认短连接（一次请求建议一次 TCP 连接，请求完就断开），支持 GET、POST、 HEAD 请求</li>
<li>1999 年　　 HTTP&#x2F;1.1 默认长连接（一次 TCP 连接可以多次请求）；支持 PUT、DELETE、PATCH 等六种请求；增加 host 头，支持虚拟主机；支持断点续传功能</li>
<li>2015 年　　 HTTP&#x2F;2.0 多路复用，降低开销（一次 TCP 连接可以处理多个请求）；服务器主动推送（相关资源一个请求全部推送）；解析基于二进制，解析错误少，更高效（HTTP&#x2F;1.X 解析基于文本）；报头压缩，降低开销。</li>
</ul>
<h2 id="HTTPS-请求过程：（一次-HTTPS-请求要进行两次-HTTP-传输）"><a href="#HTTPS-请求过程：（一次-HTTPS-请求要进行两次-HTTP-传输）" class="headerlink" title="HTTPS 请求过程：（一次 HTTPS 请求要进行两次 HTTP 传输）"></a>HTTPS 请求过程：（一次 HTTPS 请求要进行两次 HTTP 传输）</h2><p>1.客户端发出 https 请求，请求服务端建立 SSL 连接；</p>
<p>2.服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端；</p>
<p>3.客户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥；</p>
<p>4.客户端将公钥与客户端私钥进行对称加密后传给服务端；</p>
<p>5.服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥；</p>
<p>6.服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端；</p>
<p>7.客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容。</p>
<h2 id="HTTPS-怎么校验证书的有效性？"><a href="#HTTPS-怎么校验证书的有效性？" class="headerlink" title="HTTPS 怎么校验证书的有效性？"></a>HTTPS 怎么校验证书的有效性？</h2><p>证书里面包含了公钥+各种信息+签名，公钥加密私钥解，私钥加密公钥解，通过私钥将签名解密后得到的信息和证书里面的信息比对就可以验证证书的合法性了。</p>
<p>签名是私钥和各种信息加密后形成的签名。</p>
<h2 id="为什么-HTTPS-很安全却不普及？"><a href="#为什么-HTTPS-很安全却不普及？" class="headerlink" title="为什么 HTTPS 很安全却不普及？"></a>为什么 HTTPS 很安全却不普及？</h2><p>1.加密通信与普通的文本通信，要消耗更多的 CPU 和内存，缓存慢，通信成本较大；</p>
<p>2.HTTPS 通信需要证书，而证书不是免费的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portal.jpg">
      <meta itemprop="name" content="Bruce Chen">
      <meta itemprop="description" content="It's better to burn out than to fade away.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bruce Chen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F/" class="post-title-link" itemprop="url">从URL输入到页面展现到底发生什么？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-24 16:43:34" itemprop="dateCreated datePublished" datetime="2022-10-24T16:43:34+08:00">2022-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 16:04:38" itemprop="dateModified" datetime="2022-11-08T16:04:38+08:00">2022-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">前端易混知识点</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://segmentfault.com/img/remote/1460000017184704" alt="image"></p>
<p>总体来说分为以下几个过程:</p>
<ul>
<li>DNS 解析:将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<h2 id="一、URL-到底是啥"><a href="#一、URL-到底是啥" class="headerlink" title="一、URL 到底是啥"></a>一、URL 到底是啥</h2><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。<br>比如 <a target="_blank" rel="noopener" href="http://www.w3school.com.cn/html/index.asp">http://www.w3school.com.cn/ht...</a>，遵守以下的语法规则：</p>
<ul>
<li>scheme:&#x2F;&#x2F;host.domain:port&#x2F;path&#x2F;filename</li>
<li>各部分解释如下：</li>
<li>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li>
<li>host - 定义域主机（http 的默认主机是 www）</li>
<li>domain - 定义因特网域名，比如 w3school.com.cn</li>
<li>port - 定义主机上的端口号（http 的默认端口号是 80）</li>
<li>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li>
<li>filename - 定义文档&#x2F;资源的名称</li>
</ul>
<h2 id="二、域名解析（DNS）"><a href="#二、域名解析（DNS）" class="headerlink" title="二、域名解析（DNS）"></a>二、域名解析（DNS）</h2><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。大家这里或许会有个疑问—-计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 <a target="_blank" rel="noopener" href="http://www.hackr.jp.那怎么不一开始就赋予个/">www.hackr.jp。那怎么不一开始就赋予个</a> IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址</p>
<h3 id="1-IP-地址"><a href="#1-IP-地址" class="headerlink" title="1.IP 地址"></a>1.IP 地址</h3><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。<br><strong>域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址</strong>。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。<strong>因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。</strong></p>
<h3 id="2-什么是域名解析"><a href="#2-什么是域名解析" class="headerlink" title="2.什么是域名解析"></a>2.什么是域名解析</h3><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。<strong>DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如 baidu.com  220.114.23.56（服务器外网IP地址）80（服务器端口号）</span><br></pre></td></tr></table></figure>

<h3 id="3-浏览器如何通过域名去查询-URL-对应的-IP-呢"><a href="#3-浏览器如何通过域名去查询-URL-对应的-IP-呢" class="headerlink" title="3. 浏览器如何通过域名去查询 URL 对应的 IP 呢"></a>3. 浏览器如何通过域名去查询 URL 对应的 IP 呢</h3><ul>
<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>
<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li>
<li>路由缓存：路由器也有 DNS 缓存。</li>
<li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>
<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li>
</ul>
<p><img src="https://segmentfault.com/img/remote/1460000017184705" alt="image"></p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。</p>
<p><img src="https://segmentfault.com/img/remote/1460000017184706" alt="image"></p>
<h2 id="三、TCP-三次握手"><a href="#三、TCP-三次握手" class="headerlink" title="三、TCP 三次握手"></a>三、TCP 三次握手</h2><p><strong>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</strong></p>
<p><img src="https://segmentfault.com/img/remote/1460000017184707" alt="image"></p>
<h3 id="1-TCP-三次握手的过程如下："><a href="#1-TCP-三次握手的过程如下：" class="headerlink" title="1.TCP 三次握手的过程如下："></a>1.TCP 三次握手的过程如下：</h3><ul>
<li><strong>客户端发送一个带 SYN&#x3D;1，Seq&#x3D;X 的数据包到服务器端口</strong>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li>
<li><strong>服务器发回一个带 SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y 的响应包以示传达确认信息</strong>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li>
<li><strong>客户端再回传一个带 ACK&#x3D;Y+1， Seq&#x3D;Z 的数据包，代表“握手结束”</strong>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li>
</ul>
<h3 id="2-为啥需要三次握手"><a href="#2-为啥需要三次握手" class="headerlink" title="2.为啥需要三次握手"></a>2.为啥需要三次握手</h3><p>谢希仁著《计算机网络》中讲“三次握手”的目的是<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>。</p>
<h2 id="四、发送-HTTP-请求"><a href="#四、发送-HTTP-请求" class="headerlink" title="四、发送 HTTP 请求"></a>四、发送 HTTP 请求</h2><p><strong>TCP 三次握手结束后，开始发送 HTTP 请求报文。</strong><br>请求报文由请求行（request line）、请求头（header）、请求体三个部分组成,如下图所示：</p>
<p><img src="https://segmentfault.com/img/remote/1460000017184708" alt="image"></p>
<h3 id="1-请求行包含请求方法、URL、协议版本"><a href="#1-请求行包含请求方法、URL、协议版本" class="headerlink" title="1.请求行包含请求方法、URL、协议版本"></a>1.请求行包含请求方法、URL、协议版本</h3><ul>
<li>请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li>
<li>URL 即请求地址，由 &lt;协议&gt;：&#x2F;&#x2F;&lt;主机&gt;：&lt;端口&gt;&#x2F;&lt;路径&gt;?&lt;参数&gt; 组成</li>
<li>协议版本即 http 版本号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /chapter17/user.html HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>以上代码中“POST”代表请求方法，“&#x2F;chapter17&#x2F;user.html”表示 URL，“HTTP&#x2F;1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本</p>
<h3 id="2-请求头包含请求的附加信息，由关键字-x2F-值对组成，每行一对，关键字和值用英文冒号“-”分隔。"><a href="#2-请求头包含请求的附加信息，由关键字-x2F-值对组成，每行一对，关键字和值用英文冒号“-”分隔。" class="headerlink" title="2.请求头包含请求的附加信息，由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。"></a>2.请求头包含请求的附加信息，由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。</h3><p>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：<strong>Host，表示主机名，虚拟主机；Connection,HTTP&#x2F;1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。</strong></p>
<h3 id="3-请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。"><a href="#3-请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。" class="headerlink" title="3.请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。"></a>3.请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=tom&amp;password=1234&amp;realName=tomson</span><br></pre></td></tr></table></figure>

<p>上面代码，承载着 name、password、realName 三个请求参数。</p>
<h2 id="五、服务器处理请求并返回-HTTP-报文"><a href="#五、服务器处理请求并返回-HTTP-报文" class="headerlink" title="五、服务器处理请求并返回 HTTP 报文"></a>五、服务器处理请求并返回 HTTP 报文</h2><h3 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1. 服务器"></a>1. 服务器</h3><p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。<br><strong>web server 担任管控的角色</strong>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。</p>
<p><img src="https://segmentfault.com/img/remote/1460000017184709" alt="image"></p>
<h3 id="2-MVC-后台处理阶段"><a href="#2-MVC-后台处理阶段" class="headerlink" title="2.MVC 后台处理阶段"></a>2.MVC 后台处理阶段</h3><p>后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。<br>MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。</p>
<p><img src="https://segmentfault.com/img/remote/1460000017184710" alt="image"></p>
<blockquote>
<p>1、视图（view）</p>
</blockquote>
<p><strong>它是提供给用户的操作界面，是程序的外壳。</strong></p>
<blockquote>
<p>2、模型（model）</p>
</blockquote>
<p><strong>模型主要负责数据交互</strong>。在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。</p>
<blockquote>
<p>3、控制器（controller）</p>
</blockquote>
<p><strong>它负责根据用户从”视图层”输入的指令，选取”模型层”中的数据，然后对其进行相应的操作，产生最终结果</strong>。控制器属于管理者角色，从视图接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。<br>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。<br>至于这一阶段发生什么？简而言之，<strong>首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。</strong></p>
<h3 id="3-http-响应报文"><a href="#3-http-响应报文" class="headerlink" title="3.http 响应报文"></a>3.http 响应报文</h3><p>响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示：<br><img src="https://segmentfault.com/img/remote/1460000017184711" alt="image"></p>
<p>(1) 响应行包含：协议版本，状态码，状态码描述</p>
<p>状态码规则如下：</p>
<ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>
</ul>
<p>(2) 响应头部包含响应报文的附加信息，由 名&#x2F;值 对组成</p>
<p>(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</p>
<h2 id="六、浏览器解析渲染页面"><a href="#六、浏览器解析渲染页面" class="headerlink" title="六、浏览器解析渲染页面"></a>六、浏览器解析渲染页面</h2><p>浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制</p>
<p><img src="https://segmentfault.com/img/remote/1460000017184712" alt="image"></p>
<p>浏览器解析渲染页面分为以下五个步骤：</p>
<ul>
<li>根据 HTML 解析出 DOM 树</li>
<li>根据 CSS 解析生成 CSS 规则树</li>
<li>结合 DOM 树和 CSS 规则树，生成渲染树</li>
<li>根据渲染树计算每一个节点的信息</li>
<li>根据计算好的信息绘制页面</li>
</ul>
<h3 id="1-根据-HTML-解析-DOM-树"><a href="#1-根据-HTML-解析-DOM-树" class="headerlink" title="1.根据 HTML 解析 DOM 树"></a>1.根据 HTML 解析 DOM 树</h3><ul>
<li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>
<li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li>
</ul>
<h3 id="2-根据-CSS-解析生成-CSS-规则树"><a href="#2-根据-CSS-解析生成-CSS-规则树" class="headerlink" title="2.根据 CSS 解析生成 CSS 规则树"></a>2.根据 CSS 解析生成 CSS 规则树</h3><ul>
<li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li>
<li>浏览器在 CSS 规则树生成之前不会进行渲染。</li>
</ul>
<h3 id="3-结合-DOM-树和-CSS-规则树，生成渲染树"><a href="#3-结合-DOM-树和-CSS-规则树，生成渲染树" class="headerlink" title="3.结合 DOM 树和 CSS 规则树，生成渲染树"></a>3.结合 DOM 树和 CSS 规则树，生成渲染树</h3><ul>
<li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li>
<li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面响应速度。</li>
</ul>
<h3 id="4-根据渲染树计算每一个节点的信息（布局）"><a href="#4-根据渲染树计算每一个节点的信息（布局）" class="headerlink" title="4.根据渲染树计算每一个节点的信息（布局）"></a>4.根据渲染树计算每一个节点的信息（布局）</h3><ul>
<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li>
<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>
</ul>
<h3 id="5-根据计算好的信息绘制页面"><a href="#5-根据计算好的信息绘制页面" class="headerlink" title="5.根据计算好的信息绘制页面"></a>5.根据计算好的信息绘制页面</h3><ul>
<li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li>
<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li>
<li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li>
</ul>
<h2 id="七、断开连接"><a href="#七、断开连接" class="headerlink" title="七、断开连接"></a>七、断开连接</h2><p><strong>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</strong></p>
<p><img src="https://segmentfault.com/img/remote/1460000017184713" alt="image"></p>
<ul>
<li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。</strong>(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>
<li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。</strong>(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>
<li><strong>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。</strong>(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>
<li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。</strong>(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>
</ul>
<p><strong>给大家推荐一个好用的 BUG 监控工具[Fundebug]<a target="_blank" rel="noopener" href="https://www.fundebug.com/?utm_source=liao)%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%85%8D%E8%B4%B9%E8%AF%95%E7%94%A8%EF%BC%81">https://www.fundebug.com/?utm_source=liao)，欢迎免费试用！</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Chen"
      src="/images/portal.jpg">
  <p class="site-author-name" itemprop="name">Bruce Chen</p>
  <div class="site-description" itemprop="description">It's better to burn out than to fade away.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1440429303&auto=1&height=66"></iframe>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jschentt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jschentt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jschentt@gmail.com" title="E-Mail → mailto:jschentt@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/BruceCh56742806" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;BruceCh56742806" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/jinsheng.chen.5439" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;jinsheng.chen.5439" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
  </div>





      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
