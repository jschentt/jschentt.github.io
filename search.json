[{"title":"Chrome Devtool — Performance","url":"/2022/10/24/Chrome-Devtool-%E2%80%94-Performance/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Performance 一个在前端开发领域中，无法被忽视的存在。使用 Chrome DevTools 的 performance 面板可以记录和分析页面在运行时的所有活动。本文将详细介绍如何使用 performance 面板解决性能瓶颈。</p>\n<h3 id=\"一、Performance-工具优点\"><a href=\"#一、Performance-工具优点\" class=\"headerlink\" title=\"一、Performance 工具优点\"></a>一、Performance 工具优点</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- 可视化图形界面</span><br><span class=\"line\">- 每毫秒做的事情</span><br><span class=\"line\">- 文件的执行加载的顺序</span><br><span class=\"line\">- 每毫秒界面展示的效果</span><br><span class=\"line\">- 每个方法执行的顺序和时间（由下至上）</span><br><span class=\"line\">- 倒置的事件火焰图（由下至上）</span><br><span class=\"line\">- 数据总结</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、熟悉-Performance-面板\"><a href=\"#二、熟悉-Performance-面板\" class=\"headerlink\" title=\"二、熟悉 Performance 面板\"></a>二、熟悉 Performance 面板</h3><p><img src=\"https://img-blog.csdnimg.cn/20200225113413787.png\" alt=\"image\"></p>\n<h3 id=\"三、工具栏\"><a href=\"#三、工具栏\" class=\"headerlink\" title=\"三、工具栏\"></a>三、工具栏</h3><blockquote>\n<p>【3.1】录制: 点击 Record （按 Ctrl+E），这时候 Devtools 就开始录制各种性能指标。记录时，Record 按钮会变成红色。然后按 Record 按钮或再次键入键盘快捷键停止记录；</p>\n<p>【3.2】刷新: 刷新页面分析；</p>\n<p>【3.3】清除: 清除页面分析结果；</p>\n<p>【3.4】上下箭头: 用来上传和下载每一次性能检测报告；</p>\n<p>【3.5】Screendshots: 显示屏幕快照，是用来查看在每个时间段界面的变化；</p>\n<p>【3.6】Memory: 存储调用栈的大小，在不同时间段的不同大小；</p>\n<p>【3.7】Disable Javascript samples: 禁用 JavaScript 调用栈；</p>\n<p>【3.8】Enable advanced paint instrumentation(slow): 记录渲染事件的细节；</p>\n<p>【3.9】Network: 模拟不同的网络环境；</p>\n<p>【3.10】CPU: 模拟不同的 CPU 运行速度；</p>\n</blockquote>\n<h3 id=\"四、overview-页面性能高级汇总\"><a href=\"#四、overview-页面性能高级汇总\" class=\"headerlink\" title=\"四、overview(页面性能高级汇总)\"></a>四、overview(页面性能高级汇总)</h3><p>这里最主要是整体的界面渲染的时候，每个时间段执行的事件顺序，我们就能知道我们每个时间段（精确到毫秒）都做了什么，当鼠标放上去的时候，我们还可以大图的形式去查看我们每个时间段界面的渲染情况：</p>\n<p><strong>【4.1】FPS</strong>: 全称 Frames Per Second，表示每秒传输帧数，是速度单位，用来分析动画的一个主要性能指标。如果能够达到 &gt;&#x3D;60fps(帧)&#x2F;s 的刷新频率，就可以避免出现卡顿。能保持在 60 的 FPS 的话，那么用户体验就是不错的。</p>\n<blockquote>\n<p><strong>为什么是 60fps?</strong></p>\n<p>我们的目标是保证页面要有高于每秒 60fps(帧)的刷新频率，这和目前大多数显示器的刷新率相吻合(60Hz)。如果网页动画能够做到每秒 60 帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行 60 次重新渲染，每次重新渲染的时间不能超过 1&#x2F;60&#x3D;0.01666s（秒）， 0.01666s*1000&#x3D;16.66ms（毫秒）。</p>\n</blockquote>\n<blockquote>\n<p><strong>不同帧的体验</strong>：<br>帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；<br>帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；<br>帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；<br>帧率波动很大的动画，亦会使人感觉到卡顿。</p>\n</blockquote>\n<p>如下图所示，绿色的长条越高，说明 FPS 越高，用户体验越好。 如果你发现了一个红色的长条，那么就说明这些帧存在严重问题，有可能导致非常差的用户体验。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225141647281.png\" alt=\"image\"></p>\n<p><strong>【4.2】CPU</strong>: CPU 资源。CPU 图表中的各种颜色代表着在这个时间段内，CPU 在各种处理上所花费的时间。如果你看到了某个处理占用了大量的时间，那么这可能就是一个可以找到性能瓶颈的线索。</p>\n<blockquote>\n<p>**下图中颜色分别为(与 Summary 面板里的颜色是相互对应的)**：</p>\n<p><strong>蓝色(Loading)</strong>: 表示网络通信和 HTML 解析时间<br><strong>黄色(Scripting)</strong>: 表示 JavaScript 执行时间<br><strong>紫色(Rendering)</strong>: 表示样式计算和布局（重排）时间<br><strong>绿色(Painting</strong>): 表示重绘时间<br><strong>灰色(other)</strong>: 表示其它事件花费的时间<br><strong>白色(Idle)</strong>: 表示空闲时间</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225142026718.png\" alt=\"image\"></p>\n<p><strong>【4.3】NET</strong>: 每条彩色横杠表示一种资源。横杠越长，检索资源所需的时间越长。 每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间）。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225142049962.png\" alt=\"image\"></p>\n<p><strong>【4.4】HEAP</strong>: JavaScript 执行的时间分布。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2020022514210719.png\" alt=\"image\"></p>\n<h3 id=\"五、火焰图-CPU-堆叠追踪的可视化\"><a href=\"#五、火焰图-CPU-堆叠追踪的可视化\" class=\"headerlink\" title=\"五、火焰图(CPU 堆叠追踪的可视化)\"></a>五、火焰图(CPU 堆叠追踪的可视化)</h3><p><img src=\"https://img-blog.csdnimg.cn/20200225151854312.png\" alt=\"image\"></p>\n<p><strong>【5.1】Network</strong>: 表示每个服务器资源的加载情况，什么时间加载了什么资源，通过这里，我们更直观的可以知道，资源是并行加载的</p>\n<p><strong>【5.2】Frames</strong>: 表示每幅帧的运行情况</p>\n<p><strong>【5.3】Timings</strong>: 上图中有 4 条虚线，分别表示如下：</p>\n<blockquote>\n<ul>\n<li><strong>DCL(DOMContentLoaded)</strong>: 表示 HTML 文档加载完成事件。当初始 HTML 文档完全加载并解析之后触发，无需等待样式、图片、子 frame 结束。作为明显的对比，load 事件是当个页面完全被加载时才触发</li>\n<li><strong>FP(First Paint)</strong>: 首屏绘制，页面刚开始渲染的时间</li>\n<li><strong>FCP(First Contentful Paint)</strong>: 首屏内容绘制，首次绘制任何文本，图像，非空白 canvas 或 SVG 的时间点</li>\n<li><strong>FMP(First Meaningful Paint)</strong>: 首屏有意义的内容绘制，这个“有意义”没有权威的规定，本质上是通过一种算法来猜测某个时间点可能是 FMP。有的理解为是最大元素绘制的时间，即同 LCP(Largest Contentful Paint）</li>\n<li><strong>L(Onload)</strong>: 页面所有资源加载完成事件。</li>\n<li><strong>LCP(Largest Contentful Paint)</strong>: 最大内容绘制，页面上尺寸最大的元素绘制时间。<br>其中 FP、FCP、FMP 是同一条虚线，三者时间不一致。比如首次渲染过后，有可能出现 JS 阻塞，这种情况下 FCP 就会大于 FP</li>\n</ul>\n</blockquote>\n<p><strong>【5.4】Main</strong>: 表示主线程</p>\n<blockquote>\n<p><strong>主要负责</strong>：</p>\n<ul>\n<li>Javascript 的计算与执行</li>\n<li>CSS 样式计算</li>\n<li>Layout 布局计算</li>\n<li>将页面元素绘制成位图（paint），也就是光栅化（Raster）</li>\n<li>将位图给合成线程</li>\n</ul>\n</blockquote>\n<p><strong>【5.5】Raster</strong>: 光栅化（处理光栅图，即位图）</p>\n<p><strong>【5.6】GPU</strong>: 表示 GPU 占用情况</p>\n<p><strong>【5.7】Chrome_childIOThread</strong>: 子线程</p>\n<p><strong>【5.8】Compositor</strong>: 合成线程</p>\n<blockquote>\n<p><strong>主要负责</strong>：</p>\n<ul>\n<li>将位图（GraphicsLayer 层）以纹理（texture）的形式上传给 GPU</li>\n<li>计算页面的可见部分和即将可见部分（滚动）</li>\n<li>CSS 动画处理</li>\n<li>通知 GPU 绘制位图到屏幕上</li>\n</ul>\n</blockquote>\n<p><strong>【5.9】Memory</strong>: 上面有提到 Memory 选项，在勾选后，就会显示该事件折线图，通过该图，可以看出我们在不同的时间段，不同事件的执行情况</p>\n<blockquote>\n<ul>\n<li><strong>JS Heap:</strong> 表示 JS 占用的内存大小。</li>\n<li><strong>Documents</strong>: 表示文档数。</li>\n<li><strong>Nodes:</strong> 表示 Node 节点数</li>\n<li><strong>Listeners:</strong> 表示监听数。</li>\n<li><strong>GPU Memory:</strong> 表示 GPU 占用数<br>4 条折线图是以上 4 个指标（没有 GPU 消耗）对应的时间消耗的内存大小与节点数量。若将某项指标前面的勾选去掉则不会出现对应的折线。注意这个折线图只有在点击 Main 主线程的时候才会有，选择其他的指标时折线图区域是空白。</li>\n</ul>\n</blockquote>\n<h3 id=\"六、统计汇总-以图表的形式汇总数据\"><a href=\"#六、统计汇总-以图表的形式汇总数据\" class=\"headerlink\" title=\"六、统计汇总(以图表的形式汇总数据)\"></a>六、统计汇总(以图表的形式汇总数据)</h3><p><img src=\"https://img-blog.csdnimg.cn/20200225155545507.png\" alt=\"image\"></p>\n<p><strong>【6.1】Summary</strong>: 表示各指标时间占用统计报表</p>\n<blockquote>\n<ul>\n<li>Loading: 加载时间</li>\n<li>Scripting: js 计算时间</li>\n<li>Rendering: 渲染时间</li>\n<li>Painting: 绘制时间</li>\n<li>Other: 其他时间</li>\n<li>Idle: 浏览器闲置时间</li>\n</ul>\n</blockquote>\n<p><strong>【6.2】Bottom-Up</strong>: 表示事件时长排序列表（倒序）</p>\n<p>这里和 Main 里面看见的，其实是一个对应着的关系，从这里，我们可以看见所有的事件列表，还有每个事件的 Self Time(自己调用的时间） 、Total Time(总调用时间，包括子项调用时间） 、Activity(行为，包括调用该事件的位置）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225160433232.png\" alt=\"image\"></p>\n<p><strong>【6.3】Call Tree</strong>: 表示事件调用顺序列表</p>\n<p>其实这里和 Bottom-Up 部分是一样的，就不做太多的说明了</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225160516378.png\" alt=\"image\"></p>\n<p><strong>【6.4】Event Log</strong>: 表示事件发生的顺序列表</p>\n<p>这里比前面的 Bottom-Up 和 Call Tree 相比，多了一个 Start Time 属性，这个属性其实就是开始的时间，从什么时间开始执行的什么事件</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225160545704.png\" alt=\"image\"></p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"HTTP各版本的区别&HTTPS请求过程","url":"/2022/10/24/HTTP%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB-HTTPS%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/","content":"<h2 id=\"HTTP-各版本的区别\"><a href=\"#HTTP-各版本的区别\" class=\"headerlink\" title=\"HTTP 各版本的区别\"></a>HTTP 各版本的区别</h2><h3 id=\"什么是-HTTP-和-HTTPS？\"><a href=\"#什么是-HTTP-和-HTTPS？\" class=\"headerlink\" title=\"什么是 HTTP 和 HTTPS？\"></a>什么是 HTTP 和 HTTPS？</h3><p>HTTP 是浏览器与服务器之间以明文的方式传送内容的一种互联网通信协议。</p>\n<p>HTTPS 是在 HTTP 的基础上主要基于 SPDF 协议结合 SSL&#x2F;TLS 加密协议，客户端依靠证书验证服务器身份传递加密信息的通信协议。</p>\n<ul>\n<li>1991 年　　 HTTP&#x2F;0.9 仅支持 GET 请求，不支持请求头</li>\n<li>1996 年　　 HTTP&#x2F;1.0 默认短连接（一次请求建议一次 TCP 连接，请求完就断开），支持 GET、POST、 HEAD 请求</li>\n<li>1999 年　　 HTTP&#x2F;1.1 默认长连接（一次 TCP 连接可以多次请求）；支持 PUT、DELETE、PATCH 等六种请求；增加 host 头，支持虚拟主机；支持断点续传功能</li>\n<li>2015 年　　 HTTP&#x2F;2.0 多路复用，降低开销（一次 TCP 连接可以处理多个请求）；服务器主动推送（相关资源一个请求全部推送）；解析基于二进制，解析错误少，更高效（HTTP&#x2F;1.X 解析基于文本）；报头压缩，降低开销。</li>\n</ul>\n<h2 id=\"HTTPS-请求过程：（一次-HTTPS-请求要进行两次-HTTP-传输）\"><a href=\"#HTTPS-请求过程：（一次-HTTPS-请求要进行两次-HTTP-传输）\" class=\"headerlink\" title=\"HTTPS 请求过程：（一次 HTTPS 请求要进行两次 HTTP 传输）\"></a>HTTPS 请求过程：（一次 HTTPS 请求要进行两次 HTTP 传输）</h2><p>1.客户端发出 https 请求，请求服务端建立 SSL 连接；</p>\n<p>2.服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端；</p>\n<p>3.客户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥；</p>\n<p>4.客户端将公钥与客户端私钥进行对称加密后传给服务端；</p>\n<p>5.服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥；</p>\n<p>6.服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端；</p>\n<p>7.客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容。</p>\n<h2 id=\"HTTPS-怎么校验证书的有效性？\"><a href=\"#HTTPS-怎么校验证书的有效性？\" class=\"headerlink\" title=\"HTTPS 怎么校验证书的有效性？\"></a>HTTPS 怎么校验证书的有效性？</h2><p>证书里面包含了公钥+各种信息+签名，公钥加密私钥解，私钥加密公钥解，通过私钥将签名解密后得到的信息和证书里面的信息比对就可以验证证书的合法性了。</p>\n<p>签名是私钥和各种信息加密后形成的签名。</p>\n<h2 id=\"为什么-HTTPS-很安全却不普及？\"><a href=\"#为什么-HTTPS-很安全却不普及？\" class=\"headerlink\" title=\"为什么 HTTPS 很安全却不普及？\"></a>为什么 HTTPS 很安全却不普及？</h2><p>1.加密通信与普通的文本通信，要消耗更多的 CPU 和内存，缓存慢，通信成本较大；</p>\n<p>2.HTTPS 通信需要证书，而证书不是免费的。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"HTTP常用的14种状态码","url":"/2022/10/24/HTTP%E5%B8%B8%E7%94%A8%E7%9A%8414%E7%A7%8D%E7%8A%B6%E6%80%81%E7%A0%81/","content":"<p>状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误。</p>\n<p>状态码的类别：</p>\n<table>\n<thead>\n<tr>\n<th>~</th>\n<th>类别</th>\n<th>原因短语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td>Informational（信息性状态码）</td>\n<td>接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success（成功状态码）</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection（重定向状态码）</td>\n<td>需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error（客户端错误状态码）</td>\n<td>服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error（服务器错误状态码）</td>\n<td>服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<h2 id=\"2XX——表明请求被正常处理了\"><a href=\"#2XX——表明请求被正常处理了\" class=\"headerlink\" title=\"2XX——表明请求被正常处理了\"></a>2XX——表明请求被正常处理了</h2><p>1、200 OK：<strong>请求已正常处理</strong>。</p>\n<p>2、204 No Content：<strong>请求处理成功，但没有任何资源可以返回给客户端</strong>，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>\n<p>3、206 Partial Content：<strong>是对资源某一部分的请求</strong>，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>\n<h2 id=\"3XX——表明浏览器需要执行某些特殊的处理以正确处理请求\"><a href=\"#3XX——表明浏览器需要执行某些特殊的处理以正确处理请求\" class=\"headerlink\" title=\"3XX——表明浏览器需要执行某些特殊的处理以正确处理请求\"></a>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</h2><p>4、301 Moved Permanently：<strong>资源的 uri 已更新，你也更新下你的书签引用吧。永久性重定向</strong>，请求的资源已经被分配了新的 URI，以后应使用资源现在所指的 URI。</p>\n<p>5、302 Found：<strong>资源的 URI 已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向</strong>。和 301 相似，但 302 代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。</p>\n<p>6、303 See Other：<strong>资源的 URI 已更新，你是否能临时按新的 URI 访问</strong>。该状态码表示由于请求对应的资源存在着另一个 URL，应使用 GET 方法定向获取请求的资源。303 状态码和 302 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。</p>\n<p>当 301,302,303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。</p>\n<p>7、304 Not Modified：<strong>资源已找到，但未符合条件请求</strong>。该状态码表示客户端发送附带条件的请求时（采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回 304.。</p>\n<p>8、307 Temporary Redirect：<strong>临时重定向</strong>。与 302 有相同的含义。</p>\n<h2 id=\"4XX——表明客户端是发生错误的原因所在。\"><a href=\"#4XX——表明客户端是发生错误的原因所在。\" class=\"headerlink\" title=\"4XX——表明客户端是发生错误的原因所在。\"></a>4XX——表明客户端是发生错误的原因所在。</h2><p>9、400 Bad Request：<strong>服务器端无法理解客户端发送的请求</strong>，请求报文中可能存在语法错误。</p>\n<p>10、401 Unauthorized：<strong>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证，DIGEST 认证）的认证信息。</strong></p>\n<p>11、403 Forbidden：<strong>不允许访问那个资源</strong>。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权 IP 等）</p>\n<p>12、404 Not Found：<strong>服务器上没有请求的资源</strong>。路径错误等。</p>\n<h2 id=\"5XX——服务器本身发生错误\"><a href=\"#5XX——服务器本身发生错误\" class=\"headerlink\" title=\"5XX——服务器本身发生错误\"></a>5XX——服务器本身发生错误</h2><p>13、500 Internal Server Error：<strong>貌似内部资源出故障了</strong>。该状态码表明服务器端在执行请求时发生了错误。也有可能是 web 应用存在 bug 或某些临时故障。</p>\n<p>14、503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"JavaScript——链表相关","url":"/2022/12/16/JavaScript%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/","content":"<h2 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>\n<p>例如：</p>\n<p>输入：a-&gt;b-&gt;c-&gt;d-&gt;e</p>\n<p>输出：a&lt;-b&lt;-c&lt;-d&lt;-e</p>\n<p>反转链表示意图如下，链表的最后一个元素 next 指向 null。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190408161404713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3OTU0NjQz,size_16,color_FFFFFF,t_70\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*function ListNode(x)&#123;</span><br><span class=\"line\">    this.val = x;</span><br><span class=\"line\">    this.next = null;</span><br><span class=\"line\">&#125;*/</span><br><span class=\"line\"></span><br><span class=\"line\">function isEmptyObject(obj) &#123;// 判断输入参数链表是否为空</span><br><span class=\"line\">  for (var name in obj) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function ReverseList(pHead) &#123;</span><br><span class=\"line\">    if (isEmptyObject(pHead)) &#123;// 调用链表是否为空函数</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pre = null;//链表的最后一个元素</span><br><span class=\"line\">    var next = null;//初始化next为null，下面再赋值</span><br><span class=\"line\">    while (pHead != null) &#123;//pHead移动，直至到链表最后一个元素，指向null，结束循环</span><br><span class=\"line\">        next = pHead.next;//pHead.next值先赋给next，以免覆盖，next移动</span><br><span class=\"line\">        pHead.next = pre;//改变pHead指向，给pHead.next赋值，指向null</span><br><span class=\"line\">        pre = pHead;//pre移动</span><br><span class=\"line\">        pHead = next;//pHead移动</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单链表是否有环\"><a href=\"#单链表是否有环\" class=\"headerlink\" title=\"单链表是否有环\"></a>单链表是否有环</h2><ol>\n<li>创建哈希表,不过会占⽤较⼤的空间,不是最佳⽅法.( 时间复杂度 O(n) )</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function judge(list)&#123;</span><br><span class=\"line\">  var set =new Set();</span><br><span class=\"line\">  while(list)&#123;</span><br><span class=\"line\">    if(set.has(list))&#123;</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set.add(list)</span><br><span class=\"line\">    list=list.next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给节点添加 visited 访问标记 (时间复杂度 O(n)), 不需要额外的空间</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function LinkedList()&#123;</span><br><span class=\"line\">  var Node=function()&#123;</span><br><span class=\"line\">    this.element=element;</span><br><span class=\"line\">    this.next=null;</span><br><span class=\"line\">    this.visited=0; //访问标记</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function judge(list)&#123;</span><br><span class=\"line\">  while(list)&#123;</span><br><span class=\"line\">    if(list.visited==1)&#123;</span><br><span class=\"line\">     return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    list.visited=1</span><br><span class=\"line\">    list=list.next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>快慢指针法,设定快指针 fast,慢指针 slow,每次循环快指针 fast 移动两个位置,慢指针移动⼀个位置<br>(时间复杂度 O(n)) 需要额外的空间</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function judge(list)&#123;</span><br><span class=\"line\">  var fast=list.next.next,</span><br><span class=\"line\">  slow=list.next;</span><br><span class=\"line\">  while(fast)&#123;</span><br><span class=\"line\">    if(fast===slow)&#123;</span><br><span class=\"line\">          return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fast=fast.next.next</span><br><span class=\"line\">    slow=slow.next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"JavaScript变量提升和函数提升","url":"/2022/10/24/JavaScript%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/","content":"<h2 id=\"1-变量提升\"><a href=\"#1-变量提升\" class=\"headerlink\" title=\"1. 变量提升\"></a>1. 变量提升</h2><p>通常 JS 引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。(注：当前流行的 JS 引擎大都对源码进行了编译，由于引擎的不同，编译形式也会有所差异，我们这里说的预编译和提升其实是抽象出来的、易于理解的概念)</p>\n<p>下面的代码中，我们在函数中声明了一个变量，不过这个变量声明是在 if 语句块中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    if (!foo) &#123;</span><br><span class=\"line\">        var foo = 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<p>运行代码，我们会发现 foo 的值是 5，初学者可能对此不甚理解，如果外层作用域也存在一个 foo 变量，就更加困惑了，该不会是打印外层作用域中的 foo 变量吧？答案是：不会，如果当前作用域中存在此变量声明，无论它在什么地方声明，引用此变量时就会在当前作用域中查找，不会去外层作用域了。</p>\n<p>那么至于说打印结果，这要提到预编译机制了，经过一次预编译之后，上面的代码逻辑如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 预编译之后</span><br><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!foo) &#123;</span><br><span class=\"line\">        foo = 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<p>是的，引擎将变量声明提升到了函数顶部，初始值为 undefined，自然，if 语句块就会被执行，foo 变量赋值为 5，下面的打印也就是预期的结果了。</p>\n<p>类似的，还有下面一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    var foo = foo || 5;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<p>foo || 5 这个表达式的结果是 5 而不是 3，虽然外层作用域有个 foo 变量，但函数内是不会去引用的，因为预编译之后的代码逻辑是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// 预编译之后</span><br><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo = foo || 5;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<p>如果当前作用域中声明了多个同名变量，那么根据我们的推断，它们的同一个标识符会被提升至作用域顶部，其他部分按顺序执行，比如下面的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        var foo = 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<p>由于 JavaScript 没有块作用域，只有全局作用域和函数作用域，所以预编译之后的代码逻辑为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 预编译之后</span><br><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        foo = 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-函数提升\"><a href=\"#2-函数提升\" class=\"headerlink\" title=\"2. 函数提升\"></a>2. 函数提升</h2><p>相信大家对下面这段代码都不陌生，实际开发当中也很常见：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    foo(); // output: I am hoisted</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(&#x27;I am hoisted&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n\n<p>为什么函数可以在声明之前就可以调用，并且跟变量声明不同的是，它还能得到正确的结果，其实引擎是把函数声明整个地提升到了当前作用域的顶部，预编译之后的代码逻辑如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 预编译之后</span><br><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(&#x27;I am hoisted&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // output: I am hoisted</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n\n<p>相似的，如果在同一个作用域中存在多个同名函数声明，后面出现的将会覆盖前面的函数声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // output: 2</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n\n<p>对于函数，除了使用上面的函数声明，更多时候，我们会使用函数表达式，下面是函数声明和函数表达式的对比：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 函数声明</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(&#x27;function declaration&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匿名函数表达式</span><br><span class=\"line\">var foo = function() &#123;</span><br><span class=\"line\">    console.log(&#x27;anonymous function expression&#x27;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 具名函数表达式</span><br><span class=\"line\">var foo = function bar() &#123;</span><br><span class=\"line\">    console.log(&#x27;named function expression&#x27;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，匿名函数表达式，其实是将一个不带名字的函数声明赋值给了一个变量，而具名函数表达式，则是带名字的函数赋值给一个变量，需要注意到是，这个函数名只能在此函数内部使用。我们也看到了，其实函数表达式可以通过变量访问，所以也存在变量提升同样的效果。</p>\n<p>那么当函数声明遇到函数表达式时，会有什么样的结果呢，先看下面这段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    foo(); // 2</span><br><span class=\"line\"></span><br><span class=\"line\">    var foo = function() &#123;</span><br><span class=\"line\">        console.log(1);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // 1</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n\n<p>运行后我们会发现，输出的结果依次是 2 1 1，为什么会有这样的结果呢？</p>\n<p>因为 JavaScript 中的函数是一等公民，函数声明的优先级最高，会被提升至当前作用域最顶端，所以第一次调用时实际执行了下面定义的函数声明，然后第二次调用时，由于前面的函数表达式与之前的函数声明同名，故将其覆盖，以后的调用也将会打印同样的结果。上面的过程经过预编译之后，代码逻辑如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 预编译之后</span><br><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo = function foo() &#123;</span><br><span class=\"line\">        console.log(2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // 2</span><br><span class=\"line\"></span><br><span class=\"line\">    foo = function() &#123;</span><br><span class=\"line\">        console.log(1);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // 1</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n\n<p>我们也不难理解，下面的函数和变量重名时，会如何执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    console.log(foo); // function foo() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo = 5;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br><span class=\"line\">console.log(foo);     // 3</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，函数声明被提升至作用域最顶端，然后被赋值为 5，而外层的变量并没有被覆盖，经过预编译之后，上面代码的逻辑是这样的：</p>\n<p>&#x2F;&#x2F; 预编译之后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">   var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">   foo = function foo() &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   console.log(foo); // function foo() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   foo = 5;</span><br><span class=\"line\"></span><br><span class=\"line\">   console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br><span class=\"line\">console.log(foo);    // 3</span><br></pre></td></tr></table></figure>\n\n<p>所以，函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行，这一点要牢记。</p>\n<h2 id=\"3-为什么要进行提升\"><a href=\"#3-为什么要进行提升\" class=\"headerlink\" title=\"3. 为什么要进行提升\"></a>3. 为什么要进行提升</h2><p>关于为什么进行变量提升和函数提升，这个问题一直没有明确的答案，不过最近读到 Dmitry Soshnikov 之前的一篇文章时，多少了解了一些，下面是 Dmitry Soshnikov 早些年的 twitter，他也对这个问题十分感兴趣：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160927084830453-161910040.png\" alt=\"image\"></p>\n<p>然后 Jeremy Ashkenas 想让 Brendan Eich 聊聊这个话题：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160927085003891-1035941947.png\" alt=\"image\"></p>\n<p>最后，Brendan Eich 给出了答案：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160927085032422-1936451758.png\" alt=\"image\"></p>\n<p>大致的意思就是：由于第一代 JS 虚拟机中的抽象纰漏导致的，编译器将变量放到了栈槽内并编入索引，然后在（当前作用域的）入口处将变量名绑定到了栈槽内的变量。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。）</p>\n<p>然后，Dmitry Soshnikov 又提到了函数提升，他提到了相互递归（就是 A 函数内会调用到 B 函数，而 B 函数也会调用到 A 函数）：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160928082258078-892410645.png\" alt=\"image\"></p>\n<p>随后 Brendan Eich 很热心的又给出了答案：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160928082526438-697971926.png\" alt=\"image\"></p>\n<p>Brendan Eich 很确定的说，函数提升就是为了解决相互递归的问题，大体上可以解决像 ML 语言这样自下而上的顺序问题。</p>\n<p>这里简单阐述一下相互递归，下面两个函数分别在自己的函数体内调用了对方：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 验证偶数</span><br><span class=\"line\">function isEven(n) &#123;</span><br><span class=\"line\">    if (n === 0) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isOdd(n - 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(isEven(2)); // true</span><br><span class=\"line\"></span><br><span class=\"line\">// 验证奇数</span><br><span class=\"line\">function isOdd(n) &#123;</span><br><span class=\"line\">    if (n === 0) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isEven(n - 1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有函数提升，而是按照自下而上的顺序，当 isEven 函数被调用时，isOdd 函数还未声明，所以当 isEven 内部无法调用 isOdd 函数。所以 Brendan Eich 设计了函数提升这一形式，将函数提升至当前作用域的顶部：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 验证偶数</span><br><span class=\"line\">function isEven(n) &#123;</span><br><span class=\"line\">    if (n === 0) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isOdd(n - 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 验证奇数</span><br><span class=\"line\">function isOdd(n) &#123;</span><br><span class=\"line\">    if (n === 0) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isEven(n - 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(isEven(2)); // true</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，问题就迎刃而解了。</p>\n<p>最后，Brendan Eich 还对变量提升和函数提升做了总结：<br><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160928084223719-96754371.png\" alt=\"image\"><br>大概是说，变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。</p>\n<p>至此，关于变量提升和函数提升，相信大家已经明白其中的真相了。</p>\n<h2 id=\"4-最佳实践\"><a href=\"#4-最佳实践\" class=\"headerlink\" title=\"4. 最佳实践\"></a>4. 最佳实践</h2><p>理解变量提升和函数提升可以使我们更了解这门语言，更好地驾驭它，但是在开发中，我们不应该使用这些技巧，而是要规范我们的代码，做到可读性和可维护性。</p>\n<p>具体的做法是：无论变量还是函数，都必须先声明后使用。下面举了简单的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var name = &#x27;Scott&#x27;;</span><br><span class=\"line\">var sayHello = function(guest) &#123;</span><br><span class=\"line\">    console.log(name, &#x27;says hello to&#x27;, guest);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var i;</span><br><span class=\"line\">var guest;</span><br><span class=\"line\">var guests = [&#x27;John&#x27;, &#x27;Tom&#x27;, &#x27;Jack&#x27;];</span><br><span class=\"line\"></span><br><span class=\"line\">for (i = 0; i &lt; guests.length; i++) &#123;</span><br><span class=\"line\">    guest = guests[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    // do something on guest</span><br><span class=\"line\"></span><br><span class=\"line\">    sayHello(guest);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果对于新的项目，可以使用 let 替换 var，会变得更可靠，可维护性更高：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let name = &#x27;Scott&#x27;;</span><br><span class=\"line\">let sayHello = function(guest) &#123;</span><br><span class=\"line\">    console.log(name, &#x27;says hello to&#x27;, guest);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let guests = [&#x27;John&#x27;, &#x27;Tom&#x27;, &#x27;Jack&#x27;];</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; guests.length; i++) &#123;</span><br><span class=\"line\">    let guest = guests[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    // do something on guest</span><br><span class=\"line\"></span><br><span class=\"line\">    sayHello(guest);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得一提的是，ES6 中的 class 声明也存在提升，不过它和 let、const 一样，被约束和限制了，其规定，如果再声明位置之前引用，则是不合法的，会抛出一个异常。</p>\n<p>所以，无论是早期的代码，还是 ES6 中的代码，我们都需要遵循一点，先声明，后使用。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"React 的 PureComponent Vs Component","url":"/2022/10/24/React-%E7%9A%84-PureComponent-Vs-Component/","content":"<h2 id=\"一-它们几乎完全相同，但是-PureComponent-通过-prop-和-state-的浅比较来实现-shouldComponentUpdate，某些情况下可以用-PureComponent-提升性能\"><a href=\"#一-它们几乎完全相同，但是-PureComponent-通过-prop-和-state-的浅比较来实现-shouldComponentUpdate，某些情况下可以用-PureComponent-提升性能\" class=\"headerlink\" title=\"一.它们几乎完全相同，但是 PureComponent 通过 prop 和 state 的浅比较来实现 shouldComponentUpdate，某些情况下可以用 PureComponent 提升性能\"></a>一.它们几乎完全相同，但是 PureComponent 通过 prop 和 state 的浅比较来实现 shouldComponentUpdate，某些情况下可以用 PureComponent 提升性能</h2><p>1.所谓浅比较(shallowEqual)，即 react 源码中的一个函数，然后根据下面的方法进行是不是 PureComponent 的判断，帮我们做了本来应该我们在 shouldComponentUpdate 中做的事情</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (this._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class=\"line\">  shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而本来我们做的事情如下，这里判断了 state 有没有发生变化（prop 同理），从而决定要不要重新渲染，这里的函数在一个继承了 Component 的组件中，而这里 this.state.person 是一个对象，你会发现，在这个对象的引用没有发生变化的时候是不会重新 render 的（即下面提到的第三点），所以我们可以用 shouldComponentUpdate 进行优化，这个方法如果返回 false，表示不需要重新进行渲染，返回 true 则重新渲染，默认返回 true</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    return (nextState.person !== this.state.person);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.上面提到的某些情况下可以使用 PureComponent 来提升性能，那具体是哪些情况可以，哪些情况不可以呢，实践出真知</p>\n<p>3.如下显示的是一个 IndexPage 组件，设置了一个 state 是 isShow，通过一个按钮点击可以改变它的值，结果是：初始化的时候输出的是 constructor，render，而第一次点击按钮，会输出一次 render，即重新渲染了一次，界面也会从显示 false 变成显示 true，但是当这个组件是继承自 PureComponent 的时候，再点击的时，不会再输出 render，即不会再重新渲染了，而当这个组件是继承自 Component 时，还是会输出 render，还是会重新渲染，这时候就是 PureComponent 内部做了优化的体现</p>\n<p>4.同理也适用于 string，number 等基本数据类型，因为基本数据类型，值改变了就算改变了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; PureComponent &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class IndexPage extends PureComponent&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      isShow: false</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    console.log(&#x27;constructor&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  changeState = () =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      isShow: true</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(&#x27;render&#x27;);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;this.changeState&#125;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;this.state.isShow.toString()&#125;&lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.当这个 this.state.arr 是一个数组时，且这个组件是继承自 PureComponent 时，初始化依旧是输出 constructor 和 render，但是当点击按钮时，界面上没有变化，也没有输出 render，证明没有渲染，但是我们可以从下面的注释中看到，每点击一次按钮，我们想要修改的 arr 的值已经改变，而这个值将去修改 this.state.arr,但是因为在 PureComponent 中浅比较这个数组的引用没有变化所以没有渲染，this.state.arr 也没有更新，因为在 this.setState()以后，值是在 render 的时候更新的，这里涉及到 this.setState()的知识</p>\n<p>6.但是当这个组件是继承自 Component 的时候，初始化依旧是输出 constructor 和 render，但是当点击按钮时，界面上出现了变化，即我们打印处理的 arr 的值输出，而且每点击一次按钮都会输出一次 render，证明已经重新渲染，this.state.arr 的值已经更新，所以我们能在界面上看到这个变化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; PureComponent &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class IndexPage extends PureComponent&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      arr:[&#x27;1&#x27;]</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    console.log(&#x27;constructor&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  changeState = () =&gt; &#123;</span><br><span class=\"line\">    let &#123; arr &#125; = this.state;</span><br><span class=\"line\">    arr.push(&#x27;2&#x27;);</span><br><span class=\"line\">    console.log(arr);</span><br><span class=\"line\">    // [&quot;1&quot;, &quot;2&quot;]</span><br><span class=\"line\">    // [&quot;1&quot;, &quot;2&quot;, &quot;2&quot;]</span><br><span class=\"line\">    // [&quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;]</span><br><span class=\"line\">    // ....</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      arr</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(&#x27;render&#x27;);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;this.changeState&#125;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &#123;this.state.arr.map((item) =&gt; &#123;</span><br><span class=\"line\">            return item;</span><br><span class=\"line\">          &#125;)&#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>7.下面的例子用扩展运算符产生新数组，使 this.state.arr 的引用发生了变化，所以初始化的时候输出 constructor 和 render 后，每次点击按钮都会输出 render，界面也会变化，不管该组件是继承自 Component 还是 PureComponent 的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; PureComponent &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class IndexPage extends PureComponent&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      arr:[&#x27;1&#x27;]</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    console.log(&#x27;constructor&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  changeState = () =&gt; &#123;</span><br><span class=\"line\">    let &#123; arr &#125; = this.state;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      arr: [...arr, &#x27;2&#x27;]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(&#x27;render&#x27;);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;this.changeState&#125;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &#123;this.state.arr.map((item) =&gt; &#123;</span><br><span class=\"line\">            return item;</span><br><span class=\"line\">          &#125;)&#125;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>8.上面的情况同样适用于对象的情况</p>\n<h2 id=\"二-PureComponent-不仅会影响本身，而且会影响子组件，所以-PureComponent-最佳情况是展示组件\"><a href=\"#二-PureComponent-不仅会影响本身，而且会影响子组件，所以-PureComponent-最佳情况是展示组件\" class=\"headerlink\" title=\"二.PureComponent 不仅会影响本身，而且会影响子组件，所以 PureComponent 最佳情况是展示组件\"></a>二.PureComponent 不仅会影响本身，而且会影响子组件，所以 PureComponent 最佳情况是展示组件</h2><p>1.我们让 IndexPage 组件里面包含一个子组件 Example 来展示 PureComponent 是如何影响子组件的</p>\n<p>2.父组件继承 PureComponent，子组件继承 Component 时：下面的结果初始化时输出为 constructor，IndexPage render，example render，但是当我们点击按钮时，界面没有变化，因为这个 this.state.person 对象的引用没有改变，只是改变了它里面的属性值所以尽管子组件是继承 Component 的也没有办法渲染，因为父组件是 PureComponent，父组件根本没有渲染，所以子组件也不会渲染</p>\n<p>3.父组件继承 PureComponent，子组件继承 PureComponent 时：因为渲染在父组件的时候就没有进行，相当于被拦截了，所以子组件是 PureComponent 还是 Component 根本不会影响结果，界面依旧没有变化</p>\n<p>4.父组件继承 Component，子组件继承 PureComponent 时：结果和我们预期的一样，即初始化是会输出 constructor，IndexPage render，example render，但是点击的时候只会出现 IndexPage render，因为父组件是 Component，所以父组件会渲染，但是<br>当父组件把值传给子组件的时候，因为子组件是 PureComponent，所以它会对 prop 进行浅比较，发现这个 person 对象的引用没有发生变化，所以不会重新渲染，而界面显示是由子组件显示的，所以界面也不会变化</p>\n<p>5.父组件继承 Component，子组件继承 Component 时：初始化是会输出 constructor，IndexPage render，example render，当我们第一次点击按钮以后，界面发生变化，后面就不再改变，因为我们一直把它设置为 sxt2，但是每点击一次都会输出 IndexPage render，example render，因为每次不管父组件还是子组件都会渲染</p>\n<p>6.所以正如下面第四条说的，如果 state 和 prop 一直变化的话，还是建议使用 Component，并且 PureComponent 最好作为展示组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//父组件</span><br><span class=\"line\">import React, &#123; PureComponent, Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import Example from &quot;../components/Example&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class IndexPage extends PureComponent&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      person: &#123;</span><br><span class=\"line\">        name: &#x27;sxt&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    console.log(&#x27;constructor&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  changeState = () =&gt; &#123;</span><br><span class=\"line\">    let &#123; person &#125; = this.state;</span><br><span class=\"line\">    person.name = &#x27;sxt2&#x27;;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      person</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(&#x27;IndexPage render&#x27;);</span><br><span class=\"line\">    const &#123; person &#125; = this.state;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;this.changeState&#125;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">        &lt;Example person=&#123;person&#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//子组件</span><br><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Example extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(&#x27;example render&#x27;);</span><br><span class=\"line\">    const &#123; person &#125; = this.props;</span><br><span class=\"line\">    return(</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;person.name&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三-若是数组和对象等引用类型，则要引用不同，才会渲染\"><a href=\"#三-若是数组和对象等引用类型，则要引用不同，才会渲染\" class=\"headerlink\" title=\"三.若是数组和对象等引用类型，则要引用不同，才会渲染\"></a>三.若是数组和对象等引用类型，则要引用不同，才会渲染</h2><h2 id=\"四-如果-prop-和-state-每次都会变，那么-PureComponent-的效率还不如-Component，因为你知道的，进行浅比较也是需要时间\"><a href=\"#四-如果-prop-和-state-每次都会变，那么-PureComponent-的效率还不如-Component，因为你知道的，进行浅比较也是需要时间\" class=\"headerlink\" title=\"四.如果 prop 和 state 每次都会变，那么 PureComponent 的效率还不如 Component，因为你知道的，进行浅比较也是需要时间\"></a>四.如果 prop 和 state 每次都会变，那么 PureComponent 的效率还不如 Component，因为你知道的，进行浅比较也是需要时间</h2><h2 id=\"五-若有-shouldComponentUpdate，则执行它，若没有这个方法会判断是不是-PureComponent，若是，进行浅比较\"><a href=\"#五-若有-shouldComponentUpdate，则执行它，若没有这个方法会判断是不是-PureComponent，若是，进行浅比较\" class=\"headerlink\" title=\"五.若有 shouldComponentUpdate，则执行它，若没有这个方法会判断是不是 PureComponent，若是，进行浅比较\"></a>五.若有 shouldComponentUpdate，则执行它，若没有这个方法会判断是不是 PureComponent，若是，进行浅比较</h2><p>1.继承自 Component 的组件，若是 shouldComponentUpdate 返回 false，就不会渲染了，继承自 PureComponent 的组件不用我们手动去判断 prop 和 state，所以在 PureComponent 中使用 shouldComponentUpdate 会有如下警告:</p>\n<p><code>IndexPage has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.</code></p>\n<p>也是比较好理解的，就是不要在 PureComponent 中使用 shouldComponentUpdate，因为根本没有必要</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"Tree-Shaking性能优化实践 - 原理篇","url":"/2022/10/24/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E5%8E%9F%E7%90%86%E7%AF%87/","content":"<h2 id=\"一-什么是-Tree-shaking\"><a href=\"#一-什么是-Tree-shaking\" class=\"headerlink\" title=\"一. 什么是 Tree-shaking\"></a>一. 什么是 Tree-shaking</h2><p><img src=\"https://pic4.zhimg.com/80/v2-8b075867835d03be30338855aaea126b_720w.jpg\" alt=\"image\"></p>\n<p>先来看一下 Tree-shaking 原始的本意</p>\n<p><img src=\"https://tse2-mm.cn.bing.net/th/id/OIP.FK1leNlztl80mibxa-uu8QHaEM?w=322&h=183&c=7&o=5&dpr=1.25&pid=1.7\" alt=\"image\"></p>\n<p>上图形象的解释了 Tree-shaking 的本意，本文所说的前端中的 tree-shaking 可以理解为通过工具”摇”我们的 JS 文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-d415073437f0ce3c2349717b4e13a9fb_720w.jpg\" alt=\"image\"></p>\n<p>Tree-shaking 较早由 Rich_Harris 的 rollup 实现，后来，webpack2 也增加了 tree-shaking 的功能。其实在更早，google closure compiler 也做过类似的事情。三个工具的效果和使用各不相同，使用方法可以通过官网文档去了解，三者的效果对比，后文会详细介绍。</p>\n<h2 id=\"二-tree-shaking-的原理\"><a href=\"#二-tree-shaking-的原理\" class=\"headerlink\" title=\"二. tree-shaking 的原理\"></a>二. tree-shaking 的原理</h2><p><img src=\"https://pic2.zhimg.com/80/v2-ff9d9ea4b5313771471c2796a6741d91_720w.jpg\" alt=\"image\"></p>\n<p>Tree-shaking 的本质是消除无用的 js 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 DCE（dead code elimination）。</p>\n<p>Tree-shaking 是 DCE 的一种新的实现，Javascript 同传统的编程语言不同的是，javascript 绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对 javascript 来说更有意义。</p>\n<p>Tree-shaking 和传统的 DCE 的方法又不太一样，传统的 DCE 消灭不可能执行的代码，而 Tree-shaking 更关注于消除没有用到的代码。下面详细介绍一下 DCE 和 Tree-shaking。</p>\n<h3 id=\"（1）先来看一下-DCE-消除大法\"><a href=\"#（1）先来看一下-DCE-消除大法\" class=\"headerlink\" title=\"（1）先来看一下 DCE 消除大法\"></a>（1）先来看一下 DCE 消除大法</h3><p><img src=\"https://pic3.zhimg.com/80/v2-18129c123fbaebba27ac786c856abfd2_720w.jpg\" alt=\"image\"></p>\n<p>Dead Code 一般具有以下几个特征</p>\n<ul>\n<li>代码不会被执行，不可到达</li>\n<li>代码执行的结果不会被用到</li>\n<li>代码只会影响死变量（只写不读）</li>\n</ul>\n<p>下面红框标示的代码就属于死码，满足以上特征</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-e7063073c59b49906e6aa9cefac1281f_720w.jpg\" alt=\"image\"></p>\n<p>传统编译型的语言中，都是由编译器将 Dead Code 从 AST（抽象语法树）中删除，那 javascript 中是由谁做 DCE 呢？</p>\n<p>首先肯定不是浏览器做 DCE，因为当我们的代码送到浏览器，那还谈什么消除无法执行的代码来优化呢，所以肯定是送到浏览器之前的步骤进行优化。</p>\n<p>其实也不是上面提到的三个工具，rollup，webpack，cc 做的，而是著名的代码压缩优化工具 uglify，uglify 完成了 javascript 的 DCE，下面通过一个实验来验证一下。</p>\n<blockquote>\n<p>以下所有的示例代码都能在 github 中找到</p>\n</blockquote>\n<p><a href=\"https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack\">https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack</a></p>\n<p><strong>分别用 rollup 和 webpack 将图 4 中的代码进行打包</strong></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-87a1817d027f5e000b80ada132e11b33_720w.jpg\" alt=\"image\"></p>\n<p>中间是 rollup 打包的结果，右边是 webpack 打包的结果</p>\n<p>可以发现，rollup 将无用的代码 foo 函数和 unused 函数消除了，但是仍然保留了不会执行到的代码，而 webpack 完整的保留了所有的无用代码和不会执行到的代码。</p>\n<p><strong>分别用 rollup + uglify 和 webpack + uglify 将图 4 中的代码进行打包</strong></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-cd8913573d1862aa0799b28ca84e048d_720w.jpg\" alt=\"image\"></p>\n<p>中间是配置文件，右侧是结果</p>\n<p>可以看到右侧最终打包结果中都去除了无法执行到的代码，结果符合我们的预期。</p>\n<h3 id=\"2-再来看一下-Tree-shaking-消除大法\"><a href=\"#2-再来看一下-Tree-shaking-消除大法\" class=\"headerlink\" title=\"(2) 再来看一下 Tree-shaking 消除大法\"></a>(2) 再来看一下 Tree-shaking 消除大法</h3><p>前面提到了 tree-shaking 更关注于无用模块的消除，消除那些引用了但并没有被使用的模块。</p>\n<p>先思考一个问题，为什么 tree-shaking 是最近几年流行起来了？而前端模块化概念已经有很多年历史了，其实 tree-shaking 的消除原理是依赖于 ES6 的模块特性。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-e56729aa4ee3efa34ebbfe8ec02d9583_720w.jpg\" alt=\"image\"></p>\n<p>ES6 module 特点：</p>\n<ul>\n<li>只能作为模块顶层的语句出现</li>\n<li>import 的模块名只能是字符串常量</li>\n<li>import binding 是 immutable 的<br>ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础。</li>\n</ul>\n<p>所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6 之前的模块化，比如我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。</p>\n<p>这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。</p>\n<p>我们还是通过例子来详细了解一下</p>\n<p>面向过程编程函数和面向对象编程是 javascript 最常用的编程模式和代码组织方式，从这两个方面来实验：</p>\n<ul>\n<li>函数消除实验</li>\n<li>类消除实验</li>\n</ul>\n<p><strong>先看下函数消除实验</strong></p>\n<p>utils 中 get 方法没有被使用到，我们期望的是 get 方法最终被消除。</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0ab75edb6d645a574fca0f7cfed6eaf2_720w.jpg\" alt=\"image\"></p>\n<p>注意，uglify 目前不会跨文件去做 DCE，所以上面这种情况，uglify 是不能优化的。</p>\n<p><strong>先看看 rollup 的打包结果</strong></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-c6212005445fa180a103ff7c8b26c234_720w.jpg\" alt=\"image\"></p>\n<p>完全符合预期，最终结果中没有 get 方法</p>\n<p><strong>再看看 webpack 的结果</strong></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-19c1884f6deaeab166036df5dc7af121_720w.jpg\" alt=\"image\"></p>\n<p>也符合预期，最终结果中没有 get 方法</p>\n<p>可以看到 rollup 打包的结果比 webpack 更优化</p>\n<blockquote>\n<p>函数消除实验中，rollup 和 webpack 都通过，符合预期</p>\n</blockquote>\n<p><strong>再来看下类消除实验</strong></p>\n<p>增加了对 menu.js 的引用，但其实代码中并没有用到 menu 的任何方法和变量，所以我们的期望是，最终代码中 menu.js 里的内容被消除</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-eb682abb2e27a72ce2ab031ad94cdc09_720w.jpg\" alt=\"image\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-7aab6ee6e04416d34a30208d3a8125ac_720w.jpg\" alt=\"image\"></p>\n<p>rollup 打包结果</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-559f5911b18e201ca7407277ecdd3911_720w.jpg\" alt=\"image\"></p>\n<p>包中竟然包含了 menu.js 的全部代码</p>\n<p><strong>webpack 打包结果</strong></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-444d7415f84a373778702747372d2370_720w.jpg\" alt=\"image\"></p>\n<p>包中竟然也包含了 menu.js 的全部代码</p>\n<blockquote>\n<p>类消除实验中，rollup，webpack 全军覆没，都没有达到预期</p>\n</blockquote>\n<p><img src=\"https://pic3.zhimg.com/80/v2-b796932873b2f5b217a1fdd00212c376_720w.jpg\" alt=\"image\"></p>\n<p>这跟我们想象的完全不一样啊？为什么呢？无用的类不能消除，这还能叫做 tree-shaking 吗？我当时一度怀疑自己的 demo 有问题，后来各种网上搜索，才明白 demo 没有错。</p>\n<p>下面摘取了 rollup 核心贡献者的的一些回答：</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-a04ef2070513c5a4d90966c8e80df0ca_720w.jpg\" alt=\"image\"></p>\n<ul>\n<li>rollup 只处理函数和顶层的 import&#x2F;export 变量，不能把没用到的类的方法消除掉</li>\n<li>javascript 动态语言的特性使得静态分析比较困难</li>\n<li>图 7 下部分的代码就是副作用的一个例子，如果静态分析的时候删除 run 或者 jump，程序运行时就可能报错，那就本末倒置了，我们的目的是优化，肯定不能影响执行</li>\n</ul>\n<p>再举个例子说明下为什么不能消除 menu.js，比如下面这个场景</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Menu() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Menu.prototype.show = function() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Array.prototype.unique = function() &#123;</span><br><span class=\"line\">    // 将 array 中的重复元素去除</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Menu;</span><br></pre></td></tr></table></figure>\n\n<p>如果删除 menu.js，那 Array 的扩展也会被删除，就会影响功能。那也许你会问，难道 rollup，webpack 不能区分是定义 Menu 的 proptotype 还是定义 Array 的 proptotype 吗？当然如果代码写成上面这种形式是可以区分的，如果我写成这样呢？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Menu() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Menu.prototype.show = function() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var a = &#x27;Arr&#x27; + &#x27;ay&#x27;</span><br><span class=\"line\">var b</span><br><span class=\"line\">if(a == &#x27;Array&#x27;) &#123;</span><br><span class=\"line\">    b = Array</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    b = Menu</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">b.prototype.unique = function() &#123;</span><br><span class=\"line\">    // 将 array 中的重复元素去除</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Menu;</span><br></pre></td></tr></table></figure>\n\n<p>这种代码，静态分析是分析不了的，就算能静态分析代码，想要正确完全的分析也比较困难。</p>\n<p>更多关于副作用的讨论，可以看这个</p>\n<p><a href=\"https://github.com/rollup/rollup/issues/349\">https://github.com/rollup/rollup/issues/349</a></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0417d8e35bd25ec6fb184b2c378d65e6_720w.jpg\" alt=\"image\"></p>\n<blockquote>\n<p>tree-shaking 对函数效果较好</p>\n</blockquote>\n<p>函数的副作用相对较少，顶层函数相对来说更容易分析，加上 babel 默认都是”use strict”严格模式，减少顶层函数的动态访问的方式，也更容易分析</p>\n<p>我们开始说的三个工具，rollup 和 webpack 表现不理想，那 closure compiler 又如何呢？</p>\n<p>将示例中的代码用 cc 打包后得到的结果如下：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-91bc794a87ea5c35f2981ebb55b9b44b_720w.jpg\" alt=\"image\"></p>\n<p>天啊，这不就是我们要的结果吗？完美消除所有无用代码的结果，输出的结果非常性感</p>\n<blockquote>\n<p>closure compiler， tree-shaking 的结果完美！</p>\n</blockquote>\n<p>可是不能高兴得太早，能得到这么完美结果是需要条件的，那就是 cc 的侵入式约束规范。必须在代码里添加这样的代码，看红线框标示的</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-6346776acfa7b0c50a331afd22d260ad_720w.jpg\" alt=\"image\"></p>\n<p>google 定义一整套注解规范 Annotating JavaScript for the Closure Compiler，想更多了解的，可以去看下官网。</p>\n<p>侵入式这个就让人很不爽，google Closure Compiler 是 java 写的，和我们基于 node 的各种构建库不可能兼容（不过目前好像已经有 nodejs 版 Closure Compiler），Closure Compiler 使用起来也比较麻烦，所以虽然效果很赞，但比较难以应用到项目中，迁移成本较大。</p>\n<p><strong>说了这么多，总结一下：</strong></p>\n<p>三大工具的 tree-shaking 对于无用代码，无用模块的消除，都是有限的，有条件的。closure compiler 是最好的，但与我们日常的基于 node 的开发流很难兼容。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-f74aabd0006d76162998f04ac09c87ac_720w.jpg\" alt=\"image\"></p>\n<p>tree-shaking 对 web 意义重大，是一个极致优化的理想世界，是前端进化的又一个终极理想。</p>\n<p>理想是美好的，但目前还处在发展阶段，还比较困难，有各个方面的，甚至有目前看来无法解</p>\n<p>决的问题，但还是应该相信新技术能带来更好的前端世界。</p>\n<p>但优化是一种态度，不因小而不为，不因艰而不攻。</p>\n<h2 id=\"三、Tree-Shaking-的工作原理\"><a href=\"#三、Tree-Shaking-的工作原理\" class=\"headerlink\" title=\"三、Tree-Shaking 的工作原理\"></a>三、Tree-Shaking 的工作原理</h2><p>Tree-shaking （树摇）最早是由 Rollup 实现，是一种采用删除不需要的额外代码的方式优化代码体积的技术，webpack2 借鉴了这个特性也增加了 tree-shaking 的功能。</p>\n<p>tree-shaking 只能在静态 modules 下工作，在 ES6 之前我们使用 CommonJS 规范引入模块，具体采用 require()的方式动态引入模块，这个特性可以通过判断条件解决按需加载的优化问题，具体如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let module;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if(condition) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    module =  require(&quot;HellowModule&quot;) ;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    module = requitre(&#x27;BeyModule&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是 CommonJS 规范无法确定在实际运行前需要或者不需要某些模块，所以 CommonJS 不适合 tree-shaking 机制。</p>\n<p>在 JavaScript 模块化方案中，只有 ES6 的模块方案：import()引入模块的方式采用静态导入，可以采用一次导入所有的依赖包再根据条件判断的方式，获取不需要的包，然后执行删除操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import hello from &quot;Hellow&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import bey from &quot;Bey&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import other from &quot;Other&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if(condition) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // hello</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // bey</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Tree-shaking 的实现原理</strong></p>\n<p><strong>利用 ES6 模块特性：</strong></p>\n<ul>\n<li>只能作为模块顶层的语句出现</li>\n<li>import 的模块名只能是字符串常量</li>\n<li>import binding 是 immutable 的，引入的模块不能再进行修改</li>\n</ul>\n<p><strong>代码删除：</strong></p>\n<ul>\n<li>uglify：判断程序流，判断变量是否被使用和引用，进而删除代码</li>\n</ul>\n<p>实现原理可以简单的概况：</p>\n<ol>\n<li>ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块</li>\n<li>静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</li>\n</ol>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"XSS 和 CSRF 详解及区别解析","url":"/2022/10/24/XSS-%E5%92%8C-CSRF-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%8C%BA%E5%88%AB%E8%A7%A3%E6%9E%90/","content":"<h2 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h2><p>cross site script，跨站脚本攻击（关键字：脚本）。为了与 css 冲突取名为 xss！<br>XSS 攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在 url 中输入、在评论框中输入），向你的页面注入脚本（可能是 js、hmtl 代码块等）。<br>恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p>\n<p><strong>最后导致的结果可能是</strong>：</p>\n<ul>\n<li>盗用 Cookie</li>\n<li>破坏页面的正常结构，插入广告等恶意内容</li>\n<li>D-doss 攻击</li>\n</ul>\n<h3 id=\"XSS-的攻击方式\"><a href=\"#XSS-的攻击方式\" class=\"headerlink\" title=\"XSS 的攻击方式\"></a>XSS 的攻击方式</h3><p>1、反射型（临时，非持久型）<br>发出请求时，XSS 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，所以叫反射型 XSS。<br>客户端提交，服务器解析后响应，到客户端再执行</p>\n<p>2、存储型（持久型）<br>存储型 XSS 和反射型 XSS 的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等）。<br>比如先通过对一个攻击 url 进行编码(来绕过 xss filter)，然后提交该 web server(存储在 web server 中), 然后用户在浏览页面时，如果点击该 url，就会触发一个 XSS 攻击。当然用户点击该 url 时，也可能会触发一个 CSRF(Cross site request forgery)攻击。</p>\n<p>以上两种服务端参与</p>\n<p>3、DOM based XSS<br>基于 DOM 的 XSS，也就是 web server 不参与，仅仅涉及到浏览器的 XSS。比如根据用户的输入来动态构造一个 DOM 节点，如果没有对用户的输入进行过滤，那么也就导致 XSS 攻击的产生。过滤可以考虑采用 esapi4js。</p>\n<p><strong>预防</strong>：<br>简而言之：转义+过滤（<strong>输入过滤，输出转义</strong>）</p>\n<p>1、在 cookie 中设置了 HttpOnly 属性，那么通过 js 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击</p>\n<p><strong>过滤</strong>：</p>\n<p>移除用户输入的和事件相关的属性。如 onerror 可以自动触发攻击，还有 onclick 等。（总而言是，过滤掉一些不安全的内容）</p>\n<p>移除用户输入的 Style 节点、Script 节点、Iframe 节点。（尤其是 Script 节点，它可是支持跨域的呀，一定要移除）。</p>\n<h2 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h2><p>用户登录 A 网站产生 cookie，此时再访问 B（危险），B 要求访问 A，并发起一个请求</p>\n<p>此时，B（危险）就利用用户的权限在 A 进行了操作。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1627906-03e225c2ab2d1d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp\" alt=\"image\"></p>\n<p>如何预防：<br>1、Token 验证：（用的最多）</p>\n<p>（1）服务器发送给客户端一个 token；</p>\n<p>（2）客户端提交的表单中带着这个 token。</p>\n<p>（3）如果这个 token 不合法，那么服务器拒绝这个请求。</p>\n<p>2、隐藏令牌：<br>把 token 隐藏在 http 的 head 头中。</p>\n<p>响应头</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1627906-d8c2ef9a7b0c95c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1130/format/webp\" alt=\"image\"></p>\n<p>请求头</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1627906-59051e4a8516f9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/998/format/webp\" alt=\"image\"></p>\n<p>ps：方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p>\n<h2 id=\"CSRF-和-XSS-的区别\"><a href=\"#CSRF-和-XSS-的区别\" class=\"headerlink\" title=\"CSRF 和 XSS 的区别\"></a>CSRF 和 XSS 的区别</h2><p>面试官还可能喜欢问二者的区别。</p>\n<p>区别一：</p>\n<p>CSRF：需要用户先登录网站 A，获取 cookie。<br>XSS：不需要登录。<br>区别二：（原理的区别）</p>\n<p>CSRF：是利用网站 A 本身的漏洞，去请求网站 A 的 api。<br>XSS：是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"git如何正确回滚代码","url":"/2022/10/24/git%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9B%9E%E6%BB%9A%E4%BB%A3%E7%A0%81/","content":"<blockquote>\n<p>git 如何正确回滚代码</p>\n</blockquote>\n<h2 id=\"方法一，删除远程分支再提交\"><a href=\"#方法一，删除远程分支再提交\" class=\"headerlink\" title=\"方法一，删除远程分支再提交\"></a>方法一，删除远程分支再提交</h2><h3 id=\"①-首先保证当前工作区是干净的，并且和远程分支代码一致\"><a href=\"#①-首先保证当前工作区是干净的，并且和远程分支代码一致\" class=\"headerlink\" title=\"① 首先保证当前工作区是干净的，并且和远程分支代码一致\"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git co currentBranch</span><br><span class=\"line\">$ git pull origin currentBranch</span><br><span class=\"line\">$ git co ./</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"②-备份当前分支（如有必要）\"><a href=\"#②-备份当前分支（如有必要）\" class=\"headerlink\" title=\"② 备份当前分支（如有必要）\"></a>② 备份当前分支（如有必要）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git branch currentBranchBackUp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"③-恢复到指定的-commit-hash\"><a href=\"#③-恢复到指定的-commit-hash\" class=\"headerlink\" title=\"③ 恢复到指定的 commit hash\"></a>③ 恢复到指定的 commit hash</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git reset --hard resetVersionHash //将当前branch的HEAD指针指向commit hash</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://gtms04.alicdn.com/tps/i4/TB1Q0yyLpXXXXXpXXXXPw.CWFXX-632-320.png\" alt=\"image\"></p>\n<h3 id=\"④-删除当前分支的远程分支\"><a href=\"#④-删除当前分支的远程分支\" class=\"headerlink\" title=\"④ 删除当前分支的远程分支\"></a>④ 删除当前分支的远程分支</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git push origin :currentBranch</span><br><span class=\"line\">$ //或者这么写git push origin --delete currentBranch</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"⑤-把当前分支提交到远程\"><a href=\"#⑤-把当前分支提交到远程\" class=\"headerlink\" title=\"⑤ 把当前分支提交到远程\"></a>⑤ 把当前分支提交到远程</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git push origin currentBranch</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法二，强制-push-远程分支\"><a href=\"#方法二，强制-push-远程分支\" class=\"headerlink\" title=\"方法二，强制 push 远程分支\"></a>方法二，强制 push 远程分支</h2><h3 id=\"①-首先保证当前工作区是干净的，并且和远程分支代码一致-1\"><a href=\"#①-首先保证当前工作区是干净的，并且和远程分支代码一致-1\" class=\"headerlink\" title=\"① 首先保证当前工作区是干净的，并且和远程分支代码一致\"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><h3 id=\"②-备份当前分支（如有必要）-1\"><a href=\"#②-备份当前分支（如有必要）-1\" class=\"headerlink\" title=\"② 备份当前分支（如有必要）\"></a>② 备份当前分支（如有必要）</h3><h3 id=\"③-恢复到指定的-commit-hash-1\"><a href=\"#③-恢复到指定的-commit-hash-1\" class=\"headerlink\" title=\"③ 恢复到指定的 commit hash\"></a>③ 恢复到指定的 commit hash</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git reset --hard resetVersionHash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"④-把当前分支强制提交到远程\"><a href=\"#④-把当前分支强制提交到远程\" class=\"headerlink\" title=\"④ 把当前分支强制提交到远程\"></a>④ 把当前分支强制提交到远程</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git push -f origin currentBranch</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法三，从回滚位置生成新的-commit-hash\"><a href=\"#方法三，从回滚位置生成新的-commit-hash\" class=\"headerlink\" title=\"方法三，从回滚位置生成新的 commit hash\"></a>方法三，从回滚位置生成新的 commit hash</h2><h3 id=\"①-首先保证当前工作区是干净的，并且和远程分支代码一致-2\"><a href=\"#①-首先保证当前工作区是干净的，并且和远程分支代码一致-2\" class=\"headerlink\" title=\"① 首先保证当前工作区是干净的，并且和远程分支代码一致\"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><h4 id=\"②-备份当前分支（如有必要）-2\"><a href=\"#②-备份当前分支（如有必要）-2\" class=\"headerlink\" title=\"② 备份当前分支（如有必要）\"></a>② 备份当前分支（如有必要）</h4><h3 id=\"③-使用-git-revert-恢复到指定的-commit-hash，当前分支恢复到-a-gt-3-版本（见下图）\"><a href=\"#③-使用-git-revert-恢复到指定的-commit-hash，当前分支恢复到-a-gt-3-版本（见下图）\" class=\"headerlink\" title=\"③ 使用 git revert 恢复到指定的 commit hash，当前分支恢复到 a&gt;3 版本（见下图）\"></a>③ 使用 git revert 恢复到指定的 commit hash，当前分支恢复到 a&gt;3 版本（见下图）</h3><h4 id=\"a）此方法会产生一条多余的-commit-hash-amp-log，其实-1c0ce98-和-01592eb-内容上是一致的\"><a href=\"#a）此方法会产生一条多余的-commit-hash-amp-log，其实-1c0ce98-和-01592eb-内容上是一致的\" class=\"headerlink\" title=\"a）此方法会产生一条多余的 commit hash&amp;log，其实 1c0ce98 和 01592eb 内容上是一致的\"></a>a）此方法会产生一条多余的 commit hash&amp;log，其实 1c0ce98 和 01592eb 内容上是一致的</h4><h4 id=\"b）git-revert-是以要回滚的-commit-hash-1c0ce98-为基础，新生成一个-commit-hash-01592eb\"><a href=\"#b）git-revert-是以要回滚的-commit-hash-1c0ce98-为基础，新生成一个-commit-hash-01592eb\" class=\"headerlink\" title=\"b）git revert 是以要回滚的 commit hash(1c0ce98)为基础，新生成一个 commit hash(01592eb)\"></a>b）git revert 是以要回滚的 commit hash(1c0ce98)为基础，新生成一个 commit hash(01592eb)</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git revert resetVersionHash</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://gtms04.alicdn.com/tps/i4/TB1VdurLpXXXXcuXXXX_mKs_XXX-873-308.png\" alt=\"image\"></p>\n<h3 id=\"④-提交远程分支\"><a href=\"#④-提交远程分支\" class=\"headerlink\" title=\"④ 提交远程分支\"></a>④ 提交远程分支</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git push origin currentBranch</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法四，从回滚位置生成新的分支-merge\"><a href=\"#方法四，从回滚位置生成新的分支-merge\" class=\"headerlink\" title=\"方法四，从回滚位置生成新的分支 merge\"></a>方法四，从回滚位置生成新的分支 merge</h2><h3 id=\"①-首先保证当前工作区是干净的，并且和远程分支代码一致-3\"><a href=\"#①-首先保证当前工作区是干净的，并且和远程分支代码一致-3\" class=\"headerlink\" title=\"① 首先保证当前工作区是干净的，并且和远程分支代码一致\"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><h3 id=\"②-备份当前分支（如有必要）-3\"><a href=\"#②-备份当前分支（如有必要）-3\" class=\"headerlink\" title=\"② 备份当前分支（如有必要）\"></a>② 备份当前分支（如有必要）</h3><h3 id=\"③-把当前工作区的-HEAD-指针指向回滚的-commit-hash-注意不是-branch-的-HEAD-指针\"><a href=\"#③-把当前工作区的-HEAD-指针指向回滚的-commit-hash-注意不是-branch-的-HEAD-指针\" class=\"headerlink\" title=\"③ 把当前工作区的 HEAD 指针指向回滚的 commit hash(注意不是 branch 的 HEAD 指针)\"></a>③ 把当前工作区的 HEAD 指针指向回滚的 commit hash(注意不是 branch 的 HEAD 指针)</h3><p><strong>Notice:这个时候工作区 HEAD 没有指向分支，称为匿名分支 detached HEAD</strong>。</p>\n<p>这个时候提交 commit 后无法保存状态，git 中的任何提交必须是在当前工作区 HEAD 所在分支的 HEAD 上进行 push hash 入栈，所以 HEAD 必须是属于某个分支的 HEAD 位置，提交才生效。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git co resetVersionHash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"④-以该-commit-hash-创建一个新的分支\"><a href=\"#④-以该-commit-hash-创建一个新的分支\" class=\"headerlink\" title=\"④ 以该 commit hash 创建一个新的分支\"></a>④ 以该 commit hash 创建一个新的分支</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git co -b newRevertedHash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"⑤-切换到当前分支，合并-newRevertedHash。\"><a href=\"#⑤-切换到当前分支，合并-newRevertedHash。\" class=\"headerlink\" title=\"⑤ 切换到当前分支，合并 newRevertedHash。\"></a>⑤ 切换到当前分支，合并 newRevertedHash。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git co currentBranch</span><br><span class=\"line\">$ git merge newRevertedHash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"⑥-进行代码-diff，完成代码回滚，push-到远程-currentBranch\"><a href=\"#⑥-进行代码-diff，完成代码回滚，push-到远程-currentBranch\" class=\"headerlink\" title=\"⑥ 进行代码 diff，完成代码回滚，push 到远程 currentBranch\"></a>⑥ 进行代码 diff，完成代码回滚，push 到远程 currentBranch</h3><p><strong>Notice: 也可以直接 hotfix，从要回滚的地方直接重新打包一个新 tag 包，发版本 hotFixVersion 即可。</strong></p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"js---输出100-200之间所有的素数","url":"/2022/10/24/js-%E8%BE%93%E5%87%BA100-200%E4%B9%8B%E9%97%B4%E6%89%80%E6%9C%89%E7%9A%84%E7%B4%A0%E6%95%B0/","content":"<p>采用两种方式，第一种是标记法，第二种是计数法，两种方法原理是相同的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> //标记法</span><br><span class=\"line\">function fn(m, n) &#123;</span><br><span class=\"line\">    var count = &quot;&quot;;</span><br><span class=\"line\">    for (i = m; i &lt;= n; i++) &#123;//第一次循环</span><br><span class=\"line\">        var flage = true;//设一个标记</span><br><span class=\"line\">        for (j = 2; j &lt; i; j++) &#123;</span><br><span class=\"line\">            if (i % j === 0) &#123;//第二次循环</span><br><span class=\"line\">                flage = false;//不满足条件改变标记，</span><br><span class=\"line\">                break;//跳出循环</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (flage) &#123;//满足条件，也就是为true时</span><br><span class=\"line\">            count += i + &quot;,&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(fn(100, 200)) //调用函数，输出值</span><br><span class=\"line\"></span><br><span class=\"line\">//计数法</span><br><span class=\"line\">function fn(m, n) &#123;</span><br><span class=\"line\">    var sun = &quot;&quot;;</span><br><span class=\"line\">    for (i = m; i &lt;= n; i++) &#123;//第一次循环</span><br><span class=\"line\">        var count = 0;//初值为零</span><br><span class=\"line\">        for (j = 2; j &lt; i; j++) &#123;//第二次循环</span><br><span class=\"line\">            if (i % j === 0) &#123;//不满足条件加1</span><br><span class=\"line\">                count+=1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (count === 0) &#123;</span><br><span class=\"line\">            sun += i + &quot;,&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(fn(100, 200))</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"merge和rebase的区别","url":"/2022/10/24/merge%E5%92%8Crebase%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我从用 git 就一直用 rebase，但是新的公司需要用 merge 命令，我不是很明白，所以查了一些资料，总结了下面的内容，如果有什么不妥的地方，还望指正，我一定虚心学习。</p>\n<h2 id=\"merge-和-rebase\"><a href=\"#merge-和-rebase\" class=\"headerlink\" title=\"merge 和 rebase\"></a>merge 和 rebase</h2><p>标题上的两个命令：merge 和 rebase 都是用来合并分支的。</p>\n<p><strong>这里不解释 rebase 命令，以及两个命令的原理</strong>，详细解释参考<a href=\"http://gitbook.liuhui998.com/4_2.html\">这里</a>。</p>\n<p>下面的内容主要说的是两者在实际操作中的区别。</p>\n<h2 id=\"什么是分支\"><a href=\"#什么是分支\" class=\"headerlink\" title=\"什么是分支\"></a>什么是分支</h2><p>分支就是便于多人在同一项目中的协作开发。比方说：每个人开发不同的功能，在各自的分支开发过程中互不影响，完成后都提交到 develop 分支。极大的提高了开发的效率。</p>\n<h2 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h2><p>每个人创建一个分支进行开发，当开发完成，需要合并到 develop 分支的时候，就需要用到合并的命令。</p>\n<h2 id=\"什么是冲突\"><a href=\"#什么是冲突\" class=\"headerlink\" title=\"什么是冲突\"></a>什么是冲突</h2><p>合并的时候，有可能会产生冲突。</p>\n<p>冲突的产生是因为在合并的时候，不同分支修改了相同的位置。所以在合并的时候 git 不知道那个到底是你想保留的，所以就提出疑问（冲突提醒）让你自己手动选择想要保留的内容，从而解决冲突。</p>\n<h2 id=\"merge-和-rebase-的区别\"><a href=\"#merge-和-rebase-的区别\" class=\"headerlink\" title=\"merge 和 rebase 的区别\"></a>merge 和 rebase 的区别</h2><ol>\n<li>采用 merge 和 rebase 后，git log 的区别，<strong>merge 命令不会保留 merge 的分支的 commit</strong>：</li>\n<li><img src=\"https://images2015.cnblogs.com/blog/759200/201608/759200-20160806092734215-279978821.png\" alt=\"image\"></li>\n</ol>\n<p>处理冲突的方式：</p>\n<ul>\n<li>（一股脑）使用<code>merge</code>命令合并分支，解决完冲突，执行<code>git add .</code>和<code>git commit -m&#39;fix conflict</code>‘。这个时候会产生一个 commit。</li>\n<li>（交互式）使用 rebase 命令合并分支，解决完冲突，执行<code>git add .</code>和<code>git rebase --continue</code>，不会产生额外的 commit。这样的好处是，‘干净’，分支上不会有无意义的解决分支的 commit；坏处，如果合并的分支中存在多个 commit，需要重复处理多次冲突。</li>\n</ul>\n<ol start=\"3\">\n<li><code>git pull</code>和<code>git pull --rebase</code>区别：<code>git pull</code>做了两个操作分别是‘获取’和合并。所以加了 rebase 就是以 rebase 的方式进行合并分支，默认为 merge。</li>\n</ol>\n<h2 id=\"git-merge-和-git-merge-no-ff的区别\"><a href=\"#git-merge-和-git-merge-no-ff的区别\" class=\"headerlink\" title=\"git merge 和 git merge --no-ff的区别\"></a><code>git merge</code> 和 <code>git merge --no-ff</code>的区别</h2><p>1、我自己尝试 merge 命令后，发现：merge 时并没有产生一个 commit。不是说 merge 时会产生一个 merge commit 吗？</p>\n<p>注意：只有在冲突的时候，解决完冲突才会自动产生一个 commit。</p>\n<p>如果想在没有冲突的情况下也自动生成一个 commit，记录此次合并就可以用：git merge –no-ff 命令，下面用一张图来表示两者的区别：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/759200/201608/759200-20160806092744747-1816899042.png\" alt=\"image\"></p>\n<p>2、如果不加 –no-ff 则被合并的分支之前的 commit 都会被抹去，只会保留一个解决冲突后的 merge commit。</p>\n<h2 id=\"如何选择合并分支的方式\"><a href=\"#如何选择合并分支的方式\" class=\"headerlink\" title=\"如何选择合并分支的方式\"></a>如何选择合并分支的方式</h2><p>我的理解：主要是看哪个命令用的熟练，能够有效的管理自己的代码；还有就是团队用的是哪种方式。</p>\n<p>我对于 rebase 比较熟悉，所以我一般都用<code>rebase</code>，但是现在的公司用的是<code>merge --no-ff</code>命令合并分支。所以，我在工作上就用 merge，个人项目就用 rebase。</p>\n<p>也可以两者结合：</p>\n<p>获取远程项目中最新代码时：<code>git pull --rebase</code>，这个是隐性的合并远程分支的代码不会产生额外的 commit（但是如果存在冲突的 commit 太多就像上面说的，需要处理很多遍冲突）。</p>\n<p>合并到分支的时候：<code>git merge --no-ff</code>，自动一个<code>merge commit</code>，便于管理（这看管理人员怎么认为了）</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>看懂上面的两幅图就行了。</p>\n<ol>\n<li>commit log 的区别</li>\n<li>处理冲突的方式</li>\n</ol>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"promise 中的异常捕获_前端异常处理方式","url":"/2022/10/24/promise-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7-%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/","content":"<h2 id=\"一、为什么要处理异常？\"><a href=\"#一、为什么要处理异常？\" class=\"headerlink\" title=\"一、为什么要处理异常？\"></a>一、为什么要处理异常？</h2><p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p>\n<ol>\n<li>增强用户体验；</li>\n<li>远程定位问题；</li>\n<li>未雨绸缪，及早发现问题；</li>\n<li>无法复现问题，尤其是移动端，机型，系统都是问题；</li>\n<li>完善的前端方案，前端监控系统；</li>\n</ol>\n<p>对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p>\n<h2 id=\"二、需要处理哪些异常？\"><a href=\"#二、需要处理哪些异常？\" class=\"headerlink\" title=\"二、需要处理哪些异常？\"></a>二、需要处理哪些异常？</h2><p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p>\n<ul>\n<li>JS 语法错误、代码异常</li>\n<li>AJAX 请求异常</li>\n<li>静态资源加载异常</li>\n<li>Promise 异常</li>\n<li>Iframe 异常</li>\n<li>跨域 Script error</li>\n<li>崩溃和卡顿</li>\n</ul>\n<p>下面我会针对每种具体情况来说明如何处理这些异常。</p>\n<h2 id=\"三、Try-Catch-的误区\"><a href=\"#三、Try-Catch-的误区\" class=\"headerlink\" title=\"三、Try-Catch 的误区\"></a>三、Try-Catch 的误区</h2><p>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。</p>\n<ol>\n<li>同步运行时错误：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  let name = &quot;jartto&quot;;</span><br><span class=\"line\">  console.log(nam);</span><br><span class=\"line\">&#125; catch (e) &#123;</span><br><span class=\"line\">  console.log(&quot;捕获到异常：&quot;, e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">捕获到异常：ReferenceError: nam is not defined    at :3:15</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>不能捕获到具体的语法错误，只有一个语法错误提示。我们修改一下代码，删掉一个单引号：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  let name = &#x27;jartto</span><br><span class=\"line\">  console.log(nam);</span><br><span class=\"line\">&#125; catch (e) &#123;</span><br><span class=\"line\">  console.log(&quot;捕获到异常：&quot;, e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught SyntaxError: Invalid or unexpected token不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>异步错误</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    undefined.map((v) =&gt; v);</span><br><span class=\"line\">  &#125;, 1000);</span><br><span class=\"line\">&#125; catch (e) &#123;</span><br><span class=\"line\">  console.log(&quot;捕获到异常：&quot;, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们看看日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught TypeError: Cannot read property &#x27;map&#x27; of undefined    at setTimeout (:3:11)</span><br></pre></td></tr></table></figure>\n\n<p>并没有捕获到异常，这是需要我们特别注意的地方。</p>\n<h2 id=\"四、window-onerror-不是万能的\"><a href=\"#四、window-onerror-不是万能的\" class=\"headerlink\" title=\"四、window.onerror 不是万能的\"></a>四、window.onerror 不是万能的</h2><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**@param &#123;String&#125;  message    错误信息</span><br><span class=\"line\"> * @param &#123;String&#125;  source    出错文件</span><br><span class=\"line\"> * @param &#123;Number&#125;  lineno    行号</span><br><span class=\"line\"> * @param &#123;Number&#125;  colno    列号</span><br><span class=\"line\"> * @param &#123;Object&#125;  error  Error对象(对象)</span><br><span class=\"line\"> * */</span><br><span class=\"line\">window.onerror = function (message, source, lineno, colno, error) &#123;</span><br><span class=\"line\">  console.log(&quot;捕获到异常：&quot;, &#123; message, source, lineno, colno, error &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>首先试试同步运行时错误</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.onerror = function(message, source, lineno, colno, error) &#123;// message：错误信息(字符串)。// source：发生错误的脚本URL(字符串)// lineno：发生错误的行号(数字)// colno：发生错误的列号(数字)// error：Error对象(对象)console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);&#125;Jartto;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，我们捕获到了异常：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c507fb59c15171a328fb7e53d5c6671d.png\" alt=\"image\"></p>\n<ol start=\"2\">\n<li>再试试语法错误呢？</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.onerror = function(message, source, lineno, colno, error) &#123;console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let name = &#x27;Jartto</span><br></pre></td></tr></table></figure>\n\n<p>控制台打印出了这样的异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure>\n\n<p>什么，竟然没有捕获到语法错误？</p>\n<ol start=\"3\">\n<li>怀着忐忑的心，我们最后来试试异步运行时错误：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.onerror = function(message, source, lineno, colno, error) &#123;    console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);&#125;setTimeout(() =&gt; &#123;    Jartto;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">捕获到异常：&#123;message: &quot;Uncaught ReferenceError: Jartto is not defined&quot;, source: &quot;http://127.0.0.1:8001/&quot;, lineno: 36, colno: 5, error: ReferenceError: Jartto is not defined    at setTimeout (http://127.0.0.1:8001/:36:5)&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>接着，我们试试网络请求异常的情况：</li>\n</ol>\n<p><strong>我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。</strong></p>\n<p>补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.onerror = function(message, source, lineno, colno, error) &#123;    console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);    return true;&#125;setTimeout(() =&gt; &#123;    Jartto;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>控制台就不会再有这样的错误了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught ReferenceError: Jartto is not defined    at setTimeout ((index):36)</span><br></pre></td></tr></table></figure>\n\n<p>需要注意：</p>\n<ul>\n<li>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；</li>\n<li>onerror 无法捕获语法错误；</li>\n</ul>\n<p>到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>\n<p>问题又来了，捕获不到静态资源加载异常怎么办？</p>\n<h2 id=\"五、window-addEventListener\"><a href=\"#五、window-addEventListener\" class=\"headerlink\" title=\"五、window.addEventListener\"></a>五、window.addEventListener</h2><p>当一项资源(如图片或脚本)加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过(至少在 Firefox 中)能被单一的 window.addEventListener 捕获。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&#x27;error&#x27;, (error) =&gt; &#123;    console.log(&#x27;捕获到异常：&#x27;, error);&#125;, true)</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c2c41ee8e8ee6be523b3f48eaf511d84.png\" alt=\"image\"></p>\n<p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志再进行排查分析才可以。</p>\n<p><strong>需要注意</strong>：</p>\n<ul>\n<li>不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。</li>\n<li>需要注意避免 addEventListener 重复监听。</li>\n</ul>\n<h2 id=\"六、Promise-Catch\"><a href=\"#六、Promise-Catch\" class=\"headerlink\" title=\"六、Promise Catch\"></a>六、Promise Catch</h2><p>在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。</p>\n<p>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。</p>\n<p>解决方案：为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。使用方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;  console.log(e);&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们继续来尝试一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;  e.preventDefault()  console.log(&#x27;捕获到异常：&#x27;, e);  return true;&#125;);Promise.reject(&#x27;promise error&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>可以看到如下输出：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/cff9879d9b5a8785cddaddfff81f763c.png\" alt=\"image\"></p>\n<p>那如果对 Promise 不进行 catch 呢？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;  e.preventDefault()  console.log(&#x27;捕获到异常：&#x27;, e);  return true;&#125;);new Promise((resolve, reject) =&gt; &#123;  reject(&#x27;jartto: promise error&#x27;);&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>嗯，事实证明，也是会被正常捕获到的。</p>\n<p>所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。</p>\n<p>补充一点：如果去掉控制台的异常显示，需要加上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">event.preventDefault();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、VUE-errorHandler\"><a href=\"#七、VUE-errorHandler\" class=\"headerlink\" title=\"七、VUE errorHandler\"></a>七、VUE errorHandler</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.config.errorHandler = (err, vm, info) =&gt; &#123;  console.error(&#x27;通过vue errorHandler捕获的错误&#x27;);  console.error(err);  console.error(vm);  console.error(info);&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"八、React-异常捕获-React-16-提供了一个内置函数-componentDidCatch，使用它可以非常简单的获取到-react-下的错误信息\"><a href=\"#八、React-异常捕获-React-16-提供了一个内置函数-componentDidCatch，使用它可以非常简单的获取到-react-下的错误信息\" class=\"headerlink\" title=\"八、React 异常捕获 React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息\"></a>八、React 异常捕获 React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentDidCatch(error, info) &#123;    console.log(error, info);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，我们可以了解一下：error boundary UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界(error boundary)的新观念。</p>\n<p>需要注意的是：error boundaries 并不会捕捉下面这些错误。</p>\n<ol>\n<li>事件处理器</li>\n<li>异步代码</li>\n<li>服务端的渲染代码</li>\n<li>在 error boundaries 区域内的错误<br>我们来举一个小例子，在下面这个 componentDIdCatch(error,info) 里的类会变成一个 error boundary：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class ErrorBoundary extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; hasError: false &#125;;  &#125;   componentDidCatch(error, info) &#123;    // Display fallback UI    this.setState(&#123; hasError: true &#125;);    // You can also log the error to an error reporting service    logErrorToMyService(error, info);  &#125;   render() &#123;    if (this.state.hasError) &#123;      // You can render any custom fallback UI      return</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Something-went-wrong\"><a href=\"#Something-went-wrong\" class=\"headerlink\" title=\"Something went wrong.\"></a>Something went wrong.</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">; &#125; return this.props.children; &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们像使用普通组件那样使用它：</p>\n<p>componentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries 。</p>\n<p>实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！</p>\n<h2 id=\"九、iframe-异常\"><a href=\"#九、iframe-异常\" class=\"headerlink\" title=\"九、iframe 异常\"></a>九、iframe 异常</h2><p>对于 iframe 的异常捕获，我们还得借力 window.onerror：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.onerror = function(message, source, lineno, colno, error) &#123;  console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个简单的例子可能如下：</p>\n<h2 id=\"十、Script-error\"><a href=\"#十、Script-error\" class=\"headerlink\" title=\"十、Script error\"></a>十、Script error</h2><p>一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：</p>\n<p>跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。</p>\n<p>或者动态去添加 js 脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const script = document.createElement(&#x27;script&#x27;);script.crossOrigin = &#x27;anonymous&#x27;;script.src = url;document.body.appendChild(script);</span><br></pre></td></tr></table></figure>\n\n<p>特别注意，服务器端需要设置：Access-Control-Allow-Origin</p>\n<p>此外，我们也可以试试这个-解决 Script Error 的另类思路：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const originAddEventListener = EventTarget.prototype.addEventListener;EventTarget.prototype.addEventListener = function (type, listener, options) &#123;  const wrappedListener = function (...args) &#123;    try &#123;      return listener.apply(this, args);    &#125;    catch (err) &#123;      throw err;    &#125;  &#125;  return originAddEventListener.call(this, type, wrappedListener, options);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单解释一下：</p>\n<p>改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(() =&gt; &#123;   const originAddEventListener = EventTarget.prototype.addEventListener;   EventTarget.prototype.addEventListener = function (type, listener, options) &#123;+    // 捕获添加事件时的堆栈+    const addStack = new Error(`Event ($&#123;type&#125;)`).stack;     const wrappedListener = function (...args) &#123;       try &#123;         return listener.apply(this, args);       &#125;       catch (err) &#123;+        // 异常发生时，扩展堆栈+        err.stack += &#x27;&#x27; + addStack;         throw err;       &#125;     &#125;     return originAddEventListener.call(this, type, wrappedListener, options);   &#125; &#125;)();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十一、崩溃和卡顿\"><a href=\"#十一、崩溃和卡顿\" class=\"headerlink\" title=\"十一、崩溃和卡顿\"></a>十一、崩溃和卡顿</h2><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？</p>\n<p>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。</p>\n<ol>\n<li>利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&quot;load&quot;, function () &#123;</span><br><span class=\"line\">  sessionStorage.setItem(&quot;good_exit&quot;, &quot;pending&quot;);</span><br><span class=\"line\">  setInterval(function () &#123;</span><br><span class=\"line\">    sessionStorage.setItem(&quot;time_before_crash&quot;, new Date().toString());</span><br><span class=\"line\">  &#125;, 1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">window.addEventListener(&quot;beforeunload&quot;, function () &#123;</span><br><span class=\"line\">  sessionStorage.setItem(&quot;good_exit&quot;, &quot;true&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">if (</span><br><span class=\"line\">  sessionStorage.getItem(&quot;good_exit&quot;) &amp;&amp;</span><br><span class=\"line\">  sessionStorage.getItem(&quot;good_exit&quot;) !== &quot;true&quot;</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  /* insert crash logging code here   */</span><br><span class=\"line\"></span><br><span class=\"line\">  alert(</span><br><span class=\"line\">    &quot;Hey, welcome back from your crash, looks like you crashed on: &quot; +</span><br><span class=\"line\">      sessionStorage.getItem(&quot;time_before_crash&quot;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控：</li>\n</ol>\n<p>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。</p>\n<h2 id=\"十二、错误上报\"><a href=\"#十二、错误上报\" class=\"headerlink\" title=\"十二、错误上报\"></a>十二、错误上报</h2><p>1.通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。</p>\n<p>2.动态创建 img 标签的形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function report(error) &#123;  let reportUrl = &#x27;http://jartto.wang/report&#x27;;  new Image().src = `$&#123;reportUrl&#125;?logs=$&#123;error&#125;`;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Reporter.send = function(data) &#123;  // 只采集 30%  if(Math.random() &lt; 0.3) &#123;    send(data)      // 上报错误信息  &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。</p>\n<h2 id=\"十三、总结\"><a href=\"#十三、总结\" class=\"headerlink\" title=\"十三、总结\"></a>十三、总结</h2><p>回到我们开头提出的那个问题，如何优雅的处理异常呢？</p>\n<ol>\n<li>可疑区域增加 Try-Catch</li>\n<li>全局监控 JS 异常 window.onerror</li>\n<li>全局监控静态资源异常 window.addEventListener</li>\n<li>捕获没有 Catch 的 Promise 异常：unhandledrejection</li>\n<li>VUE errorHandler 和 React componentDidCatch</li>\n<li>监控网页崩溃：window 对象的 load 和 beforeunload</li>\n<li>跨域 crossOrigin 解决</li>\n</ol>\n<p>其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"react实现路由懒加载（异步组件）","url":"/2022/10/24/react%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%89/","content":"<p><strong>正如标题，react 项目在打包完成后发现 chunk.js 文件比较大，导致打开首页需要时间比较久，因此，需要进行优化。<br>其实仔细考虑一下不难发现，由于打包后将所有资源都打包到了一个 chunk.js 下，导致所有资源都一起加载了，所以，进入页面会很慢。咱们的预期目标是进入首页只加载首页的资源，进入详情页至加载详情页的资源。那么，react-loadable 是你不错的选择。</strong></p>\n<h2 id=\"1、首先，要想使用它需要先安装它。\"><a href=\"#1、首先，要想使用它需要先安装它。\" class=\"headerlink\" title=\"1、首先，要想使用它需要先安装它。\"></a>1、首先，要想使用它需要先安装它。</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add react-loadable</span><br><span class=\"line\">yarn add babel-plugin-syntax-dynamic-import</span><br></pre></td></tr></table></figure>\n\n<p>根据 npm 官网找到 react-loadable 完成配置，当然我为了以后方便使用对 react-loadable 进行了封装。</p>\n<h2 id=\"2-其次，在-utils-文件夹下新建-loadable-js-文件，配置如下：\"><a href=\"#2-其次，在-utils-文件夹下新建-loadable-js-文件，配置如下：\" class=\"headerlink\" title=\"2 其次，在 utils 文件夹下新建 loadable.js 文件，配置如下：\"></a>2 其次，在 utils 文件夹下新建 loadable.js 文件，配置如下：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import &#123; Spin &#125; from &#x27;antd&#x27;;</span><br><span class=\"line\">import Loadable from &quot;react-loadable&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#x27;./index.less&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 加载动画</span><br><span class=\"line\">const loadingComponent = () =&gt; &#123;</span><br><span class=\"line\">  return &lt;div className=&#123;&#x27;spin-loading&#x27;&#125;&gt;</span><br><span class=\"line\">    &lt;div&gt;&lt;Spin size=&quot;large&quot; /&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当不传加载动画时候使用默认的加载动画</span><br><span class=\"line\">export default (loader, loading = loadingComponent) =&gt; &#123;</span><br><span class=\"line\">  return Loadable(&#123;</span><br><span class=\"line\">    loader,</span><br><span class=\"line\">    loading,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、在-index-js-文件里配置路由时候就可以使用如下方式进行懒加载处理\"><a href=\"#3、在-index-js-文件里配置路由时候就可以使用如下方式进行懒加载处理\" class=\"headerlink\" title=\"3、在 index.js 文件里配置路由时候就可以使用如下方式进行懒加载处理\"></a>3、在 index.js 文件里配置路由时候就可以使用如下方式进行懒加载处理</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import ReactDOM from &quot;react-dom&quot;;</span><br><span class=\"line\">import &quot;./index.css&quot;;</span><br><span class=\"line\">import * as serviceWorker from &quot;./serviceWorker&quot;;</span><br><span class=\"line\">import &#123; BrowserRouter as Router, Route &#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; createBrowserHistory &#125; from &quot;history&quot;;</span><br><span class=\"line\">import loadable from &#x27;./utils/loadable&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const App = loadable(() =&gt; import(&quot;./router/login/App&quot;));</span><br><span class=\"line\">const MoveVideo = loadable(() =&gt; import(&quot;./router/video&quot;));</span><br><span class=\"line\">const UserReg = loadable(() =&gt; import(&quot;./router/userReg/index&quot;));</span><br><span class=\"line\">const FoodList = loadable(() =&gt; import(&quot;./router/food/index&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Router history=&#123;createBrowserHistory()&#125;&gt;</span><br><span class=\"line\">    &lt;Route exact path=&quot;/&quot; component=&#123;App&#125; /&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/user-reg/&quot; component=&#123;UserReg&#125; /&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/food-list&quot; component=&#123;FoodList&#125; /&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/video&quot; component=&#123;MoveVideo&#125; /&gt;</span><br><span class=\"line\">  &lt;/Router&gt;,</span><br><span class=\"line\">  document.getElementById(&quot;root&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">serviceWorker.unregister();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、再次进行打包编译，就会发现多出很多-chunk-js-文件，这就是从原来一个拆成多个，这样加载速度就会得到提升。\"><a href=\"#4、再次进行打包编译，就会发现多出很多-chunk-js-文件，这就是从原来一个拆成多个，这样加载速度就会得到提升。\" class=\"headerlink\" title=\"4、再次进行打包编译，就会发现多出很多 chunk.js 文件，这就是从原来一个拆成多个，这样加载速度就会得到提升。\"></a>4、再次进行打包编译，就会发现多出很多 chunk.js 文件，这就是从原来一个拆成多个，这样加载速度就会得到提升。</h2>","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"try-catch 能抛出 promise 的异常吗","url":"/2022/10/24/try-catch-%E8%83%BD%E6%8A%9B%E5%87%BA-promise-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%90%97/","content":"<h2 id=\"try-catch-能抛出-promise-的异常吗？\"><a href=\"#try-catch-能抛出-promise-的异常吗？\" class=\"headerlink\" title=\"try-catch 能抛出 promise 的异常吗？\"></a>try-catch 能抛出 promise 的异常吗？</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">\tthrow new Error(&#x27;1&#x27;)</span><br><span class=\"line\">&#125; catch(error) &#123;</span><br><span class=\"line\">\tconsole.log(error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是最常见的 try-catch，会 log 下面的内容：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1Lmx1b3R1eGl1LmNuL2ltZy8yMDIwMDcxMjEwMzkxOS5wbmc?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>注意，这里并不是红色的，因为 js 异常被捕获后，js 是能够正常往下执行的，如果没有被捕获的话，那么 js 将抛出异常，js 执行将会停止！</p>\n<p>例子:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 异步，宏任务</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">\tsetTimeout(function() &#123;</span><br><span class=\"line\">\t\tconsole.log(b);</span><br><span class=\"line\">\t&#125;, 0);</span><br><span class=\"line\">&#125; catch (error) &#123;</span><br><span class=\"line\">\tconsole.log(error); // 这里是不会执行的</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&#x27;out try catch&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1Lmx1b3R1eGl1LmNuL2ltZy8yMDIwMDcxMjA5NTY0OS5wbmc?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>此时 js 会抛出异常，catch 后面的代码都不会执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 异步，微任务</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">\tnew Promise(() =&gt; &#123;</span><br><span class=\"line\">\t\tthrow new Error(&#x27;new promise throw error&#x27;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125; catch (error) &#123;</span><br><span class=\"line\">\tconsole.log(error);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1Lmx1b3R1eGl1LmNuL2ltZy8yMDIwMDcxMjEwMzQ1MS5wbmc?x-oss-process=image/format,png\" alt=\"image\"></p>\n<h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>try-catch 主要用于捕获异常，注意，这里的异常，是指同步函数的异常，如果 try 里面的异步方法出现了异常，此时<strong>catch 是无法捕获到异常的</strong>，原因是因为：当异步函数抛出异常时，对于宏任务而言，执行函数时已经将该函数推入栈，此时并不在 try-catch 所在的栈，所以 try-catch 并不能捕获到错误。对于微任务而言，比如 promise，promise 的构造函数的异常只能被自带的 reject 也就是.catch 函数捕获到。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"对于同步函数\"><a href=\"#对于同步函数\" class=\"headerlink\" title=\"对于同步函数\"></a>对于同步函数</h3><p>放心用 try-catch 即可</p>\n<h3 id=\"对于异步函数-宏任务\"><a href=\"#对于异步函数-宏任务\" class=\"headerlink\" title=\"对于异步函数-宏任务\"></a>对于异步函数-宏任务</h3><p>window 有全局的错误捕获函数 onerror</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">\tsetTimeout(function() &#123;</span><br><span class=\"line\">\t\tconsole.log(b);</span><br><span class=\"line\">\t&#125;, 0);</span><br><span class=\"line\">&#125; catch (error) &#123;</span><br><span class=\"line\">\tconsole.log(error); // 这里是不会执行的</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.onerror = function() &#123;</span><br><span class=\"line\">\tconsole.log(...arguments)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时，是可以捕获到比如 setTimeout 的回调函数异常的，这里可以针对全局的异常做一些处理，比如数据上报等</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1Lmx1b3R1eGl1LmNuL2ltZy8yMDIwMDcxMjEwNTA1MS5wbmc?x-oss-process=image/format,png\" alt=\"image\"></p>\n<h2 id=\"对于异步函数-微任务\"><a href=\"#对于异步函数-微任务\" class=\"headerlink\" title=\"对于异步函数-微任务\"></a>对于异步函数-微任务</h2><p>对于微任务，js 有专门捕获没有写 catch 的 promise，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&#x27;unhandledrejection&#x27;, function() &#123;</span><br><span class=\"line\">\tconsole.log(...arguments)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>执行结果如下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1Lmx1b3R1eGl1LmNuL2ltZy8yMDIwMDcxMjExMzM1NC5wbmc?x-oss-process=image/format,png\" alt=\"image\"></p>\n<h2 id=\"更多知识点\"><a href=\"#更多知识点\" class=\"headerlink\" title=\"更多知识点\"></a>更多知识点</h2><p>try-catch 中的异常只会抛出一层，即不会冒泡，也就是如果你有多层的 try-catch 然后异常已经被内层的 catch 捕获了，外层的 catch 是捕获不到异常的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    throw new Error(&#x27;oops&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  catch (ex) &#123;</span><br><span class=\"line\">    console.error(&#x27;inner&#x27;, ex.message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  finally &#123;</span><br><span class=\"line\">    console.log(&#x27;finally&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">catch (ex) &#123;</span><br><span class=\"line\">  console.error(&#x27;outer&#x27;, ex.message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Output:</span><br><span class=\"line\">// &quot;inner&quot; &quot;oops&quot;</span><br><span class=\"line\">// &quot;finally&quot;</span><br></pre></td></tr></table></figure>\n\n<p>解决方案是可以在内层的 catch 再手动 throw 出异常</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"ts中泛型、泛型方法、泛型类、泛型接口","url":"/2022/10/24/ts%E4%B8%AD%E6%B3%9B%E5%9E%8B%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/","content":"<p>什么是泛型呢？我们可以理解为泛型就是在编译期间不确定方法的类型(广泛之意思)，在方法调用时，由程序员指定泛型具体指向什么类型。泛型在传统面向对象编程语言中是极为常见的，ts 中当然也执行泛型，如果你理解 c#或 java 中的泛型，相信本篇理解起来会很容易。</p>\n<h2 id=\"泛型函数、泛型类、泛型接口。\"><a href=\"#泛型函数、泛型类、泛型接口。\" class=\"headerlink\" title=\"泛型函数、泛型类、泛型接口。\"></a>泛型函数、泛型类、泛型接口。</h2><p><strong>generic.ts</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * ts中泛型</span><br><span class=\"line\"> *    泛型就是在编译期间不确定方法的类型(广泛之意思)，在方法调用时，由程序员指定泛型具体指向什么类型</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">//1 泛型函数</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 获取数组中最小值 （数字）</span><br><span class=\"line\"> * @param &#123;number[]&#125; arr</span><br><span class=\"line\"> * @returns &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">function  getMinNumber(arr:number[]):number&#123;</span><br><span class=\"line\">    var min=arr[0];</span><br><span class=\"line\">    arr.forEach((value)=&gt;&#123;</span><br><span class=\"line\">        if(value&lt;min)&#123;</span><br><span class=\"line\">            min=value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 获取数组中最小值 （字符串）</span><br><span class=\"line\"> * @param &#123;number[]&#125; arr</span><br><span class=\"line\"> * @returns &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">function  getMinStr(arr:string[]):string&#123;</span><br><span class=\"line\">    var min=arr[0];</span><br><span class=\"line\">    arr.forEach((value)=&gt;&#123;</span><br><span class=\"line\">        if(value&lt;min)&#123;</span><br><span class=\"line\">            min=value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(getMinNumber([1, 3, 5, 7, 8]));//1</span><br><span class=\"line\">console.log(getMinStr([&quot;tom&quot;,&quot;jerry&quot;,&quot;jack&quot;,&quot;sunny&quot;]));//jack</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 获取数组中最小值 (T泛型通用)</span><br><span class=\"line\"> * @param &#123;T[]&#125; arr</span><br><span class=\"line\"> * @returns &#123;T&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">function getMin&lt;T&gt;(arr:T[]):T&#123;</span><br><span class=\"line\">   var min=arr[0];</span><br><span class=\"line\">   arr.forEach((value)=&gt;&#123;</span><br><span class=\"line\">      if(value&lt;min)&#123;</span><br><span class=\"line\">          min=value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">    return min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(getMin([1, 3, 5, 7, 8]));</span><br><span class=\"line\">console.log(getMin([&quot;tom&quot;,&quot;jerry&quot;,&quot;jack&quot;,&quot;sunny&quot;]));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//2 泛型类</span><br><span class=\"line\">class GetMin&lt;T&gt;&#123;</span><br><span class=\"line\">     arr:T[]=[];</span><br><span class=\"line\">     add(ele:T)&#123;</span><br><span class=\"line\">         this.arr.push(ele);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    min():T&#123;</span><br><span class=\"line\">       var min=this.arr[0];</span><br><span class=\"line\">       this.arr.forEach(function (value) &#123;</span><br><span class=\"line\">          if(value&lt;min)&#123;</span><br><span class=\"line\">              min=value;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">       return min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  var gm1= new  GetMin&lt;number&gt;();</span><br><span class=\"line\">   gm1.add(5);</span><br><span class=\"line\">   gm1.add(3);</span><br><span class=\"line\">   gm1.add(2);</span><br><span class=\"line\">   gm1.add(9);</span><br><span class=\"line\">console.log(gm1.min());</span><br><span class=\"line\"></span><br><span class=\"line\">var gm2= new  GetMin&lt;string&gt;();</span><br><span class=\"line\">gm2.add(&quot;tom&quot;);</span><br><span class=\"line\">gm2.add(&quot;jerry&quot;);</span><br><span class=\"line\">gm2.add(&quot;jack&quot;);</span><br><span class=\"line\">gm2.add(&quot;sunny&quot;);</span><br><span class=\"line\">console.log(gm2.min());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 3 泛型函数接口</span><br><span class=\"line\"> */</span><br><span class=\"line\">interface ConfigFn&#123;</span><br><span class=\"line\">    &lt;T&gt;(value:T):T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var getData:ConfigFn=function&lt;T&gt;(value:T):T&#123;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getData&lt;string&gt;(&#x27;张三&#x27;);</span><br><span class=\"line\">// getData&lt;string&gt;(1243);  //错误</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 类似  Map&lt;String,Object&gt; Param  接口</span><br><span class=\"line\">interface Param&#123;</span><br><span class=\"line\">    [index:string]:any</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//4 泛型类接口</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * page分页对象</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Page&#123;</span><br><span class=\"line\">    private currentPage:number=1; //当前页码 默认1</span><br><span class=\"line\">    private pageSize:number=10;//每页条数 默认为10</span><br><span class=\"line\">    private sortName:string; //排序字段</span><br><span class=\"line\">    private sortOrder:string=&quot;asc&quot;; // 排序规则 asc | desc 默认为asc正序</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     constructor(param:Param)&#123;</span><br><span class=\"line\">         if(param[&quot;currentPage&quot;])&#123;</span><br><span class=\"line\">             this.currentPage=param[&quot;currentPage&quot;];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         if(param[&quot;pageSize&quot;])&#123;</span><br><span class=\"line\">             this.pageSize=param[&quot;pageSize&quot;];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         if(param[&quot;sortName&quot;])&#123;</span><br><span class=\"line\">             this.sortName=param[&quot;sortName&quot;];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         if(param[&quot;sortOrder&quot;])&#123;</span><br><span class=\"line\">             this.sortOrder=param[&quot;sortOrder&quot;];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public    getStartNum():number&#123;</span><br><span class=\"line\">        return   (this.currentPage-1)*this.pageSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class User&#123;</span><br><span class=\"line\">     id:number;//id主键自增</span><br><span class=\"line\">     name:string;//姓名</span><br><span class=\"line\">     sex:number;//性别 1男 2女</span><br><span class=\"line\">     age:number;//年龄</span><br><span class=\"line\">     city:string;//城市</span><br><span class=\"line\">     describe:string;//描述</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//泛型接口</span><br><span class=\"line\">interface  BaseDao&lt;T&gt; &#123;</span><br><span class=\"line\">     findById(id:number):T;//根据主键id查询一个实体</span><br><span class=\"line\">     findPageList(param:Param,page:Page):T[];//查询分页列表</span><br><span class=\"line\">     findPageCount(param:Param):number;//查询分页count</span><br><span class=\"line\">     save(o:T):void;//保存一个实体</span><br><span class=\"line\">     update(o:T):void;//更新一个实体</span><br><span class=\"line\">     deleteById(id:number);//删除一个实体</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 接口实现类</span><br><span class=\"line\"> */</span><br><span class=\"line\">class UserDao&lt;User&gt; implements BaseDao&lt;User&gt;&#123;</span><br><span class=\"line\">     findById(id:number):User&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return null;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    findPageList(param:Param,page:Page):User[]&#123;</span><br><span class=\"line\">         return [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    findPageCount(param:Param):number&#123;</span><br><span class=\"line\">         return   0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    save(o:User):void&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update(o:User):void&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    deleteById(id:number)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"上下高度固定，中间自适应，且可以滚动","url":"/2022/10/24/%E4%B8%8A%E4%B8%8B%E9%AB%98%E5%BA%A6%E5%9B%BA%E5%AE%9A%EF%BC%8C%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%8C%E4%B8%94%E5%8F%AF%E4%BB%A5%E6%BB%9A%E5%8A%A8/","content":"<p>html 布局三部分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;main&quot;&gt;</span><br><span class=\"line\">       弹性滚动区域</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>css：</p>\n<p>flex 布局方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">*&#123;</span><br><span class=\"line\">    margin:0;</span><br><span class=\"line\">    padding:0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">html,body&#123;</span><br><span class=\"line\">    height:100%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.wrap&#123;</span><br><span class=\"line\">    display:-webkit-box;</span><br><span class=\"line\">    display:-webkit-flex;</span><br><span class=\"line\">    display:-ms-flexbox;</span><br><span class=\"line\">    display:flex;</span><br><span class=\"line\">    -webkit-box-orient:vertical;</span><br><span class=\"line\">    -webkit-flex-direction:column;</span><br><span class=\"line\">    -ms-flex-direction:column;</span><br><span class=\"line\">    flex-direction:column;</span><br><span class=\"line\">    width:100%;</span><br><span class=\"line\">    height:100%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.header,.footer&#123;</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">    line-height:40px;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">    background-color:#D8D8D8;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.main&#123;</span><br><span class=\"line\">    -webkit-box-flex:1;</span><br><span class=\"line\">    -webkit-flex:1;</span><br><span class=\"line\">    -ms-flex:1;</span><br><span class=\"line\">    flex:1;</span><br><span class=\"line\">    width:100%;</span><br><span class=\"line\">    padding:10px;</span><br><span class=\"line\">    box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>absolute 布局方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">*&#123; padding:0; margin:0; &#125;</span><br><span class=\"line\">html,body&#123;height:100%;&#125;</span><br><span class=\"line\">.wrap&#123;width:100%;&#125;</span><br><span class=\"line\">.header,.footer&#123;height:40px;line-height:40px;background-color:#D8D8D8;text-align:center;&#125;</span><br><span class=\"line\">.header&#123;position: absolute;top:0;left:0;width:100%;&#125;</span><br><span class=\"line\">.footer&#123;position: absolute;bottom:0;left:0;width:100%;&#125;</span><br><span class=\"line\">.main&#123;position:absolute;z-index:1;top:40px;left:0;bottom:40px;width:100%;&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"从URL输入到页面展现到底发生什么？","url":"/2022/10/24/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><img src=\"https://segmentfault.com/img/remote/1460000017184704\" alt=\"image\"></p>\n<p>总体来说分为以下几个过程:</p>\n<ul>\n<li>DNS 解析:将域名解析成 IP 地址</li>\n<li>TCP 连接：TCP 三次握手</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>断开连接：TCP 四次挥手</li>\n</ul>\n<h2 id=\"一、URL-到底是啥\"><a href=\"#一、URL-到底是啥\" class=\"headerlink\" title=\"一、URL 到底是啥\"></a>一、URL 到底是啥</h2><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。<br>比如 <a href=\"http://www.w3school.com.cn/html/index.asp\">http://www.w3school.com.cn/ht...</a>，遵守以下的语法规则：</p>\n<ul>\n<li>scheme:&#x2F;&#x2F;host.domain:port&#x2F;path&#x2F;filename</li>\n<li>各部分解释如下：</li>\n<li>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li>\n<li>host - 定义域主机（http 的默认主机是 www）</li>\n<li>domain - 定义因特网域名，比如 w3school.com.cn</li>\n<li>port - 定义主机上的端口号（http 的默认端口号是 80）</li>\n<li>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li>\n<li>filename - 定义文档&#x2F;资源的名称</li>\n</ul>\n<h2 id=\"二、域名解析（DNS）\"><a href=\"#二、域名解析（DNS）\" class=\"headerlink\" title=\"二、域名解析（DNS）\"></a>二、域名解析（DNS）</h2><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。大家这里或许会有个疑问—-计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 <a href=\"http://www.hackr.jp.那怎么不一开始就赋予个/\">www.hackr.jp。那怎么不一开始就赋予个</a> IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址</p>\n<h3 id=\"1-IP-地址\"><a href=\"#1-IP-地址\" class=\"headerlink\" title=\"1.IP 地址\"></a>1.IP 地址</h3><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。<br><strong>域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址</strong>。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。<strong>因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。</strong></p>\n<h3 id=\"2-什么是域名解析\"><a href=\"#2-什么是域名解析\" class=\"headerlink\" title=\"2.什么是域名解析\"></a>2.什么是域名解析</h3><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。<strong>DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">例如 baidu.com  220.114.23.56（服务器外网IP地址）80（服务器端口号）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-浏览器如何通过域名去查询-URL-对应的-IP-呢\"><a href=\"#3-浏览器如何通过域名去查询-URL-对应的-IP-呢\" class=\"headerlink\" title=\"3. 浏览器如何通过域名去查询 URL 对应的 IP 呢\"></a>3. 浏览器如何通过域名去查询 URL 对应的 IP 呢</h3><ul>\n<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>\n<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li>\n<li>路由缓存：路由器也有 DNS 缓存。</li>\n<li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>\n<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184705\" alt=\"image\"></p>\n<h3 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h3><p>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184706\" alt=\"image\"></p>\n<h2 id=\"三、TCP-三次握手\"><a href=\"#三、TCP-三次握手\" class=\"headerlink\" title=\"三、TCP 三次握手\"></a>三、TCP 三次握手</h2><p><strong>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184707\" alt=\"image\"></p>\n<h3 id=\"1-TCP-三次握手的过程如下：\"><a href=\"#1-TCP-三次握手的过程如下：\" class=\"headerlink\" title=\"1.TCP 三次握手的过程如下：\"></a>1.TCP 三次握手的过程如下：</h3><ul>\n<li><strong>客户端发送一个带 SYN&#x3D;1，Seq&#x3D;X 的数据包到服务器端口</strong>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li>\n<li><strong>服务器发回一个带 SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y 的响应包以示传达确认信息</strong>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li>\n<li><strong>客户端再回传一个带 ACK&#x3D;Y+1， Seq&#x3D;Z 的数据包，代表“握手结束”</strong>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li>\n</ul>\n<h3 id=\"2-为啥需要三次握手\"><a href=\"#2-为啥需要三次握手\" class=\"headerlink\" title=\"2.为啥需要三次握手\"></a>2.为啥需要三次握手</h3><p>谢希仁著《计算机网络》中讲“三次握手”的目的是<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>。</p>\n<h2 id=\"四、发送-HTTP-请求\"><a href=\"#四、发送-HTTP-请求\" class=\"headerlink\" title=\"四、发送 HTTP 请求\"></a>四、发送 HTTP 请求</h2><p><strong>TCP 三次握手结束后，开始发送 HTTP 请求报文。</strong><br>请求报文由请求行（request line）、请求头（header）、请求体三个部分组成,如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184708\" alt=\"image\"></p>\n<h3 id=\"1-请求行包含请求方法、URL、协议版本\"><a href=\"#1-请求行包含请求方法、URL、协议版本\" class=\"headerlink\" title=\"1.请求行包含请求方法、URL、协议版本\"></a>1.请求行包含请求方法、URL、协议版本</h3><ul>\n<li>请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li>\n<li>URL 即请求地址，由 &lt;协议&gt;：&#x2F;&#x2F;&lt;主机&gt;：&lt;端口&gt;&#x2F;&lt;路径&gt;?&lt;参数&gt; 组成</li>\n<li>协议版本即 http 版本号</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST /chapter17/user.html HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<p>以上代码中“POST”代表请求方法，“&#x2F;chapter17&#x2F;user.html”表示 URL，“HTTP&#x2F;1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本</p>\n<h3 id=\"2-请求头包含请求的附加信息，由关键字-x2F-值对组成，每行一对，关键字和值用英文冒号“-”分隔。\"><a href=\"#2-请求头包含请求的附加信息，由关键字-x2F-值对组成，每行一对，关键字和值用英文冒号“-”分隔。\" class=\"headerlink\" title=\"2.请求头包含请求的附加信息，由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。\"></a>2.请求头包含请求的附加信息，由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。</h3><p>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：<strong>Host，表示主机名，虚拟主机；Connection,HTTP&#x2F;1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。</strong></p>\n<h3 id=\"3-请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。\"><a href=\"#3-请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。\" class=\"headerlink\" title=\"3.请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。\"></a>3.请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">name=tom&amp;password=1234&amp;realName=tomson</span><br></pre></td></tr></table></figure>\n\n<p>上面代码，承载着 name、password、realName 三个请求参数。</p>\n<h2 id=\"五、服务器处理请求并返回-HTTP-报文\"><a href=\"#五、服务器处理请求并返回-HTTP-报文\" class=\"headerlink\" title=\"五、服务器处理请求并返回 HTTP 报文\"></a>五、服务器处理请求并返回 HTTP 报文</h2><h3 id=\"1-服务器\"><a href=\"#1-服务器\" class=\"headerlink\" title=\"1. 服务器\"></a>1. 服务器</h3><p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。<br><strong>web server 担任管控的角色</strong>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184709\" alt=\"image\"></p>\n<h3 id=\"2-MVC-后台处理阶段\"><a href=\"#2-MVC-后台处理阶段\" class=\"headerlink\" title=\"2.MVC 后台处理阶段\"></a>2.MVC 后台处理阶段</h3><p>后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。<br>MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184710\" alt=\"image\"></p>\n<blockquote>\n<p>1、视图（view）</p>\n</blockquote>\n<p><strong>它是提供给用户的操作界面，是程序的外壳。</strong></p>\n<blockquote>\n<p>2、模型（model）</p>\n</blockquote>\n<p><strong>模型主要负责数据交互</strong>。在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。</p>\n<blockquote>\n<p>3、控制器（controller）</p>\n</blockquote>\n<p><strong>它负责根据用户从”视图层”输入的指令，选取”模型层”中的数据，然后对其进行相应的操作，产生最终结果</strong>。控制器属于管理者角色，从视图接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。<br>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。<br>至于这一阶段发生什么？简而言之，<strong>首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。</strong></p>\n<h3 id=\"3-http-响应报文\"><a href=\"#3-http-响应报文\" class=\"headerlink\" title=\"3.http 响应报文\"></a>3.http 响应报文</h3><p>响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示：<br><img src=\"https://segmentfault.com/img/remote/1460000017184711\" alt=\"image\"></p>\n<p>(1) 响应行包含：协议版本，状态码，状态码描述</p>\n<p>状态码规则如下：</p>\n<ul>\n<li>1xx：指示信息–表示请求已接收，继续处理。</li>\n<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>\n<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>\n<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>\n<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>\n</ul>\n<p>(2) 响应头部包含响应报文的附加信息，由 名&#x2F;值 对组成</p>\n<p>(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</p>\n<h2 id=\"六、浏览器解析渲染页面\"><a href=\"#六、浏览器解析渲染页面\" class=\"headerlink\" title=\"六、浏览器解析渲染页面\"></a>六、浏览器解析渲染页面</h2><p>浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184712\" alt=\"image\"></p>\n<p>浏览器解析渲染页面分为以下五个步骤：</p>\n<ul>\n<li>根据 HTML 解析出 DOM 树</li>\n<li>根据 CSS 解析生成 CSS 规则树</li>\n<li>结合 DOM 树和 CSS 规则树，生成渲染树</li>\n<li>根据渲染树计算每一个节点的信息</li>\n<li>根据计算好的信息绘制页面</li>\n</ul>\n<h3 id=\"1-根据-HTML-解析-DOM-树\"><a href=\"#1-根据-HTML-解析-DOM-树\" class=\"headerlink\" title=\"1.根据 HTML 解析 DOM 树\"></a>1.根据 HTML 解析 DOM 树</h3><ul>\n<li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>\n<li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li>\n</ul>\n<h3 id=\"2-根据-CSS-解析生成-CSS-规则树\"><a href=\"#2-根据-CSS-解析生成-CSS-规则树\" class=\"headerlink\" title=\"2.根据 CSS 解析生成 CSS 规则树\"></a>2.根据 CSS 解析生成 CSS 规则树</h3><ul>\n<li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li>\n<li>浏览器在 CSS 规则树生成之前不会进行渲染。</li>\n</ul>\n<h3 id=\"3-结合-DOM-树和-CSS-规则树，生成渲染树\"><a href=\"#3-结合-DOM-树和-CSS-规则树，生成渲染树\" class=\"headerlink\" title=\"3.结合 DOM 树和 CSS 规则树，生成渲染树\"></a>3.结合 DOM 树和 CSS 规则树，生成渲染树</h3><ul>\n<li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li>\n<li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面响应速度。</li>\n</ul>\n<h3 id=\"4-根据渲染树计算每一个节点的信息（布局）\"><a href=\"#4-根据渲染树计算每一个节点的信息（布局）\" class=\"headerlink\" title=\"4.根据渲染树计算每一个节点的信息（布局）\"></a>4.根据渲染树计算每一个节点的信息（布局）</h3><ul>\n<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li>\n<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>\n</ul>\n<h3 id=\"5-根据计算好的信息绘制页面\"><a href=\"#5-根据计算好的信息绘制页面\" class=\"headerlink\" title=\"5.根据计算好的信息绘制页面\"></a>5.根据计算好的信息绘制页面</h3><ul>\n<li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li>\n<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li>\n<li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li>\n</ul>\n<h2 id=\"七、断开连接\"><a href=\"#七、断开连接\" class=\"headerlink\" title=\"七、断开连接\"></a>七、断开连接</h2><p><strong>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184713\" alt=\"image\"></p>\n<ul>\n<li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。</strong>(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>\n<li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。</strong>(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>\n<li><strong>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。</strong>(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>\n<li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。</strong>(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>\n</ul>\n<p><strong>给大家推荐一个好用的 BUG 监控工具[Fundebug]<a href=\"https://www.fundebug.com/?utm_source=liao)%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%85%8D%E8%B4%B9%E8%AF%95%E7%94%A8%EF%BC%81\">https://www.fundebug.com/?utm_source=liao)，欢迎免费试用！</a></strong></p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"web worker的介绍和使用","url":"/2022/10/24/web-worker%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>什么是 web worker 呢？从名字上就可以看出，web worker 就是在 web 应用程序中使用的 worker。这个 worker 是独立于 web 主线程的，在后台运行的线程。</p>\n<p>web worker 的优点就是可以将工作交给独立的其他线程去做，这样就不会阻塞主线程。</p>\n<h2 id=\"Web-Workers-的基本概念和使用\"><a href=\"#Web-Workers-的基本概念和使用\" class=\"headerlink\" title=\"Web Workers 的基本概念和使用\"></a>Web Workers 的基本概念和使用</h2><p>web workers 是通过使用 Worker(）来创建的。</p>\n<p>Worker 可以指定后台执行的脚本，并在脚本执行完毕之后通常 creator。</p>\n<p>worker 有一个构造函数如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Worker(&quot;path/to/worker/script&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>我们传入要执行脚本的路径，即可创建 worker。</p>\n<p>Workers 中也可以创建新的 Workers,前提是这些 worker 都是同一个 origin。</p>\n<p>我们看一下 worker 的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Worker extends EventTarget, AbstractWorker &#123;</span><br><span class=\"line\">    onmessage: ((this: Worker, ev: MessageEvent) =&gt; any) | null;</span><br><span class=\"line\">    onmessageerror: ((this: Worker, ev: MessageEvent) =&gt; any) | null;</span><br><span class=\"line\"></span><br><span class=\"line\">    postMessage(message: any, transfer: Transferable[]): void;</span><br><span class=\"line\">    postMessage(message: any, options?: PostMessageOptions): void;</span><br><span class=\"line\"></span><br><span class=\"line\">    terminate(): void;</span><br><span class=\"line\">    addEventListener&lt;K extends keyof WorkerEventMap&gt;(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) =&gt; any, options?: boolean | AddEventListenerOptions): void;</span><br><span class=\"line\">    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;</span><br><span class=\"line\">    removeEventListener&lt;K extends keyof WorkerEventMap&gt;(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) =&gt; any, options?: boolean | EventListenerOptions): void;</span><br><span class=\"line\">    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">declare var Worker: &#123;</span><br><span class=\"line\">    prototype: Worker;</span><br><span class=\"line\">    new(stringUrl: string | URL, options?: WorkerOptions): Worker;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 Worker 的构造函数可以传入两个参数，第一个参数可以是 string 也可以是 URL，表示要执行的脚本路径。</p>\n<p>第二个参数是 WorkerOptions 选项，表示 worker 的类型，名字和权限相关的选项。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface WorkerOptions &#123;</span><br><span class=\"line\">    credentials?: RequestCredentials;</span><br><span class=\"line\">    name?: string;</span><br><span class=\"line\">    type?: WorkerType;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，worker 可以监听 onmessage 和 onmessageerror 两个事件。</p>\n<p>提供了两个方法：postMessage 和 terminate。</p>\n<p>worker 和主线程都可以通过 postMessage 来给对方发送消息，也可以用 onmessage 来接收对方发送的消息。</p>\n<p>还可以添加和移除 EventListener。</p>\n<p>我们看一个使用 worker 的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const first = document.querySelector(&#x27;#number1&#x27;);</span><br><span class=\"line\">const second = document.querySelector(&#x27;#number2&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">const result = document.querySelector(&#x27;.result&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">if (window.Worker) &#123;</span><br><span class=\"line\">\tconst myWorker = new Worker(&quot;worker.js&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfirst.onchange = function() &#123;</span><br><span class=\"line\">\t  myWorker.postMessage([first.value, second.value]);</span><br><span class=\"line\">\t  console.log(&#x27;Message posted to worker&#x27;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsecond.onchange = function() &#123;</span><br><span class=\"line\">\t  myWorker.postMessage([first.value, second.value]);</span><br><span class=\"line\">\t  console.log(&#x27;Message posted to worker&#x27;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmyWorker.onmessage = function(e) &#123;</span><br><span class=\"line\">\t\tresult.textContent = e.data;</span><br><span class=\"line\">\t\tconsole.log(&#x27;Message received from worker&#x27;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;Your browser doesn\\&#x27;t support web workers.&#x27;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子创建了一个 woker，并向 worker post 了一个消息。</p>\n<p>再看一下 worker.js 的内容是怎么样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">onmessage = function(e) &#123;</span><br><span class=\"line\">  console.log(&#x27;Worker: Message received from main script&#x27;);</span><br><span class=\"line\">  const result = e.data[0] * e.data[1];</span><br><span class=\"line\">  if (isNaN(result)) &#123;</span><br><span class=\"line\">    postMessage(&#x27;Please write two numbers&#x27;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    const workerResult = &#x27;Result: &#x27; + result;</span><br><span class=\"line\">    console.log(&#x27;Worker: Posting message back to main script&#x27;);</span><br><span class=\"line\">    postMessage(workerResult);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在主线程中向 worker postmessage，在 worker 中通过 onmessage 监听消息，然后又在 worker 中 post message，可以在 main 线程中通过 onmessage 来监听 woker 发送的消息。</p>\n<p>这样就做到了一次完美的交互。</p>\n<p>再看一下 worker 的兼容性：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201006122512486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_25,color_8F8F8F,t_70\" alt=\"image\"></p>\n<p>可以看到，基本上所有的浏览器都支持 worker，不过有些浏览器只支持部分的方法。</p>\n<p>如果想要立马结束一个 worker，我们可以使用 terminate：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">myWorker.terminate();</span><br></pre></td></tr></table></figure>\n\n<p>要想处理 worker 的异常，可以使用 onerror 来处理异常。</p>\n<p>如果 worker 的 script 比较复杂，需要用到其他的 script 文件，我们可以使用 importScripts 来导入其他的脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">importScripts();                         /* imports nothing */</span><br><span class=\"line\">importScripts(&#x27;foo.js&#x27;);                 /* imports just &quot;foo.js&quot; */</span><br><span class=\"line\">importScripts(&#x27;foo.js&#x27;, &#x27;bar.js&#x27;);       /* imports two scripts */</span><br><span class=\"line\">importScripts(&#x27;//example.com/hello.js&#x27;); /* You can import scripts from other origins */</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Web-Workers-的分类\"><a href=\"#Web-Workers-的分类\" class=\"headerlink\" title=\"Web Workers 的分类\"></a>Web Workers 的分类</h2><p>Web Workers 根据工作环境的不同，可以分为 DedicatedWorker 和 SharedWorker 两种。</p>\n<p>DedicatedWorker 的 Worker 只能从创建该 Woker 的脚本中访问，而 SharedWorker 则可以被多个脚本所访问。</p>\n<p>上面的例子中我们创建的 worker 就是 DedicatedWorker。</p>\n<p>怎么创建 sharedWorker 呢?</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var myWorker = new SharedWorker(&#x27;worker.js&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>SharedWorker 有一个单独的 SharedWorker 类，和 dedicated worker 不同的是 SharedWorker 是通过 port 对象来进行交互的。</p>\n<p>我们看一个 shared worker 的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var first = document.querySelector(&#x27;#number1&#x27;);</span><br><span class=\"line\">var second = document.querySelector(&#x27;#number2&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">var result1 = document.querySelector(&#x27;.result1&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">if (!!window.SharedWorker) &#123;</span><br><span class=\"line\">  var myWorker = new SharedWorker(&quot;worker.js&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  first.onchange = function() &#123;</span><br><span class=\"line\">    myWorker.port.postMessage([first.value, second.value]);</span><br><span class=\"line\">    console.log(&#x27;Message posted to worker&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  second.onchange = function() &#123;</span><br><span class=\"line\">    myWorker.port.postMessage([first.value, second.value]);</span><br><span class=\"line\">    console.log(&#x27;Message posted to worker&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  myWorker.port.onmessage = function(e) &#123;</span><br><span class=\"line\">    result1.textContent = e.data;</span><br><span class=\"line\">    console.log(&#x27;Message received from worker&#x27;);</span><br><span class=\"line\">    console.log(e.lastEventId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有的 postMessage 和 onmessage 都是基于 myWorker.port 来的。</p>\n<p>再看一下 worker 的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">onconnect = function(e) &#123;</span><br><span class=\"line\">  var port = e.ports[0];</span><br><span class=\"line\"></span><br><span class=\"line\">  port.onmessage = function(e) &#123;</span><br><span class=\"line\">    var workerResult = &#x27;Result: &#x27; + (e.data[0] * e.data[1]);</span><br><span class=\"line\">    port.postMessage(workerResult);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>worker 也是通过 port 来进行通信。</p>\n<p>这里我们使用了 onconnect 用来监听父线程的 onmessage 事件或者 start 事件，这两种事件都可以启动一个 SharedWorker。</p>\n<p>再看一下 sharedWorker 的浏览器兼容性：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201006234340881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_25,color_8F8F8F,t_70\" alt=\"image\"></p>\n<p>可以看到，比 worker 的兼容性要低很多，只有部分浏览器才支持这个高级特性。</p>\n<h2 id=\"worker-和-main-thread-之间的数据传输\"><a href=\"#worker-和-main-thread-之间的数据传输\" class=\"headerlink\" title=\"worker 和 main thread 之间的数据传输\"></a>worker 和 main thread 之间的数据传输</h2><p>我们知道 worker 和 main thread 之间是通过 postMessage 和 onMessage 进行交互的。这里面涉及到了数据传输的问题。</p>\n<p>实际上数据在 worker 和 main thread 之间是以拷贝的方式并且是以序列化的形式进行传输的。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"介绍防抖与节流的原理，并动手实现","url":"/2022/10/24/%E4%BB%8B%E7%BB%8D%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E5%B9%B6%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const debounce = (fn,delay) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 介绍防抖函数原理，并实现</span><br><span class=\"line\"></span><br><span class=\"line\">  // your code</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const throttle = (fn,delay = 500) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 介绍节流函数原理，并实现</span><br><span class=\"line\"></span><br><span class=\"line\">   // your code</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-防抖函数\"><a href=\"#1-防抖函数\" class=\"headerlink\" title=\"1)防抖函数\"></a>1)防抖函数</h2><h3 id=\"防抖函数原理\"><a href=\"#防抖函数原理\" class=\"headerlink\" title=\"防抖函数原理:\"></a>防抖函数原理:</h3><p>在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景:\"></a>适用场景:</h3><p>1.按钮提交场景:防止多次提交按钮，只执行最后提交的一次。</p>\n<p>2.服务端验证场景:表单验证需要服务端配合，只执行—段连续的输入事件的最后一次，还有搜索联想词功能类似</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 手写简化版实现</span><br><span class=\"line\"></span><br><span class=\"line\">const debounce = (fn,delay) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  let timer = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (...args) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    clearTimeout(timer);</span><br><span class=\"line\"></span><br><span class=\"line\">    timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      fn.apply(this,args);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,delay)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-节流函数\"><a href=\"#2-节流函数\" class=\"headerlink\" title=\"2)节流函数\"></a>2)节流函数</h2><h3 id=\"节流函数原理\"><a href=\"#节流函数原理\" class=\"headerlink\" title=\"节流函数原理:\"></a>节流函数原理:</h3><p>规定在一个单位时间内，只能触发—次函数。如果这个单位时间内触发多次函数，只有一次生效。防抖是延迟执行，而节流是间隔执行，函数节流即每隔一段时间就执行一次。</p>\n<h3 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景:\"></a>适用场景:</h3><p>1.拖拽场景:固定时间内只执行一次，防止超高频次触发位置变动</p>\n<p>⒉ 缩放场景:监控浏览器 resize</p>\n<p>3.动画场景:避免短时间内多次触发动画引起性能问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 手写简化版实现</span><br><span class=\"line\"></span><br><span class=\"line\">// ①定时器实现</span><br><span class=\"line\"></span><br><span class=\"line\">const throttle = (fn,delay = 500) =&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  let flag = true;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (...args) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!flag) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    flag = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      fn.apply(this,args);</span><br><span class=\"line\"></span><br><span class=\"line\">      flag = true;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,delay);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ②时间戳实现</span><br><span class=\"line\"></span><br><span class=\"line\">const throttle = (fn,delay = 500) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  let preTime = Date.now();</span><br><span class=\"line\"></span><br><span class=\"line\">  return (...args) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const nowTime = Date.now();</span><br><span class=\"line\"></span><br><span class=\"line\">    if(nowTime - preTime &gt;= delay)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          preTime = Date.now();</span><br><span class=\"line\"></span><br><span class=\"line\">          fn.apply(this,args);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"如何编写一个d.ts文件","url":"/2022/10/24/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAd-ts%E6%96%87%E4%BB%B6/","content":"<blockquote>\n<p>这篇文章主要讲怎么写一个 typescript 的描述文件（以 d.ts 结尾的文件名，比如 xxx.d.ts)。</p>\n</blockquote>\n<p>总结一下：<br>从类型 type 角度分为：基本类型（string、number、boolean 等）及其混合；复杂类型（class、function、object）及其混合（比如说又是 class 又是 function）。<br>从代码有效范围分为：全局变量、模块变量和又是全局变量又是模块变量的。<br>从定义文件来说：自己写的.d.ts 文件和扩展别人写的.d.ts 文件。<br>以上三个角度，应该覆盖了描述文件的各个方面了。</p>\n<p>2019.09.12 更新说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.增加了用interface的方式声明函数。</span><br><span class=\"line\">2.增加了在使用模块化导入的情况下如何声明全局变量。</span><br></pre></td></tr></table></figure>\n\n<p>2018.12.18 更新说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.增加了全局声明的原理说明。</span><br><span class=\"line\">2.增加了es6的import、export对应的d.ts文件写法。</span><br><span class=\"line\">3.增加了d.ts文件放置位置的说明。</span><br></pre></td></tr></table></figure>\n\n<p>发现了一个关于 typescript 比较好的入门教程：<a href=\"https://ts.xcatliu.com/basics/declaration-files\">https://ts.xcatliu.com/basics...</a>，这是其中的关于描述文件的文档。</p>\n<p>最近开始从 js 转 ts 了。但是要用到一些描述文件（d.ts），常用的比如 jquery 等都可以通过 npm 下载到别人已经写好的<code>npm install @types/jquery</code>。但是还是有一些小众的或者公司内部的公共库或者以前写过的公用 js 代码需要自己手动写描述文件。</p>\n<p>之前也从网上也找了一些资料，但还是看的云里雾里模糊不清，经过一段摸索，将摸索的结果记录下来，也希望可以给别人一个参考。</p>\n<p>如果你只写 js，d.ts 对你来说也是有用的，大部分编辑器能识别 d.ts 文件，当你写 js 代码的时候给你智能提示。效果像这样：</p>\n<p><img src=\"https://segmentfault.com/img/bVDReN?w=594&h=359\" alt=\"image\"></p>\n<p>详情可以看我以前写过的一些文章<a href=\"https://segmentfault.com/a/1190000007110845\">：https://segmentfault.com/a/11...</a></p>\n<p>通常，我们写 js 的时候有两种引入 js 的方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1，在html文件中通过&lt;script&gt;标签全局引入全局变量。</span><br><span class=\"line\">2，通过模块加载器require其他js文件：比如这样var j=require(&#x27;jquery&#x27;)。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"全局类型\"><a href=\"#全局类型\" class=\"headerlink\" title=\"全局类型\"></a>全局类型</h2><p>首先以第一种方式举例。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>比如现在有一个全局变量，那对应的 d.ts 文件里面这样写。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare var aaa:number</span><br></pre></td></tr></table></figure>\n\n<p>其中关键字 declare 表示声明的意思。<strong>在 d.ts 文件里面，在最外层声明变量或者函数或者类要在前面加上这个关键字。在 typescript 的规则里面，如果一个.ts、.d.ts 文件如果没有用到 import 或者 export 语法的话，那么最顶层声明的变量就是全局变量。</strong></p>\n<p>所以我们在这里声明了一个全局变量 aaa,类型是数字类型（number）。当然了也可以是 string 类型或者其他或者：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare var aaa:number|string //注意这里用的是一个竖线表示&quot;或&quot;的意思</span><br></pre></td></tr></table></figure>\n\n<p>如果是常量的话用关键字 const 表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare const max:200</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>由上面的全局变量的写法我们很自然的推断出一个全局函数的写法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** id是用户的id，可以是number或者string */</span><br><span class=\"line\">declare function getName(id:number|string):string</span><br></pre></td></tr></table></figure>\n\n<p>最后的那个 string 表示的是函数的返回值的类型。如果函数没有返回值可以用 void 表示。<br>在 js 里面调用的时候就会提示：</p>\n<p><img src=\"https://segmentfault.com/img/bVLuCP?w=579&h=122\" alt=\"image\"></p>\n<p>我们上面写的注释，写 js 的时候还可以提示。</p>\n<p>有时候同一个函数有若干种写法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXTD?w=431&h=107\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">get(1234)</span><br><span class=\"line\">get(&quot;zhangsan&quot;,18)</span><br></pre></td></tr></table></figure>\n\n<p>那么 d.ts 对应的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare function get(id: string | number): string</span><br><span class=\"line\">declare function get(name:string,age:number): string</span><br></pre></td></tr></table></figure>\n\n<p>如果有些参数可有可无，可以加个?表示非必须。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare function render(callback?:()=&gt;void): string</span><br></pre></td></tr></table></figure>\n\n<p>js 中调用的时候，回调传不传都可以：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">render()</span><br><span class=\"line\"></span><br><span class=\"line\">render(function () &#123;</span><br><span class=\"line\">    alert(&#x27;finish.&#x27;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用-interface-声明函数\"><a href=\"#用-interface-声明函数\" class=\"headerlink\" title=\"用 interface 声明函数\"></a>用 interface 声明函数</h3><p>也可以用 interface 去声明函数类型：</p>\n<p><img src=\"https://segmentfault.com/img/bVbxExG?w=440&h=178\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//Get是一种类型</span><br><span class=\"line\">declare interface Get&#123;</span><br><span class=\"line\">    (id: string): string</span><br><span class=\"line\">    (name:string,age:number):string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//get是Get类型的</span><br><span class=\"line\">declare var get:Get</span><br></pre></td></tr></table></figure>\n\n<p>用起来长这个样子：</p>\n<p><img src=\"https://segmentfault.com/img/bVbxExy?w=432&h=136\" alt=\"image\"></p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3><p>当然除了变量和函数外，我们还有类（class）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare class Person &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    static maxAge: number //静态变量</span><br><span class=\"line\">    static getMaxAge(): number //静态方法</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(name: string, age: number)  //构造函数</span><br><span class=\"line\">    getName(id: number): string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>constructor 表示的是构造方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXy0?w=651&h=91\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bVMXzk?w=524&h=100\" alt=\"image\"></p>\n<p>其中 static 表示静态的意思，用来表示静态变量和静态方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXAV?w=605&h=96\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bVMXAg?w=568&h=112\" alt=\"image\"></p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare namespace OOO&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然了这个对象上面可能有变量，可能有函数可能有类。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare namespace OOO&#123;</span><br><span class=\"line\">    var aaa: number | string</span><br><span class=\"line\">    function getName(id: number | string): string</span><br><span class=\"line\">    class Person &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        static maxAge: number //静态变量</span><br><span class=\"line\">        static getMaxAge(): number //静态方法</span><br><span class=\"line\"></span><br><span class=\"line\">        constructor(name: string, age: number) //构造函数</span><br><span class=\"line\">        getName(id: number): string //实例方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实就是把上面的那些写法放到这个 namespace 包起来的大括号里面，注意括号里面就不需要 declare 关键字了。<br>效果：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXBu?w=525&h=113\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bVMXBv?w=581&h=63\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bVMXBB?w=617&h=125\" alt=\"image\"></p>\n<p>对象里面套对象也是可以的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare namespace OOO&#123;</span><br><span class=\"line\">    var aaa: number | string</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    namespace O2&#123;</span><br><span class=\"line\">        let b:number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXB5?w=547&h=67\" alt=\"image\"></p>\n<h2 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型</h2><p>有时候有些值既是函数又是 class 又是对象的复杂对象。比如我们常用的 jquery 有各种用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">new $()</span><br><span class=\"line\">$.ajax()</span><br><span class=\"line\">$()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"既是函数又是对象\"><a href=\"#既是函数又是对象\" class=\"headerlink\" title=\"既是函数又是对象\"></a>既是函数又是对象</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare function $2(s:string): void</span><br><span class=\"line\"></span><br><span class=\"line\">declare namespace $2&#123;</span><br><span class=\"line\">    let aaa:number</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p>作为函数用：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXJ8?w=273&h=85\" alt=\"image\"></p>\n<p>作为对象用：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXKa?w=540&h=78\" alt=\"image\"></p>\n<p>也就是 ts 会自动把同名的 namespace 和 function 合并到一起。</p>\n<h3 id=\"既是函数，又是类（可以-new-出来），又是对象\"><a href=\"#既是函数，又是类（可以-new-出来），又是对象\" class=\"headerlink\" title=\"既是函数，又是类（可以 new 出来），又是对象\"></a>既是函数，又是类（可以 new 出来），又是对象</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 实例方法</span><br><span class=\"line\">interface People&#123;</span><br><span class=\"line\">    name: string</span><br><span class=\"line\">    age: number</span><br><span class=\"line\">    getName(): string</span><br><span class=\"line\">    getAge():number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface People_Static&#123;</span><br><span class=\"line\">    /** 构造函数 */</span><br><span class=\"line\">    new (name: string, age: number): People</span><br><span class=\"line\">    new (id:number): People</span><br><span class=\"line\"></span><br><span class=\"line\">    /** 作为对象，调用对象上的方法或者变量 */</span><br><span class=\"line\">    staticA():number</span><br><span class=\"line\">    aaa:string</span><br><span class=\"line\"></span><br><span class=\"line\">    /** 作为函数使用 */</span><br><span class=\"line\">    (w:number):number</span><br><span class=\"line\">    (w:string):number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">declare var People:People_Static</span><br></pre></td></tr></table></figure>\n\n<p>ts3.6 增加了新功能，function 声明和 class 声明可以合并了，所以又有了新的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** 作为函数使用 */</span><br><span class=\"line\">declare function People(w: number): number</span><br><span class=\"line\">declare function People(w: string): number</span><br><span class=\"line\"></span><br><span class=\"line\">declare class People &#123;</span><br><span class=\"line\">    /** 构造函数 */</span><br><span class=\"line\">    constructor(name: string, age: number)</span><br><span class=\"line\">    constructor(id: number)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 实例属性和实例方法</span><br><span class=\"line\">    name: string</span><br><span class=\"line\">    age: number</span><br><span class=\"line\">    getName(): string</span><br><span class=\"line\">    getAge(): number</span><br><span class=\"line\"></span><br><span class=\"line\">    /** 作为对象，调用对象上的方法或者变量 */</span><br><span class=\"line\">    static staticA(): number</span><br><span class=\"line\">    static aaa: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 作为对象，调用对象上的方法或者变量 */</span><br><span class=\"line\">declare namespace People &#123;</span><br><span class=\"line\">    export var abc: number</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数用 function，类用 class 声明，复杂对象就用 namespace，这样的对应关系简洁明了。</p>\n<p>效果：</p>\n<p>作为函数使用：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXNA?w=369&h=77\" alt=\"image\"></p>\n<p>类的静态方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXNN?w=595&h=83\" alt=\"image\"></p>\n<p>类的构造函数：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXNB?w=626&h=103\" alt=\"image\"></p>\n<p>类的实例方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXNE?w=508&h=165\" alt=\"image\"></p>\n<h2 id=\"模块化的全局变量\"><a href=\"#模块化的全局变量\" class=\"headerlink\" title=\"模块化的全局变量\"></a>模块化的全局变量</h2><p>这个是怎么回事呢，就是有时候我们定义全局变量的时候需要引入(别人写的)文件，比如这样的，我想声明个全局变量 req：</p>\n<p><img src=\"https://segmentfault.com/img/bVbxEAj?w=526&h=124\" alt=\"image\"></p>\n<p>由于我们当前的 d.ts 文件使用了 import&#x2F;export 语法，那么 ts 编译器就不把我们通过 declare var xxx:yyy 当成了全局变量了，那么我们就需要通过以下的方式声明全局变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; Request,Response&#125; from &#x27;express&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">declare global &#123;</span><br><span class=\"line\">    var req: Request</span><br><span class=\"line\">    var res: Response</span><br><span class=\"line\"></span><br><span class=\"line\">    namespace OOO &#123;</span><br><span class=\"line\">        var a:number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用起来长这个样子：</p>\n<p><img src=\"https://segmentfault.com/img/bVbxEBp?w=430&h=214\" alt=\"image\"></p>\n<p>其他类型（number、string blabla）就不一一举例了，参照上面的例子去掉 declare 填到 global 的大括号下就行了。</p>\n<h2 id=\"在-Ts-中定义-window-对象\"><a href=\"#在-Ts-中定义-window-对象\" class=\"headerlink\" title=\"在 Ts 中定义 window 对象\"></a>在 Ts 中定义 window 对象</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare global &#123;</span><br><span class=\"line\">  interface Window &#123;</span><br><span class=\"line\">    _czc: any</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模块化（CommonJS）\"><a href=\"#模块化（CommonJS）\" class=\"headerlink\" title=\"模块化（CommonJS）\"></a>模块化（CommonJS）</h2><p>除了上面的全局的方式，我们有时候还是通过 require 的方式引入模块化的代码。</p>\n<p>比如这样的效果：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXOl?w=486&h=134\" alt=\"image\"></p>\n<p>对应的写法是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare module &quot;abcde&quot; &#123;</span><br><span class=\"line\">    export let a: number</span><br><span class=\"line\">    export function b(): number</span><br><span class=\"line\">    export namespace c&#123;</span><br><span class=\"line\">        let cd: string</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实就是外面套了一层 <code>module &quot;xxx&quot;</code>，里面的写法和之前其实差不多，把<code>declare</code>换成了<code>export</code>。</p>\n<p>此外，有时候我们导出去的是一个函数本身，比如这样的：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXOU?w=358&h=110\" alt=\"image\"></p>\n<p>对应的写法很简单，长这个样子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare module &quot;app&quot; &#123;</span><br><span class=\"line\">    function aaa(some:number):number</span><br><span class=\"line\">     export=aaa</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以此类推，导出一个变量或常量的话这么写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare module &quot;ccc&quot; &#123;</span><br><span class=\"line\">    const c:400</span><br><span class=\"line\">     export=c</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXPc?w=671&h=109\" alt=\"image\"></p>\n<h2 id=\"ES6-的模块化方式（import-export）\"><a href=\"#ES6-的模块化方式（import-export）\" class=\"headerlink\" title=\"ES6 的模块化方式（import export）\"></a>ES6 的模块化方式（import export）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare var aaa: 1</span><br><span class=\"line\">declare var bbb: 2</span><br><span class=\"line\">declare var ccc: 3 //因为这个文件里我们使用了import或者export语法，所以bbb和ccc在其他代码里不能访问到，即不是全局变量</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123; aaa &#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; a1, a2 &#125; from &quot;./A&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a1)</span><br><span class=\"line\">console.log(a2)</span><br></pre></td></tr></table></figure>\n\n<p>那么对应的 A.d.ts 文件是这样写的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare var a1: 1</span><br><span class=\"line\">declare var a2: 2</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123; a1,a2 &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然了也能这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export declare var a1: 1</span><br><span class=\"line\">export declare var a2: 2</span><br></pre></td></tr></table></figure>\n\n<p>不过建议之前的第一种写法，原因看这里<a href=\"https://segmentfault.com/a/1190000017419857\">https://segmentfault.com/a/11...</a></p>\n<p>当然了还有人经常问 default 导出的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare var a1: 1</span><br><span class=\"line\">export default a1</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候当然就是这样用了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import a1 from &quot;./A&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a1)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h2><p>有一种代码，既可以通过全局变量访问到，也可以通过 require 的方式访问到。比如我们最常见的 jquery：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXPg?w=539&h=174\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bVMXPf?w=523&h=187\" alt=\"image\"></p>\n<p>其实就是按照全局的方式写 d.ts，写完后在最后加上<code>declare module &quot;xxx&quot;</code>的描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare namespace UUU&#123;</span><br><span class=\"line\">    let a:number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">declare module &quot;UUU&quot; &#123;</span><br><span class=\"line\">    export =UUU</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果这样：</p>\n<p>作为全局变量使用：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXPB?w=520&h=86\" alt=\"image\"></p>\n<p>作为模块加载使用：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXPM?w=513&h=104\" alt=\"image\"></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>有时候我们扩展了一些内置对象。比如我们给 Date 增加了一个 format 的实例方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXRR?w=517&h=103\" alt=\"image\"></p>\n<p>对应的 d.ts 描述文件这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Date &#123;</span><br><span class=\"line\">    format(f: string): string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"d-ts-文件放到哪里\"><a href=\"#d-ts-文件放到哪里\" class=\"headerlink\" title=\".d.ts 文件放到哪里\"></a>.d.ts 文件放到哪里</h2><p>经常有人问写出来的 d.ts 文件（A.d.ts）文件放到哪个目录里，如果是模块化的话那就放到和源码（A.js）文件同一个目录下，如果是全局变量的话理论上放到哪里都可以————当然除非你在 tsconfig.json 文件里面特殊配置过。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"前端大厂10道经典面试题汇总","url":"/2022/12/16/%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%8E%8210%E9%81%93%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/","content":"<h2 id=\"1、写一个-js-函数，实现对一个数字每-3-位加一个逗号，如输入-100000，-输出-100-000（不考虑负数，小数）—百度前端面试题\"><a href=\"#1、写一个-js-函数，实现对一个数字每-3-位加一个逗号，如输入-100000，-输出-100-000（不考虑负数，小数）—百度前端面试题\" class=\"headerlink\" title=\"1、写一个 js 函数，实现对一个数字每 3 位加一个逗号，如输入 100000， 输出 100,000（不考虑负数，小数）—百度前端面试题\"></a>1、写一个 js 函数，实现对一个数字每 3 位加一个逗号，如输入 100000， 输出 100,000（不考虑负数，小数）—百度前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let arr = []</span><br><span class=\"line\">function main(num) &#123;</span><br><span class=\"line\">    if (num === null) return</span><br><span class=\"line\">    let n = parseInt(num).toString()</span><br><span class=\"line\">    s(n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function s(num) &#123;</span><br><span class=\"line\">    if (num.length &gt; 3) &#123;</span><br><span class=\"line\">        arr[arr.length] = num.slice(-3)</span><br><span class=\"line\">        s(num.slice(0, -3))</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        arr[arr.length] = num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main(123456789)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(arr.reverse().join(&quot;,&quot;))</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>本题是 js 实现 number.toLocaleString()方法，面试题做了简化不考虑负数小数，此题主要是考数据类型及字符串操作，答案不唯一。</p>\n<p>按现实思路解题，现实中添加千位分隔符是从后到前，每 3 位添加逗号，所以这里输入数据转换成字符串后，利用 slice 方法的输入负数参数从后取的特点，从后取三位数字保存在数组中，并把取剩后的数据递归重复取值，直到数据不足 3 位，把剩下一起存入数组中。</p>\n<p>这时数组中按顺序保存从后到前的分割数据。实例中数组是[‘789’,’456’,’123’]。通过 reverse 方法倒序输出，并通过 join 方法添加逗号。</p>\n<h2 id=\"2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题\"><a href=\"#2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题\" class=\"headerlink\" title=\"2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题\"></a>2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// var lengthOfLongestSubstring = function(s) &#123;</span><br><span class=\"line\">//     let n = s.length;</span><br><span class=\"line\">//     let set = new Set();</span><br><span class=\"line\">//     let ans = 0, i = 0, j = 0;</span><br><span class=\"line\">//     while (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">//         if (!set.has(s[j])) &#123;</span><br><span class=\"line\">//             set.add(s[j++]);</span><br><span class=\"line\">//             ans = Math.max(ans, j - i);</span><br><span class=\"line\">//         &#125; else &#123;</span><br><span class=\"line\">//             set.delete(s[i++]);</span><br><span class=\"line\">//         &#125;</span><br><span class=\"line\">//     &#125;</span><br><span class=\"line\">//     return ans;</span><br><span class=\"line\">// &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//时间复杂度：O(2n) = O(n)O(2n)=O(n)，在最糟糕的情况下，每个字符将被 ii 和 jj 访问两次。</span><br><span class=\"line\">//空间复杂度：O(min(m, n))O(min(m,n))，与之前的方法相同。滑动窗口法需要 O(k)O(k) 的空间，其中 kk 表示 Set 的大小。而Set的大小取决于字符串 nn 的大小以及字符集/字母 mm 的大小。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function StrLen(str) &#123;</span><br><span class=\"line\">    let result = 1    //最终要返回的结果的初始值</span><br><span class=\"line\">    let norepeatStr = &#x27;&#x27; //用于存放无重复字符串</span><br><span class=\"line\">    let len = str.length</span><br><span class=\"line\">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        //charAt()获取的是字符串索引对应的具体字符</span><br><span class=\"line\">        let specStr = str.charAt(i)</span><br><span class=\"line\">        //indexOf()查找的是某个字符第一次出现并返回这个索引值，若没有这个字符，返回-1</span><br><span class=\"line\">        let index = norepeatStr.indexOf(specStr)</span><br><span class=\"line\">        if (index === -1) &#123;</span><br><span class=\"line\">            //将遍历得到的字符（未重复）拼接在norepeatStr后面</span><br><span class=\"line\">            norepeatStr = norepeatStr + specStr</span><br><span class=\"line\">            result = result &lt; norepeatStr.length ? norepeatStr.length : result</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //若遇到重复的字符，那么将已出现在norepeatStr里的字符删除，并将新的（重复的添加到末尾）</span><br><span class=\"line\">            norepeatStr = norepeatStr.substr(index + 1) + specStr</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(StrLen(abbbcbd))</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>这题的要点就是无重复字符的理解。首先字符串内字符位置是固定的，我们要采用顺序循环的方式解题，然后就是理解无重复字符的含义，把当前字符串分割，每个小分割内不能出现重复的字符。也就是说分割的字符串是不会互相叠加重复的，每当该段分割的下一个字符与该段分割内字符相同，当即重新开始分割字符。</p>\n<p>所以解题时需要一个存储当前分割片段的对象，用来比较下一个字符。并取这个分割片段的长度，与每个分割片段的最大长度比较即可。本题主要考的是题面的理解，以及字符串方法的运用，需要熟练地运用才能快速解题。</p>\n<h2 id=\"3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题\"><a href=\"#3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题\" class=\"headerlink\" title=\"3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题\"></a>3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function func() &#123;</span><br><span class=\"line\">    let a = &#x27;333333333333333333333333333&#x27;</span><br><span class=\"line\">    let b = &#x27;9999999999999999999&#x27;</span><br><span class=\"line\">    let n1 = a.length</span><br><span class=\"line\">    let n2 = b.length</span><br><span class=\"line\">    for (let i = 0; i &lt; Math.max(n1, n2) - Math.min(n1, n2); i ++) &#123;</span><br><span class=\"line\">        if (n1 &gt; n2) b = &#x27;0&#x27; + b</span><br><span class=\"line\">        if (n2 &gt; n1) a = &#x27;0&#x27; + a</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a = a.split(&#x27;&#x27;).reverse()</span><br><span class=\"line\">    b = b.split(&#x27;&#x27;).reverse()</span><br><span class=\"line\">    //split()基于指定的分隔符将一个字符串分割成多个子字符串并将结果放在一个数组中</span><br><span class=\"line\">    //reverse()反转数组项的顺序（加法计算顺序）</span><br><span class=\"line\">    //现在a，b数组中存储着相同个数的大数字的逆顺序拆解</span><br><span class=\"line\"></span><br><span class=\"line\">    let n = Math.max(n1, n2)</span><br><span class=\"line\">    let result = Array.apply(this, Array(n)).map((item, i) =&gt; &#123;</span><br><span class=\"line\">        return 0</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    //生成一个长度为n的每个元素都为0的数组（用来保存最终结果）</span><br><span class=\"line\"></span><br><span class=\"line\">    for (let k = 0; k &lt; n; k ++) &#123;</span><br><span class=\"line\">        let temp = parseInt(a[k]) + parseInt(b[k])</span><br><span class=\"line\">        if (temp &gt; 9) &#123;</span><br><span class=\"line\">            result[k] += temp - 10</span><br><span class=\"line\">            result[k+1] = 1</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            result[k] += temp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //把ab数组中的数字相加减，注意进位</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(result.reverse().join(&#x27;&#x27;).toString())</span><br><span class=\"line\">    //将数组项基于指定的分隔符以字符串输出</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>首先了解超出存储范围的大数字概念，每种数据类型可存储数据量都是存在范围的</p>\n<p>数字类型的范围：</p>\n<p>Number.MAX_VALUE &#x3D; 1.7976931348623157e+308</p>\n<p>Number.MIN_VALUE &#x3D; 5e-324</p>\n<p>整数类型的范围：-2-53-253</p>\n<p>当超出这个范围，为了避免数据丢失，就要采用其他手段进行运算。在参考答案中，运用数组的方式解决这个问题。首先两个大整数要存储在数组中，要先保证位数对齐，我们比较字符串长度把低位数的大整数字符串前面添加相应的 0 占位， 并逆排序。创建一个新的数组保存运算结果，将两个大整数按从后到前的顺序进行相加减，这里注意进位。把得到的数组反转到正常顺序即可。</p>\n<h2 id=\"4、任意数组的全排列组合—阿里巴巴前端面试题\"><a href=\"#4、任意数组的全排列组合—阿里巴巴前端面试题\" class=\"headerlink\" title=\"4、任意数组的全排列组合—阿里巴巴前端面试题\"></a>4、任意数组的全排列组合—阿里巴巴前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;hello&#x27;,&#x27;world&#x27;];</span><br><span class=\"line\">var count = 1;</span><br><span class=\"line\">function getStr(a)&#123;</span><br><span class=\"line\">\tfor (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">\t\t// indexOf 是es6数组的方法,如果不存在返回-1，存在返回下标</span><br><span class=\"line\">\t\tif(a.indexOf(arr[i])&lt;0)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//数组 a 中不存在 arr[i],将arr[i]添加到数组末尾</span><br><span class=\"line\">\t\t\ta.push(arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif(a.length==arr.length)&#123;</span><br><span class=\"line\">\t\t\t\tconsole.log(count++ + &#x27;: &#x27; +a.join(&quot;&quot;));</span><br><span class=\"line\">\t\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t\t//结束一次for循环  进行了4次递归 getStr([&#x27;foo&#x27;]) getStr([&#x27;bar&#x27;]) getStr([&#x27;hello&#x27;]) getStr([&#x27;world&#x27;])</span><br><span class=\"line\">\t\t\t\tgetStr(a);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//一定从数组 a 中删除arr[i],进行下次循环，如果不删除就只能获得一种结果了</span><br><span class=\"line\">\t\t\ta.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getStr([])</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>本题做法不唯一，这里采用了把多项数组逐步两两相乘的方式，第一次先取二维数组前两项组合，把组合的结果在与第三项组合以此类推。这种递归做法简单易懂，把复杂的多项问题简化成两项问题的逐渐递增。</p>\n<h2 id=\"5、公司最近新研发了一种产品，共生产了-n-件。有-m-个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题\"><a href=\"#5、公司最近新研发了一种产品，共生产了-n-件。有-m-个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题\" class=\"headerlink\" title=\"5、公司最近新研发了一种产品，共生产了 n 件。有 m 个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题\"></a>5、公司最近新研发了一种产品，共生产了 n 件。有 m 个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let n = 3</span><br><span class=\"line\">let m = 4</span><br><span class=\"line\">let arr = [2, 8, 10, 7]</span><br><span class=\"line\">let key = 0, max = 0</span><br><span class=\"line\">arr = arr.sort( (a, b) =&gt; &#123;</span><br><span class=\"line\">    return a - b   //升序</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">if (n &lt; m) &#123;</span><br><span class=\"line\">    arr = arr.slice(m - n)  //截取出价高的人</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for (let i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class=\"line\">    if (max &lt; arr[i] * (arr.length - i)) &#123;</span><br><span class=\"line\">        max = arr[i] * (arr.length - i)</span><br><span class=\"line\">        key = arr[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(key)</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>本题是京东的业务演变题，首先要理清思路。本题中，固定出价，以及出价低于产品的顾客会被拒绝购买是解题核心。</p>\n<p>条件中已知产品总个数，顾客出价。这里有个小陷阱，会出现 N&lt;M 供不应求的情况，要特殊考虑。依据题目，我们首先需要对顾客出价排序，这里按升序排列。当供不应求出现时，我们截取出价高的顾客。然后把每个顾客的出价当做最终售价循环，得出最大化利润下的售价。</p>\n<h2 id=\"6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题\"><a href=\"#6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题\" class=\"headerlink\" title=\"6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题\"></a>6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let s = &#x27;asdaaaaaad&#x27;</span><br><span class=\"line\">let count = 0, char = &#x27;&#x27;         //count出现次数 char字符</span><br><span class=\"line\">let arr = []        // 储存去重后字符</span><br><span class=\"line\">function foo(str) &#123;         // 去重</span><br><span class=\"line\">    return r = str.split(&quot;&quot;).filter(function (element, index, self) &#123;</span><br><span class=\"line\">        return self.indexOf(element) === index     // 输出第一次出现的字符</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">arr = foo(s)</span><br><span class=\"line\">for (let i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class=\"line\">    let n = (s.split(arr[i])).length - 1           //出现次数</span><br><span class=\"line\">    if (count &lt; n) &#123;</span><br><span class=\"line\">        count = n</span><br><span class=\"line\">        char = arr[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&quot;count:&quot; + count + &quot;,char:&quot; + char)</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>计算出全部字符出现次数，并留下最大的。首先利用 filter()与 indexOf()的方法连用字符串去重，再将得到的作为索引，利用 split()分割字符串，得到字符出现次数，比较得出结果。</p>\n<h2 id=\"7、”123456789876543212345678987654321…”的第-n-位是什么？—小米面试题\"><a href=\"#7、”123456789876543212345678987654321…”的第-n-位是什么？—小米面试题\" class=\"headerlink\" title=\"7、”123456789876543212345678987654321…”的第 n 位是什么？—小米面试题\"></a>7、”123456789876543212345678987654321…”的第 n 位是什么？—小米面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let k = &quot;1234567898765432&quot;  //最小循环节</span><br><span class=\"line\">function getNum(n) &#123;</span><br><span class=\"line\">    console.log(k.charAt(n % k.length - 1))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getNum(20)</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>这道题的答案不唯一，这里可以利用数学中最小循环节的概念解题，找到最小循环节后，利用余数查找第 n 位数字。</p>\n<h2 id=\"8、请编写一个-JavaScript-函数-parseQueryString，它的用途是把-URL-参数解析为一个对象—淘宝面试题\"><a href=\"#8、请编写一个-JavaScript-函数-parseQueryString，它的用途是把-URL-参数解析为一个对象—淘宝面试题\" class=\"headerlink\" title=\"8、请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象—淘宝面试题\"></a>8、请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象—淘宝面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function parseQueryString(url) &#123;</span><br><span class=\"line\">  var pos = url.indexOf(&quot;?&quot;)</span><br><span class=\"line\">  var obj = &#123;&#125;</span><br><span class=\"line\">  if (pos != -1) &#123;</span><br><span class=\"line\">    var urlString=url.slice(pos+1)</span><br><span class=\"line\">    var urlArr = urlString.split(&quot;&amp;&quot;)</span><br><span class=\"line\">    var keyValue = []</span><br><span class=\"line\">    for (var i = 0; i &lt; urlArr.length; i++) &#123;</span><br><span class=\"line\">      keyValue = urlArr[i].split(&quot;=&quot;)</span><br><span class=\"line\">      obj[keyValue[0]]=keyValue[1]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>淘宝这道题是很常用的场景题，这里需要处理好分段次序，首先把？分离，然后按&amp;分割最后按&#x3D;分割，主要考察字符串的函数运用以及对象的创建。</p>\n<h2 id=\"9、如果给定的字符串是回文，返回-true，反之，返回-false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是-palindrome-回文-。—网易前端面试题\"><a href=\"#9、如果给定的字符串是回文，返回-true，反之，返回-false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是-palindrome-回文-。—网易前端面试题\" class=\"headerlink\" title=\"9、如果给定的字符串是回文，返回 true，反之，返回 false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是 palindrome(回文)。—网易前端面试题\"></a>9、如果给定的字符串是回文，返回 true，反之，返回 false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是 palindrome(回文)。—网易前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function palindrome(str) &#123;</span><br><span class=\"line\">    let str1 = str.replace(/[^0-9a-zA-Z]/g,&quot;&quot;).toLowerCase()  // 去掉标点符号，转化成小写，比较参数一</span><br><span class=\"line\">    let str2 = str1.split(&quot;&quot;).reverse().join(&quot;&quot;)   // 翻转字符串，比较参数二</span><br><span class=\"line\">    if (str1 === str2) &#123;</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125; else return false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(palindrome(&quot;aBc,./1d42--==EFG0 00 h0 &#x27;;00gfE&#x27; ./.24d 1cBA&quot;)) // 输出结果：true</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。</p>\n<h2 id=\"10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题\"><a href=\"#10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题\" class=\"headerlink\" title=\"10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题\"></a>10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function titleCase(str) &#123;</span><br><span class=\"line\">    let aStr = str.toLowerCase().split(&quot; &quot;)   // 转小写，分割成字符串数组</span><br><span class=\"line\">    for (let i = 0; i &lt; aStr.length; i ++) &#123;</span><br><span class=\"line\">        aStr[i] = aStr[i][0].toUpperCase() + aStr[i].slice(1) // 重新组合字符串元素</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let oString = aStr.join(&quot; &quot;)  //转成字符串</span><br><span class=\"line\">    return oString</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(titleCase(&quot;I&#x27;m a title Case&quot;)) // 输出结果为 I&#x27;m A Title Case</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>字符串转化成小写；<br>分割成字符串数组；<br>新组合字符串元素&#x3D;首字母转大写+其余小写。</p>\n<p><a href=\"https://github.com/guochangxindeGH/LeetCode/tree/master/Algorithms/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB\">代码 github 地址</a></p>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"前端代码开发规范","url":"/2022/12/16/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","content":"<h2 id=\"前端-JS-项目开发规范\"><a href=\"#前端-JS-项目开发规范\" class=\"headerlink\" title=\"前端 JS 项目开发规范\"></a>前端 JS 项目开发规范</h2><p>规范的目的是为了编写高质量的代码，让你的团队成员每天的心情都是愉悦的，大家在一起是快乐的。</p>\n<p>引自《阿里规约》的开头片段：</p>\n<p>—-现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。</p>\n<h2 id=\"一、编程规约\"><a href=\"#一、编程规约\" class=\"headerlink\" title=\"一、编程规约\"></a>一、编程规约</h2><h3 id=\"一-命名规范\"><a href=\"#一-命名规范\" class=\"headerlink\" title=\"(一)命名规范\"></a>(一)命名规范</h3><h4 id=\"1-1-1-项目命名\"><a href=\"#1-1-1-项目命名\" class=\"headerlink\" title=\"1.1.1 项目命名\"></a>1.1.1 项目命名</h4><p>全部采用小写方式， 以中划线分隔。</p>\n<p>正例：<code>mall-management-system</code></p>\n<p>反例：<code>mall_management-system / mallManagementSystem</code></p>\n<h4 id=\"1-1-2-目录命名\"><a href=\"#1-1-2-目录命名\" class=\"headerlink\" title=\"1.1.2 目录命名\"></a>1.1.2 目录命名</h4><p>全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数</p>\n<p>正例： <code>scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc</code></p>\n<p>反例： <code>script / style / demo_scripts / demoStyles / imgs / docs</code></p>\n<p>【特殊】VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名</p>\n<p>正例： <code>head-search / page-loading / authorized / notice-icon</code></p>\n<p>反例： <code>HeadSearch / PageLoading</code></p>\n<p>【特殊】VUE 的项目中除 components 组件目录外的所有目录也使用 kebab-case 命名<br>正例： <code>page-one / shopping-car / user-management</code></p>\n<p>反例： <code>ShoppingCar / UserManagement</code></p>\n<h4 id=\"1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名\"><a href=\"#1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名\" class=\"headerlink\" title=\"1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名\"></a>1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</h4><p>全部采用小写方式， 以中划线分隔</p>\n<p>正例： <code>render-dom.js / signup.css / index.html / company-logo.png</code></p>\n<p>反例： <code>renderDom.js / UserManagement.html</code></p>\n<h4 id=\"1-1-4-命名严谨性\"><a href=\"#1-1-4-命名严谨性\" class=\"headerlink\" title=\"1.1.4 命名严谨性\"></a>1.1.4 命名严谨性</h4><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用</p>\n<p>正例：<code>henan / luoyang / rmb</code> 等国际通用的名称，可视同英文。</p>\n<p>反例：<code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code></p>\n<p>杜绝完全不规范的缩写，避免望文不知义：</p>\n<p>反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</p>\n<h3 id=\"二-HTML-规范-（Vue-Template-同样适用）\"><a href=\"#二-HTML-规范-（Vue-Template-同样适用）\" class=\"headerlink\" title=\"(二)HTML 规范 （Vue Template 同样适用）\"></a>(二)HTML 规范 （Vue Template 同样适用）</h3><h4 id=\"1-2-1-HTML-类型\"><a href=\"#1-2-1-HTML-类型\" class=\"headerlink\" title=\"1.2.1 HTML 类型\"></a>1.2.1 HTML 类型</h4><p>推荐使用 HTML5 的文档类型声明： .<br>（建议使用 text&#x2F;html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application&#x2F;xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p>\n<ul>\n<li>规定字符编码</li>\n<li>IE 兼容模式</li>\n<li>规定字符编码</li>\n<li>doctype 大写<br>正例：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">    &lt;title&gt;Page title&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot; /&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-2-缩进\"><a href=\"#1-2-2-缩进\" class=\"headerlink\" title=\"1.2.2 缩进\"></a>1.2.2 缩进</h4><p>缩进使用 2 个空格（一个 tab）</p>\n<p>嵌套的节点应该缩进。</p>\n<h4 id=\"1-2-3-分块注释\"><a href=\"#1-2-3-分块注释\" class=\"headerlink\" title=\"1.2.3 分块注释\"></a>1.2.3 分块注释</h4><p>在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式</p>\n<p>…</p>\n<h4 id=\"1-2-4-语义化标签\"><a href=\"#1-2-4-语义化标签\" class=\"headerlink\" title=\"1.2.4 语义化标签\"></a>1.2.4 语义化标签</h4><p>HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签</p>\n<p>正例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;header&gt;&lt;/header&gt;</span><br><span class=\"line\">&lt;footer&gt;&lt;/footer&gt;</span><br></pre></td></tr></table></figure>\n\n<p>反例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-5-引号\"><a href=\"#1-2-5-引号\" class=\"headerlink\" title=\"1.2.5 引号\"></a>1.2.5 引号</h4><p>使用双引号(“”) 而不是单引号(‘’) 。</p>\n<p>正例： “”</p>\n<p>反例： ‘’</p>\n<h3 id=\"三-CSS-规范\"><a href=\"#三-CSS-规范\" class=\"headerlink\" title=\"(三) CSS 规范\"></a>(三) CSS 规范</h3><h4 id=\"1-3-1-命名\"><a href=\"#1-3-1-命名\" class=\"headerlink\" title=\"1.3.1 命名\"></a>1.3.1 命名</h4><ul>\n<li>类名使用小写字母，以中划线分隔</li>\n<li>id 采用驼峰式命名</li>\n<li>scss 中的变量、函数、混合、placeholder 采用驼峰式命名<br>ID 和 class 的名称总是使用可以反映元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</li>\n</ul>\n<p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.fw-800 &#123;</span><br><span class=\"line\">  font-weight: 800;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.red &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.heavy &#123;</span><br><span class=\"line\">  font-weight: 800;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.important &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-2-选择器\"><a href=\"#1-3-2-选择器\" class=\"headerlink\" title=\"1.3.2 选择器\"></a>1.3.2 选择器</h4><p>1)css 选择器中避免使用标签名<br>从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。</p>\n<p>2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。</p>\n<p>不推荐:</p>\n<p><code>.content .title &#123;   font-size: 2rem; &#125;</code></p>\n<p>推荐:</p>\n<p><code>.content &gt; .title &#123;   font-size: 2rem; &#125;</code></p>\n<h4 id=\"1-3-3-尽量使用缩写属性\"><a href=\"#1-3-3-尽量使用缩写属性\" class=\"headerlink\" title=\"1.3.3 尽量使用缩写属性\"></a>1.3.3 尽量使用缩写属性</h4><p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">border-top-style: none;</span><br><span class=\"line\">font-family: palatino, georgia, serif;</span><br><span class=\"line\">font-size: 100%;</span><br><span class=\"line\">line-height: 1.6;</span><br><span class=\"line\">padding-bottom: 2em;</span><br><span class=\"line\">padding-left: 1em;</span><br><span class=\"line\">padding-right: 1em;</span><br><span class=\"line\">padding-top: 0;</span><br></pre></td></tr></table></figure>\n\n<p>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">border-top: 0;</span><br><span class=\"line\">font: 100%/1.6 palatino, georgia, serif;</span><br><span class=\"line\">padding: 0 1em 2em;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-4-每个选择器及属性独占一行\"><a href=\"#1-3-4-每个选择器及属性独占一行\" class=\"headerlink\" title=\"1.3.4 每个选择器及属性独占一行\"></a>1.3.4 每个选择器及属性独占一行</h4><p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">button&#123;</span><br><span class=\"line\">  width:100px;height:50px;color:#fff;background:#00a0e9;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">button&#123;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  color:#fff;</span><br><span class=\"line\">  background:#00a0e9;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-5-省略-0-后面的单位\"><a href=\"#1-3-5-省略-0-后面的单位\" class=\"headerlink\" title=\"1.3.5 省略 0 后面的单位\"></a>1.3.5 省略 0 后面的单位</h4><p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">  padding-bottom: 0px;</span><br><span class=\"line\">  margin: 0em;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">  padding-bottom: 0;</span><br><span class=\"line\">  margin: 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-6-避免使用-ID-选择器及全局标签选择器防止污染全局样式\"><a href=\"#1-3-6-避免使用-ID-选择器及全局标签选择器防止污染全局样式\" class=\"headerlink\" title=\"1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式\"></a>1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式</h4><p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#header&#123;</span><br><span class=\"line\">  padding-bottom: 0px;</span><br><span class=\"line\">  margin: 0em;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.header&#123;</span><br><span class=\"line\">  padding-bottom: 0px;</span><br><span class=\"line\">  margin: 0em;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四-LESS-规范\"><a href=\"#四-LESS-规范\" class=\"headerlink\" title=\"(四) LESS 规范\"></a>(四) LESS 规范</h3><h4 id=\"1-4-1-代码组织\"><a href=\"#1-4-1-代码组织\" class=\"headerlink\" title=\"1.4.1 代码组织\"></a>1.4.1 代码组织</h4><p>1)将公共 less 文件放置在<code>style/less/common</code>文件夹<br>例:<code>// color.less,common.less</code></p>\n<p>2)按以下顺序组织</p>\n<ul>\n<li>1、@import;</li>\n<li>2、变量声明;</li>\n<li>3、样式声明;</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@import &quot;mixins/size.less&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">@default-text-color: #333;</span><br><span class=\"line\"></span><br><span class=\"line\">.page &#123;</span><br><span class=\"line\">  width: 960px;</span><br><span class=\"line\">  margin: 0 auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-4-2-避免嵌套层级过多\"><a href=\"#1-4-2-避免嵌套层级过多\" class=\"headerlink\" title=\"1.4.2 避免嵌套层级过多\"></a>1.4.2 避免嵌套层级过多</h4><p>将嵌套深度限制在 3 级。对于超过 4 级的嵌套，给予重新评估。这可以避免出现过于详实的 CSS 选择器。<br>避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于 20 行的嵌套规则出现</p>\n<p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.main&#123;</span><br><span class=\"line\">  .title&#123;</span><br><span class=\"line\">    .name&#123;</span><br><span class=\"line\">       color:#fff</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.main-title&#123;</span><br><span class=\"line\">   .name&#123;</span><br><span class=\"line\">      color:#fff</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五-Javascript-规范\"><a href=\"#五-Javascript-规范\" class=\"headerlink\" title=\"(五) Javascript 规范\"></a>(五) Javascript 规范</h3><h4 id=\"1-5-1-命名\"><a href=\"#1-5-1-命名\" class=\"headerlink\" title=\"1.5.1 命名\"></a>1.5.1 命名</h4><ol>\n<li><p>采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束<br>反例： <code>_name / name_ / name$</code></p>\n</li>\n<li><p>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。<br>正例： <code>localValue / getHttpMessage() / inputUserId</code></p>\n</li>\n</ol>\n<p><strong>其中 method 方法命名必须是 动词 或者 动词+名词 形式</strong></p>\n<p>正例：<code>saveShopCarData /openShopCarInfoDialog</code></p>\n<p>反例：<code>save / open / show / go</code></p>\n<p><strong>特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）</strong></p>\n<p><code>add / update / delete / detail / get</code></p>\n<p><strong>附： 函数方法常用的动词:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">get 获取/set 设置,</span><br><span class=\"line\">add 增加/remove 删除</span><br><span class=\"line\">create 创建/destory 移除</span><br><span class=\"line\">start 启动/stop 停止</span><br><span class=\"line\">open 打开/close 关闭,</span><br><span class=\"line\">read 读取/write 写入</span><br><span class=\"line\">load 载入/save 保存,</span><br><span class=\"line\">create 创建/destroy 销毁</span><br><span class=\"line\">begin 开始/end 结束,</span><br><span class=\"line\">backup 备份/restore 恢复</span><br><span class=\"line\">import 导入/export 导出,</span><br><span class=\"line\">split 分割/merge 合并</span><br><span class=\"line\">inject 注入/extract 提取,</span><br><span class=\"line\">attach 附着/detach 脱离</span><br><span class=\"line\">bind 绑定/separate 分离,</span><br><span class=\"line\">view 查看/browse 浏览</span><br><span class=\"line\">edit 编辑/modify 修改,</span><br><span class=\"line\">select 选取/mark 标记</span><br><span class=\"line\">copy 复制/paste 粘贴,</span><br><span class=\"line\">undo 撤销/redo 重做</span><br><span class=\"line\">insert 插入/delete 移除,</span><br><span class=\"line\">add 加入/append 添加</span><br><span class=\"line\">clean 清理/clear 清除,</span><br><span class=\"line\">index 索引/sort 排序</span><br><span class=\"line\">find 查找/search 搜索,</span><br><span class=\"line\">increase 增加/decrease 减少</span><br><span class=\"line\">play 播放/pause 暂停,</span><br><span class=\"line\">launch 启动/run 运行</span><br><span class=\"line\">compile 编译/execute 执行,</span><br><span class=\"line\">debug 调试/trace 跟踪</span><br><span class=\"line\">observe 观察/listen 监听,</span><br><span class=\"line\">build 构建/publish 发布</span><br><span class=\"line\">input 输入/output 输出,</span><br><span class=\"line\">encode 编码/decode 解码</span><br><span class=\"line\">encrypt 加密/decrypt 解密,</span><br><span class=\"line\">compress 压缩/decompress 解压缩</span><br><span class=\"line\">pack 打包/unpack 解包,</span><br><span class=\"line\">parse 解析/emit 生成</span><br><span class=\"line\">connect 连接/disconnect 断开,</span><br><span class=\"line\">send 发送/receive 接收</span><br><span class=\"line\">download 下载/upload 上传,</span><br><span class=\"line\">refresh 刷新/synchronize 同步</span><br><span class=\"line\">update 更新/revert 复原,</span><br><span class=\"line\">lock 锁定/unlock 解锁</span><br><span class=\"line\">check out 签出/check in 签入,</span><br><span class=\"line\">submit 提交/commit 交付</span><br><span class=\"line\">push 推/pull 拉,</span><br><span class=\"line\">expand 展开/collapse 折叠</span><br><span class=\"line\">begin 起始/end 结束,</span><br><span class=\"line\">start 开始/finish 完成</span><br><span class=\"line\">enter 进入/exit 退出,</span><br><span class=\"line\">abort 放弃/quit 离开</span><br><span class=\"line\">obsolete 废弃/depreciate 废旧,</span><br><span class=\"line\">collect 收集/aggregate 聚集</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>正例： <code>MAX_STOCK_COUNT</code></li>\n</ol>\n<p>反例： <code>MAX_COUNT</code></p>\n<h4 id=\"1-5-2-代码格式\"><a href=\"#1-5-2-代码格式\" class=\"headerlink\" title=\"1.5.2 代码格式\"></a>1.5.2 代码格式</h4><ol>\n<li>使用 2 个空格进行缩进<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (x &lt; y) &#123;</span><br><span class=\"line\">  x += 10;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  x += 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。<br>说明：任何情形，没有必要插入多个空行进行隔开。</li>\n</ol>\n<h4 id=\"1-5-3-字符串\"><a href=\"#1-5-3-字符串\" class=\"headerlink\" title=\"1.5.3 字符串\"></a>1.5.3 字符串</h4><p>统一使用单引号(‘’)，不使用双引号(“”)。这在创建 HTML 字符串非常有好处：</p>\n<p>正例:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let str = &#x27;foo&#x27;;</span><br><span class=\"line\">let testDiv = &#x27;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p>反例:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let str = &quot;foo&quot;;</span><br><span class=\"line\">let testDiv = &quot;&lt;div id=&#x27;test&#x27;&gt;&lt;/div&gt;&quot;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-5-4-对象声明\"><a href=\"#1-5-4-对象声明\" class=\"headerlink\" title=\"1.5.4 对象声明\"></a>1.5.4 对象声明</h4><p>1)使用字面值创建对象<br>正例：<code> let user = &#123;&#125;;</code></p>\n<p>反例： <code>let user = new Object();</code></p>\n<ol start=\"2\">\n<li>使用字面量来代替对象构造器<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var user = &#123;</span><br><span class=\"line\">  age: 0,</span><br><span class=\"line\">  name: 1,</span><br><span class=\"line\">  city: 3</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var user = new Object();</span><br><span class=\"line\">user.age = 0;</span><br><span class=\"line\">user.name = 0;</span><br><span class=\"line\">user.city = 0;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-5-5-使用-ES6-7\"><a href=\"#1-5-5-使用-ES6-7\" class=\"headerlink\" title=\"1.5.5 使用 ES6,7\"></a>1.5.5 使用 ES6,7</h4><p>必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</p>\n<p>必须强制使用 ES6, ES7 的新语法，比如箭头函数、await&#x2F;async ， 解构， let ， for…of 等等</p>\n<h4 id=\"1-5-6-括号\"><a href=\"#1-5-6-括号\" class=\"headerlink\" title=\"1.5.6 括号\"></a>1.5.6 括号</h4><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。</p>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (condition) &#123;</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (condition) doSomething();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-5-7-undefined-判断\"><a href=\"#1-5-7-undefined-判断\" class=\"headerlink\" title=\"1.5.7 undefined 判断\"></a>1.5.7 undefined 判断</h4><p>永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。</p>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (typeof person === &#x27;undefined&#x27;) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (person === undefined) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-5-8-条件判断和循环最多三层\"><a href=\"#1-5-8-条件判断和循环最多三层\" class=\"headerlink\" title=\"1.5.8 条件判断和循环最多三层\"></a>1.5.8 条件判断和循环最多三层</h4><p>条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。</p>\n<h4 id=\"1-5-9-this-的转换命名\"><a href=\"#1-5-9-this-的转换命名\" class=\"headerlink\" title=\"1.5.9 this 的转换命名\"></a>1.5.9 this 的转换命名</h4><p>对上下文 this 的引用只能使用’self’来命名</p>\n<h4 id=\"1-5-10-慎用-console-log\"><a href=\"#1-5-10-慎用-console-log\" class=\"headerlink\" title=\"1.5.10 慎用 console.log\"></a>1.5.10 慎用 console.log</h4><p>因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能</p>\n<h2 id=\"二、Vue-项目规范\"><a href=\"#二、Vue-项目规范\" class=\"headerlink\" title=\"二、Vue 项目规范\"></a>二、Vue 项目规范</h2><h3 id=\"一-Vue-编码基础\"><a href=\"#一-Vue-编码基础\" class=\"headerlink\" title=\"(一) Vue 编码基础\"></a>(一) Vue 编码基础</h3><p>vue 项目规范以 Vue 官方规范 （<a href=\"https://cn.vuejs.org/v2/style-guide/%EF%BC%89\">https://cn.vuejs.org/v2/style-guide/）</a> 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</p>\n<p>请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</p>\n<h4 id=\"2-1-1-组件规范\"><a href=\"#2-1-1-组件规范\" class=\"headerlink\" title=\"2.1.1. 组件规范\"></a>2.1.1. 组件规范</h4><ol>\n<li>组件名为多个单词。<br>组件名应该始终是多个单词组成（大于等于 2），且命名规范为 KebabCase 格式。<br>这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</li>\n</ol>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;TodoItem&#x27;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;Todo&#x27;,</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;todo-item&#x27;,</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>组件文件名为 pascal-case 格式<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- my-component.vue</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- myComponent.vue</span><br><span class=\"line\">|- MyComponent.vue</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>基础组件文件名为 base 开头，使用完整单词而不是缩写。<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- base-button.vue</span><br><span class=\"line\">|- base-table.vue</span><br><span class=\"line\">|- base-icon.vue</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- MyButton.vue</span><br><span class=\"line\">|- VueTable.vue</span><br><span class=\"line\">|- Icon.vue</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- todo-list.vue</span><br><span class=\"line\">|- todo-list-item.vue</span><br><span class=\"line\">|- todo-list-item-button.vue</span><br><span class=\"line\">|- user-profile-options.vue （完整单词）</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- TodoList.vue</span><br><span class=\"line\">|- TodoItem.vue</span><br><span class=\"line\">|- TodoButton.vue</span><br><span class=\"line\">|- UProfOpts.vue （使用了缩写）</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span><br><span class=\"line\">&lt;MyComponent /&gt;</span><br><span class=\"line\">&lt;Row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/Row&gt;</span><br><span class=\"line\">反例：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;my-component /&gt; &lt;row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/row&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>组件的 data 必须是一个函数<br>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。</li>\n</ol>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      name: &#x27;jack&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    name: &#x27;jack&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>Prop 定义应该尽量详细</li>\n</ol>\n<ul>\n<li>必须使用 camelCase 驼峰命名</li>\n<li>必须指定类型</li>\n<li>必须加上注释，表明其含义</li>\n<li>必须加上 required 或者 default，两者二选其一</li>\n<li>如果有业务需要，必须加上 validator 验证<br>正例：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">  // 组件状态，用于控制组件的颜色</span><br><span class=\"line\">   status: &#123;</span><br><span class=\"line\">     type: String,</span><br><span class=\"line\">     required: true,</span><br><span class=\"line\">     validator: function (value) &#123;</span><br><span class=\"line\">       return [</span><br><span class=\"line\">         &#x27;succ&#x27;,</span><br><span class=\"line\">         &#x27;info&#x27;,</span><br><span class=\"line\">         &#x27;error&#x27;</span><br><span class=\"line\">       ].indexOf(value) !== -1</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">    // 用户级别，用于显示皇冠个数</span><br><span class=\"line\">   userLevel：&#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>为组件样式设置作用域<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 使用 `scoped` 特性 --&gt;</span><br><span class=\"line\">&lt;style scoped&gt;</span><br><span class=\"line\">  .btn-close &#123;</span><br><span class=\"line\">    background-color: red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;!-- 没有使用 `scoped` 特性 --&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  .btn-close &#123;</span><br><span class=\"line\">    background-color: red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li>如果特性元素较多，应该主动换行。<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class=\"line\">    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class=\"line\">    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class=\"line\"> /&gt;</span><br><span class=\"line\">反例：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-2-模板中使用简单的表达式\"><a href=\"#2-1-2-模板中使用简单的表达式\" class=\"headerlink\" title=\"2.1.2. 模板中使用简单的表达式\"></a>2.1.2. 模板中使用简单的表达式</h4><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; normalizedFullName &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 复杂表达式已经移入一个计算属性</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  normalizedFullName: function () &#123;</span><br><span class=\"line\">    return this.fullName.split(&#x27; &#x27;).map(function (word) &#123;</span><br><span class=\"line\">      return word[0].toUpperCase() + word.slice(1)</span><br><span class=\"line\">    &#125;).join(&#x27; &#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;p&gt;</span><br><span class=\"line\">       &#123;&#123;</span><br><span class=\"line\">          fullName.split(&#x27; &#x27;).map(function (word) &#123;</span><br><span class=\"line\">             return word[0].toUpperCase() + word.slice(1)</span><br><span class=\"line\">           &#125;).join(&#x27; &#x27;)</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">  &lt;/p&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-3-指令都使用缩写形式\"><a href=\"#2-1-3-指令都使用缩写形式\" class=\"headerlink\" title=\"2.1.3 指令都使用缩写形式\"></a>2.1.3 指令都使用缩写形式</h4><p>指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)</p>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  @input=&quot;onInput&quot;</span><br><span class=\"line\">  @focus=&quot;onFocus&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  v-on:input=&quot;onInput&quot;</span><br><span class=\"line\">  @focus=&quot;onFocus&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-4-标签顺序保持一致\"><a href=\"#2-1-4-标签顺序保持一致\" class=\"headerlink\" title=\"2.1.4 标签顺序保持一致\"></a>2.1.4 标签顺序保持一致</h4><p>单文件组件应该总是让标签顺序保持为 &#96;</p>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;...&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;...&lt;/script&gt;</span><br><span class=\"line\">&lt;style&gt;...&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;...&lt;/template&gt;</span><br><span class=\"line\">&lt;style&gt;...&lt;/style&gt;</span><br><span class=\"line\">&lt;script&gt;...&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-5-必须为-v-for-设置键值-key\"><a href=\"#2-1-5-必须为-v-for-设置键值-key\" class=\"headerlink\" title=\"2.1.5 必须为 v-for 设置键值 key\"></a>2.1.5 必须为 v-for 设置键值 key</h4><h4 id=\"2-1-6-v-show-与-v-if-选择\"><a href=\"#2-1-6-v-show-与-v-if-选择\" class=\"headerlink\" title=\"2.1.6 v-show 与 v-if 选择\"></a>2.1.6 v-show 与 v-if 选择</h4><p>如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</p>\n<h4 id=\"2-1-7-script-标签内部结构顺序\"><a href=\"#2-1-7-script-标签内部结构顺序\" class=\"headerlink\" title=\"2.1.7 script 标签内部结构顺序\"></a>2.1.7 script 标签内部结构顺序</h4><p>components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</p>\n<h4 id=\"2-1-8-Vue-Router-规范\"><a href=\"#2-1-8-Vue-Router-规范\" class=\"headerlink\" title=\"2.1.8 Vue Router 规范\"></a>2.1.8 Vue Router 规范</h4><ol>\n<li>页面跳转数据传递使用路由参数<br>页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。</li>\n</ol>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let id = &#x27;123&#x27;;</span><br><span class=\"line\">this.$router.push(&#123; name: &#x27;userCenter&#x27;, query: &#123; id: id &#125; &#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用路由懒加载（延迟加载）机制</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path: &#x27;/uploadAttachment&#x27;,</span><br><span class=\"line\">    name: &#x27;uploadAttachment&#x27;,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &#x27;上传附件&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    component: () =&gt; import(&#x27;@/view/components/uploadAttachment/index.vue&#x27;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>router 中的命名规范<br>path、childrenPoints 命名规范采用 kebab-case 命名规范（尽量 vue 文件的目录结构保持一致，因为目录、文件名都是 kebab-case，这样很方便找到对应的文件）</li>\n</ol>\n<p>name 命名规范采用 KebabCase 命名规范且和 component 组件名保持一致！（因为要保持 keep-alive 特性，keep-alive 按照 component 的 name 进行缓存，所以两者必须高度保持一致）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 动态加载</span><br><span class=\"line\">export const reload = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/reload&#x27;,</span><br><span class=\"line\">    name: &#x27;reload&#x27;,</span><br><span class=\"line\">    component: Main,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &#x27;动态加载&#x27;,</span><br><span class=\"line\">      icon: &#x27;icon iconfont&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;/reload/smart-reload-list&#x27;,</span><br><span class=\"line\">        name: &#x27;SmartReloadList&#x27;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &#x27;SmartReload&#x27;,</span><br><span class=\"line\">          childrenPoints: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              title: &#x27;查询&#x27;,</span><br><span class=\"line\">              name: &#x27;smart-reload-search&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              title: &#x27;执行reload&#x27;,</span><br><span class=\"line\">              name: &#x27;smart-reload-update&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              title: &#x27;查看执行结果&#x27;,</span><br><span class=\"line\">              name: &#x27;smart-reload-result&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        component: () =&gt;</span><br><span class=\"line\">          import(&#x27;@/views/reload/smart-reload/smart-reload-list.vue&#x27;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>router 中的 path 命名规范<br>path 除了采用 kebab-case 命名规范以外，必须以 &#x2F; 开头，即使是 children 里的 path 也要以 &#x2F; 开头。如下示例</li>\n</ol>\n<p>目的：</p>\n<p>经常有这样的场景：某个页面有问题，要立刻找到这个 vue 文件，如果不用以&#x2F;开头，path 为 parent 和 children 组成的，可能经常需要在 router 文件里搜索多次才能找到，而如果以&#x2F;开头，则能立刻搜索到对应的组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path: &#x27;/file&#x27;,</span><br><span class=\"line\">    name: &#x27;File&#x27;,</span><br><span class=\"line\">    component: Main,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &#x27;文件服务&#x27;,</span><br><span class=\"line\">      icon: &#x27;ios-cloud-upload&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;/file/file-list&#x27;,</span><br><span class=\"line\">        name: &#x27;FileList&#x27;,</span><br><span class=\"line\">        component: () =&gt; import(&#x27;@/views/file/file-list.vue&#x27;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;/file/file-add&#x27;,</span><br><span class=\"line\">        name: &#x27;FileAdd&#x27;,</span><br><span class=\"line\">        component: () =&gt; import(&#x27;@/views/file/file-add.vue&#x27;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;/file/file-update&#x27;,</span><br><span class=\"line\">        name: &#x27;FileUpdate&#x27;,</span><br><span class=\"line\">        component: () =&gt; import(&#x27;@/views/file/file-update.vue&#x27;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二-Vue-项目目录规范\"><a href=\"#二-Vue-项目目录规范\" class=\"headerlink\" title=\"(二) Vue 项目目录规范\"></a>(二) Vue 项目目录规范</h3><h4 id=\"2-2-1-基础\"><a href=\"#2-2-1-基础\" class=\"headerlink\" title=\"2.2.1 基础\"></a>2.2.1 基础</h4><p>vue 项目中的所有命名一定要与后端命名统一。</p>\n<p>比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！</p>\n<h4 id=\"2-2-2-使用-Vue-cli-脚手架\"><a href=\"#2-2-2-使用-Vue-cli-脚手架\" class=\"headerlink\" title=\"2.2.2 使用 Vue-cli 脚手架\"></a>2.2.2 使用 Vue-cli 脚手架</h4><p>使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。</p>\n<h4 id=\"2-2-3-目录说明\"><a href=\"#2-2-3-目录说明\" class=\"headerlink\" title=\"2.2.3 目录说明\"></a>2.2.3 目录说明</h4><p>目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">src                               源码目录</span><br><span class=\"line\">|-- api                              所有api接口</span><br><span class=\"line\">|-- assets                           静态资源，images, icons, styles等</span><br><span class=\"line\">|-- components                       公用组件</span><br><span class=\"line\">|-- config                           配置信息</span><br><span class=\"line\">|-- constants                        常量信息，项目所有Enum, 全局常量等</span><br><span class=\"line\">|-- directives                       自定义指令</span><br><span class=\"line\">|-- filters                          过滤器，全局工具</span><br><span class=\"line\">|-- datas                            模拟数据，临时存放</span><br><span class=\"line\">|-- lib                              外部引用的插件存放及修改文件</span><br><span class=\"line\">|-- mock                             模拟接口，临时存放</span><br><span class=\"line\">|-- plugins                          插件，全局使用</span><br><span class=\"line\">|-- router                           路由，统一管理</span><br><span class=\"line\">|-- store                            vuex, 统一管理</span><br><span class=\"line\">|-- themes                           自定义样式主题</span><br><span class=\"line\">|-- views                            视图目录</span><br><span class=\"line\">|   |-- role                             role模块名</span><br><span class=\"line\">|   |-- |-- role-list.vue                    role列表页面</span><br><span class=\"line\">|   |-- |-- role-add.vue                     role新建页面</span><br><span class=\"line\">|   |-- |-- role-update.vue                  role更新页面</span><br><span class=\"line\">|   |-- |-- index.less                      role模块样式</span><br><span class=\"line\">|   |-- |-- components                      role模块通用组件文件夹</span><br><span class=\"line\">|   |-- employee                         employee模块</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>api 目录</li>\n</ol>\n<ul>\n<li>文件、变量命名要与后端保持一致。</li>\n<li>此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。</li>\n<li>api 中的方法名字要与后端 api url 尽量保持语义高度一致性。</li>\n<li>对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。<br>正例：</li>\n</ul>\n<p>后端 url： EmployeeController.java</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/employee/add</span><br><span class=\"line\">/employee/delete/&#123;id&#125;</span><br><span class=\"line\">/employee/update</span><br></pre></td></tr></table></figure>\n\n<p>前端： employee.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 添加员工</span><br><span class=\"line\">addEmployee: (data) =&gt; &#123;</span><br><span class=\"line\">    return postAxios(&#x27;/employee/add&#x27;, data)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 更新员工信息</span><br><span class=\"line\">updateEmployee: (data) =&gt; &#123;</span><br><span class=\"line\">    return postAxios(&#x27;/employee/update&#x27;, data)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 删除员工</span><br><span class=\"line\">deleteEmployee: (employeeId) =&gt; &#123;</span><br><span class=\"line\">    return postAxios(&#x27;/employee/delete/&#x27; + employeeId)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>assets 目录<br>assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|assets</span><br><span class=\"line\">|-- icons</span><br><span class=\"line\">|-- images</span><br><span class=\"line\">|   |-- background-color.png</span><br><span class=\"line\">|   |-- upload-header.png</span><br><span class=\"line\">|-- styles</span><br><span class=\"line\">3) components 目录</span><br><span class=\"line\">此目录应按照组件进行目录划分，目录命名为 KebabCase，组件命名规则也为 KebabCase</span><br><span class=\"line\"></span><br><span class=\"line\">|components</span><br><span class=\"line\">|-- error-log</span><br><span class=\"line\">|   |-- index.vue</span><br><span class=\"line\">|   |-- index.less</span><br><span class=\"line\">|-- markdown-editor</span><br><span class=\"line\">|   |-- index.vue</span><br><span class=\"line\">|   |-- index.js</span><br><span class=\"line\">|-- kebab-case</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>constants 目录<br>此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件(<a href=\"https://www.npmjs.com/package/vue-enum\">https://www.npmjs.com/package/vue-enum</a>)</li>\n</ol>\n<p>目录结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|constants</span><br><span class=\"line\">|-- index.js</span><br><span class=\"line\">|-- role.js</span><br><span class=\"line\">|-- employee.js</span><br></pre></td></tr></table></figure>\n\n<p>例子： employee.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export const EMPLOYEE_STATUS = &#123;</span><br><span class=\"line\">  NORMAL: &#123;</span><br><span class=\"line\">    value: 1,</span><br><span class=\"line\">    desc: &#x27;正常&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  DISABLED: &#123;</span><br><span class=\"line\">    value: 1,</span><br><span class=\"line\">    desc: &#x27;禁用&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  DELETED: &#123;</span><br><span class=\"line\">    value: 2,</span><br><span class=\"line\">    desc: &#x27;已删除&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const EMPLOYEE_ACCOUNT_TYPE = &#123;</span><br><span class=\"line\">  QQ: &#123;</span><br><span class=\"line\">    value: 1,</span><br><span class=\"line\">    desc: &#x27;QQ登录&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  WECHAT: &#123;</span><br><span class=\"line\">    value: 2,</span><br><span class=\"line\">    desc: &#x27;微信登录&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  DINGDING: &#123;</span><br><span class=\"line\">    value: 3,</span><br><span class=\"line\">    desc: &#x27;钉钉登录&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  USERNAME: &#123;</span><br><span class=\"line\">    value: 4,</span><br><span class=\"line\">    desc: &#x27;用户名密码登录&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  EMPLOYEE_STATUS,</span><br><span class=\"line\">  EMPLOYEE_ACCOUNT_TYPE</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>router 与 store 目录<br>这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。</li>\n</ol>\n<p>router 尽量按照 views 中的结构保持一致</p>\n<p>store 按照业务进行拆分不同的 js 文件</p>\n<ol start=\"6\">\n<li>views 目录</li>\n</ol>\n<ul>\n<li>命名要与后端、router、api 等保持一致</li>\n<li>components 中组件要使用 PascalCase 规则</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|-- views                            视图目录</span><br><span class=\"line\">|   |-- role                             role模块名</span><br><span class=\"line\">|   |   |-- role-list.vue                    role列表页面</span><br><span class=\"line\">|   |   |-- role-add.vue                     role新建页面</span><br><span class=\"line\">|   |   |-- role-update.vue                  role更新页面</span><br><span class=\"line\">|   |   |-- index.less                      role模块样式</span><br><span class=\"line\">|   |   |-- components                      role模块通用组件文件夹</span><br><span class=\"line\">|   |   |   |-- role-header.vue                        role头部组件</span><br><span class=\"line\">|   |   |   |-- role-modal.vue                         role弹出框组件</span><br><span class=\"line\">|   |-- employee                         employee模块</span><br><span class=\"line\">|   |-- behavior-log                      行为日志log模块</span><br><span class=\"line\">|   |-- code-generator                    代码生成器模块</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-4-注释说明\"><a href=\"#2-2-4-注释说明\" class=\"headerlink\" title=\"2.2.4 注释说明\"></a>2.2.4 注释说明</h4><p>整理必须加注释的地方</p>\n<ul>\n<li>公共组件使用说明</li>\n<li>api 目录的接口 js 文件必须加注释</li>\n<li>store 中的 state, mutation, action 等必须加注释</li>\n<li>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释</li>\n<li>vue 文件的 methods，每个 method 必须添加注释</li>\n<li>vue 文件的 data, 非常见单词要加注释</li>\n</ul>\n<h4 id=\"2-2-5-其他\"><a href=\"#2-2-5-其他\" class=\"headerlink\" title=\"2.2.5 其他\"></a>2.2.5 其他</h4><ol>\n<li><p>尽量不要手动操作 DOM<br>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。</p>\n</li>\n<li><p>删除无用代码<br>因使用了 git&#x2F;svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p>\n</li>\n</ol>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"封装一个autoTry函数，指定错误情况下重复执行次数，最终返回结果","url":"/2022/10/24/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAautoTry%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8C%87%E5%AE%9A%E9%94%99%E8%AF%AF%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E6%AC%A1%E6%95%B0%EF%BC%8C%E6%9C%80%E7%BB%88%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/","content":"<h2 id=\"一、封装-autoTry-函数\"><a href=\"#一、封装-autoTry-函数\" class=\"headerlink\" title=\"一、封装 autoTry 函数\"></a>一、封装 autoTry 函数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo(params) &#123;</span><br><span class=\"line\">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            JSON.parse(&#x27;&#123;&#123;&#x27;);</span><br><span class=\"line\">            return resolve(params);</span><br><span class=\"line\">          &#125; catch (e) &#123;</span><br><span class=\"line\">            return reject(e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;, 1000);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ========doing======</span><br><span class=\"line\">    function autoTry(fn, times) &#123;</span><br><span class=\"line\">      const retry = (params) =&gt; new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        fn(params).then(</span><br><span class=\"line\">          (response) =&gt; &#123; resolve(response) &#125;</span><br><span class=\"line\">        ).catch(e =&gt; &#123;</span><br><span class=\"line\">          console.log(&#x27;retrying: &#x27; + new Date(), e)</span><br><span class=\"line\">          if (times &gt; 1) &#123;</span><br><span class=\"line\">            times -= 1</span><br><span class=\"line\">            retry()</span><br><span class=\"line\">          &#125; else &#123; reject(e) &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      return retry</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ========test======</span><br><span class=\"line\">    func = autoTry(foo, 3);</span><br><span class=\"line\">    func(&#123; a: 1, b: 2 &#125;).then((res) =&gt; &#123;</span><br><span class=\"line\">      console.log(`结果：$&#123;JSON.stringify(res)&#125;`);</span><br><span class=\"line\">    &#125;, (error) =&gt; &#123;</span><br><span class=\"line\">      console.log(error)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、一个-n-个大小写字母组成的字符串按-ascii-码从小到大排序-查找字符串中第-k-个最小-ascii-码的字母输出该字母所在字符串位置索引\"><a href=\"#二、一个-n-个大小写字母组成的字符串按-ascii-码从小到大排序-查找字符串中第-k-个最小-ascii-码的字母输出该字母所在字符串位置索引\" class=\"headerlink\" title=\"二、一个 n 个大小写字母组成的字符串按 ascii 码从小到大排序 查找字符串中第 k 个最小 ascii 码的字母输出该字母所在字符串位置索引\"></a>二、一个 n 个大小写字母组成的字符串按 ascii 码从小到大排序 查找字符串中第 k 个最小 ascii 码的字母输出该字母所在字符串位置索引</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function lookup(str,key)&#123;</span><br><span class=\"line\">  if(typeof str !=&#x27;string&#x27;||key&lt;1)return -1;</span><br><span class=\"line\">  let value = str.split(&quot;&quot;).sort()[key-1];</span><br><span class=\"line\">  return str.indexOf(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(lookup(&#x27;asasdskdjdfgnsdkfnmsASDdf&#x27;,5)+1)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let getIndexChar = (str,index)=&gt;&#123;</span><br><span class=\"line\">    let sortChar = []</span><br><span class=\"line\">    for(let i=0;i&lt;str.length;i++) &#123;</span><br><span class=\"line\">        sortChar.push(str.charCodeAt(i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortChar = sortChar.sort((a,b)=&gt;&#123;</span><br><span class=\"line\">        return a-b</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    let indexCode = -1</span><br><span class=\"line\">    for(let i=0;i&lt;str.length;i++) &#123;</span><br><span class=\"line\">        if(str[i].charCodeAt(0)==sortChar[index]) &#123;</span><br><span class=\"line\">            indexCode = i</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return indexCode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getIndexChar(&#x27;asdEQW&#x27;,1) //4</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、ts-工具函数\"><a href=\"#三、ts-工具函数\" class=\"headerlink\" title=\"三、ts 工具函数\"></a>三、ts 工具函数</h2><p><strong>1、实现一个 ts 的工具函数 GetOnlyFnProps<T> ，提取泛型类型 T 中字段类型是函数的工具函数，其中 T 属于一个对象。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type GetOnlyFnKeys&lt;T extends object&gt; = &#123;</span><br><span class=\"line\"> [Key in keyof T]: T[K] extends Function ? K : never</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type GetOnlyFnProps&lt;T extends object&gt; = &#123;</span><br><span class=\"line\"> [K in GetOnlyFnKeys&lt;T&gt;]: T[K]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现一个 ts 的工具函数 UnGenericPromise<T> ，提取 Promise 中的泛型类型</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type UnGenericPromise&lt;T extends Promise&lt;any&gt;&gt; = T extends Promise&lt;infer U&gt; ? U : never</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、分页加载\"><a href=\"#四、分页加载\" class=\"headerlink\" title=\"四、分页加载\"></a>四、分页加载</h2><p><strong>h5_demo</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123;PREFIX_URL ,request ,TITLE&#125; from &#x27;../../common&#x27;;</span><br><span class=\"line\">import DetailedList from &quot;../../components/movie/DetailedListComponent&quot;;</span><br><span class=\"line\">import Loading from &#x27;../../components/common/LoadingComponent&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const PS = 5;</span><br><span class=\"line\">class FilmList extends Component &#123;</span><br><span class=\"line\">    constructor(...args) &#123;</span><br><span class=\"line\">        super(...args);</span><br><span class=\"line\">        document.title = &#x27;艾米电影推荐&#x27;;</span><br><span class=\"line\">        this.stgId = localStorage.getItem(&quot;stgId&quot;) || &quot;&quot;;</span><br><span class=\"line\">        this.id = this.props.match.params.id;</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            listData: &quot;&quot;,</span><br><span class=\"line\">            page: 1,</span><br><span class=\"line\">            pageSize: PS,</span><br><span class=\"line\">            hasMore: false,</span><br><span class=\"line\">            desc:&#x27;&#x27;,</span><br><span class=\"line\">            loading:true,</span><br><span class=\"line\">            display:&#x27;none&#x27;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async componentWillMount() &#123;</span><br><span class=\"line\">        // console.log(&quot;片单ID--&gt;&quot;, this.id);</span><br><span class=\"line\">        await this.getList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async getList(page=1) &#123;</span><br><span class=\"line\">        let url = `$&#123;PREFIX_URL&#125;movie_client/list`+</span><br><span class=\"line\">            `?stgId=$&#123;this.stgId&#125;&amp;movieListId=$&#123;this.id&#125;&amp;page=$&#123;page&#125;&amp;pageSize=$&#123;this.state.pageSize&#125;`;</span><br><span class=\"line\">        let res = await request(url);</span><br><span class=\"line\">        if (res &amp;&amp; res.success) &#123;</span><br><span class=\"line\">            document.title = res.title;</span><br><span class=\"line\">            let listData = &quot;&quot;;</span><br><span class=\"line\">            if (page === 1) &#123;</span><br><span class=\"line\">                listData = res.data;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                listData = this.state.listData;</span><br><span class=\"line\">                listData = listData.concat(res.data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            await this.setState(&#123;</span><br><span class=\"line\">                listData,</span><br><span class=\"line\">                loading:false,</span><br><span class=\"line\">                display:&#x27;block&#x27;,</span><br><span class=\"line\">                desc:res.desc,</span><br><span class=\"line\">                page:res.page.current,</span><br><span class=\"line\">                hasMore: res.page.current &lt; res.page.pages</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async componentWillUnmount () &#123;</span><br><span class=\"line\">        document.title = TITLE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async refresh () &#123;</span><br><span class=\"line\">        await this.setState(&#123;page: 1&#125;);</span><br><span class=\"line\">        await this.getList(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async loadMore() &#123;</span><br><span class=\"line\">        await this.setState(&#123;page: this.state.page + 1&#125;);</span><br><span class=\"line\">        await this.getList(this.state.page);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;page-movie-detailed-list&quot;&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    !!this.state.listData &amp;&amp;</span><br><span class=\"line\">                    &lt;DetailedList</span><br><span class=\"line\">                        refresh=&#123;this.refresh.bind(this)&#125;</span><br><span class=\"line\">                        loadMore=&#123;this.loadMore.bind(this)&#125;</span><br><span class=\"line\">                        hasMore=&#123;this.state.hasMore&#125;</span><br><span class=\"line\">                        listData=&#123;this.state.listData&#125;</span><br><span class=\"line\">                        desc=&#123;this.state.desc&#125;</span><br><span class=\"line\">                        style=&#123;&#123;&#x27;display&#x27;:this.state.display&#125;&#125;/&gt;&#125;</span><br><span class=\"line\">                &#123;this.state.loading ? &lt;Loading/&gt; : &#x27;&#x27; &#125;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FilmList;</span><br></pre></td></tr></table></figure>\n\n<p><strong>PC_demo</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; Button, Col, message as Message, Row, Icon &#125; from &#x27;antd&#x27;</span><br><span class=\"line\">import &#123; Link &#125; from &#x27;react-router-dom&#x27;</span><br><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\">import MessageListFilter, &#123; IMessageListFilter &#125; from &#x27;./components/MessageListFilter&#x27;</span><br><span class=\"line\">import MessageListTable from &#x27;./components/MessageListTable&#x27;</span><br><span class=\"line\">import MessageService from &#x27;../../../service/driverManage/MessageService&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class MessageList extends React.Component &#123;</span><br><span class=\"line\">  // public constructor(props: any)&#123;</span><br><span class=\"line\">  //   super(props)</span><br><span class=\"line\">  // &#125;</span><br><span class=\"line\">  public state = &#123;</span><br><span class=\"line\">    filterProps: &#123;</span><br><span class=\"line\">      filter: &#123;</span><br><span class=\"line\">        beginCreatedTime: &#x27;&#x27;,</span><br><span class=\"line\">        endCreatedTime: &#x27;&#x27;, // 日期</span><br><span class=\"line\">        sendStatus: &#x27;-1&#x27;, //发送状态</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    tableProps: &#123;</span><br><span class=\"line\">      page: &#123;</span><br><span class=\"line\">        current: 1,</span><br><span class=\"line\">        pageSize: 10,</span><br><span class=\"line\">        total: 0,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      data: [],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    searching: false,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public componentDidMount() &#123;</span><br><span class=\"line\">    this.reSearch()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public filterChange = (params: IMessageListFilter) =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      filterProps: &#123;</span><br><span class=\"line\">        filter: &#123;</span><br><span class=\"line\">          ...this.state.filterProps.filter,</span><br><span class=\"line\">          ...params,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public search = async () =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      searching: true,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    const &#123; code, message, data &#125; = await MessageService.pageMessageList(&#123;</span><br><span class=\"line\">      ...this.state.filterProps.filter,</span><br><span class=\"line\">      ...&#123;</span><br><span class=\"line\">        sendStatus:</span><br><span class=\"line\">          this.state.filterProps.filter.sendStatus !== &#x27;-1&#x27;</span><br><span class=\"line\">            ? this.state.filterProps.filter.sendStatus</span><br><span class=\"line\">            : null,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pageNum: this.state.tableProps.page.current,</span><br><span class=\"line\">      pageSize: this.state.tableProps.page.pageSize,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      searching: false,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    if (code !== 200) &#123;</span><br><span class=\"line\">      Message.error(message)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const &#123; current, pageSize &#125; = this.state.tableProps.page</span><br><span class=\"line\">    let rows = []</span><br><span class=\"line\">    rows =</span><br><span class=\"line\">      data.rows &amp;&amp; data.rows.length</span><br><span class=\"line\">        ? data.rows.map((item: any, index: number) =&gt; &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">              ...item,</span><br><span class=\"line\">              num: (current - 1) * pageSize + index + 1,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        : []</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      tableProps: &#123;</span><br><span class=\"line\">        page: &#123;</span><br><span class=\"line\">          ...this.state.tableProps.page,</span><br><span class=\"line\">          total: data.total,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data: rows,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public reSearch = () =&gt; &#123;</span><br><span class=\"line\">    const &#123; tableProps &#125; = this.state</span><br><span class=\"line\">    const &#123;</span><br><span class=\"line\">      page: &#123; pageSize, total &#125;,</span><br><span class=\"line\">    &#125; = tableProps</span><br><span class=\"line\"></span><br><span class=\"line\">    this.setState(</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        tableProps: &#123;</span><br><span class=\"line\">          ...tableProps,</span><br><span class=\"line\">          page: &#123;</span><br><span class=\"line\">            pageSize,</span><br><span class=\"line\">            total,</span><br><span class=\"line\">            current: 1,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      () =&gt; &#123;</span><br><span class=\"line\">        this.search()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public pageChange = (page: object) =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      tableProps: &#123;</span><br><span class=\"line\">        ...this.state.tableProps,</span><br><span class=\"line\">        page,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    this.search()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public getDetail = (params: any) =&gt; &#123;</span><br><span class=\"line\">    ;(this.props as any).history.push(&#x27;messageDetail&#x27;, &#123; id: 6, type: 0 &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public render() &#123;</span><br><span class=\"line\">    const &#123; filterProps, tableProps, searching &#125; = this.state</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;section&gt;</span><br><span class=\"line\">        &lt;MessageListFilter</span><br><span class=\"line\">          loading=&#123;searching&#125;</span><br><span class=\"line\">          &#123;...filterProps&#125;</span><br><span class=\"line\">          onChange=&#123;this.filterChange&#125;</span><br><span class=\"line\">          onSearch=&#123;this.reSearch&#125;</span><br><span class=\"line\">        &gt;&lt;/MessageListFilter&gt;</span><br><span class=\"line\">        &lt;Row style=&#123;&#123; marginBottom: &#x27;10px&#x27; &#125;&#125;&gt;</span><br><span class=\"line\">          &lt;Col&gt;</span><br><span class=\"line\">            &lt;Button type=&quot;primary&quot;&gt;</span><br><span class=\"line\">              &lt;Link to=&#123;`/fast/message/messageCreate`&#125;&gt;</span><br><span class=\"line\">                &lt;Icon type=&quot;plus&quot; /&gt;</span><br><span class=\"line\">                &lt;span style=&#123;&#123; marginLeft: &#x27;8px&#x27; &#125;&#125;&gt;新建推送&lt;/span&gt;</span><br><span class=\"line\">              &lt;/Link&gt;</span><br><span class=\"line\">            &lt;/Button&gt;</span><br><span class=\"line\">          &lt;/Col&gt;</span><br><span class=\"line\">        &lt;/Row&gt;</span><br><span class=\"line\">        &lt;MessageListTable</span><br><span class=\"line\">          &#123;...tableProps&#125;</span><br><span class=\"line\">          onPagechange=&#123;this.pageChange&#125;</span><br><span class=\"line\">          getDetail=&#123;this.getDetail&#125;</span><br><span class=\"line\">          onSearch=&#123;this.search&#125;</span><br><span class=\"line\">          loading=&#123;searching&#125;</span><br><span class=\"line\">        &gt;&lt;/MessageListTable&gt;</span><br><span class=\"line\">      &lt;/section&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; Button, Table, Col, Modal, message as Message &#125; from &#x27;antd&#x27;</span><br><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\">import &#123; PaginationConf &#125; from &#x27;../../../../config/antd/PaginationConf&#x27;</span><br><span class=\"line\">import &#123; Link &#125; from &#x27;react-router-dom&#x27;</span><br><span class=\"line\">import MessageService from &#x27;../../../../service/driverManage/MessageService&#x27;</span><br><span class=\"line\">export interface IMessageTable &#123;</span><br><span class=\"line\">  num: string | number</span><br><span class=\"line\">  creatTime: string</span><br><span class=\"line\">  driverName: string</span><br><span class=\"line\">  driverPhoneNum: string</span><br><span class=\"line\">  receiptType: number</span><br><span class=\"line\">  receipt: number | string</span><br><span class=\"line\">  output: number | string</span><br><span class=\"line\">  banace: number | string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export interface IProps &#123;</span><br><span class=\"line\">  data: IMessageTable[]</span><br><span class=\"line\">  page: &#123;</span><br><span class=\"line\">    current: number</span><br><span class=\"line\">    pageSize: number</span><br><span class=\"line\">    total: number</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onPagechange?: (page: &#123; current: number; pageSize: number; total: number &#125;) =&gt; void</span><br><span class=\"line\">  getDetail: (param: any) =&gt; void</span><br><span class=\"line\">  onSearch: () =&gt; void</span><br><span class=\"line\">  loading: boolean</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; confirm &#125; = Modal</span><br><span class=\"line\">class MessageListTable extends React.Component&lt;IProps&gt; &#123;</span><br><span class=\"line\">  public constructor(props: IProps) &#123;</span><br><span class=\"line\">    super(props)</span><br><span class=\"line\">    ;(this as any).columns = [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;序号&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;num&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;发送时间&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;sendTime&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;发送范围&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;sendScope&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;消息中心&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;canIntoMessageCenter&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;标题&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;title&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;操作人&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;createdBy&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;创建时间&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;createdTime&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;发送状态&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;sendStatus&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;操作&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">        render(row: any) &#123;</span><br><span class=\"line\">          return (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">              &#123;row.canCancelSend ? (</span><br><span class=\"line\">                &lt;Col&gt;</span><br><span class=\"line\">                  &lt;Button</span><br><span class=\"line\">                    type=&quot;primary&quot;</span><br><span class=\"line\">                    onClick=&#123;() =&gt; &#123;</span><br><span class=\"line\">                      cancel(row)</span><br><span class=\"line\">                    &#125;&#125;</span><br><span class=\"line\">                  &gt;</span><br><span class=\"line\">                    取消发送</span><br><span class=\"line\">                  &lt;/Button&gt;</span><br><span class=\"line\">                  &#123;new Date(row.sendTime).getTime() - new Date().getTime() &gt; 5 * 60 * 60 * 1000 ? (</span><br><span class=\"line\">                    &lt;Button type=&quot;primary&quot; style=&#123;&#123; marginLeft: &#x27;5px&#x27; &#125;&#125;&gt;</span><br><span class=\"line\">                      &lt;Link to=&#123;`/fast/message/messageUpdate/$&#123;row.id&#125;`&#125;&gt;查看&lt;/Link&gt;</span><br><span class=\"line\">                    &lt;/Button&gt;</span><br><span class=\"line\">                  ) : (</span><br><span class=\"line\">                    &lt;Button type=&quot;primary&quot; style=&#123;&#123; marginLeft: &#x27;5px&#x27; &#125;&#125;&gt;</span><br><span class=\"line\">                      &lt;Link to=&#123;`/fast/message/messageDetail/$&#123;row.id&#125;`&#125;&gt;查看&lt;/Link&gt;</span><br><span class=\"line\">                    &lt;/Button&gt;</span><br><span class=\"line\">                  )&#125;</span><br><span class=\"line\">                &lt;/Col&gt;</span><br><span class=\"line\">              ) : (</span><br><span class=\"line\">                &lt;Button type=&quot;primary&quot;&gt;</span><br><span class=\"line\">                  &lt;Link to=&#123;`/fast/message/messageDetail/$&#123;row.id&#125;`&#125;&gt;查看&lt;/Link&gt;</span><br><span class=\"line\">                &lt;/Button&gt;</span><br><span class=\"line\">              )&#125;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    function cancel(row: any) &#123;</span><br><span class=\"line\">      const &#123; onSearch &#125; = props</span><br><span class=\"line\">      if (new Date(row.sendTime).getTime() - new Date().getTime() &gt; 5 * 60 * 60 * 1000) &#123;</span><br><span class=\"line\">        confirm(&#123;</span><br><span class=\"line\">          title: &#x27;提示&#x27;,</span><br><span class=\"line\">          content: &#x27;是否确认取消&#x27;,</span><br><span class=\"line\">          async onOk() &#123;</span><br><span class=\"line\">            const &#123; code, message &#125; = await MessageService.messageCancel(row.id)</span><br><span class=\"line\">            if (code !== 200) &#123;</span><br><span class=\"line\">              Message.error(message)</span><br><span class=\"line\">              return</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Message.success(&#x27;取消成功&#x27;)</span><br><span class=\"line\">            onSearch()</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          onCancel() &#123;</span><br><span class=\"line\">            return</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        Modal.info(&#123;</span><br><span class=\"line\">          title: &#x27;提示&#x27;,</span><br><span class=\"line\">          content: &lt;div&gt;距离预计发送时间不到5分钟 禁止取消&lt;/div&gt;,</span><br><span class=\"line\">          okText: &#x27;关闭&#x27;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public render() &#123;</span><br><span class=\"line\">    const &#123; data, page, onPagechange, loading &#125; = this.props</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;section&gt;</span><br><span class=\"line\">        &lt;Table</span><br><span class=\"line\">          dataSource=&#123;data&#125;</span><br><span class=\"line\">          loading=&#123;loading&#125;</span><br><span class=\"line\">          // @ts-ignore</span><br><span class=\"line\">          columns=&#123;this.columns&#125;</span><br><span class=\"line\">          rowKey=&#123;&#x27;id&#x27;&#125;</span><br><span class=\"line\">          size=&#123;&#x27;middle&#x27;&#125;</span><br><span class=\"line\">          // scroll=&#123;&#123; x: 2500 &#125;&#125;</span><br><span class=\"line\">          pagination=&#123;&#123;</span><br><span class=\"line\">            ...PaginationConf,</span><br><span class=\"line\">            ...this.props.page,</span><br><span class=\"line\">            onChange: (toCurrent, pageSize) =&gt; &#123;</span><br><span class=\"line\">              page.current = toCurrent</span><br><span class=\"line\">              page.pageSize = pageSize as number</span><br><span class=\"line\"></span><br><span class=\"line\">              if (onPagechange) &#123;</span><br><span class=\"line\">                onPagechange(page)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            onShowSizeChange: (current, toPageSize) =&gt; &#123;</span><br><span class=\"line\">              page.current = current</span><br><span class=\"line\">              page.pageSize = toPageSize</span><br><span class=\"line\"></span><br><span class=\"line\">              if (onPagechange) &#123;</span><br><span class=\"line\">                onPagechange(page)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            showTotal: (total: number) =&gt; `共计 $&#123;total&#125; 条`,</span><br><span class=\"line\">          &#125;&#125;</span><br><span class=\"line\">        &gt;&lt;/Table&gt;</span><br><span class=\"line\">      &lt;/section&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123; MessageListTable &#125;</span><br><span class=\"line\">export default MessageListTable</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"彻底弄懂强缓存与协商缓存","url":"/2022/10/24/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/","content":"<p>在工作中，前端代码打包之后生成的静态资源就要发布到静态服务器上，这时候就要对这些静态资源做一些运维配置，其中，gzip 和设置缓存是必不可少的。这两项是最直接影响到网站性能和用户体验的。</p>\n<p>缓存的优点：</p>\n<ul>\n<li>减少了不必要的数据传输，节省带宽</li>\n<li>减少服务器的负担，提升网站性能</li>\n<li>加快了客户端加载网页的速度</li>\n<li>用户体验友好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>资源如果有更改但是客户端不及时更新会造成用户获取信息滞后，如果老版本有 bug 的话，情况会更加糟糕。</li>\n</ul>\n<p><strong>所以，为了避免设置缓存错误，掌握缓存的原理对于我们工作中去更加合理的配置缓存是非常重要的。</strong></p>\n<h2 id=\"一、强缓存\"><a href=\"#一、强缓存\" class=\"headerlink\" title=\"一、强缓存\"></a>一、强缓存</h2><p>到底什么是强缓存？强在哪？其实强是强制的意思。当浏览器去请求某个文件的时候，服务端就在 response header 里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体表现为：<br>response header 的 cache-control，常见的设置是 max-age public private no-cache no-store 等</p>\n<p>如下图,<br>设置了<strong>cache-control:max-age&#x3D;31536000,public,immutable</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6782944-2953183b0a2ab1dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/751/format/webp\" alt=\"image\"></p>\n<p>max-age 表示缓存的时间是 31536000 秒（1 年），public 表示可以被浏览器和代理服务器缓存，代理服务器一般可用 nginx 来做。immutable 表示该资源永远不变，但是实际上该资源并不是永远不变，它这么设置的意思是为了让用户在刷新页面的时候不要去请求服务器！啥意思？就是说，如果你只设置了 cache-control:max-age&#x3D;31536000,public 这属于强缓存，每次用户正常打开这个页面，浏览器会判断缓存是否过期，没有过期就从缓存中读取数据；但是有一些 “聪明” 的用户会点击浏览器左上角的刷新按钮去刷新页面，这时候就算资源没有过期（1 年没这么快过），浏览器也会直接去请求服务器，这就是额外的请求消耗了，这时候就相当于是走协商缓存的流程了（下面会讲到）。如果 cache-control:max-age&#x3D;315360000,public 再加个 immutable 的话，就算用户刷新页面，浏览器也不会发起请求去服务器，浏览器会直接从本地磁盘或者内存中读取缓存并返回 200 状态，看上图的红色框（from memory cache）。这是 2015 年 facebook 团队向制定 HTTP 标准的 IETF 工作组提到的建议：他们希望 HTTP 协议能给 Cache-Control 响应头增加一个属性字段表明该资源永不过期，浏览器就没必要再为这些资源发送条件请求了。</p>\n<h3 id=\"强缓存总结\"><a href=\"#强缓存总结\" class=\"headerlink\" title=\"强缓存总结\"></a>强缓存总结</h3><ol>\n<li><p>cache-control: max-age&#x3D;xxxx，public<br>客户端和代理服务器都可以缓存该资源；<br>客户端在 xxx 秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,status code:200 ，如果用户做了刷新操作，就向服务器发起 http 请求</p>\n</li>\n<li><p>cache-control: max-age&#x3D;xxxx，private<br>只让客户端可以缓存该资源；代理服务器不缓存<br>客户端在 xxx 秒内直接读取缓存,status code:200</p>\n</li>\n<li><p>cache-control: max-age&#x3D;xxxx，immutable<br>客户端在 xxx 秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起 http 请求</p>\n</li>\n<li><p>cache-control: no-cache<br>跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了 no-cache 就不会走强缓存了，每次请求都会询问服务端。</p>\n</li>\n<li><p>cache-control: no-store<br>不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。</p>\n</li>\n</ol>\n<h2 id=\"二、协商缓存\"><a href=\"#二、协商缓存\" class=\"headerlink\" title=\"二、协商缓存\"></a>二、协商缓存</h2><p>上面说到的强缓存就是给资源设置个过期时间，客户端每次请求资源时都会看是否过期；只有在过期才会去询问服务器。所以，强缓存就是为了给客户端自给自足用的。而当某天，客户端请求该资源时发现其过期了，这时就会去请求服务器了，而这时候去请求服务器的这过程就可以设置协商缓存。这时候，协商缓存就是需要客户端和服务器两端进行交互的。</p>\n<p><strong>怎么设置协商缓存？</strong></p>\n<p>response header 里面的设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">etag: &#x27;5c20abbd-e2e8&#x27;</span><br><span class=\"line\">last-modified: Mon, 24 Dec 2018 09:49:49 GMT</span><br></pre></td></tr></table></figure>\n\n<p>etag：每个文件有一个，改动文件了就变了，就是个文件 hash，每个文件唯一，就像用 webpack 打包的时候，每个资源都会有这个东西，如： app.js 打包后变为 app.c20abbde.js，加个唯一 hash，也是为了解决缓存问题。</p>\n<p>last-modified：文件的修改时间，精确到秒</p>\n<p>也就是说，每次请求返回来 response header 中的 etag 和 last-modified，在下次请求时在 request header 就把这两个带上，服务端把你带过来的标识进行对比，然后判断资源是否更改了，如果更改就直接返回新的资源，和更新对应的 response header 的标识 etag、last-modified。如果资源没有变，那就不变 etag、last-modified，这时候对客户端来说，每次请求都是要进行协商缓存了，即：</p>\n<p>发请求–&gt;看资源是否过期–&gt;过期–&gt;请求服务器–&gt;服务器对比资源是否真的过期–&gt;没过期–&gt;返回 304 状态码–&gt;客户端用缓存的老资源。</p>\n<p>这就是一条完整的协商缓存的过程。</p>\n<p>当然，当服务端发现资源真的过期的时候，会走如下流程：</p>\n<p>发请求–&gt;看资源是否过期–&gt;过期–&gt;请求服务器–&gt;服务器对比资源是否真的过期–&gt;过期–&gt;返回 200 状态码–&gt;客户端如第一次接收该资源一样，记下它的 cache-control 中的 max-age、etag、last-modified 等。</p>\n<p>所以协商缓存步骤总结：</p>\n<p>请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。<br>如果资源没更改，返回 304，浏览器读取本地缓存。<br>如果资源有更改，返回 200，返回最新的资源。</p>\n<p>补充一点，response header 中的 etag、last-modified 在客户端重新向服务端发起请求时，会在 request header 中换个 key 名：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// response header</span><br><span class=\"line\">etag: &#x27;5c20abbd-e2e8&#x27;</span><br><span class=\"line\">last-modified: Mon, 24 Dec 2018 09:49:49 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">// request header 变为</span><br><span class=\"line\">if-none-matched: &#x27;5c20abbd-e2e8&#x27;</span><br><span class=\"line\">if-modified-since: Mon, 24 Dec 2018 09:49:49 GMT</span><br></pre></td></tr></table></figure>\n\n<p><strong>为什么要有 etag？</strong></p>\n<p>你可能会觉得使用 last-modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 etag 呢？HTTP1.1 中 etag 的出现（也就是说，etag 是新增的，为了解决之前只有 If-Modified 的缺点）主要是为了解决几个 last-modified 比较难解决的问题：</p>\n<ol>\n<li><p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 get；</p>\n</li>\n<li><p>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，if-modified-since 能检查到的粒度是秒级的，这种修改无法判断(或者说 UNIX 记录 MIME 只能精确到秒)；</p>\n</li>\n<li><p>某些服务器不能精确的得到文件的最后修改时间。</p>\n</li>\n</ol>\n<p><strong>怎么设置强缓存与协商缓存</strong></p>\n<ol>\n<li>后端服务器如 nodejs:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">res.setHeader(&#x27;max-age&#x27;: &#x27;3600 public&#x27;)</span><br><span class=\"line\">res.setHeader(etag: &#x27;5c20abbd-e2e8&#x27;)</span><br><span class=\"line\">res.setHeader(&#x27;last-modified&#x27;: Mon, 24 Dec 2018 09:49:49 GMT)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>nginx 配置</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6782944-b8701adefe6341e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp\" alt=\"image\"></p>\n<p>偶尔自己折腾一番非前端的东西时，若心中有数，自然不会手忙脚乱。</p>\n<p><strong>怎么去用？</strong></p>\n<p>举个例子，像目前用 vue-cli 打包后生成的单页文件是有一个 html，与及一堆 js css img 资源，怎么去设置这些文件呢，核心需求是</p>\n<ol>\n<li>要有缓存，毋庸置疑</li>\n<li>当发新包的时候，要避免加载老的缓存资源</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6782944-618911ae2fbba06c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/236/format/webp\" alt=\"image\"></p>\n<p><strong>我的做法是：</strong></p>\n<p>index.html 文件采用协商缓存，理由就是要用户每次请求 index.html 不拿浏览器缓存，直接请求服务器，这样就保证资源更新了，用户能马上访问到新资源，如果服务端返回 304，这时候再拿浏览器的缓存的 index.html，<strong>切记不要设置强缓存！！！</strong></p>\n<p>其他资源采用强缓存 + 协商缓存,理由就不多说了。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"常用算法总结","url":"/2022/12/16/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","content":"<h2 id=\"迭代算法-Iteration\"><a href=\"#迭代算法-Iteration\" class=\"headerlink\" title=\"迭代算法(Iteration)\"></a>迭代算法(Iteration)</h2><h2 id=\"递归算法-Recursion\"><a href=\"#递归算法-Recursion\" class=\"headerlink\" title=\"递归算法(Recursion)\"></a>递归算法(Recursion)</h2><ul>\n<li>二叉树的遍历算法</li>\n</ul>\n<h2 id=\"回溯算法-Backtrack\"><a href=\"#回溯算法-Backtrack\" class=\"headerlink\" title=\"回溯算法(Backtrack)\"></a>回溯算法(Backtrack)</h2><ul>\n<li>八皇后问题</li>\n</ul>\n<h2 id=\"深度优先-Depth-First-Search-DFS\"><a href=\"#深度优先-Depth-First-Search-DFS\" class=\"headerlink\" title=\"深度优先(Depth First Search, DFS)\"></a>深度优先(Depth First Search, DFS)</h2><ul>\n<li>全排列问题</li>\n</ul>\n<h2 id=\"广度优先-Breadth-First-Search-BFS\"><a href=\"#广度优先-Breadth-First-Search-BFS\" class=\"headerlink\" title=\"广度优先(Breadth First Search, BFS)\"></a>广度优先(Breadth First Search, BFS)</h2><p><strong>类型</strong></p>\n<ul>\n<li>不需要确定当前深度</li>\n<li>需要确定当前深度</li>\n</ul>\n<h2 id=\"动态规划-Dynamic-Programming-DP\"><a href=\"#动态规划-Dynamic-Programming-DP\" class=\"headerlink\" title=\"动态规划(Dynamic Programming, DP)\"></a>动态规划(Dynamic Programming, DP)</h2><ul>\n<li>斐波那契数列</li>\n<li>爬楼梯问题</li>\n<li>背包问题</li>\n<li>最长公共子序列</li>\n<li>最优二叉搜索树</li>\n</ul>\n<h2 id=\"分治算法-二分法-Binary-Algorithm\"><a href=\"#分治算法-二分法-Binary-Algorithm\" class=\"headerlink\" title=\"分治算法(二分法, Binary Algorithm)\"></a>分治算法(二分法, Binary Algorithm)</h2><ul>\n<li>二分排序</li>\n<li>二分查找</li>\n</ul>\n<h2 id=\"贪心算法-Greedy-Algorithm\"><a href=\"#贪心算法-Greedy-Algorithm\" class=\"headerlink\" title=\"贪心算法(Greedy Algorithm)\"></a>贪心算法(Greedy Algorithm)</h2><ul>\n<li>霍夫曼编码</li>\n</ul>\n<h2 id=\"滑动窗口-Slipping-Window\"><a href=\"#滑动窗口-Slipping-Window\" class=\"headerlink\" title=\"滑动窗口(Slipping Window)\"></a>滑动窗口(Slipping Window)</h2><h2 id=\"双指针-Double-Pointer\"><a href=\"#双指针-Double-Pointer\" class=\"headerlink\" title=\"双指针(Double Pointer)\"></a>双指针(Double Pointer)</h2><h2 id=\"位运算-Bit\"><a href=\"#位运算-Bit\" class=\"headerlink\" title=\"位运算(Bit)\"></a>位运算(Bit)</h2><p>要点</p>\n<ul>\n<li>异或运算（xor）</li>\n<li>任何数与 0 做异或运算，结果仍为原来的数。即：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a⊕0=a</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任何数和其自身做异或运算，结果为 0。即：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a⊕a=0</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>异或运算满足交换律和结合律。即：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a⊕b=b⊕a</span><br><span class=\"line\">a⊕b⊕c=a⊕(b⊕c)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动机\"><a href=\"#自动机\" class=\"headerlink\" title=\"自动机\"></a>自动机</h2><ul>\n<li>搜索&#x2F;排序算法</li>\n<li>快速排序</li>\n<li>希尔排序</li>\n<li>插入排序</li>\n<li>拓扑排序</li>\n<li>二分排序</li>\n<li>堆排序</li>\n</ul>\n<h2 id=\"关于链表-List\"><a href=\"#关于链表-List\" class=\"headerlink\" title=\"关于链表(List)\"></a>关于链表(List)</h2><ul>\n<li>单向链表</li>\n<li>双向链表</li>\n<li>广义表</li>\n</ul>\n<h2 id=\"关于树-Tree\"><a href=\"#关于树-Tree\" class=\"headerlink\" title=\"关于树(Tree)\"></a>关于树(Tree)</h2><ul>\n<li>二叉树遍历<ul>\n<li>前序遍历</li>\n<li>中序遍历</li>\n<li>后序遍历</li>\n<li>层序遍历</li>\n</ul>\n</li>\n<li>二叉搜索树</li>\n<li>红黑树</li>\n<li>kd 树</li>\n<li>B 树</li>\n<li>堆</li>\n<li>极大堆</li>\n</ul>\n<h2 id=\"关于图-Graph\"><a href=\"#关于图-Graph\" class=\"headerlink\" title=\"关于图(Graph)\"></a>关于图(Graph)</h2><ul>\n<li>最小生成树</li>\n<li>最短路径问题</li>\n</ul>\n<h2 id=\"关于栈、队列、散列表-queue-stack-hashlist\"><a href=\"#关于栈、队列、散列表-queue-stack-hashlist\" class=\"headerlink\" title=\"关于栈、队列、散列表(queue, stack, hashlist)\"></a>关于栈、队列、散列表(queue, stack, hashlist)</h2><ul>\n<li>栈对于二叉树层序遍历的实现</li>\n<li>最大优先级队列</li>\n</ul>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"利用js实现文件上传","url":"/2022/10/24/%E5%88%A9%E7%94%A8js%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"<h2 id=\"一、前端-HTML-部分\"><a href=\"#一、前端-HTML-部分\" class=\"headerlink\" title=\"一、前端 HTML 部分\"></a>一、前端 HTML 部分</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=&#x27;main&#x27;&gt;</span><br><span class=\"line\">\t&lt;input type=&#x27;file&#x27; class=&#x27;filebutton&#x27; style=&#x27;display:none&#x27; οnchange=&#x27;fileSelected()&#x27;  /&gt; &lt;br&gt;</span><br><span class=\"line\">\t&lt;button class=&quot;upload&quot; οnclick=&#x27;openFileDialog()&#x27; &gt; 选择文件上传 &lt;/button&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;img&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、js-部分\"><a href=\"#二、js-部分\" class=\"headerlink\" title=\"二、js 部分\"></a>二、js 部分</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//点击普通按钮,打开文件选择框</span><br><span class=\"line\">function openFileDialog()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t$(&quot;.filebutton&quot;).click();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//选择一个文件时onchange事件被触发</span><br><span class=\"line\">function fileSelected()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvar fbutton = $(&quot;.filebutton&quot;)[0];//dom元素</span><br><span class=\"line\">\t//读取文件</span><br><span class=\"line\">\tvar reader = new FileReader();</span><br><span class=\"line\">\treader.onload = function(e)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvar dataURL = e.target.result;//&#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;</span><br><span class=\"line\">\t\t//alert(data);</span><br><span class=\"line\">\t\tvar htmlImg = &quot;&lt;img src = &#x27;&quot; + dataURL + &quot;&#x27;/&gt;&quot;;</span><br><span class=\"line\">    \t$(&quot;.img&quot;).html(htmlImg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvar file = fbutton.files[0];</span><br><span class=\"line\">\treader.readAsDataURL(file);</span><br><span class=\"line\"></span><br><span class=\"line\">\tstartFileUpload(file);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//开始上传</span><br><span class=\"line\">function startFileUpload(file)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvar uploadURL = &quot;FileUploadServer&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//手工构造一个form对象</span><br><span class=\"line\">\tvar formData = new FormData();</span><br><span class=\"line\">\tformData.append(&quot;file&quot; , file);// &#x27;file&#x27; 为HTTP Post里的字段名, file 对浏览器里的File对象</span><br><span class=\"line\">\t//手工构造一个请求对象，用这个对象发送表单数据</span><br><span class=\"line\">\t//设置 progress, load, error, abort 4个事件处理器</span><br><span class=\"line\">\tvar request = new XMLHttpRequest();</span><br><span class=\"line\">\trequest.upload.addEventListener(&quot;progress&quot; , window.evt_upload_progress , false);</span><br><span class=\"line\">    request.addEventListener(&quot;load&quot;, window.evt_upload_complete, false);</span><br><span class=\"line\">    request.addEventListener(&quot;error&quot;, window.evt_upload_failed, false);</span><br><span class=\"line\">    request.addEventListener(&quot;abort&quot;, window.evt_upload_cancel, false);</span><br><span class=\"line\">\trequest.open(&quot;POST&quot;, uploadURL ); // 设置服务URL</span><br><span class=\"line\">    request.send(formData);  // 发送表单数据</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.evt_upload_progress = function(evt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(evt.lengthComputable)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar progress = Math.round(evt.loaded * 100 / evt.total);</span><br><span class=\"line\">\t\tconsole.log(&quot;上传进度&quot; + progress);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">window.evt_upload_complete = function (evt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(evt.loaded == 0)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tconsole.log (&quot;上传失败!&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tconsole.log (&quot;上传完成!&quot;);</span><br><span class=\"line\">    \tvar response = JSON.parse(evt.target.responseText);</span><br><span class=\"line\">    \tconsole.log (response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">window.evt_upload_failed = function (evt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconsole.log  (&quot;上传出错&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">window.evt_upload_cancel = function (evt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconsole.log( &quot;上传中止!&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、后端部分，需要两个-jar-包的支持，他们分别是：commons-fileupload-1-3-1-jar-commons-io-2-4-jar\"><a href=\"#三、后端部分，需要两个-jar-包的支持，他们分别是：commons-fileupload-1-3-1-jar-commons-io-2-4-jar\" class=\"headerlink\" title=\"三、后端部分，需要两个 jar 包的支持，他们分别是：commons-fileupload-1.3.1.jar commons-io-2.4.jar\"></a>三、后端部分，需要两个 jar 包的支持，他们分别是：<code>commons-fileupload-1.3.1.jar</code> <code>commons-io-2.4.jar</code></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package my.fileUpload;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.File;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\">import java.io.PrintWriter;</span><br><span class=\"line\">import java.text.SimpleDateFormat;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.UUID;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.servlet.ServletException;</span><br><span class=\"line\">import javax.servlet.http.HttpServlet;</span><br><span class=\"line\">import javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\">import javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.apache.commons.fileupload.FileItemIterator;</span><br><span class=\"line\">import org.apache.commons.fileupload.FileItemStream;</span><br><span class=\"line\">import org.apache.commons.fileupload.servlet.ServletFileUpload;</span><br><span class=\"line\">import org.apache.commons.fileupload.util.Streams;</span><br><span class=\"line\">import org.json.JSONObject;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FileUploadServer extends HttpServlet &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFile tmpDir;//文件保存的临时目录</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void init() throws ServletException &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;初始化&quot;);</span><br><span class=\"line\">\t   File webRoot = new File(getServletContext().getRealPath(&quot;/&quot;));</span><br><span class=\"line\">\t   tmpDir = new File(webRoot , &quot;upload&quot;);</span><br><span class=\"line\">\t   if(!tmpDir.exists()) tmpDir.mkdirs();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class=\"line\">\t\t\tthrows ServletException, IOException &#123;</span><br><span class=\"line\">\t\tdoPost(request , response);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class=\"line\">\t\t\tthrows ServletException, IOException &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;进入&quot;);</span><br><span class=\"line\">\t\tint error = 0;</span><br><span class=\"line\">\t\tString reason = &quot;OK&quot;;</span><br><span class=\"line\">\t\tString data = null;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\t data = doUpload(request , response);</span><br><span class=\"line\">\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\terror = -1;</span><br><span class=\"line\">\t\t\treason = e.getMessage();</span><br><span class=\"line\">\t\t\t// TODO Auto-generated catch block</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tJSONObject jreq = new JSONObject();</span><br><span class=\"line\">\t\tjreq.put(&quot;error&quot;, error);</span><br><span class=\"line\">\t\tjreq.put(&quot;reason&quot;, reason);</span><br><span class=\"line\">\t\tif(data != null) jreq.put(&quot;data&quot;, data);</span><br><span class=\"line\">\t\tresponse.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class=\"line\">\t\tresponse.setContentType(&quot;text/plain&quot;);</span><br><span class=\"line\">\t\tPrintWriter out = response.getWriter();</span><br><span class=\"line\">\t\tout.write(jreq.toString(2));</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String doUpload(HttpServletRequest request, HttpServletResponse response) throws Exception</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tString result = null;</span><br><span class=\"line\">\t\tboolean isMultipart = ServletFileUpload.isMultipartContent(request);</span><br><span class=\"line\">\t\tif(!isMultipart)</span><br><span class=\"line\">\t\t\tthrow new Exception(&quot;请求编码必须为: multipart/form-data !&quot;);</span><br><span class=\"line\">\t\trequest.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class=\"line\">\t\tServletFileUpload upload = new ServletFileUpload();</span><br><span class=\"line\">\t\tFileItemIterator iter = upload.getItemIterator(request);</span><br><span class=\"line\">\t\twhile(iter.hasNext())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t//表单域</span><br><span class=\"line\">\t\t\tFileItemStream item = iter.next();</span><br><span class=\"line\">\t\t\tString fieldName = item.getFieldName();</span><br><span class=\"line\">\t\t\tInputStream fieldStream = item.openStream();</span><br><span class=\"line\">\t\t\tif(item.isFormField())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t//普通表单域直接读取</span><br><span class=\"line\">\t\t\t\tString fieldValue = Streams.asString(fieldStream , &quot;utf-8&quot;);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;表单域:&quot; + fieldName + &quot;=&quot; + fieldValue);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tString realName = item.getName();//原始文件名</span><br><span class=\"line\">\t\t\t\t//文件的后缀名</span><br><span class=\"line\">\t\t\t\tString suffix = realName.substring(realName.lastIndexOf(&quot;.&quot;)+1);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;文件名：&quot; + realName + &quot;.....&quot; + &quot;后缀名：&quot; + suffix);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//创建已个临时文件名</span><br><span class=\"line\">\t\t\t\tString s = UUID.randomUUID().toString();</span><br><span class=\"line\">\t\t\t\tString s2 = s.substring(0,8)+s.substring(9,13)+s.substring(14,18)+s.substring(19,23)+s.substring(24);</span><br><span class=\"line\">\t\t\t\ts2 = s2.toUpperCase();</span><br><span class=\"line\">\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMdd-HHmmss&quot;);</span><br><span class=\"line\">\t\t\t\tString dateStr = sdf.format(new Date());</span><br><span class=\"line\">\t\t\t\tString fileName = dateStr +&quot;-&quot; + s2 + &quot;.&quot; + suffix;</span><br><span class=\"line\">\t\t\t\tresult = fileName;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;文件名：&quot; + fileName);</span><br><span class=\"line\">\t\t\t\tFile file = new File(tmpDir , fileName);</span><br><span class=\"line\">\t\t\t\tlong fileSsize = 0;//文件大小</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;===========文件开始上传=============&quot;);</span><br><span class=\"line\">\t\t\t\t//从FieldStream读取数据，保存到目标文件</span><br><span class=\"line\">\t\t\t\tfile.getParentFile().mkdirs();</span><br><span class=\"line\">\t\t\t\tFileOutputStream fileStream = new FileOutputStream(file);</span><br><span class=\"line\">\t\t\t\ttry</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tbyte[] buf = new byte[1024];</span><br><span class=\"line\">\t\t\t\t\twhile(true)</span><br><span class=\"line\">\t\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t\tint n = fieldStream.read(buf);</span><br><span class=\"line\">\t\t\t\t\t\tif(n &lt; 0) break;</span><br><span class=\"line\">\t\t\t\t\t\tif(n == 0) continue;</span><br><span class=\"line\">\t\t\t\t\t\tfileStream.write(buf, 0, n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\tfileSsize += n;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;finally</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tfileStream.close();</span><br><span class=\"line\">\t\t\t\t\tfieldStream.close();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;上传完成！&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"数组和链表的区别","url":"/2022/10/24/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<p>数组和链表是两种基本的数据结构，他们在内存存储上的表现不一样，所以也有各自的特点。</p>\n<p>大致总结一下特点和区别，拿几个人一起去看电影时坐座位为例。</p>\n<h2 id=\"数组的特点\"><a href=\"#数组的特点\" class=\"headerlink\" title=\"数组的特点\"></a>数组的特点</h2><ul>\n<li>在内存中，数组是一块连续的区域。 拿上面的看电影来说，这几个人在电影院必须坐在一起。</li>\n<li>数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。 比如看电影时，为了保证 10 个人能坐在一起，必须提前订好 10 个连续的位置。这样的好处就是能保证 10 个人可以在一起。但是这样的缺点是，如果来的人不够 10 个，那么剩下的位置就浪费了。如果临时又多来了个人，那么 10 个就不够用了，这时可能需要将第 11 个位置上的人挪走，或者是他们 11 个人重新去找一个 11 连坐的位置，效率都很低。如果没有找到符合要求的座位，那么就没法坐了。</li>\n<li>插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。 比如原来去了 5 个人，然后后来又去了一个人要坐在第三个位置上，那么第三个到第五个都要往后移动一个位子，将第三个位置留给新来的人。 当这个人走了的时候，因为他们要连在一起的，所以他后面几个人要往前移动一个位置，把这个空位补上。</li>\n<li>随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到该地址的数据。</li>\n<li>并且不利于扩展，数组定义的空间不够时要重新定义数组。</li>\n</ul>\n<h2 id=\"链表的特点\"><a href=\"#链表的特点\" class=\"headerlink\" title=\"链表的特点\"></a>链表的特点</h2><ul>\n<li>在内存中可以存在任何地方，不要求连续。 在电影院几个人可以随便坐。</li>\n<li>每一个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据。 第一个人知道第二个人的座位号，第二个人知道第三个人的座位号……</li>\n<li>增加数据和删除数据很容易。 再来个人可以随便坐，比如来了个人要做到第三个位置，那他只需要把自己的位置告诉第二个人，然后问第二个人拿到原来第三个人的位置就行了。其他人都不用动。</li>\n<li>查找数据时效率低，因为不具有随机访问性，所以访问某个位置的数据都要从第一个数据开始访问，然后根据第一个数据保存的下一个数据的地址找到第二个数据，以此类推。 要找到第三个人，必须从第一个人开始问起。</li>\n<li>不指定大小，扩展方便。链表大小不用定义，数据随意增删。</li>\n</ul>\n<h2 id=\"各自的优缺点\"><a href=\"#各自的优缺点\" class=\"headerlink\" title=\"各自的优缺点\"></a>各自的优缺点</h2><h3 id=\"数组的优点\"><a href=\"#数组的优点\" class=\"headerlink\" title=\"数组的优点\"></a>数组的优点</h3><ul>\n<li>随机访问性强</li>\n<li>查找速度快</li>\n</ul>\n<h3 id=\"数组的缺点\"><a href=\"#数组的缺点\" class=\"headerlink\" title=\"数组的缺点\"></a>数组的缺点</h3><ul>\n<li>插入和删除效率低</li>\n<li>可能浪费内存</li>\n<li>内存空间要求高，必须有足够的连续内存空间。</li>\n<li>数组大小固定，不能动态拓展</li>\n</ul>\n<h3 id=\"链表的优点\"><a href=\"#链表的优点\" class=\"headerlink\" title=\"链表的优点\"></a>链表的优点</h3><ul>\n<li>插入删除速度快</li>\n<li>内存利用率高，不会浪费内存</li>\n<li>大小没有固定，拓展很灵活。</li>\n</ul>\n<h3 id=\"链表的缺点\"><a href=\"#链表的缺点\" class=\"headerlink\" title=\"链表的缺点\"></a>链表的缺点</h3><ul>\n<li><p>不能随机查找，必须从第一个开始遍历，查找效率低</p>\n</li>\n<li><p>| 数组 | 链表 |<br>| —- | —- | —- |<br>| 读取 | O(1) | O(n) |<br>| 插入 | O(n) | O(1) |<br>| 删除 | O(n) | O(1) |</p>\n</li>\n</ul>\n<p><img src=\"http://privateimage.oss-cn-hongkong.aliyuncs.com/%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%87%B5%E9%80%BC.gif\" alt=\"image\"></p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"浅析koa的洋葱模型实现","url":"/2022/10/24/%E6%B5%85%E6%9E%90koa%E7%9A%84%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>koa 被认为是第二代 node web framework，它最大的特点就是独特的中间件流程控制，是一个典型的洋葱模型。koa 和 koa2 中间件的思路是一样的，但是实现方式有所区别，koa2 在 node7.6 之后更是可以直接用 async&#x2F;await 来替代 generator 使用中间件，本文以最后一种情况举例。</p>\n<h2 id=\"洋葱模型\"><a href=\"#洋葱模型\" class=\"headerlink\" title=\"洋葱模型\"></a>洋葱模型</h2><p>下面两张图是网上找的，很清晰的表明了一个请求是如何经过中间件最后生成响应的，这种模式中开发和使用中间件都是非常方便的</p>\n<p><img src=\"https://segmentfault.com/img/bV6DZG?w=478&h=435\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bV6D5Z?w=470&h=411\" alt=\"image\"></p>\n<p>来看一个 koa2 的 demo:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const Koa = require(&#x27;koa&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\">const PORT = 3000;</span><br><span class=\"line\"></span><br><span class=\"line\">// #1</span><br><span class=\"line\">app.use(async (ctx, next)=&gt;&#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// #2</span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    console.log(3)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(PORT);</span><br><span class=\"line\">console.log(`http://localhost:$&#123;PORT&#125;`);</span><br></pre></td></tr></table></figure>\n\n<p>访问 <a href=\"http://localhost:3000，控制台打印：\">http://localhost:3000，控制台打印：</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>怎么样，是不是有一点点感觉了。当程序运行到 await next()的时候就会暂停当前程序，进入下一个中间件，处理完之后才会在回过头来继续处理。也就是说，当一个请求进入，#1 会被第一个和最后一个经过，#2 则是被第二和倒数第二个经过，依次类推。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>koa 的实现有几个最重要的点</p>\n<ol>\n<li>context 的保存和传递</li>\n<li>中间件的管理和 next 的实现</li>\n</ol>\n<p>翻看源码我们发现<br>app.listen 使用了 this.callback()来生成 node 的 httpServer 的回调函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">listen(...args) &#123;</span><br><span class=\"line\">    debug(&#x27;listen&#x27;);</span><br><span class=\"line\">    const server = http.createServer(this.callback());</span><br><span class=\"line\">    return server.listen(...args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那就再来看 this.callback</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">callback() &#123;</span><br><span class=\"line\">    const fn = compose(this.middleware);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!this.listeners(&#x27;error&#x27;).length) this.on(&#x27;error&#x27;, this.onerror);</span><br><span class=\"line\"></span><br><span class=\"line\">    const handleRequest = (req, res) =&gt; &#123;</span><br><span class=\"line\">      const ctx = this.createContext(req, res);</span><br><span class=\"line\">      return this.handleRequest(ctx, fn);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    return handleRequest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里用 compose 处理了一下 this.middleware，创建了 ctx 并赋值为 createContext 的返回值，最后返回了 handleRequest。</p>\n<p>this.middleware 看起来应该是中间件的集合，查了下代码，果不其然：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">this.middleware = [];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">use(fn) &#123;</span><br><span class=\"line\">    if (typeof fn !== &#x27;function&#x27;) throw new TypeError(&#x27;middleware must be a function!&#x27;);</span><br><span class=\"line\">    if (isGeneratorFunction(fn)) &#123;</span><br><span class=\"line\">      deprecate(&#x27;Support for generators will be removed in v3. &#x27; +</span><br><span class=\"line\">                &#x27;See the documentation for examples of how to convert old middleware &#x27; +</span><br><span class=\"line\">                &#x27;https://github.com/koajs/koa/blob/master/docs/migration.md&#x27;);</span><br><span class=\"line\">      fn = convert(fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debug(&#x27;use %s&#x27;, fn._name || fn.name || &#x27;-&#x27;);</span><br><span class=\"line\">    this.middleware.push(fn);</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抛开兼容和判断，这段代码只做了一件事：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">use(fn) &#123;</span><br><span class=\"line\">    this.middleware.push(fn);</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来当我们 app.use 的时候，只是把方法存在了一个数组里。<br>那么 compose 又是什么呢。跟踪源码可以看到 compose 来自 koa-compose 模块，代码也不多：（去掉了一些不影响主逻辑的判断）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function compose (middleware) &#123;</span><br><span class=\"line\">  return function (context, next) &#123;</span><br><span class=\"line\">    // last called middleware #</span><br><span class=\"line\">    let index = -1</span><br><span class=\"line\">    return dispatch(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    function dispatch (i) &#123;</span><br><span class=\"line\">      if (i &lt;= index) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;))</span><br><span class=\"line\">      index = i</span><br><span class=\"line\">      let fn = middleware[i]</span><br><span class=\"line\">      if (i === middleware.length) fn = next</span><br><span class=\"line\">      if (!fn) return Promise.resolve()</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        return Promise.resolve(fn(context, function next () &#123;</span><br><span class=\"line\">          return dispatch(i + 1)</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">      &#125; catch (err) &#123;</span><br><span class=\"line\">        return Promise.reject(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比较关键的就是这个 dispatch 函数了，它将遍历整个 middleware，然后将 context 和 dispatch(i + 1)传给 middleware 中的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">return Promise.resolve(fn(context, function next () &#123;</span><br><span class=\"line\">      return dispatch(i + 1)</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<p>这段代码就很巧妙的实现了两点:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 将`context`一路传下去给中间件</span><br><span class=\"line\"></span><br><span class=\"line\">2. 将`middleware`中的下一个中间件`fn`作为未来`next`的返回值</span><br></pre></td></tr></table></figure>\n\n<p>这两点也是洋葱模型实现的核心。<br>再往下看代码实际上就没有太多花样了。<br>createContext 和 handleRequest 做的事实际上是把 ctx 和中间件进行绑定，也就是第一次调用 compose 返回值的地方。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">createContext(req, res) &#123;</span><br><span class=\"line\">   const context = Object.create(this.context);</span><br><span class=\"line\">   const request = context.request = Object.create(this.request);</span><br><span class=\"line\">   const response = context.response = Object.create(this.response);</span><br><span class=\"line\">   context.app = request.app = response.app = this;</span><br><span class=\"line\">   context.req = request.req = response.req = req;</span><br><span class=\"line\">   context.res = request.res = response.res = res;</span><br><span class=\"line\">   request.ctx = response.ctx = context;</span><br><span class=\"line\">   request.response = response;</span><br><span class=\"line\">   response.request = request;</span><br><span class=\"line\">   context.originalUrl = request.originalUrl = req.url;</span><br><span class=\"line\">   context.cookies = new Cookies(req, res, &#123;</span><br><span class=\"line\">     keys: this.keys,</span><br><span class=\"line\">     secure: request.secure</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   request.ip = request.ips[0] || req.socket.remoteAddress || &#x27;&#x27;;</span><br><span class=\"line\">   context.accept = request.accept = accepts(req);</span><br><span class=\"line\">   context.state = &#123;&#125;;</span><br><span class=\"line\">   return context;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> handleRequest(ctx, fnMiddleware) &#123;</span><br><span class=\"line\">   const res = ctx.res;</span><br><span class=\"line\">   res.statusCode = 404;</span><br><span class=\"line\">   const onerror = err =&gt; ctx.onerror(err);</span><br><span class=\"line\">   const handleResponse = () =&gt; respond(ctx);</span><br><span class=\"line\">   onFinished(res, onerror);</span><br><span class=\"line\">   return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"深入理解react中的虚拟DOM、diff算法","url":"/2022/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E3%80%81diff%E7%AE%97%E6%B3%95/","content":"<p>文章结构：</p>\n<ul>\n<li>React 中的虚拟 DOM 是什么？</li>\n<li>虚拟 DOM 的简单实现（diff 算法）</li>\n<li>虚拟 DOM 的内部工作原理</li>\n<li>React 中的虚拟 DOM 与 Vue 中的虚拟 DOM 比较</li>\n</ul>\n<h2 id=\"React-中的虚拟-DOM-是什么？\"><a href=\"#React-中的虚拟-DOM-是什么？\" class=\"headerlink\" title=\"React 中的虚拟 DOM 是什么？\"></a>React 中的虚拟 DOM 是什么？</h2><p>虽然 React 中的虚拟 DOM 很好用，但是这是一个无心插柳的结果。</p>\n<p><strong>React 的核心思想：一个 Component 拯救世界，忘掉烦恼，从此不再操心界面</strong>。</p>\n<h3 id=\"1-Virtual-Dom-快，有两个前提\"><a href=\"#1-Virtual-Dom-快，有两个前提\" class=\"headerlink\" title=\"1. Virtual Dom 快，有两个前提\"></a>1. Virtual Dom 快，有两个前提</h3><h4 id=\"1-1-Javascript-很快\"><a href=\"#1-1-Javascript-很快\" class=\"headerlink\" title=\"1.1 Javascript 很快\"></a>1.1 Javascript 很快</h4><p><strong>Chrome 刚出来的时候，在 Chrome 里跑 Javascript 非常快，给了其它浏览器很大压力</strong>。而现在经过几轮你追我赶，各主流浏览器的 Javascript 执行速度都很快了。</p>\n<p>在 <a href=\"https://julialang.org/benchmarks/\">https://julialang.org/benchmarks/</a> 这个网站上，我们可以看到，JavaScript 语言已经非常快了，和 C 就是几倍的关系，和 java 在同一个量级。<strong>所以说，单纯的 JavaScript 还是很快的。</strong></p>\n<h4 id=\"1-2-Dom-很慢\"><a href=\"#1-2-Dom-很慢\" class=\"headerlink\" title=\"1.2 Dom 很慢\"></a>1.2 Dom 很慢</h4><p>当创建一个元素比如 div，有以下几项内容需要实现： <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement\">HTML element</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element\">Element</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers\">GlobalEventHandler</a>。简单的说，就是插入一个 Dom 元素的时候，这个元素上本身或者继承很多属性如 width、height、offsetHeight、style、title，另外还需要注册这个元素的诸多方法，比如 onfocus、onclick 等等。 这还只是一个元素，如果元素比较多的时候，还涉及到嵌套，那么元素的属性和方法等等就会很多，效率很低。</p>\n<p>比如，我们在一个空白网页的 body 中添加一个 div 元素，如下所示：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170801225429255-521935350.png\" alt=\"image\"></p>\n<p>这个元素<strong>会挂载默认的 styles、得到这个元素的 computed 属性、注册相应的 Event Listener、DOM Breakpoints 以及大量的 properties，这些属性、方法的注册肯定是需要耗费大量时间的</strong>。</p>\n<p>尤其是在 js 操作 DOM 的过程中，不仅有 dom 本身的繁重，js 的操作也需要浪费时间，我们认为 js 和 DOM 之间有一座桥，如果你频繁的在桥两边走动，显然效率是很低的，<strong>如果你的 JavaScript 操作 DOM 的方式还非常不合理，那么显然就会更糟糕了</strong>。</p>\n<p><strong>而 React 的虚拟 DOM 就是解决这个问题的！</strong> 虽然它解决不了 DOM 自身的繁重，但是<strong>虚拟 DOM 可以对 JavaScript 操作 DOM 这一部分内容进行优化</strong>。</p>\n<p>比如说，现在你的 list 是这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &lt;li&gt;0&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;1&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;2&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;3&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n<p>你希望把它变成下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &lt;li&gt;6&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;7&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;8&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;9&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;10&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>通常的操作是什么?</strong></p>\n<p>先把 0， 1，2，3 这些 Element 删掉，然后加几个新的 Element 6，7，8，9，10 进去，这里面就有 4 次 Element 删除，5 次 Element 添加。共计 9 次 DOM 操作。</p>\n<p><strong>那 React 的虚拟 DOM 可以怎么做呢？</strong></p>\n<p>而 React 会把这两个做一下 Diff，然后发现其实不用删除 0，1，2，3，而是可以直接改 innerHTML，然后只需要添加一个 Element（10）就行了，这样就是 4 次 innerHTML 操作加 1 个 Element 添加。<strong>共计 5 次操作，这样效率的提升是非常可观的。</strong></p>\n<h3 id=\"2、-关于-React\"><a href=\"#2、-关于-React\" class=\"headerlink\" title=\"2、 关于 React\"></a>2、 关于 React</h3><h4 id=\"2-1-接口和设计\"><a href=\"#2-1-接口和设计\" class=\"headerlink\" title=\"2.1 接口和设计\"></a>2.1 接口和设计</h4><p><strong>在 React 的设计中，是完全不需要你来操作 DOM 的。我们也可以认为，在 React 中根本就没有 DOM 这个概念，有的只是 Component。</strong></p>\n<p>当你写好一个 Component 以后，Component 会完全负责 UI，你不需要也不应该去也不能够指挥 Component 怎么显示，你只能告诉它你想要显示一个香蕉还是两个梨。</p>\n<p><strong>隔离 DOM 并不仅仅是因为 DOM 慢，而也是为了把界面和业务完全隔离，操作数据的只关心数据，操作界面的只关心界面</strong>。比如在 websocket 聊天室的创建房间时，我们可以首先把 Component 写好，然后当获取到数据的时候，只要把数据放在 redux 中就好，然后 Component 就自动把房间添加到页面中去，而不是你先拿到数据，然后使用 js 操作 DOM 把数据显示在页面上。</p>\n<p>即<strong>我提供一个 Component，然后你只管给我数据，界面的事情完全不用你操心，我保证会把界面变成你想要的样子。所以说 React 的着力点就在于 View 层，即 React 专注于 View 层</strong>。你可以把一个 React 的 Component 想象成一个 Pure Function，只要你给的数据是[1, 2, 3]，我保证显示的是[1, 2, 3]。没有什么删除一个 Element，添加一个 Element 这样的事情。NO。你要我显示什么就给我一个完整的列表。</p>\n<p>另外，Flux 虽然说的是单向的 Data Flow(redux 也是)，但是实际上就是单向的 Observer，Store-&gt;View-&gt;Action-&gt;Store（箭头是数据流向，实现上可以理解为 View 监听 Store，View 直接 trigger action，然后 Store 监听 Action）。</p>\n<h4 id=\"2-2-实现\"><a href=\"#2-2-实现\" class=\"headerlink\" title=\"2.2 实现\"></a>2.2 实现</h4><p>那么 react 如何实现呢？ 最简单的方法就是当数据变化时，我直接把原先的 DOM 卸载，然后把最新数据的 DOM 替换上去。 但是，虚拟 DOM 哪去了？ 这样做的效率显然是极低的。</p>\n<p>所以虚拟 DOM 就来救场了。</p>\n<p>那么虚拟 DOM 和 DOM 之间的关系是什么呢？</p>\n<p>首先，Virtual DOM 并没有完全实现 DOM，即虚拟 DOM 和真正地 DOM 是不一样的，Virtual DOM 最主要的还是保留了 Element 之间的层次关系和一些基本属性。因为真实 DOM 实在是太复杂，一个空的 Element 都复杂得能让你崩溃，并且几乎所有内容我根本不关心好吗。所以 Virtual DOM 里每一个 Element 实际上只有几个属性，即最重要的，最为有用的，并且没有那么多乱七八糟的引用，比如一些注册的属性和函数啊，这些都是默认的，创建虚拟 DOM 进行 diff 的过程中大家都一致，是不需要进行比对的。所以哪怕是直接把 Virtual DOM 删了，根据新传进来的数据重新创建一个新的 Virtual DOM 出来都非常非常非常快。（每一个 component 的 render 函数就是在做这个事情，给新的 virtual dom 提供 input）。</p>\n<p>所以，引入了 Virtual DOM 之后，React 是这么干的：你给我一个数据，我根据这个数据生成一个全新的 Virtual DOM，然后跟我上一次生成的 Virtual DOM 去 diff，得到一个 Patch，然后把这个 Patch 打到浏览器的 DOM 上去。完事。并且这里的 patch 显然不是完整的虚拟 DOM，而是新的虚拟 DOM 和上一次的虚拟 DOM 经过 diff 后的差异化的部分。</p>\n<p>假设在任意时候有，VirtualDom1 &#x3D;&#x3D; DOM1 （组织结构相同, 显然虚拟 DOM 和真实 DOM 是不可能完全相等的，这里的&#x3D;&#x3D;是 js 中非完全相等）。当有新数据来的时候，我生成 VirtualDom2，然后去和 VirtualDom1 做 diff，得到一个 Patch（差异化的结果）。然后将这个 Patch 去应用到 DOM1 上，得到 DOM2。如果一切正常，那么有 VirtualDom2 &#x3D;&#x3D; DOM2（同样是结构上的相等）。</p>\n<p>这里你可以做一些小实验，去破坏 VirtualDom1 &#x3D;&#x3D; DOM1 这个假设（手动在 DOM 里删除一些 Element，这时候 VirtualDom 里的 Element 没有被删除，所以两边不一样了）。<br>然后给新的数据，你会发现生成的界面就不是你想要的那个界面了。</p>\n<p>最后，回到为什么 Virtual Dom 快这个问题上。<br>其实是由于每次生成 virtual dom 很快，diff 生成 patch 也比较快，而在对 DOM 进行 patch 的时候，虽然 DOM 的变更比较慢，但是 React 能够根据 Patch 的内容，优化一部分 DOM 操作，比如之前的那个例子。</p>\n<p>重点就在最后，哪怕是我生成了 virtual dom(需要耗费时间)，哪怕是我跑了 diff（还需要花时间），但是我根据 patch 简化了那些 DOM 操作省下来的时间依然很可观（这个就是时间差的问题了，即节省下来的时间 &gt; 生成 virtual dom 的时间 + diff 时间）。所以总体上来说，还是比较快。</p>\n<p>简单发散一下思路，如果哪一天，DOM 本身的操作已经非常非常非常快了，并且我们手动对于 DOM 的操作都是精心设计优化过后的，那么加上了 VirtualDom 还会快吗？<br>当然不行了，毕竟你多做了这么多额外的工作。</p>\n<pre><code>    但是那一天会来到吗？\n    诶，大不了到时候不用Virtual DOM。\n</code></pre>\n<p>注： 此部分内容整理自：<a href=\"https://www.zhihu.com/question/29504639/answer/44680878\">https://www.zhihu.com/question/29504639/answer/44680878</a></p>\n<h2 id=\"虚拟-DOM-的简单实现（diff-算法）\"><a href=\"#虚拟-DOM-的简单实现（diff-算法）\" class=\"headerlink\" title=\"虚拟 DOM 的简单实现（diff 算法）\"></a>虚拟 DOM 的简单实现（diff 算法）</h2><p>目录</p>\n<ul>\n<li>1 前言</li>\n<li>2 对前端应用状态管理思考</li>\n<li>3 Virtual DOM 算法</li>\n<li>4 算法实现<ul>\n<li>4.1 步骤一：用 JS 对象模拟 DOM 树</li>\n<li>4.2 步骤二：比较两棵虚拟 DOM 树的差异</li>\n<li>4.3 步骤三：把差异应用到真正的 DOM 树上</li>\n</ul>\n</li>\n<li>5 结语</li>\n</ul>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在上面一部分中，我们已经简单介绍了虚拟 DOM 的答题思路和好处，这里我们将通过自己写一个虚拟 DOM 来加深对其的理解，有一些自己的思考。</p>\n<h3 id=\"对前端应用状态管理思考\"><a href=\"#对前端应用状态管理思考\" class=\"headerlink\" title=\"对前端应用状态管理思考\"></a>对前端应用状态管理思考</h3><p>维护状态，更新视图。</p>\n<h3 id=\"虚拟-DOM-算法\"><a href=\"#虚拟-DOM-算法\" class=\"headerlink\" title=\"虚拟 DOM 算法\"></a>虚拟 DOM 算法</h3><p>DOM 是很慢的，如果我们创建一个简单的 div，然后把他的所有的属性都打印出来，你会看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var div = document.createElement(&#x27;div&#x27;),</span><br><span class=\"line\">    str = &#x27;&#x27;;</span><br><span class=\"line\">for (var key in div) &#123;</span><br><span class=\"line\">  str = str + &#x27; &#x27; + key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(str);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830091841171-1021895840.png\" alt=\"image\"></p>\n<p>可以看到，这些属性还是非常惊人的，包括样式的修饰特性、一般的特性、方法等等，如果我们打印出其长度，可以得到惊人的 227 个。<br>而这仅仅是一层，真正的 DOM 元素是非常庞大的，这是因为标准就是这么设计的，而且操作他们的时候你要小心翼翼，轻微的触碰就有可能导致页面发生重排，这是杀死性能的罪魁祸首。</p>\n<p>而相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单，DOM 树上的结构信息我们都可以使用 JavaScript 对象很容易的表示出来。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var element = &#123;</span><br><span class=\"line\">      tagName: &#x27;ul&#x27;,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        id: &#x27;list&#x27;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      children: &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          tagName: &#x27;li&#x27;,</span><br><span class=\"line\">          props: &#123;</span><br><span class=\"line\">            class: &#x27;item&#x27;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          children: [&#x27;Item1&#x27;]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          tagName: &#x27;li&#x27;,</span><br><span class=\"line\">          props: &#123;</span><br><span class=\"line\">            class: &#x27;item&#x27;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          children: [&#x27;Item1&#x27;]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          tagName: &#x27;li&#x27;,</span><br><span class=\"line\">          props: &#123;</span><br><span class=\"line\">            class: &#x27;item&#x27;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          children: [&#x27;Item1&#x27;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，对于一个元素，我们只需要一个 JavaScript 对象就可以很容易的表示出来，这个对象中有三个属性:</p>\n<ol>\n<li>tagName: 用来表示这个元素的标签名。</li>\n<li>props: 用来表示这元素所包含的属性。</li>\n<li>children: 用来表示这元素的 children。</li>\n</ol>\n<p>而上面的这个对象使用 HTML 表示就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul id=&#x27;list&#x27;&gt;</span><br><span class=\"line\">  &lt;li class=&#x27;item&#x27;&gt;Item 1&lt;/li&gt;</span><br><span class=\"line\">  &lt;li class=&#x27;item&#x27;&gt;Item 2&lt;/li&gt;</span><br><span class=\"line\">  &lt;li class=&#x27;item&#x27;&gt;Item 3&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>OK! 既然原来的 DOM 信息可以使用 JavaScript 来表示，那么反过来，我们就可以用这个 JavaScript 对象来构建一个真正的 DOM 树。</p>\n<p>所以之前所说的状态变更的时候会重新构建这个 JavaScript 对象，然后呢，用新渲染的对象和旧的对象去对比， 记录两棵树的差异，记录下来的就是我们需要改变的地方。 这就是所谓的虚拟 DOM，包括下面的几个步骤：</p>\n<ol>\n<li>用 JavaScript 对象来表示 DOM 树的结构； 然后用这个树构建一个真正的 DOM 树，插入到文档中。</li>\n<li>当状态变更的时候，重新构造一个新的对象树，然后用这个新的树和旧的树作对比，记录两个树的差异。</li>\n<li>把 2 所记录的差异应用在步骤一所构建的真正的 DOM 树上，视图就更新了。</li>\n</ol>\n<p>Virtual DOM 的本质就是在 JS 和 DOM 之间做一个缓存，可以类比 CPU 和硬盘，既然硬盘这么慢，我们就也在他们之间添加一个缓存； 既然 DOM 这么慢，我们就可以在 JS 和 DOM 之间添加一个缓存。 CPU（JS）只操作内存（虚拟 DOM），最后的时候在把变更写入硬盘（DOM）。</p>\n<h3 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><h4 id=\"1、-用-JavaScript-对象模拟-DOM-树\"><a href=\"#1、-用-JavaScript-对象模拟-DOM-树\" class=\"headerlink\" title=\"1、 用 JavaScript 对象模拟 DOM 树\"></a>1、 用 JavaScript 对象模拟 DOM 树</h4><p>用 JavaScript 对象来模拟一个 DOM 节点并不难，你只需要记录他的节点类型（tagName）、属性（props）、子节点（children）。</p>\n<p>element.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Element(tagName, props, children) &#123;</span><br><span class=\"line\">  this.tagName = tagName;</span><br><span class=\"line\">  this.props = props;</span><br><span class=\"line\">  this.children = children;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = function (tagName, props, children) &#123;</span><br><span class=\"line\">   return new Element(tagName, props, children);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这个构造函数，我们就可以传入标签名、属性以及子节点了，tagName 可以在我们 render 的时候直接根据它来创建真实的元素，这里的 props 使用一个对象传入，可以方便我们遍历。</p>\n<p>基本使用方法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var el = require(&#x27;./element&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">var ul = el(&#x27;ul&#x27;, &#123;id: &#x27;list&#x27;&#125;, [</span><br><span class=\"line\">    el(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item1&#x27;]),</span><br><span class=\"line\">    el(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item2&#x27;]),</span><br><span class=\"line\">    el(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item3&#x27;])</span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n\n<p>然而，现在的 ul 只是 JavaScript 表示的一个 DOM 结构，页面上并没有这个结构，所有我们可以根据 ul 构建一个真正的<code>&lt;ul&gt;</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Element.prototype.render = function () &#123;</span><br><span class=\"line\">      // 根据tagName创建一个真实的元素</span><br><span class=\"line\">      var el = document.createElement(this.tagName);</span><br><span class=\"line\">      // 得到这个元素的属性对象，方便我们遍历。</span><br><span class=\"line\">      var props = this.props;</span><br><span class=\"line\"></span><br><span class=\"line\">      for (var propName in props) &#123;</span><br><span class=\"line\">        // 获取到这个元素值</span><br><span class=\"line\">        var propValue = props[propName];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 通过setAttribute设置元素属性。</span><br><span class=\"line\">        el.setAttribute(propName, propValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 注意： 这里的children，我们传入的是一个数组，所以，children不存在时我们用【】来替代。</span><br><span class=\"line\">      var children = this.children || [];</span><br><span class=\"line\"></span><br><span class=\"line\">      //遍历children</span><br><span class=\"line\">      children.forEach(function (child) &#123;</span><br><span class=\"line\">        var childEl = (child instanceof Element)</span><br><span class=\"line\">                      ? child.render()</span><br><span class=\"line\">                      : document.createTextNode(child);</span><br><span class=\"line\">        // 无论childEl是元素还是文字节点，都需要添加到这个元素中。</span><br><span class=\"line\">        el.appendChild(childEl);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      return el;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，render 方法会根据 tagName 构建一个真正的 DOM 节点，然后设置这个节点的属性，最后递归的把自己的子节点也构建起来，所以只需要调用 ul 的 render 方法，通过 document.body.appendChild 就可以挂载到真实的页面上了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;div&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    function Element(tagName, props, children) &#123;</span><br><span class=\"line\">      this.tagName = tagName;</span><br><span class=\"line\">      this.props = props;</span><br><span class=\"line\">      this.children = children;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    var ul = new Element(&#x27;ul&#x27;, &#123;id: &#x27;list&#x27;&#125;, [</span><br><span class=\"line\">        new Element(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item1&#x27;]),</span><br><span class=\"line\">        new Element(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item2&#x27;]),</span><br><span class=\"line\">        new Element(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item3&#x27;])</span><br><span class=\"line\">      ]);</span><br><span class=\"line\"></span><br><span class=\"line\">    Element.prototype.render = function () &#123;</span><br><span class=\"line\">      // 根据tagName创建一个真实的元素</span><br><span class=\"line\">      var el = document.createElement(this.tagName);</span><br><span class=\"line\">      // 得到这个元素的属性对象，方便我们遍历。</span><br><span class=\"line\">      var props = this.props;</span><br><span class=\"line\"></span><br><span class=\"line\">      for (var propName in props) &#123;</span><br><span class=\"line\">        // 获取到这个元素值</span><br><span class=\"line\">        var propValue = props[propName];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 通过setAttribute设置元素属性。</span><br><span class=\"line\">        el.setAttribute(propName, propValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 注意： 这里的children，我们传入的是一个数组，所以，children不存在时我们用【】来替代。</span><br><span class=\"line\">      var children = this.children || [];</span><br><span class=\"line\"></span><br><span class=\"line\">      //遍历children</span><br><span class=\"line\">      children.forEach(function (child) &#123;</span><br><span class=\"line\">        var childEl = (child instanceof Element)</span><br><span class=\"line\">                      ? child.render()</span><br><span class=\"line\">                      : document.createTextNode(child);</span><br><span class=\"line\">        // 无论childEl是元素还是文字节点，都需要添加到这个元素中。</span><br><span class=\"line\">        el.appendChild(childEl);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      return el;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var ulRoot = ul.render();</span><br><span class=\"line\">    document.body.appendChild(ulRoot);</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面的这段代码，就可以渲染出下面的结果了：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830101420718-2040904880.png\" alt=\"image\"></p>\n<h4 id=\"2、比较两颗虚拟-DOM-树的差异\"><a href=\"#2、比较两颗虚拟-DOM-树的差异\" class=\"headerlink\" title=\"2、比较两颗虚拟 DOM 树的差异\"></a>2、比较两颗虚拟 DOM 树的差异</h4><p>比较两颗 DOM 树的差异是 Virtual DOM 算法中最为核心的部分，这也就是所谓的 Virtual DOM 的 diff 算法。 两个树的完全的 diff 算法是一个时间复杂度为 O(n3) 的问题。 但是在前端中，你会很少跨层地移动 DOM 元素，所以真实的 DOM 算法会对同一个层级的元素进行对比。</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830101733202-1167202046.png\" alt=\"image\"></p>\n<p>上图中，div 只会和同一层级的 div 对比，第二层级的只会和第二层级对比。 这样算法复杂度就可以达到 O(n)。</p>\n<p><strong>（1）深度遍历优先，记录差异</strong></p>\n<p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每一个节点就会有一个唯一的标记：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830102245702-1187605690.png\" alt=\"image\"></p>\n<p>上面的这个遍历过程就是深度优先，即深度完全完成之后，再转移位置。 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比，如果有差异的话就记录到一个对象里面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// diff函数，对比两颗树</span><br><span class=\"line\">function diff(oldTree, newTree) &#123;</span><br><span class=\"line\">  // 当前的节点的标志。因为在深度优先遍历的过程中，每个节点都有一个index。</span><br><span class=\"line\">  var index = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 在遍历到每个节点的时候，都需要进行对比，找到差异，并记录在下面的对象中。</span><br><span class=\"line\">  var pathches = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 开始进行深度优先遍历</span><br><span class=\"line\">  dfsWalk(oldTree, newTree, index, pathches);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 最终diff算法返回的是一个两棵树的差异。</span><br><span class=\"line\">  return pathches;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 对两棵树进行深度优先遍历。</span><br><span class=\"line\">function dfsWalk(oldNode, newNode, index, pathches) &#123;</span><br><span class=\"line\">  // 对比oldNode和newNode的不同，记录下来</span><br><span class=\"line\">  pathches[index] = [...];</span><br><span class=\"line\"></span><br><span class=\"line\">  diffChildren(oldNode.children, newNode.children, index, pathches);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 遍历子节点</span><br><span class=\"line\">function diffChildren(oldChildren, newChildren, index, pathches) &#123;</span><br><span class=\"line\">  var leftNode = null;</span><br><span class=\"line\">  var currentNodeIndex = index;</span><br><span class=\"line\">  oldChildren.forEach(function (child, i) &#123;</span><br><span class=\"line\">    var newChild = newChildren[i];</span><br><span class=\"line\">    currentNodeIndex = (leftNode &amp;&amp; leftNode.count)</span><br><span class=\"line\">    ? currentNodeIndex + leftNode.count + 1</span><br><span class=\"line\">    : currentNodeIndex + 1</span><br><span class=\"line\"></span><br><span class=\"line\">    // 深度遍历子节点</span><br><span class=\"line\">    dfsWalk(child, newChild, currentNodeIndex, pathches);</span><br><span class=\"line\">    leftNode = child;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如，上面的 div 和新的 div 有差异，当前的标记是 0， 那么我们可以使用数组来存储新旧节点的不同：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...]</span><br></pre></td></tr></table></figure>\n\n<p>同理使用 patches[1]来记录 p，使用 patches[3]来记录 ul，以此类推。</p>\n<p><strong>（2）差异类型</strong></p>\n<p>上面说的节点的差异指的是什么呢？ 对 DOM 操作可能会：</p>\n<ol>\n<li>替换原来的节点，如把上面的 div 换成了 section。</li>\n<li>移动、删除、新增子节点， 例如上面 div 的子节点，把 p 和 ul 顺序互换。</li>\n<li>修改了节点的属性。</li>\n<li>对于文本节点，文本内容可能会改变。 例如修改上面的文本内容 2 内容为 Virtual DOM2.<br>　　所以，我们可以定义下面的几种类型：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var REPLACE = 0;</span><br><span class=\"line\">var REORDER = 1;</span><br><span class=\"line\">var PROPS = 2;</span><br><span class=\"line\">var TEXT = 3;</span><br></pre></td></tr></table></figure>\n\n<p>对于节点替换，很简单，判断新旧节点的 tagName 是不是一样的，如果不一样的说明需要替换掉。 如 div 换成了 section，就记录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">patches[0] = [&#123;</span><br><span class=\"line\">  type: REPALCE,</span><br><span class=\"line\">  node: newNode // el(&#x27;section&#x27;, props, children)</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，如果给 div 新增了属性 id 为 container，就记录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pathches[0] = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    type: REPLACE,</span><br><span class=\"line\">    node: newNode</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    type: PROPS,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      id: &#x27;container&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>如果是文本节点发生了变化，那么就记录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pathches[2] = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    type:  TEXT,</span><br><span class=\"line\">    content: &#x27;virtual DOM2&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>那么如果我们把 div 的子节点重新排序下了呢？ 比如 p、ul、div 的顺序换成了 div、p、ul，那么这个该怎么对比呢？ 如果按照同级进行顺序对比的话，他们就会被替换掉，如 p 和 div 的 tagName 不同，p 就会被 div 所代替，最终，三个节点就都会被替换，这样 DOM 开销就会非常大，而实际上是不需要替换节点的，只需要移动就可以了， 我们只需要知道怎么去移动。这里牵扯到了两个列表的对比算法，如下。</p>\n<p><strong>（3）列表对比算法</strong></p>\n<p>假设现在可以用英文字母唯一地标识每一个子节点：</p>\n<p>旧的节点顺序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a b c d e f g h i</span><br></pre></td></tr></table></figure>\n\n<p>现在对节点进行了删除、插入、移动的操作。新增 j 节点，删除 e 节点，移动 h 节点：</p>\n<p>新的节点顺序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a b c h d f g i j</span><br></pre></td></tr></table></figure>\n\n<p>现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），最常见的解决算法是 Levenshtein Distance，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定 DOM 操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考代码。</p>\n<p>我们能够获取到某个父节点的子节点的操作，就可以记录下来：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">patches[0] = [&#123;</span><br><span class=\"line\">  type: REORDER,</span><br><span class=\"line\">  moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>但是要注意的是，因为 tagName 是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识 key，列表对比的时候，使用 key 进行对比，这样才能复用老的 DOM 树上的节点。</p>\n<p>这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 diff.js。</p>\n<h3 id=\"3、把差异引用到真正的-DOM-树上\"><a href=\"#3、把差异引用到真正的-DOM-树上\" class=\"headerlink\" title=\"3、把差异引用到真正的 DOM 树上\"></a>3、把差异引用到真正的 DOM 树上</h3><p>因为步骤一所构建的 JavaScript 对象树和 render 出来真正的 DOM 树的信息、结构是一样的。所以我们可以对那棵 DOM 树也进行深度优先的遍历，遍历的时候从步骤二生成的 patches 对象中找出当前遍历的节点差异，然后进行 DOM 操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function patch (node, patches) &#123;</span><br><span class=\"line\">  var walker = &#123;index: 0&#125;</span><br><span class=\"line\">  dfsWalk(node, walker, patches)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function dfsWalk (node, walker, patches) &#123;</span><br><span class=\"line\">  var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异</span><br><span class=\"line\"></span><br><span class=\"line\">  var len = node.childNodes</span><br><span class=\"line\">    ? node.childNodes.length</span><br><span class=\"line\">    : 0</span><br><span class=\"line\">  for (var i = 0; i &lt; len; i++) &#123; // 深度遍历子节点</span><br><span class=\"line\">    var child = node.childNodes[i]</span><br><span class=\"line\">    walker.index++</span><br><span class=\"line\">    dfsWalk(child, walker, patches)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (currentPatches) &#123;</span><br><span class=\"line\">    applyPatches(node, currentPatches) // 对当前节点进行DOM操作</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function applyPatches (node, currentPatches) &#123;</span><br><span class=\"line\">  currentPatches.forEach(function (currentPatch) &#123;</span><br><span class=\"line\">    switch (currentPatch.type) &#123;</span><br><span class=\"line\">      case REPLACE:</span><br><span class=\"line\">        node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case REORDER:</span><br><span class=\"line\">        reorderChildren(node, currentPatch.moves)</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case PROPS:</span><br><span class=\"line\">        setProps(node, currentPatch.props)</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case TEXT:</span><br><span class=\"line\">        node.textContent = currentPatch.content</span><br><span class=\"line\">        break</span><br><span class=\"line\">      default:</span><br><span class=\"line\">        throw new Error(&#x27;Unknown patch type &#x27; + currentPatch.type)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5、结语</p>\n<p>virtual DOM 算法主要实现上面步骤的三个函数： element、diff、patch，然后就可以实际的进行使用了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 1. 构建虚拟DOM</span><br><span class=\"line\">var tree = el(&#x27;div&#x27;, &#123;&#x27;id&#x27;: &#x27;container&#x27;&#125;, [</span><br><span class=\"line\">    el(&#x27;h1&#x27;, &#123;style: &#x27;color: blue&#x27;&#125;, [&#x27;simple virtal dom&#x27;]),</span><br><span class=\"line\">    el(&#x27;p&#x27;, [&#x27;Hello, virtual-dom&#x27;]),</span><br><span class=\"line\">    el(&#x27;ul&#x27;, [el(&#x27;li&#x27;)])</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 通过虚拟DOM构建真正的DOM</span><br><span class=\"line\">var root = tree.render()</span><br><span class=\"line\">document.body.appendChild(root)</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. 生成新的虚拟DOM</span><br><span class=\"line\">var newTree = el(&#x27;div&#x27;, &#123;&#x27;id&#x27;: &#x27;container&#x27;&#125;, [</span><br><span class=\"line\">    el(&#x27;h1&#x27;, &#123;style: &#x27;color: red&#x27;&#125;, [&#x27;simple virtal dom&#x27;]),</span><br><span class=\"line\">    el(&#x27;p&#x27;, [&#x27;Hello, virtual-dom&#x27;]),</span><br><span class=\"line\">    el(&#x27;ul&#x27;, [el(&#x27;li&#x27;), el(&#x27;li&#x27;)])</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">// 4. 比较两棵虚拟DOM树的不同</span><br><span class=\"line\">var patches = diff(tree, newTree)</span><br><span class=\"line\"></span><br><span class=\"line\">// 5. 在真正的DOM元素上应用变更</span><br><span class=\"line\">patch(root, patches)</span><br></pre></td></tr></table></figure>\n\n<p>当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的 ReactJS 了。</p>\n<ul>\n<li>源码地址： <a href=\"https://github.com/livoras/simple-virtual-dom\">https://github.com/livoras/simple-virtual-dom</a></li>\n<li>参考文章：<a href=\"https://github.com/livoras/blog/issues/13\">https://github.com/livoras/blog/issues/13</a></li>\n</ul>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"讲讲PWA","url":"/2022/10/24/%E8%AE%B2%E8%AE%B2PWA/","content":"<h2 id=\"一、背景\"><a href=\"#一、背景\" class=\"headerlink\" title=\"一、背景\"></a>一、背景</h2><p>大家都知道 Native app 体验确实很好，下载到手机上之后入口也方便。它也有一些缺点:</p>\n<ul>\n<li>开发成本高(ios 和安卓)</li>\n<li>软件上线需要审核</li>\n<li>版本更新需要将新版本上传到不同的应用商店</li>\n<li>想使用一个 app 就必须去下载才能使用，即使是偶尔需要使用一下下</li>\n</ul>\n<p>而 web 网页开发成本低，网站更新时上传最新的资源到服务器即可，用手机带的浏览器打开就可以使用。但是除了体验上比 Native app 还是差一些，还有一些明显的缺点</p>\n<ul>\n<li>手机桌面入口不够便捷，想要进入一个页面必须要记住它的 url 或者加入书签</li>\n<li>没网络就没响应，不具备离线能力</li>\n<li>不像 APP 一样能进行消息推送<br>那么什么是 PWA 呢？</li>\n</ul>\n<h2 id=\"二、What’s-PWA\"><a href=\"#二、What’s-PWA\" class=\"headerlink\" title=\"二、What’s PWA?\"></a>二、What’s PWA?</h2><p>PWA 全称 Progressive Web App，即渐进式 WEB 应用。</p>\n<p>一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能<br>解决了哪些问题？</p>\n<ul>\n<li>可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏</li>\n<li>实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能</li>\n<li>实现了消息推送<br>它解决了上述提到的问题，这些特性将使得 Web 应用渐进式接近原生 App。</li>\n</ul>\n<h2 id=\"三、PWA-的实现\"><a href=\"#三、PWA-的实现\" class=\"headerlink\" title=\"三、PWA 的实现\"></a>三、PWA 的实现</h2><h3 id=\"3-1-Manifest-实现添加至主屏幕\"><a href=\"#3-1-Manifest-实现添加至主屏幕\" class=\"headerlink\" title=\"3.1 Manifest 实现添加至主屏幕\"></a>3.1 Manifest 实现添加至主屏幕</h3><p><strong>index.html</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;title&gt;Minimal PWA&lt;/title&gt;</span><br><span class=\"line\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot; /&gt;</span><br><span class=\"line\">  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt;</span><br><span class=\"line\">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;main.css&quot;&gt;</span><br><span class=\"line\">  &lt;link rel=&quot;icon&quot; href=&quot;/e.png&quot; type=&quot;image/png&quot; /&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>manifest.json</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;Minimal PWA&quot;, // 必填 显示的插件名称</span><br><span class=\"line\">  &quot;short_name&quot;: &quot;PWA Demo&quot;, // 可选  在APP launcher和新的tab页显示，如果没有设置，则使用name</span><br><span class=\"line\">  &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //用于描述应用</span><br><span class=\"line\">  &quot;display&quot;: &quot;standalone&quot;, // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的</span><br><span class=\"line\">  &quot;start_url&quot;: &quot;/&quot;, // 应用启动时的url</span><br><span class=\"line\">  &quot;theme_color&quot;: &quot;#313131&quot;, // 桌面图标的背景色</span><br><span class=\"line\">  &quot;background_color&quot;: &quot;#313131&quot;, // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。</span><br><span class=\"line\">  &quot;icons&quot;: [ // 桌面图标，是一个数组</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &quot;src&quot;: &quot;icon/lowres.webp&quot;,</span><br><span class=\"line\">    &quot;sizes&quot;: &quot;48x48&quot;,  // 以空格分隔的图片尺寸</span><br><span class=\"line\">    &quot;type&quot;: &quot;image/webp&quot;  // 帮助userAgent快速排除不支持的类型</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;src&quot;: &quot;icon/lowres&quot;,</span><br><span class=\"line\">    &quot;sizes&quot;: &quot;48x48&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;src&quot;: &quot;icon/hd_hi.ico&quot;,</span><br><span class=\"line\">    &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;src&quot;: &quot;icon/hd_hi.svg&quot;,</span><br><span class=\"line\">    &quot;sizes&quot;: &quot;72x72&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Manifest 参考文档：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Manifest\">https://developer.mozilla.org/zh-CN/docs/Web/Manifest</a><br>可以打开网站 <a href=\"https://developers.google.cn/web/showcase/2015/chrome-dev-summit\">https://developers.google.cn/web/showcase/2015/chrome-dev-summit</a> 查看添加至主屏幕的动图。</p>\n<p>如果用的是安卓手机，可以下载 chrome 浏览器自己操作看看</p>\n</blockquote>\n<h3 id=\"3-2-service-worker-实现离线缓存\"><a href=\"#3-2-service-worker-实现离线缓存\" class=\"headerlink\" title=\"3.2 service worker 实现离线缓存\"></a>3.2 service worker 实现离线缓存</h3><h4 id=\"3-2-1-什么是-service-worker\"><a href=\"#3-2-1-什么是-service-worker\" class=\"headerlink\" title=\"3.2.1 什么是 service worker\"></a>3.2.1 什么是 service worker</h4><p>Service Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000012353478?w=747&h=240\" alt=\"image\"></p>\n<p>Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的 HTTP 请求，从而完全控制你的网站。</p>\n<p><strong>最主要的特点</strong></p>\n<ul>\n<li>在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。</li>\n<li>网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost)</li>\n<li>运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求</li>\n<li>单独的作用域范围，单独的运行环境和执行线程</li>\n<li>不能操作页面 DOM。但可以通过事件机制来处理</li>\n<li>事件驱动型服务线程<blockquote>\n<p>为什么要求网站必须是 HTTPS 的，大概是因为 service worker 权限太大能拦截所有页面的请求吧，如果 http 的网站安装 service worker 很容易被攻击</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>浏览器支持情况</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000012353479?w=2494&h=588\" alt=\"image\"></p>\n<blockquote>\n<p>浏览器支持情况详见： <a href=\"https://caniuse.com/#feat=serviceworkers\">https://caniuse.com/#feat=serviceworkers</a></p>\n</blockquote>\n<p><strong>生命周期</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000012353480?w=726&h=629\" alt=\"image\"></p>\n<p>当用户首次导航至 URL 时，服务器会返回响应的网页。</p>\n<ul>\n<li>第 1 步:当你调用 register() 函数时， Service Worker 开始下载。</li>\n<li>第 2 步:在注册过程中，浏览器会下载、解析并执行 Service Worker ()。如果在此步骤中出现任何错误，register() 返回的 promise 都会执行 reject 操作，并且 Service Worker 会被废弃。</li>\n<li>第 3 步:一旦 Service Worker 成功执行了，install 事件就会激活</li>\n<li>第 4 步:安装完成，Service Worker 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，Service Worker 便已准备就绪，随时可以使用了！</li>\n</ul>\n<blockquote>\n<p>chrome:&#x2F;&#x2F;serviceworker-internals 来了解当前浏览器中所有已安装 Service Worker 的详细情况</p>\n</blockquote>\n<h4 id=\"3-2-2-HTTP-缓存与-service-worker-缓存\"><a href=\"#3-2-2-HTTP-缓存与-service-worker-缓存\" class=\"headerlink\" title=\"3.2.2 HTTP 缓存与 service worker 缓存\"></a>3.2.2 HTTP 缓存与 service worker 缓存</h4><p><strong>HTTP 缓存</strong><br>Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。<br>使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期。</p>\n<p><strong>service worker 缓存</strong></p>\n<p>Service Workers 的强大在于它们拦截 HTTP 请求的能力<br>进入任何传入的 HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！</p>\n<h4 id=\"3-2-3-实现离线缓存\"><a href=\"#3-2-3-实现离线缓存\" class=\"headerlink\" title=\"3.2.3 实现离线缓存\"></a>3.2.3 实现离线缓存</h4><p><strong>index.html</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Hello Caching World!&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;!-- Image --&gt;</span><br><span class=\"line\">    &lt;img src=&quot;/images/hello.png&quot; /&gt;</span><br><span class=\"line\">    &lt;!-- JavaScript --&gt;</span><br><span class=\"line\">    &lt;script async src=&quot;/js/script.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">      // 注册 service worker</span><br><span class=\"line\">      if (&#x27;serviceWorker&#x27; in navigator) &#123;</span><br><span class=\"line\">        navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;, &#123;scope: &#x27;/&#x27;&#125;).then(function (registration) &#123;</span><br><span class=\"line\">          // 注册成功</span><br><span class=\"line\">          console.log(&#x27;ServiceWorker registration successful with scope: &#x27;, registration.scope);</span><br><span class=\"line\">        &#125;).catch(function (err) &#123;</span><br><span class=\"line\">          // 注册失败 :(</span><br><span class=\"line\">          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注：Service Worker 的注册路径决定了其 scope 默认作用页面的范围。<br>如果 service-worker.js 是在 &#x2F;sw&#x2F; 页面路径下，这使得该 Service Worker 默认只会收到 页面&#x2F;sw&#x2F; 路径下的 fetch 事件。<br>如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。<br>如果希望改变它的作用域，可在第二个参数设置 scope 范围。示例中将其改为了根目录，即对整个站点生效。</p>\n</blockquote>\n<p><strong>service-worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var cacheName = &#x27;helloWorld&#x27;;     // 缓存的名称</span><br><span class=\"line\">// install 事件，它发生在浏览器安装并注册 Service Worker 时</span><br><span class=\"line\">self.addEventListener(&#x27;install&#x27;, event =&gt; &#123;</span><br><span class=\"line\">/* event.waitUtil 用于在安装成功之前执行一些预装逻辑</span><br><span class=\"line\"> 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率</span><br><span class=\"line\"> 安装成功后 ServiceWorker 状态会从 installing 变为 installed */</span><br><span class=\"line\">  event.waitUntil(</span><br><span class=\"line\">    caches.open(cacheName)</span><br><span class=\"line\">    .then(cache =&gt; cache.addAll([    // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。</span><br><span class=\"line\">      &#x27;/js/script.js&#x27;,</span><br><span class=\"line\">      &#x27;/images/hello.png&#x27;</span><br><span class=\"line\">    ]))</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。</span><br><span class=\"line\">如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。</span><br><span class=\"line\">*/</span><br><span class=\"line\">self.addEventListener(&#x27;fetch&#x27;, function (event) &#123;</span><br><span class=\"line\">  event.respondWith(</span><br><span class=\"line\">    caches.match(event.request)</span><br><span class=\"line\">    .then(function (response) &#123;</span><br><span class=\"line\">      if (response) &#123;</span><br><span class=\"line\">        return response;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      var requestToCache = event.request.clone();  //</span><br><span class=\"line\">      return fetch(requestToCache).then(</span><br><span class=\"line\">        function (response) &#123;</span><br><span class=\"line\">          if (!response || response.status !== 200) &#123;</span><br><span class=\"line\">            return response;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          var responseToCache = response.clone();</span><br><span class=\"line\">          caches.open(cacheName)</span><br><span class=\"line\">            .then(function (cache) &#123;</span><br><span class=\"line\">              cache.put(requestToCache, responseToCache);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          return response;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注：为什么用 request.clone()和 response.clone()<br>需要这么做是因为 request 和 response 是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 HTTP 请求还要再消耗一次，所以我们需要在此时克隆请求<br>Clone the request—a request is a stream and can only be consumed once.</p>\n</blockquote>\n<h3 id=\"3-2-4-调试相关\"><a href=\"#3-2-4-调试相关\" class=\"headerlink\" title=\"3.2.4 调试相关\"></a>3.2.4 调试相关</h3><p>chrome 浏览器打开 <a href=\"https://googlechrome.github.io/samples/service-worker/basic/index.html\">https://googlechrome.github.io/samples/service-worker/basic/index.html</a> ，这是一个实现了 service worker 离线缓存功能的网站，打开调试工具</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000012353481?w=1438&h=430\" alt=\"image\"></p>\n<p>介绍一个图中的 1.和 2.</p>\n<ol>\n<li>勾选可以模拟网站离线情况，勾选后 network 会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示</li>\n<li>当前 service worker 的 scope。它能够拦截 h<a href=\"https://googlechrome.github.io/samples/service-worker/basic/index.html%E4%B8%8B%E7%9A%84%E8%AF%B7%E6%B1%82\">ttps:&#x2F;&#x2F;googlechrome.github.i…</a>，同样也能够拦截<a href=\"https://googlechrome.github.io/samples/service-worker/basic/\">https://googlechrome.github.i...</a>下的请求</li>\n</ol>\n<blockquote>\n<p>调试面板具体代表的什么参看 <a href=\"https://x5.tencent.com/tbs/guide/serviceworker.html\">https://x5.tencent.com/tbs/guide/serviceworker.html</a> 的第三部分</p>\n</blockquote>\n<h3 id=\"3-3-service-worker-实现消息推送\"><a href=\"#3-3-service-worker-实现消息推送\" class=\"headerlink\" title=\"3.3 service worker 实现消息推送\"></a>3.3 service worker 实现消息推送</h3><p><img src=\"https://segmentfault.com/img/remote/1460000012353482?w=677&h=368\" alt=\"image\"></p>\n<ul>\n<li>步骤一、提示用户并获得他们的订阅详细信息</li>\n<li>步骤二、将这些详细信息保存在服务器上</li>\n<li>步骤三、在需要时发送任何消息<blockquote>\n<p>不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging<GCM> 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>步骤一和步骤二</strong><br><strong>index.html</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Progressive Times&lt;/title&gt;</span><br><span class=\"line\">    &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">      var endpoint;</span><br><span class=\"line\">      var key;</span><br><span class=\"line\">      var authSecret;</span><br><span class=\"line\">      var vapidPublicKey = &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;;</span><br><span class=\"line\">      // 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用</span><br><span class=\"line\">      function urlBase64ToUint8Array(base64String) &#123;</span><br><span class=\"line\">        const padding = &#x27;=&#x27;.repeat((4 - base64String.length % 4) % 4);</span><br><span class=\"line\">        const base64 = (base64String + padding)</span><br><span class=\"line\">          .replace(/\\-/g, &#x27;+&#x27;)</span><br><span class=\"line\">          .replace(/_/g, &#x27;/&#x27;);</span><br><span class=\"line\">        const rawData = window.atob(base64);</span><br><span class=\"line\">        const outputArray = new Uint8Array(rawData.length);</span><br><span class=\"line\">        for (let i = 0; i &lt; rawData.length; ++i) &#123;</span><br><span class=\"line\">          outputArray[i] = rawData.charCodeAt(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return outputArray;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (&#x27;serviceWorker&#x27; in navigator) &#123;</span><br><span class=\"line\">        navigator.serviceWorker.register(&#x27;sw.js&#x27;).then(function (registration) &#123;</span><br><span class=\"line\">          return registration.pushManager.getSubscription()</span><br><span class=\"line\">            .then(function (subscription) &#123;</span><br><span class=\"line\">              if (subscription) &#123;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              return registration.pushManager.subscribe(&#123;</span><br><span class=\"line\">                  userVisibleOnly: true,</span><br><span class=\"line\">                  applicationServerKey: urlBase64ToUint8Array(vapidPublicKey)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .then(function (subscription) &#123;</span><br><span class=\"line\">                  var rawKey = subscription.getKey ? subscription.getKey(&#x27;p256dh&#x27;) : &#x27;&#x27;;</span><br><span class=\"line\">                  key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : &#x27;&#x27;;</span><br><span class=\"line\">                  var rawAuthSecret = subscription.getKey ? subscription.getKey(&#x27;auth&#x27;) : &#x27;&#x27;;</span><br><span class=\"line\">                  authSecret = rawAuthSecret ?</span><br><span class=\"line\">                    btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : &#x27;&#x27;;</span><br><span class=\"line\">                  endpoint = subscription.endpoint;</span><br><span class=\"line\">                  return fetch(&#x27;./register&#x27;, &#123;</span><br><span class=\"line\">                    method: &#x27;post&#x27;,</span><br><span class=\"line\">                    headers: new Headers(&#123;</span><br><span class=\"line\">                      &#x27;content-type&#x27;: &#x27;application/json&#x27;</span><br><span class=\"line\">                    &#125;),</span><br><span class=\"line\">                    body: JSON.stringify(&#123;</span><br><span class=\"line\">                      endpoint: subscription.endpoint,</span><br><span class=\"line\">                      key: key,</span><br><span class=\"line\">                      authSecret: authSecret,</span><br><span class=\"line\">                    &#125;),</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;).catch(function (err) &#123;</span><br><span class=\"line\">          // 注册失败 :(</span><br><span class=\"line\">          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>步骤三 服务器发送消息给 service worker</strong></p>\n<p>app.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const webpush = require(&#x27;web-push&#x27;);</span><br><span class=\"line\">const express = require(&#x27;express&#x27;);</span><br><span class=\"line\">var bodyParser = require(&#x27;body-parser&#x27;);</span><br><span class=\"line\">const app = express();</span><br><span class=\"line\">webpush.setVapidDetails(</span><br><span class=\"line\">  &#x27;mailto:contact@deanhume.com&#x27;,</span><br><span class=\"line\">  &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;,</span><br><span class=\"line\">  &#x27;p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0&#x27;</span><br><span class=\"line\">);</span><br><span class=\"line\">app.post(&#x27;/register&#x27;, function (req, res) &#123;</span><br><span class=\"line\">  var endpoint = req.body.endpoint;</span><br><span class=\"line\">  saveRegistrationDetails(endpoint, key, authSecret);</span><br><span class=\"line\">  const pushSubscription = &#123;</span><br><span class=\"line\">    endpoint: req.body.endpoint,</span><br><span class=\"line\">    keys: &#123;</span><br><span class=\"line\">      auth: req.body.authSecret,</span><br><span class=\"line\">      p256dh: req.body.key</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  var body = &#x27;Thank you for registering&#x27;;</span><br><span class=\"line\">  var iconUrl = &#x27;https://example.com/images/homescreen.png&#x27;;</span><br><span class=\"line\">  // 发送 Web 推送消息</span><br><span class=\"line\">  webpush.sendNotification(pushSubscription,</span><br><span class=\"line\">      JSON.stringify(&#123;</span><br><span class=\"line\">        msg: body,</span><br><span class=\"line\">        url: &#x27;http://localhost:3111/&#x27;,</span><br><span class=\"line\">        icon: iconUrl</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    .then(result =&gt; res.sendStatus(201))</span><br><span class=\"line\">    .catch(err =&gt; &#123;</span><br><span class=\"line\">      console.log(err);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.listen(3111, function () &#123;</span><br><span class=\"line\">  console.log(&#x27;Web push app listening on port 3111!&#x27;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>service worker 监听 push 事件，将通知详情推送给用户</strong></p>\n<p>service-worker.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#x27;push&#x27;, function (event) &#123;</span><br><span class=\"line\"> // 检查服务端是否发来了任何有效载荷数据</span><br><span class=\"line\">  var payload = event.data ? JSON.parse(event.data.text()) : &#x27;no payload&#x27;;</span><br><span class=\"line\">  var title = &#x27;Progressive Times&#x27;;</span><br><span class=\"line\">  event.waitUntil(</span><br><span class=\"line\">    // 使用提供的信息来显示 Web 推送通知</span><br><span class=\"line\">    self.registration.showNotification(title, &#123;</span><br><span class=\"line\">      body: payload.msg,</span><br><span class=\"line\">      url: payload.url,</span><br><span class=\"line\">      icon: payload.icon</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>扩展知识：<a href=\"https://lzw.me/a/pwa-service-worker.html#3.3\">service worker 的更新</a></p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"PWA-的优势\"><a href=\"#PWA-的优势\" class=\"headerlink\" title=\"PWA 的优势\"></a>PWA 的优势</h3><ul>\n<li>可以将 app 的快捷方式放置到桌面上，全屏运行，与原生 app 无异</li>\n<li>能够在各种网络环境下使用，包括网络差和断网条件下，不会显示 undefined</li>\n<li>推送消息的能力</li>\n<li>其本质是一个网页，没有原生 app 的各种启动条件，快速响应用户指令</li>\n</ul>\n<h3 id=\"PWA-存在的问题\"><a href=\"#PWA-存在的问题\" class=\"headerlink\" title=\"PWA 存在的问题\"></a>PWA 存在的问题</h3><ul>\n<li>支持率不高:现在 ios 手机端不支持 pwa，IE 也暂时不支持</li>\n<li>Chrome 在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低</li>\n<li>各大厂商还未明确支持 pwa</li>\n<li>依赖的 GCM 服务在国内无法使用</li>\n<li>微信小程序的竞争</li>\n</ul>\n<p>尽管有上述的一些缺点，PWA 技术仍然有很多可以使用的点。</p>\n<ul>\n<li>service worker 技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。</li>\n<li>service worker 实现消息推送，使用浏览器推送功能，吸引用户</li>\n<li>渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验。</li>\n</ul>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"数据结构有哪些，常用数据结构详解","url":"/2022/12/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/","content":"<p>数据结构大致包含以下几种存储结构：</p>\n<ul>\n<li>线性表，还可细分为顺序表、链表、栈和队列；</li>\n<li>树结构，包括普通树，二叉树，线索二叉树等；</li>\n<li>图存储结构；</li>\n</ul>\n<p>下面对各种数据结构做详细讲解。</p>\n<h2 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h2><p>线性表结构存储的数据往往是可以依次排列的，就像小朋友手拉手，每位学生的前面和后面都仅有一个小朋友和他拉手，具备这种“一对一”关系的数据就可以使用线性表来存储。</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH151411.gif\" alt=\"image\"></p>\n<p>例如，存储类似 {1,3,5,7,9} 这样的数据时，各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（除首元素和尾元素），因此可以使用线性表存储。</p>\n<p>线性表并不是一种具体的存储结构，它包含顺序存储结构和链式存储结构，是顺序表和链表的统称。</p>\n<h3 id=\"顺序表\"><a href=\"#顺序表\" class=\"headerlink\" title=\"顺序表\"></a>顺序表</h3><p>顺序表，简单地理解，就是常用的数组，只是换了个名字而已，例如使用顺序表存储 {1,3,5,7,9}，如图 1 所示：</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QI9559D.gif\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">由于顺序表结构的底层实现借助的就是数组，因此对于初学者来说，可以把顺序表完全等价为数组，但实则不是这样。数据结构是研究数据存储方式的一门学科，它囊括的都是各种存储结构，而数组只是各种编程语言中的基本数据类型，并不属于数据结构的范畴。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><p>我们知道，使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的，如图 1 所示。</p>\n<p>链表则完全不同，使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。</p>\n<p>为了给各个数据块建立“依次排列”的关系，链表给各数据块增设一个指针，每个数据块的指针都指向下一个数据块（最后一个数据块的指针指向 NULL），就如同一个个小学生都伸手去拉住下一个小学生的手，这样，看似毫无关系的数据块就建立了“依次排列”的关系，也就形成了链表，如图 2 所示：</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH334H1.gif\" alt=\"image\"></p>\n<h3 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h3><p>栈和队列隶属于线性表，是特殊的线性表，因为它们对线性表中元素的进出做了明确的要求。</p>\n<p>栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈。</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH634D9.gif\" alt=\"image\"></p>\n<p>栈结构如图 3 所示，像一个木桶，栈中含有 3 个元素，分别是 A、B 和 C，从在栈中的状态可以看出 A 最先进的栈，然后 B 进栈，最后 C 进栈。根据“先进后出”的原则，3 个元素出栈的顺序应该是：C 最先出栈，然后 B 出栈，最后才是 A 出栈。</p>\n<p>队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列。</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QHIJO.gif\" alt=\"image\"></p>\n<p>队列结构如图 4 所示，队列中有 3 个元素，分别是 A、B 和 C，从在队列中的状态可以看出是 A 先进队列，然后 B 进，最后 C 进。根据“先进先出”的原则，3 个元素出队列的顺序应该是 A 最先出队列，然后 B 出，最后 C 出。</p>\n<h2 id=\"树存储结构\"><a href=\"#树存储结构\" class=\"headerlink\" title=\"树存储结构\"></a>树存储结构</h2><p>树存储结构适合存储具有“一对多”关系的数据。</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QJJ0142.gif\" alt=\"image\"></p>\n<p>如图 5 所示，其中张平只有一个父亲，但他却有两（多）个孩子，这就是“一对多”的关系，满足这种关系的数据可以使用树存储结构。</p>\n<h2 id=\"图存储结构\"><a href=\"#图存储结构\" class=\"headerlink\" title=\"图存储结构\"></a>图存储结构</h2><p>图存储结构适合存储具有“多对多”关系的数据。</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QIFS44.gif\" alt=\"image\"></p>\n<p>如图 6 所示，从 V1 可以到达 V2、V3、V4，同样，从 V2、V3、V4 也可以到达 V1，这就是“多对多”的关系，满足这种关系的数据可以使用图存储结构。</p>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"前端面试中的常见的算法问题","url":"/2022/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/","content":"<h2 id=\"Q1-判断一个单词是否是回文？\"><a href=\"#Q1-判断一个单词是否是回文？\" class=\"headerlink\" title=\"Q1 判断一个单词是否是回文？\"></a>Q1 判断一个单词是否是回文？</h2><blockquote>\n<p>回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider .</p>\n</blockquote>\n<p>很多人拿到这样的题目非常容易想到用 for 将字符串颠倒字母顺序然后匹配就行了。其实重要的考察的就是对于 reverse 的实现。其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function checkPalindrom(str) &#123;</span><br><span class=\"line\">    return str == str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q2-去掉一组整型数组重复的值\"><a href=\"#Q2-去掉一组整型数组重复的值\" class=\"headerlink\" title=\"Q2 去掉一组整型数组重复的值\"></a>Q2 去掉一组整型数组重复的值</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">比如输入: [1,13,24,11,11,14,1,2]</span><br><span class=\"line\">输出: [1,13,24,11,14,2]</span><br><span class=\"line\">需要去掉重复的11 和 1 这两个元素。</span><br></pre></td></tr></table></figure>\n\n<p>这道问题出现在诸多的前端面试题中，主要考察个人对 Object 的使用，利用 key 来进行筛选。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* unique an array</span><br><span class=\"line\">**/</span><br><span class=\"line\">let unique = function(arr) &#123;</span><br><span class=\"line\">  let hashTable = &#123;&#125;;</span><br><span class=\"line\">  let data = [];</span><br><span class=\"line\">  for(let i=0,l=arr.length;i&lt;l;i++) &#123;</span><br><span class=\"line\">    if(!hashTable[arr[i]]) &#123;</span><br><span class=\"line\">      hashTable[arr[i]] = true;</span><br><span class=\"line\">      data.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return data</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = unique;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q3-统计一个字符串出现最多的字母\"><a href=\"#Q3-统计一个字符串出现最多的字母\" class=\"headerlink\" title=\"Q3 统计一个字符串出现最多的字母\"></a>Q3 统计一个字符串出现最多的字母</h2><p>给出一段英文连续的英文字符串，找出重复出现次数最多的字母</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入 ： afjghdfraaaasdenas</span><br><span class=\"line\"></span><br><span class=\"line\">输出 ： a</span><br></pre></td></tr></table></figure>\n\n<p>前面出现过去重的算法，这里需要是统计重复次数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function findMaxDuplicateChar(str) &#123;</span><br><span class=\"line\">  if(str.length == 1) &#123;</span><br><span class=\"line\">    return str;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let charObj = &#123;&#125;;</span><br><span class=\"line\">  for(let i=0;i&lt;str.length;i++) &#123;</span><br><span class=\"line\">    if(!charObj[str.charAt(i)]) &#123;</span><br><span class=\"line\">      charObj[str.charAt(i)] = 1;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">      charObj[str.charAt(i)] += 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let maxChar = &#x27;&#x27;,</span><br><span class=\"line\">      maxValue = 1;</span><br><span class=\"line\">  for(var k in charObj) &#123;</span><br><span class=\"line\">    if(charObj[k] &gt;= maxValue) &#123;</span><br><span class=\"line\">      maxChar = k;</span><br><span class=\"line\">      maxValue = charObj[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return maxChar;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = findMaxDuplicateChar;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q4-排序算法\"><a href=\"#Q4-排序算法\" class=\"headerlink\" title=\"Q4 排序算法\"></a>Q4 排序算法</h2><p>如果抽到算法题目的话，应该大多都是比较开放的题目，不限定算法的实现，但是一定要求掌握其中的几种，所以冒泡排序，这种较为基础并且便于理解记忆的算法一定需要熟记于心。冒泡排序算法就是依次比较大小，小的的大的进行位置上的交换。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function bubbleSort(arr) &#123;</span><br><span class=\"line\">    for(let i = 0,l=arr.length;i&lt;l-1;i++) &#123;</span><br><span class=\"line\">        for(let j = i+1;j&lt;l;j++) &#123;</span><br><span class=\"line\">          if(arr[i]&gt;arr[j]) &#123;</span><br><span class=\"line\">                let tem = arr[i];</span><br><span class=\"line\">                arr[i] = arr[j];</span><br><span class=\"line\">                arr[j] = tem;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = bubbleSort;</span><br></pre></td></tr></table></figure>\n\n<p>除了冒泡排序外，其实还有很多诸如 插入排序,快速排序，希尔排序等。每一种排序算法都有各自的特点。全部掌握也不需要，但是心底一定要熟悉几种算法。 比如快速排序，其效率很高，而其基本原理如图(来自 wiki)：</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif\" alt=\"image\"></p>\n<p>算法参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function quickSort(arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if(arr.length&lt;=1) &#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    let leftArr = [];</span><br><span class=\"line\">    let rightArr = [];</span><br><span class=\"line\">    let q = arr[0];</span><br><span class=\"line\">    for(let i = 1,l=arr.length; i&lt;l; i++) &#123;</span><br><span class=\"line\">        if(arr[i]&gt;q) &#123;</span><br><span class=\"line\">            rightArr.push(arr[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            leftArr.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return [].concat(quickSort(leftArr),[q],quickSort(rightArr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = quickSort;</span><br></pre></td></tr></table></figure>\n\n<p>安利大家一个学习的地址，通过动画演示算法的实现。<br><a href=\"http://math.hws.edu/eck/jsdemo/sortlab.html\">HTML5 Canvas Demo: Sorting Algorithms</a></p>\n<h2 id=\"Q5-不借助临时变量，进行两个整数的交换\"><a href=\"#Q5-不借助临时变量，进行两个整数的交换\" class=\"headerlink\" title=\"Q5 不借助临时变量，进行两个整数的交换\"></a>Q5 不借助临时变量，进行两个整数的交换</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入 a = 2, b = 4 输出 a = 4, b =2</span><br></pre></td></tr></table></figure>\n\n<p>这种问题非常巧妙，需要大家跳出惯有的思维，利用 a , b 进行置换。</p>\n<p>主要是利用 + - 去进行运算，类似 a &#x3D; a + ( b - a) 实际上等同于最后 的 a &#x3D; b;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function swap(a , b) &#123;</span><br><span class=\"line\">  b = b - a;</span><br><span class=\"line\">  a = a + b;</span><br><span class=\"line\">  b = a - b;</span><br><span class=\"line\">  return [a,b];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = swap;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q6-使用-canvas-绘制一个有限度的斐波那契数列的曲线？\"><a href=\"#Q6-使用-canvas-绘制一个有限度的斐波那契数列的曲线？\" class=\"headerlink\" title=\"Q6 使用 canvas 绘制一个有限度的斐波那契数列的曲线？\"></a>Q6 使用 canvas 绘制一个有限度的斐波那契数列的曲线？</h2><p><img src=\"http://img1.vued.vanthink.cn/vued90edf7b944ec479ee8b4203cf56e158d.png\" alt=\"image\"></p>\n<p>数列长度限定在 9.</p>\n<p>斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列主要考察递归的调用。我们一般都知道定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fibo[i] = fibo[i-1]+fibo[i-2];</span><br></pre></td></tr></table></figure>\n\n<p>生成斐波那契数组的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getFibonacci(n) &#123;</span><br><span class=\"line\">  var fibarr = [];</span><br><span class=\"line\">  var i = 0;</span><br><span class=\"line\">  while(i&lt;n) &#123;</span><br><span class=\"line\">    if(i&lt;=1) &#123;</span><br><span class=\"line\">      fibarr.push(i);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">      fibarr.push(fibarr[i-1] + fibarr[i-2])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return fibarr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>剩余的工作就是利用 canvas arc 方法进行曲线绘制了</p>\n<p><a href=\"http://codepen.io/Jack_Pu/pen/LRaxZB\">DEMO</a></p>\n<h2 id=\"Q7-找出下列正数组的最大差值比如\"><a href=\"#Q7-找出下列正数组的最大差值比如\" class=\"headerlink\" title=\"Q7 找出下列正数组的最大差值比如:\"></a>Q7 找出下列正数组的最大差值比如:</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入 [10,5,11,7,8,9]</span><br><span class=\"line\"></span><br><span class=\"line\">输出 6</span><br></pre></td></tr></table></figure>\n\n<p>这是通过一道题目去测试对于基本的数组的最大值的查找，很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getMaxProfit(arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var minPrice = arr[0];</span><br><span class=\"line\">    var maxProfit = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        var currentPrice = arr[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        minPrice = Math.min(minPrice, currentPrice);</span><br><span class=\"line\"></span><br><span class=\"line\">        var potentialProfit = currentPrice - minPrice;</span><br><span class=\"line\"></span><br><span class=\"line\">        maxProfit = Math.max(maxProfit, potentialProfit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return maxProfit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q8-随机生成指定长度的字符串\"><a href=\"#Q8-随机生成指定长度的字符串\" class=\"headerlink\" title=\"Q8 随机生成指定长度的字符串\"></a>Q8 随机生成指定长度的字符串</h2><p>实现一个算法，随机生成指定长度的字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">比如给定 长度 8  输出 4ldkfg9j</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function randomString(n) &#123;</span><br><span class=\"line\">  let str = &#x27;abcdefghijklmnopqrstuvwxyz9876543210&#x27;;</span><br><span class=\"line\">  let tmp = &#x27;&#x27;,</span><br><span class=\"line\">      i = 0,</span><br><span class=\"line\">      l = str.length;</span><br><span class=\"line\">  for (i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">    tmp += str.charAt(Math.floor(Math.random() * l));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = randomString;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q9-实现类似-getElementsByClassName-的功能\"><a href=\"#Q9-实现类似-getElementsByClassName-的功能\" class=\"headerlink\" title=\"Q9 实现类似 getElementsByClassName 的功能\"></a>Q9 实现类似 getElementsByClassName 的功能</h2><p>自己实现一个函数，查找某个 DOM 节点下面的包含某个 class 的所有 DOM 节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供 DOM 查找函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function queryClassName(node, name) &#123;</span><br><span class=\"line\">  var starts = &#x27;(^|[ \\n\\r\\t\\f])&#x27;,</span><br><span class=\"line\">       ends = &#x27;([ \\n\\r\\t\\f]|$)&#x27;;</span><br><span class=\"line\">  var array = [],</span><br><span class=\"line\">        regex = new RegExp(starts + name + ends),</span><br><span class=\"line\">        elements = node.getElementsByTagName(&quot;*&quot;),</span><br><span class=\"line\">        length = elements.length,</span><br><span class=\"line\">        i = 0,</span><br><span class=\"line\">        element;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (i &lt; length) &#123;</span><br><span class=\"line\">        element = elements[i];</span><br><span class=\"line\">        if (regex.test(element.className)) &#123;</span><br><span class=\"line\">            array.push(element);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        i += 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q10-使用-JS-实现二叉查找树-Binary-Search-Tree\"><a href=\"#Q10-使用-JS-实现二叉查找树-Binary-Search-Tree\" class=\"headerlink\" title=\"Q10 使用 JS 实现二叉查找树(Binary Search Tree)\"></a>Q10 使用 JS 实现二叉查找树(Binary Search Tree)</h2><p>一般叫全部写完的概率比较少，但是重点考察你对它的理解和一些基本特点的实现。 二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树：</p>\n<ul>\n<li>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>\n<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>\n<li>任意节点的左、右子树也分别为二叉查找树；</li>\n<li>没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。</li>\n</ul>\n<p><img src=\"http://img1.vued.vanthink.cn/vued95685e8f89199babd6273a93651ecd8b.png\" alt=\"image\"></p>\n<p>在写的时候需要足够理解二叉搜素树的特点，需要先设定好每个节点的数据结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Node &#123;</span><br><span class=\"line\">  constructor(data, left, right) &#123;</span><br><span class=\"line\">    this.data = data;</span><br><span class=\"line\">    this.left = left;</span><br><span class=\"line\">    this.right = right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>树是有节点构成，由根节点逐渐延生到各个子节点，因此它具备基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class BinarySearchTree &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.root = null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  insert(data) &#123;</span><br><span class=\"line\">    let n = new Node(data, null, null);</span><br><span class=\"line\">    if (!this.root) &#123;</span><br><span class=\"line\">      return this.root = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let currentNode = this.root;</span><br><span class=\"line\">    let parent = null;</span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">      parent = currentNode;</span><br><span class=\"line\">      if (data &lt; currentNode.data) &#123;</span><br><span class=\"line\">        currentNode = currentNode.left;</span><br><span class=\"line\">        if (currentNode === null) &#123;</span><br><span class=\"line\">          parent.left = n;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        currentNode = currentNode.right;</span><br><span class=\"line\">        if (currentNode === null) &#123;</span><br><span class=\"line\">          parent.right = n;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  remove(data) &#123;</span><br><span class=\"line\">    this.root = this.removeNode(this.root, data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  removeNode(node, data) &#123;</span><br><span class=\"line\">    if (node == null) &#123;</span><br><span class=\"line\">      return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (data == node.data) &#123;</span><br><span class=\"line\">      // no children node</span><br><span class=\"line\">      if (node.left == null &amp;&amp; node.right == null) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (node.left == null) &#123;</span><br><span class=\"line\">        return node.right;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (node.right == null) &#123;</span><br><span class=\"line\">        return node.left;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      let getSmallest = function(node) &#123;</span><br><span class=\"line\">        if(node.left === null &amp;&amp; node.right == null) &#123;</span><br><span class=\"line\">          return node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(node.left != null) &#123;</span><br><span class=\"line\">          return node.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(node.right !== null) &#123;</span><br><span class=\"line\">          return getSmallest(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      let temNode = getSmallest(node.right);</span><br><span class=\"line\">      node.data = temNode.data;</span><br><span class=\"line\">      node.right = this.removeNode(temNode.right,temNode.data);</span><br><span class=\"line\">      return node;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; else if (data &lt; node.data) &#123;</span><br><span class=\"line\">      node.left = this.removeNode(node.left,data);</span><br><span class=\"line\">      return node;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      node.right = this.removeNode(node.right,data);</span><br><span class=\"line\">      return node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  find(data) &#123;</span><br><span class=\"line\">    var current = this.root;</span><br><span class=\"line\">    while (current != null) &#123;</span><br><span class=\"line\">      if (data == current.data) &#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (data &lt; current.data) &#123;</span><br><span class=\"line\">        current = current.left;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        current = current.right</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return current.data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = BinarySearchTree;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q11-数组全排列\"><a href=\"#Q11-数组全排列\" class=\"headerlink\" title=\"Q11 数组全排列\"></a>Q11 数组全排列</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;hello&#x27;,&#x27;world&#x27;];</span><br><span class=\"line\">var count = 1;</span><br><span class=\"line\">function getStr(a)&#123;</span><br><span class=\"line\">\tfor (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">\t\t// indexOf 是es6数组的方法,如果不存在返回-1，存在返回下标</span><br><span class=\"line\">\t\tif(a.indexOf(arr[i])&lt;0)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//数组 a 中不存在 arr[i],将arr[i]添加到数组末尾</span><br><span class=\"line\">\t\t\ta.push(arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif(a.length==arr.length)&#123;</span><br><span class=\"line\">\t\t\t\tconsole.log(count++ + &#x27;: &#x27; +a.join(&quot;&quot;));</span><br><span class=\"line\">\t\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t\t//结束一次for循环  进行了4次递归 getStr([&#x27;foo&#x27;]) getStr([&#x27;bar&#x27;]) getStr([&#x27;hello&#x27;]) getStr([&#x27;world&#x27;])</span><br><span class=\"line\">\t\t\t\tgetStr(a);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//一定从数组 a 中删除arr[i],进行下次循环，如果不删除就只能获得一种结果了</span><br><span class=\"line\">\t\t\ta.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getStr([])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>除去注释只用了 15 行代码，通过上面的方法 我们实现了单个数组全排<br><a href=\"http://www.lingchenliang.com/post/134.html\">更多方法阅读</a></p>\n<h2 id=\"Q12-最大连续子序列和\"><a href=\"#Q12-最大连续子序列和\" class=\"headerlink\" title=\"Q12 最大连续子序列和\"></a>Q12 最大连续子序列和</h2><blockquote>\n<p>思路： 比较若干个连续</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 6, -1, 5, 4, -7, 2, 3];</span><br><span class=\"line\">var maxSum = arr[0],</span><br><span class=\"line\">\tsum = arr[0];</span><br><span class=\"line\">for(var i=1;i&lt;arr.length;i++) &#123;</span><br><span class=\"line\">\tif(sum&lt; 0) &#123;</span><br><span class=\"line\">\t\tsum = arr[i];</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tsum += arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif (sum &gt; maxSum) &#123;</span><br><span class=\"line\">\t\tmaxSum = sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> \tconsole.log(sum, maxSum);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(maxSum);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function maxSeq(arr) &#123;</span><br><span class=\"line\">    var sum=arr[0], maxSum = arr[0]</span><br><span class=\"line\"></span><br><span class=\"line\">    for(var i=1; i&lt; arr.length; i++) &#123;</span><br><span class=\"line\">        if (sum &lt; 0) &#123;</span><br><span class=\"line\">            sum = arr[i]</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            sum += arr[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (sum &gt; maxSum) &#123;</span><br><span class=\"line\">            msxSum = sum</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return maxSum</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q13-DOM-遍历深度优先和广度优先算法\"><a href=\"#Q13-DOM-遍历深度优先和广度优先算法\" class=\"headerlink\" title=\"Q13 DOM 遍历深度优先和广度优先算法\"></a>Q13 DOM 遍历深度优先和广度优先算法</h2><h3 id=\"1-深度优先\"><a href=\"#1-深度优先\" class=\"headerlink\" title=\"1. 深度优先\"></a>1. 深度优先</h3><p><img src=\"https://img-blog.csdnimg.cn/20191227181534979.png\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 递归</span><br><span class=\"line\">let arr = []</span><br><span class=\"line\">function deepTraversal(node) &#123;</span><br><span class=\"line\">  if(!node) return;</span><br><span class=\"line\">  arr.push(node)</span><br><span class=\"line\">  for (var i = 0; i&lt; node.children.length; i++) &#123;</span><br><span class=\"line\">    deepTraversal(node.children[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 非递归</span><br><span class=\"line\">let arr =[]</span><br><span class=\"line\">function deepTraversal(node) &#123;</span><br><span class=\"line\">  if(!node) return;</span><br><span class=\"line\">  var stack = [node];</span><br><span class=\"line\">  while (stack.length) &#123;</span><br><span class=\"line\">    var item = stack.shift();</span><br><span class=\"line\">    arr.push(item);</span><br><span class=\"line\">    var children = item.children;</span><br><span class=\"line\">    for (var i = children.length - 1; i &gt;= 0 ; i--) &#123;</span><br><span class=\"line\">      stack.unshift(children[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-广度优先\"><a href=\"#2-广度优先\" class=\"headerlink\" title=\"2. 广度优先\"></a>2. 广度优先</h3><p><img src=\"https://img-blog.csdnimg.cn/2019122718211761.png\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 递归</span><br><span class=\"line\">let nodes = []; //nodes可放函数中</span><br><span class=\"line\">let i = 0;</span><br><span class=\"line\">function wideTraversal(node) &#123;</span><br><span class=\"line\">  if (node) &#123;</span><br><span class=\"line\">    nodes.push(node);</span><br><span class=\"line\">    wideTraversal(node.nextElementSibling);</span><br><span class=\"line\">    node = nodes[i++];</span><br><span class=\"line\">    wideTraversal(node.firstElementChild);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wideTraversal(rootElement);</span><br><span class=\"line\">console.log(nodes);</span><br><span class=\"line\"></span><br><span class=\"line\">let nodes = [rootElement]; //nodes可放函数中</span><br><span class=\"line\">let stack = []</span><br><span class=\"line\">function wideTraversal(node) &#123;</span><br><span class=\"line\">  if (node) &#123;</span><br><span class=\"line\">    for(var i =0; i&lt; node.children.length; i++) &#123;</span><br><span class=\"line\">      nodes.push(node.children[i]);</span><br><span class=\"line\">      stack.push(node.children[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wideTraversal(stack.shift())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wideTraversal(rootElement);</span><br><span class=\"line\"></span><br><span class=\"line\">// 非递归  先进先出</span><br><span class=\"line\">let arr = [];</span><br><span class=\"line\">let stack = [rootElement]</span><br><span class=\"line\">function wideTraversal(node) &#123;</span><br><span class=\"line\">  while(stack.length) &#123;</span><br><span class=\"line\">    let item = stack.shift()</span><br><span class=\"line\">    arr.push(item)</span><br><span class=\"line\">    for (var i = 0; i &lt; item.children.length;i++) &#123;</span><br><span class=\"line\">      stack.push(item.children[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wideTraversal(rootElement);</span><br><span class=\"line\">console.log(arr);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q14-JS-洗牌算法\"><a href=\"#Q14-JS-洗牌算法\" class=\"headerlink\" title=\"Q14 JS 洗牌算法\"></a>Q14 JS 洗牌算法</h2><p>塔罗牌</p>\n<p>举例来说，我们有一个如下图所示的数组，数组长度为 9，数组内元素的值顺次分别是 1~9：</p>\n<p><img src=\"https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/yrpGxAD5lVSqbjgJL7E1BPzC83gibLVIHoa9RjVrBUFdCfoSJUsVXhs4CNROkszm8eibymxzR60nra3UOJwavWYg/640?wx_fmt=png\" alt=\"image\"></p>\n<p>从上面这个数组入手，我们要做的就是打乱数组内元素的顺序：</p>\n<p><img src=\"https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/yrpGxAD5lVSqbjgJL7E1BPzC83gibLVIHR4BDaN36lLZU1BPDTjkvHqqo9aiaK1icRd7Y7riaofelVqiabdF8y6wHKA/640?wx_fmt=png\" alt=\"image\"></p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.shuffle = function () &#123;</span><br><span class=\"line\">    let input = this;</span><br><span class=\"line\">    for (let i = input.length - 1; i&gt;= 0; i--) &#123;</span><br><span class=\"line\">        let randomIndex = Math.floor(Math.random() * (i + 1));</span><br><span class=\"line\">        let itemAtIndex = input[randomIndex];</span><br><span class=\"line\">        input[randomIndex] = input[i];</span><br><span class=\"line\">        input[i] = itemAtIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们创建了一个 shuffle() 方法，该方法用于随机排列数组内的元素。</p>\n<p>此外，我们将该方法挂载在了 Array 对象的原型下面，所以任何数组都可以直接调用该方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let tempArray = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</span><br><span class=\"line\">tempArray.shuffle();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q15-假设现在有两个函数-function-A-和-function-B-，现在希望创建一个新的函数-function-C-，新函数的逻辑是将自己接收到的前两个参数传给函数-A，剩余所有参数传给函数-B，请用原生-javascript-实现函数-C\"><a href=\"#Q15-假设现在有两个函数-function-A-和-function-B-，现在希望创建一个新的函数-function-C-，新函数的逻辑是将自己接收到的前两个参数传给函数-A，剩余所有参数传给函数-B，请用原生-javascript-实现函数-C\" class=\"headerlink\" title=\"Q15 假设现在有两个函数 function A()和 function B()，现在希望创建一个新的函数 function C()，新函数的逻辑是将自己接收到的前两个参数传给函数 A，剩余所有参数传给函数 B，请用原生 javascript 实现函数 C\"></a>Q15 假设现在有两个函数 function A()和 function B()，现在希望创建一个新的函数 function C()，新函数的逻辑是将自己接收到的前两个参数传给函数 A，剩余所有参数传给函数 B，请用原生 javascript 实现函数 C</h2><p>举例：</p>\n<p>如果调用函数 C：C[a,b,c,d,e]</p>\n<p>相当于调用函数 A 和函数 B：A(a,b),B(c,d,e)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function C()&#123;</span><br><span class=\"line\">     var a_args=Array.prototype.slice.call(arguments,0,2);</span><br><span class=\"line\">     var b_args=Array.prototype.slice.call(arguments,2);</span><br><span class=\"line\">     A.apply(this,a_args);</span><br><span class=\"line\">     B.apply(this,b_args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function C(...s)&#123;</span><br><span class=\"line\">      A.call(this,s[0],s[1]);</span><br><span class=\"line\">      B.apply(this,s.slice(2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function C(...s)&#123;</span><br><span class=\"line\">      A.apply(this,s.slice(0,2));</span><br><span class=\"line\">      B.apply(this,s.slice(2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function C()&#123;</span><br><span class=\"line\">   A(arguments[0],arguments[1]);</span><br><span class=\"line\">   B(Array.prototype.slice.call(arguments,2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function C(a1,a2,...args) &#123;</span><br><span class=\"line\">    A(a1,a2)</span><br><span class=\"line\">    B(...args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Array.prototype.slice 表示数组的原型中的 slice 方法。这个 slice 方法返回的是一个 Array 类型的对象。可以把类数组对象转化成真正的数组，与 Array.from 类似。</p>\n<h2 id=\"Q16-请实现以下-template-方法，用于模板解析\"><a href=\"#Q16-请实现以下-template-方法，用于模板解析\" class=\"headerlink\" title=\"Q16 请实现以下 template 方法，用于模板解析\"></a>Q16 请实现以下 template 方法，用于模板解析</h2><p>var compiled &#x3D; template(“hello &lt;%&#x3D;user%&gt;!”);<br>compiled({“user”:”world”}); &#x3D;&gt; hello world!</p>\n<p>var compiled &#x3D; template(“welocm to &lt;%&#x3D;location%&gt;!”);<br>compiled({“location”:”CVTE”}); &#x3D;&gt; welcom to CVTE!;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function template(source)&#123;</span><br><span class=\"line\">   var temp=source;</span><br><span class=\"line\">   return function(obj)&#123;</span><br><span class=\"line\">       for(var prop in obj)&#123;</span><br><span class=\"line\">              var tpl=&quot;&lt;%=&quot;+prop+&quot;%&gt;&quot;;</span><br><span class=\"line\">              temp=temp.replace(tpl,obj[prop]);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       console.log(temp);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q17-写一个函数，将传进去的数组按深度展开\"><a href=\"#Q17-写一个函数，将传进去的数组按深度展开\" class=\"headerlink\" title=\"Q17 写一个函数，将传进去的数组按深度展开\"></a>Q17 写一个函数，将传进去的数组按深度展开</h2><p>例子：<br>list:[1,2,[3,4],[5,6,[7,8],9],10,11]<br/><br>depth 等于 1 时输出<br/><br>depth &#x3D; 1 :[1,2,3,4,5,6,[7,8],9,10,11]</p>\n<p>depth 等于 2 时输出<br/><br>depth &#x3D; 2 :[1,2,3,4,5,6,7,8,9,10,11]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function flattern(array,num = 0) &#123;</span><br><span class=\"line\">\tvar newArray = array;</span><br><span class=\"line\">\tfor(let i = 0; i &lt; num; i ++) &#123;</span><br><span class=\"line\">\t\tnewArray = [].concat(...newArray)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn newArray;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(flattern([1,2,3,[4,5,[6,7]]],2))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q18-实现一个简单的模板引擎\"><a href=\"#Q18-实现一个简单的模板引擎\" class=\"headerlink\" title=\"Q18 实现一个简单的模板引擎\"></a>Q18 实现一个简单的模板引擎</h2><p>例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let template = &#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;;</span><br><span class=\"line\">let data = &#123;</span><br><span class=\"line\">  name: &#x27;姓名&#x27;,</span><br><span class=\"line\">  age: 18</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">render(template, data); // 我是姓名，年龄18，性别undefined</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">方法1：先将模板与数据中均存在的属性替换掉，再将数据中不存在模板中存在的属性设置为undefined</span><br><span class=\"line\">function render(template, data) &#123;</span><br><span class=\"line\">\tfor(let key in data) &#123;</span><br><span class=\"line\">\t\tif(template.indexOf(key)) &#123;</span><br><span class=\"line\">\t\t\tvar reg =new RegExp(&quot;&#123;&#123;&quot; + key + &quot;&#125;&#125;&quot;,&quot;g&quot;);</span><br><span class=\"line\">\t\t\ttemplate = template.replace(reg,data[key])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemplate = template.replace(/\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;/g,&#x27;undefined&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn template;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">方法2 迭代，一个一个替换，注意exec匹配到的第一项是匹配字符串，第二项为分组内的字符串[&#123;&#123;name&#125;&#125;,name]</span><br><span class=\"line\">function render(template, data) &#123;</span><br><span class=\"line\">  const reg = /\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;/; // 模板字符串正则</span><br><span class=\"line\">  if (reg.test(template)) &#123; // 判断模板里是否有模板字符串</span><br><span class=\"line\">    const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段</span><br><span class=\"line\">    template = template.replace(reg, data[name]); // 将第一个模板字符串渲染</span><br><span class=\"line\">    return render(template, data); // 递归的渲染并返回渲染后的结构</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return template; // 如果模板没有模板字符串直接返回</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q19-动态规划\"><a href=\"#Q19-动态规划\" class=\"headerlink\" title=\"Q19 动态规划\"></a>Q19 动态规划</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。例如，给定三角形：</p>\n<p>[[2],[3,4],[6,5,7],[4,1,8,3]]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p>\n<p>动态规划我个人的理解是：能将一个大问题分解为一个个小问题，并且这些小问题之间有共性能重复调用。那么如何判断这道题是否可以用到动态规划，首先从底往上看，[6,5,7]对应的最小路径很明显可以看出分别是[1,1,3]，那么后两层的最短路径是[7,6,10]，再往上看[3,4]的最短路径也能明显看出是[9,10]，那么 2 对应的最短路径很明显就是 11。其实从这里就能看出每层分析判断的逻辑是一致的。js 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const minimumTotal = triangle =&gt; &#123;</span><br><span class=\"line\">    // es6方法填充数组</span><br><span class=\"line\">    const dp = Array.of(...triangle[triangle.length - 1])</span><br><span class=\"line\">\tfor (let i = dp.length - 2; i &gt;= 0; i--) &#123;</span><br><span class=\"line\">        for (let j = 0; j &lt; triangle[i].length; j++) &#123;</span><br><span class=\"line\">            // 状态转移方程</span><br><span class=\"line\">            dp[j] = Math.min(dp[j], dp[j + 1]) + triangle[i][j]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dp[0]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"详解JavaScript中的Event Loop（事件循环）机制","url":"/2022/10/24/%E8%AF%A6%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84Event-Loop%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89%E6%9C%BA%E5%88%B6/","content":"<p><img src=\"https://pic4.zhimg.com/v2-0b35a3df0b2e2712839ce551062e6d7f_1440w.jpg?source=172ae18b\" alt=\"image\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我们都知道，javascript 从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。</p>\n<p>单线程意味着，javascript 代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p>\n<p>而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 I&#x2F;O 事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p>\n<p>单线程是必要的，也是 javascript 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 dom 操作。试想一下 如果 javascript 是多线程的，那么当两个线程同时对 dom 进行一项操作，例如一个向其添加事件，而另一个删除了这个 dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p>\n<p>当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了 javascript 的效率，因此开发出了 web worker 技术。这项技术号称让 javascript 成为一门多线程语言。</p>\n<p>然而，使用 web worker 技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行 I&#x2F;O 操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了 javascript 语言的单线程本质。</p>\n<p>可以预见，未来的 javascript 也会一直是一门单线程的语言。</p>\n<p>话说回来，前面提到 javascript 的另一个特点是“非阻塞”，那么 javascript 引擎到底是如何实现的这一点呢？答案就是今天这篇文章的主角——event loop（事件循环）。</p>\n<p>注：虽然 nodejs 中也存在与传统浏览器环境下的相似的事件循环。然而两者间却有着诸多不同，故把两者分开，单独解释。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"浏览器环境下-js-引擎的事件循环机制\"><a href=\"#浏览器环境下-js-引擎的事件循环机制\" class=\"headerlink\" title=\"浏览器环境下 js 引擎的事件循环机制\"></a>浏览器环境下 js 引擎的事件循环机制</h3><h4 id=\"1-执行栈与事件队列\"><a href=\"#1-执行栈与事件队列\" class=\"headerlink\" title=\"1.执行栈与事件队列\"></a>1.执行栈与事件队列</h4><p>当 javascript 代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p>\n<p>我们知道，当我们调用一个方法的时候，js 会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的 this 对象。 而当一系列方法被依次调用的时候，因为 js 是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p>\n<p>当一个脚本第一次执行的时候，js 引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么 js 会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js 会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p>\n<p>下面这个图片非常直观的展示了这个过程，其中的 global 就是初次运行脚本时向执行栈中加入的代码：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.webp\" alt=\"image\"></p>\n<p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p>\n<p>以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送 ajax 请求数据）执行后会如何呢？前文提过，js 的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。</p>\n<p>js 引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js 会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p>\n<p>这里还有一张图来展示这个过程：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-da078fa3eadf3db4bf455904ae06f84b_720w.jpg\" alt=\"image\"></p>\n<p>图中的 stack 表示我们所说的执行栈，web apis 则是代表一些异步事件，而 callback queue 即事件队列。</p>\n<h4 id=\"2-macro-task-与-micro-task\"><a href=\"#2-macro-task-与-micro-task\" class=\"headerlink\" title=\"2.macro task 与 micro task\"></a>2.macro task 与 micro task</h4><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p>\n<p>以下事件属于宏任务：</p>\n<ul>\n<li><code>setInterval()</code></li>\n<li><code>setTimeout()</code></li>\n</ul>\n<p>以下事件属于微任务</p>\n<ul>\n<li><code>new Promise()</code></li>\n<li><code>new MutaionObserver()</code></li>\n</ul>\n<p>前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回调加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p>\n<p>我们只需记住<strong>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p>\n<p>这样就能解释下面这段代码的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    console.log(1);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">    resolve(3)</span><br><span class=\"line\">&#125;).then(function(val)&#123;</span><br><span class=\"line\">    console.log(val);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"node-环境下的事件循环机制\"><a href=\"#node-环境下的事件循环机制\" class=\"headerlink\" title=\"node 环境下的事件循环机制\"></a>node 环境下的事件循环机制</h3><h4 id=\"1-与浏览器环境有何不同\"><a href=\"#1-与浏览器环境有何不同\" class=\"headerlink\" title=\"1.与浏览器环境有何不同?\"></a>1.与浏览器环境有何不同?</h4><p>在 node 中，事件循环表现出的状态与浏览器中大致相同。不同的是 node 中有一套自己的模型。node 中事件循环的实现是依靠的 libuv 引擎。我们知道 node 选择 chrome v8 引擎作为 js 解释器，v8 引擎将 js 代码分析后去调用对应的 node api，而这些 api 最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 node 中的事件循环存在于 libuv 引擎中。</p>\n<h4 id=\"2-事件循环模型\"><a href=\"#2-事件循环模型\" class=\"headerlink\" title=\"2.事件循环模型\"></a>2.事件循环模型</h4><p>下面是一个 libuv 引擎中的事件循环的模型:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────────────────────┐</span><br><span class=\"line\">┌─&gt;│        timers         │</span><br><span class=\"line\">│  └──────────┬────────────┘</span><br><span class=\"line\">│  ┌──────────┴────────────┐</span><br><span class=\"line\">│  │     I/O callbacks     │</span><br><span class=\"line\">│  └──────────┬────────────┘</span><br><span class=\"line\">│  ┌──────────┴────────────┐</span><br><span class=\"line\">│  │     idle, prepare     │</span><br><span class=\"line\">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class=\"line\">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class=\"line\">│  │         poll          │&lt;──connections───     │</span><br><span class=\"line\">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class=\"line\">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class=\"line\">│  │        check          │</span><br><span class=\"line\">│  └──────────┬────────────┘</span><br><span class=\"line\">│  ┌──────────┴────────────┐</span><br><span class=\"line\">└──┤    close callbacks    │</span><br><span class=\"line\">   └───────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>注：模型中的每一个方块代表事件循环的一个阶段</p>\n<p>这个模型是 node 官网上的一篇文章中给出的，我下面的解释也都来源于这篇文章。我会在文末把文章地址贴出来，有兴趣的朋友可以亲自看看原文。</p>\n<h3 id=\"3-事件循环各阶段详解\"><a href=\"#3-事件循环各阶段详解\" class=\"headerlink\" title=\"3.事件循环各阶段详解\"></a>3.事件循环各阶段详解</h3><p>从上面这个模型中，我们可以大致分析出 node 中的事件循环的顺序：</p>\n<p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I&#x2F;O 事件回调阶段(I&#x2F;O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段…</p>\n<p>以上各阶段的名称是根据我个人理解的翻译，为了避免错误和歧义，下面解释的时候会用英文来表示这些阶段。</p>\n<p>这些阶段大致的功能如下：</p>\n<ul>\n<li>timers: 这个阶段执行定时器队列中的回调如 <code>setTimeout()</code> 和 <code>setInterval()</code>。</li>\n<li>I&#x2F;O callbacks: 这个阶段执行几乎所有的回调。但是不包括 close 事件，定时器和<code>setImmediate()</code>的回调。</li>\n<li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li>\n<li>poll: 等待新的 I&#x2F;O 事件，node 在一些特殊情况下会阻塞在这里。</li>\n<li>check: <code>setImmediate()</code>的回调会在这个阶段执行。</li>\n<li>close callbacks: 例如<code>socket.on(&#39;close&#39;, ...)</code>这种 close 事件的回调。<br>下面我们来按照代码第一次进入 libuv 引擎后的顺序来详细解说这些阶段：</li>\n</ul>\n<h4 id=\"poll-阶段\"><a href=\"#poll-阶段\" class=\"headerlink\" title=\"poll 阶段\"></a>poll 阶段</h4><p>当个 v8 引擎将 js 代码解析后传入 libuv 引擎后，循环首先进入 poll 阶段。poll 阶段的执行逻辑如下： 先查看 poll queue 中是否有事件，有任务就按先进先出的顺序依次执行回调。 当 queue 为空时，会检查是否有 setImmediate()的 callback，如果有就进入 check 阶段执行这些 callback。但同时也会检查是否有到期的 timer，如果有，就把这些到期的 timer 的 callback 按照调用顺序放到 timer queue 中，之后循环会进入 timer 阶段执行 queue 中的 callback。 这两者的顺序是不固定的，受到代码运行的环境的影响。如果两者的 queue 都是空的，那么 loop 会在 poll 阶段停留，直到有一个 i&#x2F;o 事件返回，循环会进入 i&#x2F;o callback 阶段并立即执行这个事件的 callback。</p>\n<p>值得注意的是，poll 阶段在执行 poll queue 中的回调时实际上不会无限的执行下去。有两种情况 poll 阶段会终止执行 poll queue 中的下一个回调：1.所有回调执行完毕。2.执行数超过了 node 的限制。</p>\n<h4 id=\"check-阶段\"><a href=\"#check-阶段\" class=\"headerlink\" title=\"check 阶段\"></a>check 阶段</h4><p>check 阶段专门用来执行 setImmediate()方法的回调，当 poll 阶段进入空闲状态，并且 setImmediate queue 中有 callback 时，事件循环进入这个阶段。</p>\n<h4 id=\"close-阶段\"><a href=\"#close-阶段\" class=\"headerlink\" title=\"close 阶段\"></a>close 阶段</h4><p>当一个 socket 连接或者一个 handle 被突然关闭时（例如调用了 socket.destroy()方法），close 事件会被发送到这个阶段执行回调。否则事件会用 process.nextTick（）方法发送出去。</p>\n<h4 id=\"timer-阶段\"><a href=\"#timer-阶段\" class=\"headerlink\" title=\"timer 阶段\"></a>timer 阶段</h4><p>这个阶段以先进先出的方式执行所有到期的 timer 加入 timer 队列里的 callback，一个 timer callback 指得是一个通过 setTimeout 或者 setInterval 函数设置的回调函数。</p>\n<h4 id=\"I-x2F-O-callback-阶段\"><a href=\"#I-x2F-O-callback-阶段\" class=\"headerlink\" title=\"I&#x2F;O callback 阶段\"></a>I&#x2F;O callback 阶段</h4><p>如上文所言，这个阶段主要执行大部分 I&#x2F;O 事件的回调，包括一些为操作系统执行的回调。例如一个 TCP 连接生错误时，系统需要执行回调来获得这个错误的报告。</p>\n<h3 id=\"4-process-nextTick-setTimeout-与-setImmediate-的区别与使用场景\"><a href=\"#4-process-nextTick-setTimeout-与-setImmediate-的区别与使用场景\" class=\"headerlink\" title=\"4.process.nextTick,setTimeout 与 setImmediate 的区别与使用场景\"></a>4.process.nextTick,setTimeout 与 setImmediate 的区别与使用场景</h3><p>在 node 中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval 与之相同）与 setImmediate</p>\n<p>这三者间存在着一些非常不同的区别：</p>\n<h4 id=\"process-nextTick\"><a href=\"#process-nextTick\" class=\"headerlink\" title=\"process.nextTick()\"></a>process.nextTick()</h4><p>尽管没有提及，但是实际上 node 中存在着一个特殊的队列，即 nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，但是这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查 nextTick queue 中是否有任务，如果有，那么会先清空这个队列。与执行 poll queue 中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用 process.nextTick()方法会导致 node 进入一个死循环。。直到内存泄漏。</p>\n<p>那么何时使用这个方法比较合适呢？下面有一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const server = net.createServer(() =&gt; &#123;&#125;).listen(8080);</span><br><span class=\"line\"></span><br><span class=\"line\">server.on(&#x27;listening&#x27;, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这个例子中当，当 listen 方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发 listening 事件并执行其回调。然而，这时候<code>on(&#39;listening)</code>还没有将 callback 设置好，自然没有 callback 可以执行。为了避免出现这种情况，node 会在 listen 事件中使用<code>process.nextTick()</code>方法，确保事件在回调函数绑定后被触发。</p>\n<h4 id=\"setTimeout-和-setImmediate\"><a href=\"#setTimeout-和-setImmediate\" class=\"headerlink\" title=\"setTimeout()和 setImmediate()\"></a>setTimeout()和 setImmediate()</h4><p>在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。</p>\n<p><code>setTimeout()</code>方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node 会在可以执行 timer 回调的第一时间去执行你所设定的任务。</p>\n<p><code>setImmediate()</code>方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即 poll 阶段之后。有趣的是，这个名字的意义和之前提到过的<code>process.nextTick()</code>方法才是最匹配的。node 的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的 node 程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。</p>\n<p><code>setTimeout()</code>和不设置时间间隔的<code>setImmediate()</code>表现上及其相似。猜猜下面这段代码的结果是什么？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;timeout&#x27;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">setImmediate(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;immediate&#x27;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>实际上，答案是不一定。没错，就连 node 的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个 I&#x2F;O 事件的回调中。下面这段代码的顺序永远是固定的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.readFile(__filename, () =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        console.log(&#x27;timeout&#x27;);</span><br><span class=\"line\">    &#125;, 0);</span><br><span class=\"line\">    setImmediate(() =&gt; &#123;</span><br><span class=\"line\">        console.log(&#x27;immediate&#x27;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>答案永远是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">immediate</span><br><span class=\"line\">timeout</span><br></pre></td></tr></table></figure>\n\n<p>因为在 I&#x2F;O 事件的回调中，<code>setImmediate</code>方法的回调永远在 timer 的回调前执行。</p>\n<h2 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h2><p>javascript 的事件循环是这门语言中非常重要且基础的概念。清楚的了解了事件循环的执行顺序和每一个阶段的特点，可以使我们对一段异步代码的执行顺序有一个清晰的认识，从而减少代码运行的不确定性。合理的使用各种延迟事件的方法，有助于代码更好的按照其优先级去执行。这篇文章期望用最易理解的方式和语言准确描述事件循环这个复杂过程，但由于作者自己水平有限，文章中难免出现疏漏。如果您发现了文章中的一些问题，欢迎在留言中提出，我会尽量回复这些评论，把错误更正。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"重绘（redraw或repaint）与重排（reflow）","url":"/2022/10/24/%E9%87%8D%E7%BB%98%EF%BC%88redraw%E6%88%96repaint%EF%BC%89%E4%B8%8E%E9%87%8D%E6%8E%92%EF%BC%88reflow%EF%BC%89/","content":"<p>浏览器运行机制图：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1209205/201710/1209205-20171010151938027-587388886.png\" alt=\"image\"></p>\n<h2 id=\"浏览器的运行机制：layout：布局；\"><a href=\"#浏览器的运行机制：layout：布局；\" class=\"headerlink\" title=\"浏览器的运行机制：layout：布局；\"></a>浏览器的运行机制：layout：布局；</h2><p>1、<strong>构建 DOM 树（parse）</strong>：渲染引擎解析 HTML 文档，首先将标签转换成 DOM 树中的 DOM node（包括 js 生成的标签）生成内容树（Content Tree&#x2F;DOM Tree）；</p>\n<p>2、<strong>构建渲染树（construct）</strong>：解析对应的 CSS 样式文件信息（包括 js 生成的样式和外部 css 文件），而这些文件信息以及 HTML 中可见的指令（如<code>&lt;b&gt;&lt;/b&gt;</code>），构建渲染树（Rendering Tree&#x2F;Frame Tree）；</p>\n<p>3、<strong>布局渲染树（reflow&#x2F;layout）</strong>：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；</p>\n<p>4、<strong>绘制渲染树（paint&#x2F;repaint）</strong>：遍历渲染树，使用 UI 后端层来绘制每个节点。</p>\n<h2 id=\"重绘（repaint-或-redraw）：\"><a href=\"#重绘（repaint-或-redraw）：\" class=\"headerlink\" title=\"重绘（repaint 或 redraw）：\"></a>重绘（repaint 或 redraw）：</h2><p>当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。</p>\n<p>重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>\n<p>触发重绘的条件：改变元素外观属性。如：color，background-color 等。</p>\n<p>注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。</p>\n<h2 id=\"重排（重构-x2F-回流-x2F-reflow）：\"><a href=\"#重排（重构-x2F-回流-x2F-reflow）：\" class=\"headerlink\" title=\"重排（重构&#x2F;回流&#x2F;reflow）：\"></a>重排（重构&#x2F;回流&#x2F;reflow）：</h2><p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>\n<p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，<strong>重排必定会引发重绘，但重绘不一定会引发重排</strong>。</p>\n<p>触发重排的条件：任何页面布局和几何属性的改变都会触发重排，比如：</p>\n<p>1、页面渲染初始化；(无法避免)</p>\n<p>2、添加或删除可见的 DOM 元素；</p>\n<p>3、元素位置的改变，或者使用动画；</p>\n<p>4、元素尺寸的改变——大小，外边距，边框；</p>\n<p>5、浏览器窗口尺寸的变化（resize 事件发生时）；</p>\n<p>6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；</p>\n<p>7、读取某些元素属性：（offsetLeft&#x2F;Top&#x2F;Height&#x2F;Width,　 clientTop&#x2F;Left&#x2F;Width&#x2F;Height,　 scrollTop&#x2F;Left&#x2F;Width&#x2F;Height,　 width&#x2F;height,　 getComputedStyle(),　 currentStyle(IE)　)</p>\n<h2 id=\"重绘重排的代价：耗时，导致浏览器卡慢。\"><a href=\"#重绘重排的代价：耗时，导致浏览器卡慢。\" class=\"headerlink\" title=\"重绘重排的代价：耗时，导致浏览器卡慢。\"></a>重绘重排的代价：耗时，导致浏览器卡慢。</h2><h3 id=\"优化：\"><a href=\"#优化：\" class=\"headerlink\" title=\"优化：\"></a>优化：</h3><p>1、浏览器自己的优化：浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>\n<p>2、我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的 DOM 和样式的修改。并减少对 style 样式的请求。</p>\n<p>（1）直接改变元素的 className</p>\n<p>（2）display：none；先设置元素为 display：none；然后进行页面布局等操作；设置完成后将元素设置为 display：block；这样的话就只引发两次重绘和重排；</p>\n<p>（3）不要经常访问浏览器的 flush 队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流；</p>\n<p>（4）使用 cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</p>\n<p>（5）将需要多次重排的元素，position 属性设为 absolute 或 fixed，元素脱离了文档流，它的变化不会影响到其他元素；</p>\n<p>（6）如果需要创建多个 DOM 节点，可以使用 DocumentFragment 创建完后一次性的加入 document；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var fragment = document.createDocumentFragment();</span><br><span class=\"line\"></span><br><span class=\"line\">var li = document.createElement(&#x27;li&#x27;);</span><br><span class=\"line\">li.innerHTML = &#x27;apple&#x27;;</span><br><span class=\"line\">fragment.appendChild(li);</span><br><span class=\"line\"></span><br><span class=\"line\">var li = document.createElement(&#x27;li&#x27;);</span><br><span class=\"line\">li.innerHTML = &#x27;watermelon&#x27;;</span><br><span class=\"line\">fragment.appendChild(li);</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&#x27;fruit&#x27;).appendChild(fragment);</span><br></pre></td></tr></table></figure>\n\n<p>（7）尽量不要使用 table 布局。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"试玩NodeJS多进程","url":"/2022/10/24/%E8%AF%95%E7%8E%A9NodeJS%E5%A4%9A%E8%BF%9B%E7%A8%8B/","content":"<p>NodeJS 的 JavaScript 运行在单个进程的单个线程上，一个 JavaScript 执行进程只能利用一个 CPU 核心，而如今大多数 CPU 均为多核 CPU，为了充分利用 CPU 资源，Node 提供了 child_process 和 cluster 模块来实现多进程以及进程管理。本文将根据 Master-Worker 模式，搭建一个简单的服务器集群来充分利用多核 CPU 资源，探索进程间通信、负载均衡、进程重启等知识。</p>\n<p>下图是 Master-Worker 模式，进程分为 master 进程和 worker 进程，master 进程负责调度或管理 worker 进程，worker 进程则负责具体的业务处理。在服务器层面，worker 可以是一个服务进程，负责处理来自客户端的请求，多个 worker 便相当于多个服务器，从而构成一个服务器集群。master 则是负责创建 worker，将来自客户端的请求分配到各个服务器上去处理，并监控 worker 的运行状态以及进行管理等操作。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162337266?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>本文将从 child_process 模块开始，熟悉该模块的基本用法。后面再继续进入 cluster 模块的学习。本文所用的代码示例可以从该仓库中找到–【<a href=\"https://github.com/hongchh/nodejs-demo/tree/master/multi-process\">multi-process</a>】。</p>\n<h2 id=\"一、child-process\"><a href=\"#一、child-process\" class=\"headerlink\" title=\"一、child_process\"></a>一、child_process</h2><h3 id=\"1-1、Hello-world\"><a href=\"#1-1、Hello-world\" class=\"headerlink\" title=\"1.1、Hello world\"></a>1.1、Hello world</h3><p>child_process 模块提供了 spawn()、exec()、execFile()、fork()这 4 个方法用于创建子进程，本文将使用 fork()方法来创建子进程，fork()方法只需指定要执行的 JavaScript 文件模块，即可创建 Node 的子进程。下面是简单的 HelloWorld 示例，master 进程根据 CPU 数量创建出相应数量的 worker 进程，worker 进程中利用进程 ID 来标记自己。</p>\n<p>以下是 master 进程代码，文件名为 master.js。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class=\"line\">const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">  childProcess.fork(&#x27;./worker.js&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;Master: Hello world.&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>以下是 worker 进程的代码，文件名为 worker.js。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;Worker-&#x27; + process.pid + &#x27;: Hello world.&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>node master.js</code>，得到如下结果，master 创建 4 个 worker 后输出 HelloWorld 信息，每个 worker 也分别输出自己的 HelloWorld 信息。</p>\n<p><img src=\"https://img-blog.csdn.net/201804111624180?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"1-2、父子进程间的通信\"><a href=\"#1-2、父子进程间的通信\" class=\"headerlink\" title=\"1.2、父子进程间的通信\"></a>1.2、父子进程间的通信</h3><p>创建 worker 之后，接下来实现 master 和 worker 之间的通信。Node 父子进程之间可以通过<code>on(&#39;message&#39;)</code>和<code>send()</code>来实现通信，<code>on(&#39;message&#39;)</code>其实是监听 message 事件，当该进程收到其他进程发送的消息时，便会触发 message 事件。<code>send()</code>方法则是用于向其他进程发送信息。master 进程中调用<code>child_process</code>的<code>fork()</code>方法后会得到一个子进程的实例，通过这个实例可以监听来自子进程的消息或者向子进程发送消息。worker 进程则通过 process 对象接口监听来自父进程的消息或者向父进程发送消息。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162446285?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>下面是简单示例，master 创建 worker 之后，向 worker 发送信息，worker 在收到 master 的信息后将信息输出，并回复 master。master 收到回复后输出信息。</p>\n<p><strong>master.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class=\"line\">const worker = childProcess.fork(&#x27;./worker.js&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">worker.send(&#x27;Hello world.&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">worker.on(&#x27;message&#x27;, (msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;[Master] Received message from worker: &#x27; + msg)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">process.on(&#x27;message&#x27;, (msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;[Worker] Received message from master: &#x27; + msg)</span><br><span class=\"line\">  process.send(&#x27;Hi master.&#x27;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>node master.js</code>，结果如下，master 和 worker 可以正常通信。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162506991?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"1-3、Master-分发请求给-Worker-处理\"><a href=\"#1-3、Master-分发请求给-Worker-处理\" class=\"headerlink\" title=\"1.3、Master 分发请求给 Worker 处理\"></a>1.3、Master 分发请求给 Worker 处理</h3><p>进程通信时使用到的<code>send()</code>方法，除了发送普通的对象之外，还可以用于发送句柄。句柄是一种引用，可以用来标识资源，例如通过句柄可以标识一个 socket 对象、一个 server 对象等。利用句柄传递，可以实现请求的分发。master 进程创建一个 TCP 服务器监听特定端口，收到客户端的请求后，会得到一个 socket 对象，通过这个 socket 对象可以跟客户端进行通信从而处理客户端的请求。master 进程可以通过句柄传递将该 socket 对象发送给 worker 进程，让 worker 进程去处理请求。该模式的结构图如下，在 master 上还可以通过特定的算法实现负载均衡，将客户端的请求均衡地分发给 worker 去处理。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162530412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>下面是一个简单示例。master 创建 TCP 服务器并监听 8080 端口，收到请求后将请求分发给 worker 处理。worker 收到 master 发来的 socket 以后，通过 socket 对客户端进行响应。为方便看到请求的处理情况，worker 给出的响应内容会说明该请求是被哪个 worker 处理。</p>\n<p><strong>master.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class=\"line\">const net = require(&#x27;net&#x27;)</span><br><span class=\"line\">const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建工作进程</span><br><span class=\"line\">let workers = []</span><br><span class=\"line\">let cur = 0</span><br><span class=\"line\">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">  workers.push(childProcess.fork(&#x27;./worker.js&#x27;))</span><br><span class=\"line\">  console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建TCP服务器</span><br><span class=\"line\">const server = net.createServer()</span><br><span class=\"line\"></span><br><span class=\"line\">// 服务器收到请求后分发给工作进程去处理</span><br><span class=\"line\">// 通过轮转方式实现工作进程的负载均衡</span><br><span class=\"line\">server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">  workers[cur].send(&#x27;socket&#x27;, socket)</span><br><span class=\"line\">  cur = Number.parseInt((cur + 1) % cpuNum)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;TCP server: 127.0.0.1:8080&#x27;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">process.on(&#x27;message&#x27;, (msg, socket) =&gt; &#123;</span><br><span class=\"line\">  if (msg === &#x27;socket&#x27; &amp;&amp; socket) &#123;</span><br><span class=\"line\">    // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class=\"line\">    &#125;, 10)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>为了访问 TCP 服务器进行实验，这里需要写一个简单的 TCP 客户端，代码如下。该客户端会创建 10 个 TCP 连接，得到服务器响应之后将响应的内容进行输出。</p>\n<p><strong>tcp_client.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const net = require(&#x27;net&#x27;)</span><br><span class=\"line\">const maxConnectCount = 10</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; maxConnectCount; ++i) &#123;</span><br><span class=\"line\">  net.createConnection(&#123;</span><br><span class=\"line\">    port: 8080,</span><br><span class=\"line\">    host: &#x27;127.0.0.1&#x27;</span><br><span class=\"line\">  &#125;).on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class=\"line\">    console.log(data.toString())</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先执行<code>node master.js</code>启动服务器，然后执行 node tcp_client.js 启动客户端。得到的结果如下，10 个请求被分发到不同服务器上进行处理，并且可以看到 master 中的轮转分发请求起到了作用，实现了简单的负载均衡。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162556605?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"1-4、Worker-监听同一个端口\"><a href=\"#1-4、Worker-监听同一个端口\" class=\"headerlink\" title=\"1.4、Worker 监听同一个端口\"></a>1.4、Worker 监听同一个端口</h3><p>前面说过，<code>send()</code>方法可以传递句柄，通过传递句柄，我们除了发送 socket 对象之外，还可以直接发送一个 server 对象。我们可以在 master 进程中创建一个 TCP 服务器，将服务器对象直接发送给 worker 进程，让 worker 去监听端口并处理请求。这样的话，master 和 worker 进程都会监听相同端口，当客户端发起请求时，请求可能被 master 接收，也可能被 worker 接收。而 master 不负责处理业务，如果请求被 master 接收到，由于 master 上没有处理业务的逻辑，请求将无法得到处理。因此可以实现为如下图所示的模式，master 将 TCP 服务器发送给 worker 使得所有 worker 监听同一个端口以后，master 关闭对端口的监听。这样便只有 worker 在监听同一端口，请求将会都被 worker 进行处理，与 master 无关。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162619227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>这种模式下，多个进程监听相同端口，当网络请求到来时，会进行抢占式调度，只有一个进程会抢到连接然后进行服务。因此，可以确保每个请求都会被特定的 worker 处理，而不是一个请求同时被多个 worker 处理。但由于是抢占式的调度，不能够保证每个 worker 的负载均衡。可能由于处理不同业务时 CPU 和 IO 繁忙度的不同导致进程抢到的请求数量不同，形成负载不均衡的情况。</p>\n<p>下面是简单示例。</p>\n<p><strong>master.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class=\"line\">const net = require(&#x27;net&#x27;)</span><br><span class=\"line\">const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建工作进程</span><br><span class=\"line\">let workers = []</span><br><span class=\"line\">let cur = 0</span><br><span class=\"line\">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">  workers.push(childProcess.fork(&#x27;./worker.js&#x27;))</span><br><span class=\"line\">  console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建TCP服务器</span><br><span class=\"line\">const server = net.createServer()</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;TCP server: 127.0.0.1:8080&#x27;)</span><br><span class=\"line\">  // 监听端口后将服务器句柄发送给工作进程</span><br><span class=\"line\">  for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">    workers[i].send(&#x27;server&#x27;, server)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 关闭主线程服务器的端口监听</span><br><span class=\"line\">  server.close()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">process.on(&#x27;message&#x27;, (msg, server) =&gt; &#123;</span><br><span class=\"line\">  if (msg === &#x27;server&#x27; &amp;&amp; server) &#123;</span><br><span class=\"line\">    server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">      // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class=\"line\">      &#125;, 10)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>继续使用之前的<code>tcp_client</code>来进行实验，先执行<code>node master.js</code>启动服务器，然后执行<code>node tcp_client.js</code>启动客户端。得到结果如下，请求可以被不同的 worker 进程处理，但由于 worker 进程是抢占式地为请求进行服务，所以不一定能实现每个 worker 的负载均衡。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162643242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"1-5、进程重启\"><a href=\"#1-5、进程重启\" class=\"headerlink\" title=\"1.5、进程重启\"></a>1.5、进程重启</h3><p>worker 进程可能因为某些异常情况而退出，为了提高集群的稳定性，master 进程需要监听子进程的存活状态，当子进程退出之后，master 进程要及时重启新的子进程。在 Node 中，子进程退出时，会在父进程中触发 exit 事件。父进程只需通过监听该事件便可知道子进程是否退出，并在退出的时候做出相应的处理。下面是在之前的监听同一端口模式下，增加了进程重启功能。进程重启时，master 进程需要重新传递 server 对象给新的 worker 进程，因此不能关闭 master 进程上的 server，否则在进程重启时 server 被关闭，得到的句柄将为空，无法正常传递。master 进程的 server 不关闭，会导致 master 进程也监听端口，会有部分请求被 master 进程接收，为了让着部分请求能够得到处理，可以在 master 进程添加处理业务的代码。由于 master 也参与了业务处理，业务处理进程的数量增加 1 个，所以 worker 进程可以少创建 1 个。这也就是下面简单示例中的做法。</p>\n<p>这种实现方式使得 master 既进行进程管理又参与了业务处理，如果要保持 master 只负责进程管理而不涉及业务处理，可以采取另外一种实现方式：master 接收到请求后，按照前面 1.3 节的做法将请求转发给 worker 进行处理，这样 master 将继续只负责对 worker 进程的管理。</p>\n<p><strong>master.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class=\"line\">const net = require(&#x27;net&#x27;)</span><br><span class=\"line\">const cpuNum = require(&#x27;os&#x27;).cpus().length - 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建工作进程</span><br><span class=\"line\">let workers = []</span><br><span class=\"line\">let cur = 0</span><br><span class=\"line\">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">  workers.push(childProcess.fork(&#x27;./worker.js&#x27;))</span><br><span class=\"line\">  console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建TCP服务器</span><br><span class=\"line\">const server = net.createServer()</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于master进程也会监听端口。因此需要对请求做出处理</span><br><span class=\"line\">server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">  // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    socket.end(&#x27;Request handled by master&#x27;)</span><br><span class=\"line\">  &#125;, 10)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;TCP server: 127.0.0.1:8080&#x27;)</span><br><span class=\"line\">  // 监听端口后将服务器句柄发送给工作进程</span><br><span class=\"line\">  for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">    workers[i].send(&#x27;server&#x27;, server)</span><br><span class=\"line\">    // 工作进程退出后重启</span><br><span class=\"line\">    workers[i].on(&#x27;exit&#x27;, ((i) =&gt; &#123;</span><br><span class=\"line\">      return () =&gt; &#123;</span><br><span class=\"line\">        console.log(&#x27;Worker-&#x27; + workers[i].pid + &#x27; exited&#x27;)</span><br><span class=\"line\">        workers[i] = childProcess.fork(&#x27;./worker.js&#x27;)</span><br><span class=\"line\">        console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class=\"line\">        workers[i].send(&#x27;server&#x27;, server)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(i))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 关闭主线程服务器的端口监听</span><br><span class=\"line\">  // server.close()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">process.on(&#x27;message&#x27;, (msg, server) =&gt; &#123;</span><br><span class=\"line\">  if (msg === &#x27;server&#x27; &amp;&amp; server) &#123;</span><br><span class=\"line\">    server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">      // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class=\"line\">      &#125;, 10)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>node master.js</code>启动服务器后，可以通过任务管理器直接杀掉进程来模拟进程异常退出。可以看到 worker 进程退出后，master 能够发现并及时创建新的 worker 进程。任务管理器中的 Node 进程数量恢复原样。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162706612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdn.net/20180411162725201?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>执行<code>node tcp_client.js</code>启动客户端，客户端发出的连接请求被处理的情况如下，同样地，由于监听同一端口，进程之间采取抢占式服务，不一定保障负载均衡。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162742587?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"1-6、处理-HTTP-服务\"><a href=\"#1-6、处理-HTTP-服务\" class=\"headerlink\" title=\"1.6、处理 HTTP 服务\"></a>1.6、处理 HTTP 服务</h3><p>前面的示例所使用的是 TCP 服务器，如果要处理 HTTP 请求，需要使用 HTTP 服务器。而 HTTP 其实是基于 TCP 的，发送 HTTP 请求的时候同样也会发起 TCP 连接。只需要对前面的 TCP 服务器进行一点小改动便可以支持 HTTP 了。在进程中新增 HTTP 服务器，当 TCP 服务器收到请求时，把请求提交给 HTTP 服务器处理即可。下面是 worker 进程的改动示例。</p>\n<p><strong>worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const http = require(&#x27;http&#x27;)</span><br><span class=\"line\">const httpServer = http.createServer((req, res) =&gt; &#123;</span><br><span class=\"line\">  // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;)</span><br><span class=\"line\">    res.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class=\"line\">  &#125;, 10)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">process.on(&#x27;message&#x27;, (msg, server) =&gt; &#123;</span><br><span class=\"line\">  if (msg === &#x27;server&#x27; &amp;&amp; server) &#123;</span><br><span class=\"line\">    server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">      // 提交给HTTP服务器处理</span><br><span class=\"line\">      httpServer.emit(&#x27;connection&#x27;, socket)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdn.net/20180411162802792?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h2 id=\"二、cluster\"><a href=\"#二、cluster\" class=\"headerlink\" title=\"二、cluster\"></a>二、cluster</h2><p>前面简单描述了使用 child_process 实现单机 Node 集群的做法，需要处理挺多的细节。Node 提供了 cluster 模块，该模块提供了更完善的 API，除了能够实现多进程充分利用 CPU 资源以外，还能够帮助我们更好地进行进程管理和处理进程的健壮性问题。下面是简单示例，if 条件语句判断当前进程是 master 还是 worker，master 进程会执行 if 语句块包含的代码，而 worker 进程则执行 else 语句块包含的代码。master 进程中，利用 cluster 模块创建了与 CPU 数量相应的 worker 进程，并通过监听 cluster 的 online 事件来判断 worker 的创建成功。在 worker 进程退出后，会触发 master 进程中 cluster 模块上的 exit 事件，通过监听该事件可以了解 worker 进程的退出情况并及时 fork 新的 worker。最后，worker 进程中只需创建服务器监听端口，对客户端请求做出处理即可。（这里设置相同端口 8080 之后，所有 worker 都将监听同一个端口）</p>\n<p><strong>server.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const cluster = require(&#x27;cluster&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">if (cluster.isMaster) &#123;</span><br><span class=\"line\">  const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class=\"line\"></span><br><span class=\"line\">  for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">    cluster.fork()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 创建进程完成后输出提示信息</span><br><span class=\"line\">  cluster.on(&#x27;online&#x27;, (worker) =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;Create worker-&#x27; + worker.process.pid)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  // 子进程退出后重启</span><br><span class=\"line\">  cluster.on(&#x27;exit&#x27;, (worker, code, signal) =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;[Master] worker &#x27; + worker.process.pid + &#x27; died with code: &#x27; + code + &#x27;, and signal: &#x27; + signal)</span><br><span class=\"line\">    cluster.fork()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  const net = require(&#x27;net&#x27;)</span><br><span class=\"line\">  net.createServer().on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">    // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class=\"line\">    &#125;, 10)</span><br><span class=\"line\">  &#125;).listen(8080)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>node server.js</code>启动服务器，继续按照之前的做法，利用任务管理器杀死进程，可以看到在进程被杀后 master 能够及时启动新的 worker。</p>\n<p><img src=\"https://img-blog.csdn.net/2018041116282181?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>继续运行 tcp_client，可以看到服务器能够正常处理请求。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162838577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h2 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h2><p>利用<code>child_process</code>和<code>cluster</code>模块能够很好地实现<code>Master-Worker</code>模式多进程架构，实现单机服务器集群，充分利用了多核 CPU 资源。通过进程通信能够实现进程管理、重启以及负载均衡，从而提高集群的稳定性和健壮性。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]}]