[{"title":"Angular——前端知识点总结","url":"/2022/12/16/Angular%E2%80%94%E2%80%94%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","content":"<h2 id=\"一、Angular-概述\"><a href=\"#一、Angular-概述\" class=\"headerlink\" title=\"一、Angular 概述\"></a>一、Angular 概述</h2><p>基于命令行的开发方式？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">①hot reload</span><br><span class=\"line\">②编译工作</span><br><span class=\"line\">③集成了webpack打包工具</span><br><span class=\"line\">。。。。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"http://angular.cn/\">http://angular.cn</a> 中文</li>\n<li><a href=\"http://angular.io/\">http://angular.io</a> 正式官网</li>\n<li><a href=\"http://angular.cn/guide/styleguide\">http://angular.cn/guide/styleguide</a> 风格指南</li>\n</ul>\n<h3 id=\"1、what？\"><a href=\"#1、what？\" class=\"headerlink\" title=\"1、what？\"></a>1、what？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">angular是一个Google推出的js框架，是以模块为基本单位，模块又可以包含组件、指令、过滤器。。</span><br><span class=\"line\"></span><br><span class=\"line\">1.1 版本问题</span><br><span class=\"line\">    angular angular2.0以后所有的版本统称为angular</span><br><span class=\"line\">    (当前学习ng4.0)</span><br><span class=\"line\"></span><br><span class=\"line\">    angular.js angular1.* 统称为angular.js</span><br><span class=\"line\">    （http://www.runoob.com/angularjs/angularjs-tutorial.html）</span><br><span class=\"line\"></span><br><span class=\"line\">1.2 版本之间的区别</span><br><span class=\"line\">    ①新版本是有组件的概念的</span><br><span class=\"line\">    ②老版本是$scope和controller为主</span><br><span class=\"line\">    ③angular引入了rxjs</span><br><span class=\"line\">    ④angular采用ts（typescript是es6的超集，是由微软和谷歌） ts是一种强类型检查机制的语言</span><br><span class=\"line\">    ⑤angular可读性、提高了代码的复用率、维护成本变低。。。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、where\"><a href=\"#2、where\" class=\"headerlink\" title=\"2、where\"></a>2、where</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">可以使用支持angular的Ionic框架来实现移动端的开发，直接使用angular来实现pc端的开发</span><br><span class=\"line\"></span><br><span class=\"line\">实现操作比较频繁的SPA</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、why\"><a href=\"#3、why\" class=\"headerlink\" title=\"3、why\"></a>3、why</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">①遵循w3c所推出的webComponent标准（组件化）</span><br><span class=\"line\">②代码具有更好的可读性和可维护性、</span><br><span class=\"line\">③引入了更多的高效率的工具 ，比如rxjs\\immutable.js。。。， 让代码的编译、部署更简单</span><br><span class=\"line\">④ts --》 健壮</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、how\"><a href=\"#4、how\" class=\"headerlink\" title=\"4、how\"></a>4、how</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">angular的开发整体框架，是有8大组成部分构成</span><br><span class=\"line\"></span><br><span class=\"line\">搭建环境的方式：</span><br><span class=\"line\">方式1：</span><br><span class=\"line\">    ①下载quickstart-master.zip压缩包</span><br><span class=\"line\">    https://github.com/angular/quickstart download</span><br><span class=\"line\">    或者 直接拷贝老师提供的压缩包</span><br><span class=\"line\">    ②解压缩 压缩包，进入对应的目录中</span><br><span class=\"line\">    执行npm install 安装项目所需要用到的依赖</span><br><span class=\"line\">    ③npm start 启动开发服务器</span><br><span class=\"line\"></span><br><span class=\"line\">方式2：</span><br><span class=\"line\">    Angular CLI是一个命令行界面工具，它可以创建项目、</span><br><span class=\"line\">    添加文件以及执行一大堆开发任务，比如测试、打包和发布。</span><br><span class=\"line\">    //安装基于angular的命令工具</span><br><span class=\"line\">    npm install -g @angular/cli</span><br><span class=\"line\">    //创建一个有着ng模板的项目</span><br><span class=\"line\">    ng new my-app</span><br><span class=\"line\">    //进入当前目录下的my-app</span><br><span class=\"line\">    cd my-app</span><br><span class=\"line\">    //启动开发服务器</span><br><span class=\"line\">    ng serve --open</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、Angular-模板项目的启动流程\"><a href=\"#二、Angular-模板项目的启动流程\" class=\"headerlink\" title=\"二、Angular 模板项目的启动流程\"></a>二、Angular 模板项目的启动流程</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">index.html</span><br><span class=\"line\"></span><br><span class=\"line\">main.js (main.ts)--&gt;启动一个模块 AppModule</span><br><span class=\"line\"></span><br><span class=\"line\">app/app.module.ts ---&gt; 启动一个组件 app/app.component.ts</span><br><span class=\"line\"></span><br><span class=\"line\">Hello Angular</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、完成组件的创建和使用\"><a href=\"#三、完成组件的创建和使用\" class=\"headerlink\" title=\"三、完成组件的创建和使用\"></a>三、完成组件的创建和使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1、创建组件和使用组件</span><br><span class=\"line\">    ①创建文件 app/test/test.component.ts</span><br><span class=\"line\">    ②将类装饰成一个组件类</span><br><span class=\"line\">        import &#123;Component&#125; from &#x27;@angular/core&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Component(&#123;</span><br><span class=\"line\">            selector:&#x27;test&#x27;,</span><br><span class=\"line\">            template:`&lt;h1&gt;it is a test&lt;/h1&gt;`</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        export class Demo01Component&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ③使用组件</span><br><span class=\"line\">        ①到模块中声明</span><br><span class=\"line\">            app.module.ts中，</span><br><span class=\"line\">            import &#123;TestComponent&#125; from &#x27;./test/test.component&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">            @NgModule(&#123;</span><br><span class=\"line\">                declarations:[TestComponent]</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ②&lt;test&gt;&lt;/test&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    练习：（16:50 - 17:00）</span><br><span class=\"line\">        demo02/demo02.component.ts</span><br><span class=\"line\">        组件中渲染一个无序列表（5个列表）</span><br><span class=\"line\"></span><br><span class=\"line\">        将组件渲染AppComponent</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Angular-中常见的指令\"><a href=\"#四、Angular-中常见的指令\" class=\"headerlink\" title=\"四、Angular 中常见的指令\"></a>四、Angular 中常见的指令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1、循环指令</span><br><span class=\"line\">Vue :  &lt;any v-for=&quot;tmp in list&quot;&gt;&lt;/any&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Angular:</span><br><span class=\"line\">        语法：</span><br><span class=\"line\">   &lt;any *ngFor=&quot;let tmp of list&quot;&gt;&lt;/any&gt;</span><br><span class=\"line\">   &lt;any *ngFor=&quot;let tmp of list;let myIndex=index&quot;&gt;&lt;/any&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">2、选择指令</span><br><span class=\"line\">Vue: &lt;any v-if=&quot;表达式&quot;&gt;&lt;/any&gt;</span><br><span class=\"line\">angular:</span><br><span class=\"line\">        &lt;any *ngIf=&quot;表达式&quot;&gt;&lt;/any&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、常见指令\"><a href=\"#五、常见指令\" class=\"headerlink\" title=\"五、常见指令\"></a>五、常见指令</h2><p>指令和组件的关系：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">组件就是一个带有模板的指令！！！</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1、多重分支判断\"><a href=\"#1、多重分支判断\" class=\"headerlink\" title=\"1、多重分支判断\"></a>1、多重分支判断</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vue</span><br><span class=\"line\">    v-if</span><br><span class=\"line\">    v-else-if</span><br><span class=\"line\">    v-else</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div [ngSwitch]=&quot;answer&quot;&gt;</span><br><span class=\"line\">    &lt;p *ngSwitchCase=&quot;&#x27;a&#x27;&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p *ngSwitchDefault&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、属性绑定\"><a href=\"#2、属性绑定\" class=\"headerlink\" title=\"2、属性绑定\"></a>2、属性绑定</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue:</span><br><span class=\"line\">    &lt;img v-bind:src=&quot;imgUrl&quot;/&gt;</span><br><span class=\"line\">    &lt;img :src=&quot;imgUrl&quot;/&gt;</span><br><span class=\"line\">    &lt;button :class=&quot;&#123;myHightlight:true&#125;&quot;&gt;&lt;/button&gt;</span><br><span class=\"line\">    &lt;h1 :style=&quot;&#123;backgroundColor:myBG&#125;&quot;&gt;&lt;/h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Angular:</span><br><span class=\"line\">    &lt;img [src]=&quot;imgUrl&quot;/&gt;</span><br><span class=\"line\">    &lt;button [ngClass]=&quot;&#123;myHightlight:true&#125;&quot;&gt;&lt;/button&gt;</span><br><span class=\"line\">    &lt;h1 [ngStyle]=&quot;&#123;backgroundColor:myBG&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、事件绑定\"><a href=\"#3、事件绑定\" class=\"headerlink\" title=\"3、事件绑定\"></a>3、事件绑定</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue</span><br><span class=\"line\">    &lt;button v-on:click=&quot;handleClick&quot;&gt;&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;</span><br><span class=\"line\">Angular</span><br><span class=\"line\">    语法：</span><br><span class=\"line\">    &lt;any (eventName)=&quot;eventHandler()&quot;&gt;&lt;/any&gt;</span><br><span class=\"line\">    举例：</span><br><span class=\"line\">    &lt;button (click)=&quot;handleClick()&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、双向数据绑定\"><a href=\"#4、双向数据绑定\" class=\"headerlink\" title=\"4、双向数据绑定\"></a>4、双向数据绑定</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue:</span><br><span class=\"line\">    &lt;input v-model=&quot;addr&quot;/&gt;</span><br><span class=\"line\">Angular:</span><br><span class=\"line\">    &lt;input [(ngModel)]=&quot;addr&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">依赖注入：</span><br><span class=\"line\">    将依赖的东西注入到指定的地方，让依赖可被使用</span><br><span class=\"line\">    举例：AppModule依赖于FormsModule,</span><br><span class=\"line\">    只需要在AppModule的imports数组写上FormsModule名称</span><br><span class=\"line\">    就可以使用FormsModule所提供的东西。</span><br><span class=\"line\">    好处：解耦，降低了耦合度</span><br><span class=\"line\"></span><br><span class=\"line\">Angular中如果想要监听双向数据绑定数据的变化，提供一个事件 ngModelChange</span><br><span class=\"line\"></span><br><span class=\"line\">注意事项：</span><br><span class=\"line\">①Angular中如果要想使用双向数据绑定，就必须指定模块依赖于FormsModule</span><br><span class=\"line\">②使用ngModelChange事件时，通过$event去传递用户当前所输入的信息</span><br><span class=\"line\">    （ngModelChange）=&quot;handleChange($event)&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>内置的指令：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">*ngFor</span><br><span class=\"line\">*ngIf</span><br><span class=\"line\">*ngSwitchCase</span><br><span class=\"line\">*ngSwitchDefault</span><br><span class=\"line\">ngSwitch</span><br><span class=\"line\">[]</span><br><span class=\"line\">()</span><br><span class=\"line\">[(ngModel)]</span><br><span class=\"line\">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、自定义指令\"><a href=\"#5、自定义指令\" class=\"headerlink\" title=\"5、自定义指令\"></a>5、自定义指令</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue中自定义指令：</span><br><span class=\"line\">    Vue.directive(&#x27;change&#x27;,&#123;</span><br><span class=\"line\">        bind:function(el,binding)&#123;&#125;,</span><br><span class=\"line\">        update:function()&#123;&#125;,</span><br><span class=\"line\">        unbind:function()&#123;&#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    v-change</span><br><span class=\"line\">Angular中指令创建和使用</span><br><span class=\"line\"></span><br><span class=\"line\">5.1 创建</span><br><span class=\"line\">    import &#123;Directive&#125;    from &#x27;@angular/core&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Directive(&#123;</span><br><span class=\"line\">        selector:&#x27;[test]&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    export class TestDirective&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">5.2 使用</span><br><span class=\"line\">    ①到模块中声明</span><br><span class=\"line\">        app.module.ts</span><br><span class=\"line\">            import &#123;TestDirective&#125; from &#x27;***&#x27;</span><br><span class=\"line\">            @NgModule(&#123;</span><br><span class=\"line\">                declarations:[TestDirective]</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">    ②作为标签的属性</span><br><span class=\"line\">        &lt;h1 test&gt;&lt;/h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">5.3 得到调用指令的元素</span><br><span class=\"line\">    ①import &#123;ElementRef&#125; from &#x27;@angular/core&#x27;</span><br><span class=\"line\">    ②实例化</span><br><span class=\"line\">        constructor(private el:ElementRef)&#123;&#125;</span><br><span class=\"line\">    ③读取元素</span><br><span class=\"line\">        this.el.nativeElement</span><br><span class=\"line\"></span><br><span class=\"line\">5.4 指令调用时传参？？</span><br><span class=\"line\">    ①&lt;h1 test=&quot;123&quot;&gt;&lt;/h1&gt;</span><br><span class=\"line\">    ②在指令类的内部</span><br><span class=\"line\">        import &#123;Input&#125; from &#x27;@angular/core&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Input() test=&quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">        this.test</span><br><span class=\"line\"></span><br><span class=\"line\">补充：使用生命周期的处理函数？</span><br><span class=\"line\">    ①引入</span><br><span class=\"line\">        import &#123;OnDestroy&#125; from &#x27;@angular/core&#x27;</span><br><span class=\"line\">    ②在定义类的时候 实现接口类</span><br><span class=\"line\">        export class Test implements OnDestroy&#123;</span><br><span class=\"line\">            ngOnDestroy()&#123;&#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、组件之间通信\"><a href=\"#六、组件之间通信\" class=\"headerlink\" title=\"六、组件之间通信\"></a>六、组件之间通信</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue中组件通信的方式？</span><br><span class=\"line\">    ①props down</span><br><span class=\"line\">        步骤1：发送</span><br><span class=\"line\">            &lt;son myName=&quot;zhangsan&quot;&gt;&lt;/son&gt;</span><br><span class=\"line\">        步骤2：接收</span><br><span class=\"line\">            Vue.component(&#x27;son&#x27;,&#123;</span><br><span class=\"line\">                props:[&#x27;myName&#x27;]</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">    ②events up（子-》父）</span><br><span class=\"line\">        步骤1: 事件的绑定</span><br><span class=\"line\">            methods:&#123;</span><br><span class=\"line\">                rcvMsg:function(msg)&#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &lt;son @customEvent=&quot;rcvMsg&quot;&gt;&lt;/son&gt;</span><br><span class=\"line\">        步骤2：事件的触发（儿子）</span><br><span class=\"line\">            this.$emit(&#x27;customEvent&#x27;,123);</span><br><span class=\"line\">    ③$refs $parent</span><br><span class=\"line\">    ④bus</span><br><span class=\"line\">Angular中组件通信？</span><br><span class=\"line\">    1、props down</span><br><span class=\"line\">        步骤1：发送</span><br><span class=\"line\">        &lt;son uName=&quot;zhangsan&quot;&gt;&lt;/son&gt;</span><br><span class=\"line\">        步骤2：接收</span><br><span class=\"line\">            import &#123;Input&#125; from &#x27;@angular/core&#x27;</span><br><span class=\"line\">            @Input() uName=&quot;&quot;;</span><br><span class=\"line\">            this.uName</span><br><span class=\"line\">    2、events up</span><br><span class=\"line\">        步骤1：事件和处理函数的绑定</span><br><span class=\"line\">            定义一个方法</span><br><span class=\"line\">                rcvMsg(msg)&#123;&#125;</span><br><span class=\"line\">            &lt;son (toFatherEvent)=&quot;rcvMsg($event)&quot;&gt;</span><br><span class=\"line\">            &lt;/son&gt;</span><br><span class=\"line\">        步骤2：触发事件</span><br><span class=\"line\">            子组件触发</span><br><span class=\"line\">                import &#123;Output,EventEmitter&#125; from &#x27;@angular/core&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">                @Output() toFatherEvent = new EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">                this.toFatherEvent.emit(&#x27;123&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>我们是这样写 Angular 应用的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">用 Angular 扩展语法编写 HTML 模板，</span><br><span class=\"line\">用组件类管理这些模板，</span><br><span class=\"line\">用服务添加应用逻辑，</span><br><span class=\"line\">用模块打包发布组件与服务。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、管道（pipe）\"><a href=\"#七、管道（pipe）\" class=\"headerlink\" title=\"七、管道（pipe）\"></a>七、管道（pipe）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">管道是用来对数据进行筛选、过滤、格式化</span><br><span class=\"line\"></span><br><span class=\"line\">Vue中过滤器：</span><br><span class=\"line\">    &lt;any&gt;&#123;&#123;expression | filter(1,2) | filter2 &#125;&#125;&lt;/any&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.filter(&#x27;changeSex&#x27;,function(arg,arg1,arg2)&#123;</span><br><span class=\"line\">        return 处理后的结果</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">angular中管道：</span><br><span class=\"line\"></span><br><span class=\"line\">过滤器的本质就是一个有参数有返回值的方法</span><br><span class=\"line\"></span><br><span class=\"line\">    语法:</span><br><span class=\"line\">            &lt;any&gt;</span><br><span class=\"line\">            &#123;&#123;expression | pipe1:&#x27;12&#x27;:34 | pipe2&#125;&#125;</span><br><span class=\"line\">            &lt;/any&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    1、内置管道</span><br><span class=\"line\"></span><br><span class=\"line\">        常见内置管道：</span><br><span class=\"line\">            uppercase/lowercase/date/number/slice</span><br><span class=\"line\"></span><br><span class=\"line\">    2、自定义管道</span><br><span class=\"line\">        创建一个自定义管道：</span><br><span class=\"line\">            import &#123;Pipe,PipeTransform&#125; from &#x27;@angular/core&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Pipe(&#123;</span><br><span class=\"line\">                name:&#x27;testNG&#x27;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            export class TestPipe implements PipeTransform &#123;</span><br><span class=\"line\">                    //value是竖杠前表达式执行的结果</span><br><span class=\"line\">                    //args通过调用管道时，冒号后边跟的参数</span><br><span class=\"line\">                 transfrom(value:any,...args:[]):any&#123;</span><br><span class=\"line\">                    return ‘处理后的结果’</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        调用：</span><br><span class=\"line\">            ①声明</span><br><span class=\"line\">                到模块中先引入再声明</span><br><span class=\"line\">            ②调用</span><br><span class=\"line\">                和内置管道的用法是一样的,同样支持传参、多重过滤</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"八、服务-依赖注入\"><a href=\"#八、服务-依赖注入\" class=\"headerlink\" title=\"八、服务 (依赖注入)\"></a>八、服务 (依赖注入)</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">服务 service:服务的本质是一个类，在服务类中封装的是经常用到的数据和方法。</span><br><span class=\"line\"></span><br><span class=\"line\">常见的服务：日志类服务、心跳服务、网络请求服务。。。</span><br><span class=\"line\"></span><br><span class=\"line\">1、服务的创建和使用</span><br><span class=\"line\">    创建：</span><br><span class=\"line\">        import &#123;Injectable&#125; from &#x27;@angular/core&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Injectable()</span><br><span class=\"line\">        export class UserService &#123;</span><br><span class=\"line\">            constructor()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            checkUserLogin()&#123;return true&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    使用：</span><br><span class=\"line\">        ①需要给服务指定provider</span><br><span class=\"line\">            在组件中或者模块中指定providers:[UserService]</span><br><span class=\"line\">        ②调用</span><br><span class=\"line\">            import &#123;UserService&#125; from &#x27;./***&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">            constructor(private myService:UserService)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            this.myService.checkUserLogin()</span><br><span class=\"line\"></span><br><span class=\"line\">2、如何封装一个网络请求的服务</span><br><span class=\"line\"></span><br><span class=\"line\">    ①创建服务的文件</span><br><span class=\"line\">    ②在服务中封装一个方法</span><br><span class=\"line\">        sendRequest(myUrl:string)&#123;</span><br><span class=\"line\">            return  this.http.get(myUrl).map((response)=&gt;</span><br><span class=\"line\">                response.json()</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ③调用之前 首先指定providers</span><br><span class=\"line\">    ④到组件中，先引入，再实例化，再调用</span><br><span class=\"line\">        this.myHS.sendRequest().subscribe((result)=&gt;&#123;</span><br><span class=\"line\">            //result就是服务器端返回的结果！</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    与服务器端通信如果涉及的session，angular需要这么处理：</span><br><span class=\"line\">        客户端</span><br><span class=\"line\">            ①发起请求 withCredentials:true</span><br><span class=\"line\">                this.http.get(</span><br><span class=\"line\">        myUrl,</span><br><span class=\"line\">        &#123;withCredentials:true&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        服务器端：</span><br><span class=\"line\">            ①跨域header(&#x27;Access-Control-Allow-Origin:http://localhost:3000&#x27;);</span><br><span class=\"line\">            ②服务器允许接收凭证</span><br><span class=\"line\">            header(&#x27;Access-Control-Allow-Credentials:true&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">服务创建和使用：</span><br><span class=\"line\">    1、创建一个文件 test.service.ts</span><br><span class=\"line\">    2、在文件中编写代码，装饰一个服务</span><br><span class=\"line\">        @Injectable()</span><br><span class=\"line\">        export class TestService&#123;</span><br><span class=\"line\">            showAlert(msg)&#123;</span><br><span class=\"line\">                alert(msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    3、    给模块或者组件,在providers属性对应的数组中 [TestService]</span><br><span class=\"line\"></span><br><span class=\"line\">    4、组件中要想使用服务中的方法</span><br><span class=\"line\">        import &#123;TestService&#125; from &#x27;***&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">        constructor(private myService:TestService)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        this.myService.showAlert()</span><br></pre></td></tr></table></figure>\n\n<p><strong>Angular 中开发模式：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们是这样写 Angular 应用的：</span><br><span class=\"line\">用 Angular 扩展语法编写 HTML 模板，</span><br><span class=\"line\">用组件类管理这些模板，</span><br><span class=\"line\">用服务添加应用逻辑，</span><br><span class=\"line\">用模块打包发布组件与服务。</span><br><span class=\"line\"></span><br><span class=\"line\">然后，我们通过引导根模块来启动该应用。</span><br><span class=\"line\">Angular 在浏览器中接管、展现应用的内容，并根据我们提供的操作指令响应用户的交互。</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 Angular 开发时，八大组成部分：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1、模块</span><br><span class=\"line\">2、组件</span><br><span class=\"line\">3、模板 自带的html标签+指令、绑定相关的ng的语法</span><br><span class=\"line\">4、元数据 告诉 Angular 如何处理一个类。</span><br><span class=\"line\">5、数据绑定</span><br><span class=\"line\">    &#123;&#123;&#125;&#125; () [] [(ngModel)]</span><br><span class=\"line\">6、指令</span><br><span class=\"line\">        三大类：组件、结构型、属性型</span><br><span class=\"line\">7、服务</span><br><span class=\"line\">    封装一些数据和方法</span><br><span class=\"line\">8、依赖注入</span><br><span class=\"line\">    就是将依赖的服务、模块注入到指定组件、模块中使用，提供了一种新的实例化的方式（解耦）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"九、路由模块\"><a href=\"#九、路由模块\" class=\"headerlink\" title=\"九、路由模块\"></a>九、路由模块</h2><p>路由模块：建立起 url 和页面之间的映射关系</p>\n<h3 id=\"1、实现-SPA-的基本步骤\"><a href=\"#1、实现-SPA-的基本步骤\" class=\"headerlink\" title=\"1、实现 SPA 的基本步骤\"></a>1、实现 SPA 的基本步骤</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue：</span><br><span class=\"line\">实现一个SPA基本思路：</span><br><span class=\"line\">①指定一个容器</span><br><span class=\"line\">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">②创建代码片段</span><br><span class=\"line\">    创建组件</span><br><span class=\"line\">    var Login = Vue.component(&#x27;login-component&#x27;,&#123;</span><br><span class=\"line\">        template:`&lt;h1&gt;登录页面&lt;/h1&gt;`</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">③配置路由词典</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        router:new VueRouter(&#123;</span><br><span class=\"line\">            routes:[</span><br><span class=\"line\">                &#123;path:&#x27;/myLogin&#x27;,component:Login&#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">④测试</span><br><span class=\"line\">    测试路由词典中 路由地址能否按照需求 正确加载所需要用到的页面</span><br><span class=\"line\"></span><br><span class=\"line\">Angular：</span><br><span class=\"line\">①指定容器</span><br><span class=\"line\">    &lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br><span class=\"line\">②创建组件 （声明）</span><br><span class=\"line\">    @Component(&#123;&#125;) export class **</span><br><span class=\"line\">③配置路由词典</span><br><span class=\"line\">    //a-module-routing</span><br><span class=\"line\">    import &#123;Routes,RouterModule&#125; from &#x27;@angular/router&#x27;</span><br><span class=\"line\">    import &#123;LoginComponent&#125; from &#x27;./demo15_spa/login.component&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">    const routes:Routes = [</span><br><span class=\"line\">        &#123;path:&#x27;&#x27;,component:LoginComponent&#125;</span><br><span class=\"line\">        .....</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">    @NgModule(&#123;</span><br><span class=\"line\">        import:[RouterModule.forRoot(routes)],</span><br><span class=\"line\">        exports:[RouterModule]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    export class AppRoutingModule&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    找到根模块：</span><br><span class=\"line\">        import &#123;AppRoutingModule&#125; from &#x27;./app.router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">        @NgModule(&#123;</span><br><span class=\"line\">            imports:[AppRoutingModule]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">④测试</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、在-Angular-实现组件间的导航的方式\"><a href=\"#2、在-Angular-实现组件间的导航的方式\" class=\"headerlink\" title=\"2、在 Angular 实现组件间的导航的方式\"></a>2、在 Angular 实现组件间的导航的方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue写法：</span><br><span class=\"line\">        ①可以直接修改地址栏（内部测试）</span><br><span class=\"line\">        ②可以通过js</span><br><span class=\"line\">         this.$router.push(&#x27;目的地的路由地址&#x27;)</span><br><span class=\"line\">        ③routerLink</span><br><span class=\"line\">         &lt;router-link to=&quot;目的地的路由地址&quot;&gt;&lt;/router-link&gt;</span><br><span class=\"line\">Angular：</span><br><span class=\"line\">①直接修改地址栏</span><br><span class=\"line\">②js</span><br><span class=\"line\">    import &#123;Router&#125; from &#x27;@angular/router&#x27;</span><br><span class=\"line\">    constructor(private myRouter:Router)&#123;&#125;</span><br><span class=\"line\">    this.myRouter.navigateByUrl(&#x27;url&#x27;);</span><br><span class=\"line\">③ &lt;a routerLink=&quot;地址&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">补充：实现前进和后退</span><br><span class=\"line\">    import &#123;Location&#125; from &#x27;@angular/common&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(private myLocation:Location)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    this.myLocation.back();                this.myLocation.forward();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、参数的传递\"><a href=\"#3、参数的传递\" class=\"headerlink\" title=\"3、参数的传递\"></a>3、参数的传递</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Angular:</span><br><span class=\"line\">    3.1 发送</span><br><span class=\"line\">        this.myRouter.navigateByUrl(&#x27;myOC/123&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    3.2 接收</span><br><span class=\"line\">        ① 配置接收方的路由地址</span><br><span class=\"line\">            &#123;path:&#x27;myOC&#x27;&#125; ==&gt; &#123;path:&#x27;myOC/:price&#x27;&#125;</span><br><span class=\"line\">        ② 接收参数</span><br><span class=\"line\">                import &#123;ActivatedRoute&#125; from &#x27;@angular/router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">                constructor(private myAR:ActivatedRoute)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                this.myAR.params.subscribe((result)=&gt;&#123;</span><br><span class=\"line\">                    //result.price</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    在Angular中 实现数据传输的方式：</span><br><span class=\"line\">        ①组件间通信</span><br><span class=\"line\">        ②跳转时指定参数</span><br><span class=\"line\">        ③与远程服务器端通信</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、路由嵌套\"><a href=\"#4、路由嵌套\" class=\"headerlink\" title=\"4、路由嵌套\"></a>4、路由嵌套</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">可以在SPA中某个组件中，根据url嵌套其它的组件</span><br><span class=\"line\">    Vue中实现方式：</span><br><span class=\"line\">        ①在准备嵌套其它组件的，指定一个容器 &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">        ②配置路由词典</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                path:&#x27;&#x27;,</span><br><span class=\"line\">                component:MailComponent,</span><br><span class=\"line\">                children:[</span><br><span class=\"line\">                    &#123;path:&#x27;inbox&#x27;,component:***&#125;</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Angular中实现方式：</span><br><span class=\"line\">        ①指定容器</span><br><span class=\"line\">            router-outlet</span><br><span class=\"line\">        ②配置子路由</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                path:&#x27;mail&#x27;,</span><br><span class=\"line\">                children:[</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        总结：在Angular中实现一个支持路由嵌套的SPA，</span><br><span class=\"line\">        导航到对应的子路由对应的页面时，必须在携带父组件的地址</span><br><span class=\"line\">            localhost:3000/mail/outbox</span><br><span class=\"line\">            localhost:3000/mail/inbox</span><br><span class=\"line\"></span><br><span class=\"line\">        demo18_embed</span><br><span class=\"line\">            mylogin.component.ts  MyLoginComponent</span><br><span class=\"line\">            mail.component.ts MailComponent</span><br><span class=\"line\">            inbox.component.ts InboxComponent</span><br><span class=\"line\">            outbox.component.ts OutboxComponent</span><br><span class=\"line\">        ①完成组件的创建和声明</span><br><span class=\"line\"></span><br><span class=\"line\">        ②路由模块</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、路由守卫\"><a href=\"#5、路由守卫\" class=\"headerlink\" title=\"5、路由守卫\"></a>5、路由守卫</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">路由守卫 RouteGuard，控制是否能够访问某一个url中所对应的组件！</span><br><span class=\"line\">    鉴权的组件</span><br><span class=\"line\">    用户登录的页面</span><br><span class=\"line\">    。。。</span><br><span class=\"line\"></span><br><span class=\"line\">如何使用路由守卫：</span><br><span class=\"line\">    ①创建一个服务</span><br><span class=\"line\">        import &#123;Injectable&#125; from &#x27;@angular/core&#x27;</span><br><span class=\"line\">        import &#123;CanActivate&#125; from &#x27;@angular/router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Injectable()</span><br><span class=\"line\">        export class MailGuard implments CanActivate&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            canActivate()&#123;</span><br><span class=\"line\">                return true/false</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ②给服务指定提供商</span><br><span class=\"line\">         providers:[MailGuard]</span><br><span class=\"line\">    ③给路由词典中想要保护的路由指定canActivate</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                path:&#x27;mail&#x27;,</span><br><span class=\"line\">                canActivate:[MailGuard]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue中如果也想实现路由守卫：</span><br><span class=\"line\">        const router = new VueRouter(&#123; ... &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class=\"line\">            // ...</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        https://router.vuejs.org/zh-cn/advanced/navigation-guards.html</span><br></pre></td></tr></table></figure>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"Axios常见用法指南","url":"/2022/12/16/Axios%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97/","content":"<p>axios 是基于 promise 封装的异步请求插件，其中包含两套核心，基于浏览器的 XHR 核心，基于服务端 http 模块，可以兼容浏览器与服务端两个业务场景，同时通过了多种传参方式，拦截全局请求，全局数据格式化等功能，方便开发者使用。</p>\n<h2 id=\"一、发送请求\"><a href=\"#一、发送请求\" class=\"headerlink\" title=\"一、发送请求\"></a>一、发送请求</h2><h3 id=\"1-传统用法-类-Ajax\"><a href=\"#1-传统用法-类-Ajax\" class=\"headerlink\" title=\"1. 传统用法 类$.Ajax\"></a>1. 传统用法 类$.Ajax</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 发送 POST 请求</span><br><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: &#x27;&#x27;,//类型</span><br><span class=\"line\">  url: &#x27;&#x27;,// url</span><br><span class=\"line\">  data: &#123;  // data</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(res=&gt;&#123;&#125;)</span><br><span class=\"line\">.catch(err=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-get-方法抽离\"><a href=\"#2-get-方法抽离\" class=\"headerlink\" title=\"2. get 方法抽离\"></a>2. get 方法抽离</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// axios.post(url,&#123;params:&#x27;&#x27;&#125;)</span><br><span class=\"line\">axios.get(&#x27;/user&#x27;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-post-方法抽离\"><a href=\"#3-post-方法抽离\" class=\"headerlink\" title=\"3. post 方法抽离\"></a>3. post 方法抽离</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// axios.post(url,body)</span><br><span class=\"line\">axios.post(&#x27;/user&#x27;, &#123;</span><br><span class=\"line\">    ID: 12345</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>一定要注意两者参数传递时的区别，否则容易在项目中踩坑</strong></p>\n<h2 id=\"二、创建请求实例\"><a href=\"#二、创建请求实例\" class=\"headerlink\" title=\"二、创建请求实例\"></a>二、创建请求实例</h2><p>通过创建实例，可以避免在使用时 重复填写相同配置</p>\n<h3 id=\"1-在-vue-项目中创建一个实例，并挂载到全局\"><a href=\"#1-在-vue-项目中创建一个实例，并挂载到全局\" class=\"headerlink\" title=\"1. 在 vue 项目中创建一个实例，并挂载到全局\"></a>1. 在 vue 项目中创建一个实例，并挂载到全局</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$http = axios.create(&#123;</span><br><span class=\"line\">    baseURL: &#x27;http://www.&#x27;,//配置一个默认域名</span><br><span class=\"line\">    timeout: 5000, // 超时时间</span><br><span class=\"line\">    headers:&#123;&#x27;Content-Type&#x27;:&#x27;application/json;charset=utf8&#x27;&#125; // 配置header</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用</span><br><span class=\"line\">this.$http()</span><br><span class=\"line\">this.$http.get()</span><br><span class=\"line\">this.$http.post()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-其它配置项可参考官方文档\"><a href=\"#2-其它配置项可参考官方文档\" class=\"headerlink\" title=\"2. 其它配置项可参考官方文档\"></a>2. 其它配置项可参考官方文档</h3><h2 id=\"三、多接口并发统一处理\"><a href=\"#三、多接口并发统一处理\" class=\"headerlink\" title=\"三、多接口并发统一处理\"></a>三、多接口并发统一处理</h2><p>由于 axios 基于 promise 开发，所以 promise.all()，Promise.race()同样适用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  this.$axios.get(url).then(res=&gt;&#123;</span><br><span class=\"line\">      resolve(res)</span><br><span class=\"line\">  &#125;).catch(err=&gt;&#123;</span><br><span class=\"line\">      reject(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">  this.$axios.get(url).then(res=&gt;&#123;</span><br><span class=\"line\">      resolve(res)</span><br><span class=\"line\">  &#125;).catch(err=&gt;&#123;</span><br><span class=\"line\">      reject(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 请求都完成后执行</span><br><span class=\"line\">// 调用Promise.all().then(res=&gt;&#123;&#125;)</span><br><span class=\"line\">Promise.all([p1,p2]).then(res=&gt;&#123;</span><br><span class=\"line\">  console.log(res);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 有一个请求完成即执行</span><br><span class=\"line\">// 调用Promise.race().then(res=&gt;&#123;&#125;)</span><br><span class=\"line\">Promise.race([p1,p2]).then(res=&gt;&#123;</span><br><span class=\"line\">  console.log(res);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、全局拦截器\"><a href=\"#四、全局拦截器\" class=\"headerlink\" title=\"四、全局拦截器\"></a>四、全局拦截器</h2><p>在<strong>请求，响应</strong>被 then 或 catch 处理前拦截它们，比如添加其它全局请求数据(token,签名)，集中处理 catch 报错，判断请求是否成功，避免分开处理。</p>\n<h3 id=\"1-向服务器发出请求前拦截处理\"><a href=\"#1-向服务器发出请求前拦截处理\" class=\"headerlink\" title=\"1. 向服务器发出请求前拦截处理\"></a>1. 向服务器发出请求前拦截处理</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 添加请求拦截器</span><br><span class=\"line\">axios.interceptors.request.use(function (config) &#123;</span><br><span class=\"line\">    // 在发送请求之前做些什么</span><br><span class=\"line\">    return config;</span><br><span class=\"line\">&#125;, function (error) &#123;</span><br><span class=\"line\">    // 对请求错误做些什么</span><br><span class=\"line\">    return Promise.reject(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-被服务器响应后拦截处理\"><a href=\"#2-被服务器响应后拦截处理\" class=\"headerlink\" title=\"2. 被服务器响应后拦截处理\"></a>2. 被服务器响应后拦截处理</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 添加响应拦截器</span><br><span class=\"line\">axios.interceptors.response.use(function (response) &#123;</span><br><span class=\"line\">    // 对响应数据做点什么</span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;, function (error) &#123;</span><br><span class=\"line\">    // 对响应错误做点什么</span><br><span class=\"line\">    return Promise.reject(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"Ant Design 框架总结","url":"/2022/12/16/Ant-Design-%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","content":"<h1 id=\"Ant-Design-常用命令汇总\"><a href=\"#Ant-Design-常用命令汇总\" class=\"headerlink\" title=\"Ant Design 常用命令汇总\"></a>Ant Design 常用命令汇总</h1><h2 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h2><h3 id=\"1-安装脚手架工具\"><a href=\"#1-安装脚手架工具\" class=\"headerlink\" title=\"1. 安装脚手架工具\"></a>1. 安装脚手架工具</h3><p><a href=\"https://github.com/ant-design/antd-init/\">antd-init</a> 是一个用于演示 antd 如何使用的脚手架工具，真实项目建议使用 <a href=\"https://github.com/dvajs/dva-cli\">dva-cli</a>。</p>\n<p>更多功能请参考 <a href=\"https://github.com/ant-design/antd-init/\">脚手架工具</a> 和 <a href=\"http://ant-tool.github.io/\">开发工具文档</a>。</p>\n<p>除了官方提供的脚手架，您也可以使用社区提供的脚手架和范例：</p>\n<ul>\n<li><a href=\"https://github.com/zuiidea/antd-admin\">antd-admin</a></li>\n<li><a href=\"https://github.com/JasonBai007/reactSPA\">reactSPA</a></li>\n<li><a href=\"https://github.com/Justin-lu/react-redux-antd\">react-redux-antd by Justin-lu</a></li>\n<li><a href=\"https://github.com/okoala/react-redux-antd\">react-redux-antd by okoala</a></li>\n<li><a href=\"https://github.com/fireyy/react-antd-admin\">react-antd-admin</a></li>\n<li><a href=\"https://github.com/yuzhouisme/react-antd-redux-router-starter\">react-antd-redux-router-starter</a></li>\n<li><a href=\"https://github.com/BetaRabbit/react-redux-antd-starter\">react-redux-antd-starter</a></li>\n</ul>\n<p>更多脚手架可以查看 <a href=\"http://scaffold.ant.design/\">脚手架市场</a></p>\n<h3 id=\"创建一个项目\"><a href=\"#创建一个项目\" class=\"headerlink\" title=\"创建一个项目\"></a>创建一个项目</h3><p>使用命令行进行初始化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mkdir antd-demo &amp;&amp; cd antd-demo</span><br><span class=\"line\">$ antd-init</span><br><span class=\"line\">antd-init 会自动安装 npm 依赖，若有问题则可自行安装。</span><br><span class=\"line\"></span><br><span class=\"line\">若安装缓慢报错，可尝试用 cnpm 或别的镜像源自行安装：rm -rf node_modules &amp;&amp; cnpm install。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用组件\"><a href=\"#3-使用组件\" class=\"headerlink\" title=\"3. 使用组件\"></a>3. 使用组件</h3><p>脚手架会生成一个 Todo 应用实例（一个很有参考价值的 React 上手示例），先不管它，我们用来测试组件。</p>\n<p>直接用下面的代码替换 index.js 的内容，用 React 的方式直接使用 antd 组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class=\"line\">import &#123; LocaleProvider, DatePicker, message &#125; from &#x27;antd&#x27;;</span><br><span class=\"line\">// 由于 antd 组件的默认文案是英文，所以需要修改为中文</span><br><span class=\"line\">import zhCN from &#x27;antd/lib/locale-provider/zh_CN&#x27;;</span><br><span class=\"line\">import moment from &#x27;moment&#x27;;</span><br><span class=\"line\">import &#x27;moment/locale/zh-cn&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">moment.locale(&#x27;zh-cn&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      date: &#x27;&#x27;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleChange(date) &#123;</span><br><span class=\"line\">    message.info(&#x27;您选择的日期是: &#x27; + date.toString());</span><br><span class=\"line\">    this.setState(&#123; date &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;LocaleProvider locale=&#123;zhCN&#125;&gt;</span><br><span class=\"line\">        &lt;div style=&#123;&#123; width: 400, margin: &#x27;100px auto&#x27; &#125;&#125;&gt;</span><br><span class=\"line\">          &lt;DatePicker onChange=&#123;value =&gt; this.handleChange(value)&#125; /&gt;</span><br><span class=\"line\">          &lt;div style=&#123;&#123; marginTop: 20 &#125;&#125;&gt;当前日期：&#123;this.state.date.toString()&#125;&lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/LocaleProvider&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-开发调试\"><a href=\"#4-开发调试\" class=\"headerlink\" title=\"4. 开发调试\"></a>4. 开发调试</h3><p>一键启动调试，访问 <a href=\"http://127.0.0.1:8000/\">http://127.0.0.1:8000</a> 查看效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-构建和部署\"><a href=\"#5-构建和部署\" class=\"headerlink\" title=\"5. 构建和部署\"></a>5. 构建和部署</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm run build</span><br></pre></td></tr></table></figure>\n\n<p>入口文件会构建到 dist 目录中，你可以自由部署到不同环境中进行引用。</p>\n<h2 id=\"二、Ant-Design-Pro-安装\"><a href=\"#二、Ant-Design-Pro-安装\" class=\"headerlink\" title=\"二、Ant Design Pro 安装\"></a>二、Ant Design Pro 安装</h2><p>有两种方式进行安装：</p>\n<h3 id=\"1-直接-clone-git-仓库\"><a href=\"#1-直接-clone-git-仓库\" class=\"headerlink\" title=\"1. 直接 clone git 仓库\"></a>1. 直接 clone git 仓库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git clone --depth=1 https://github.com/ant-design/ant-design-pro.git my-project</span><br><span class=\"line\">$ cd my-project</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用命令行工具\"><a href=\"#2-使用命令行工具\" class=\"headerlink\" title=\"2. 使用命令行工具\"></a>2. 使用命令行工具</h3><p>你可以使用集成化的命令行工具 <a href=\"https://github.com/ant-design/ant-design-pro-cli\">ant-design-pro-cli</a>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install ant-design-pro-cli -g</span><br><span class=\"line\">$ mkdir my-project &amp;&amp; cd my-project</span><br><span class=\"line\">$ pro new  # 安装脚手架</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、目录结构\"><a href=\"#三、目录结构\" class=\"headerlink\" title=\"三、目录结构\"></a>三、目录结构</h2><p>我们已经为你生成了一个完整的开发框架，提供了涵盖中后台开发的各类功能和坑位，下面是整个项目的目录结构。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── mock                     # 本地模拟数据</span><br><span class=\"line\">├── public</span><br><span class=\"line\">│   └── favicon.ico          # Favicon</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── assets               # 本地静态资源</span><br><span class=\"line\">│   ├── common               # 应用公用配置，如导航信息</span><br><span class=\"line\">│   ├── components           # 业务通用组件</span><br><span class=\"line\">│   ├── e2e                  # 集成测试用例</span><br><span class=\"line\">│   ├── layouts              # 通用布局</span><br><span class=\"line\">│   ├── models               # dva model</span><br><span class=\"line\">│   ├── routes               # 业务页面入口和常用模板</span><br><span class=\"line\">│   ├── services             # 后台接口服务</span><br><span class=\"line\">│   ├── utils                # 工具库</span><br><span class=\"line\">│   ├── g2.js                # 可视化图形配置</span><br><span class=\"line\">│   ├── theme.js             # 主题配置</span><br><span class=\"line\">│   ├── index.ejs            # HTML 入口模板</span><br><span class=\"line\">│   ├── index.js             # 应用入口</span><br><span class=\"line\">│   ├── index.less           # 全局样式</span><br><span class=\"line\">│   └── router.js            # 路由入口</span><br><span class=\"line\">├── tests                    # 测试工具</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、本地开发\"><a href=\"#四、本地开发\" class=\"headerlink\" title=\"四、本地开发\"></a>四、本地开发</h2><p>安装依赖。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<p>如果网络状况不佳，可以使用 cnpm 进行加速。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure>\n\n<p>启动完成后会自动打开浏览器访问 <a href=\"http://localhost:8000，你看到下面的页面就代表成功了。\">http://localhost:8000，你看到下面的页面就代表成功了。</a></p>\n<h3 id=\"1-创建一个项目\"><a href=\"#1-创建一个项目\" class=\"headerlink\" title=\"1. 创建一个项目\"></a>1. 创建一个项目</h3><p>可以是已有项目，或者是使用 <a href=\"https://github.com/dvajs/dva\">dva</a> &#x2F; create-react(-native)-app 新创建的空项目，你也可以从 <a href=\"https://github.com/ant-design/antd-mobile-samples/tree/master/rn-web\">官方示例</a> 脚手架里拷贝并修改</p>\n<blockquote>\n<p>参考更多<a href=\"https://github.com/ant-design/antd-mobile-samples\">官方示例集</a> 或者你可以利用 React 生态圈中的 <a href=\"https://github.com/enaqx/awesome-react#boilerplates\">各种脚手架</a></p>\n</blockquote>\n<h3 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2. 安装\"></a>2. 安装</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install antd-mobile --save</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3. 使用\"></a>3. 使用</h3><p>Web 使用方式<br>React Native 使用方式<br>入口页面 (html 或 模板) 相关设置：</p>\n<blockquote>\n<p>引入 <a href=\"https://github.com/ftlabs/fastclick\">FastClick</a> 并且设置 html meta</p>\n</blockquote>\n<p>引入 Promise 的 fallback 支持 (部分安卓手机不支持 Promise)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;!-- set `maximum-scale` for some compatibility issues --&gt;</span><br><span class=\"line\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot; /&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://as.alipayobjects.com/g/component/fastclick/1.0.6/fastclick.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    if (&#x27;addEventListener&#x27; in document) &#123;</span><br><span class=\"line\">      document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123;</span><br><span class=\"line\">        FastClick.attach(document.body);</span><br><span class=\"line\">      &#125;, false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(!window.Promise) &#123;</span><br><span class=\"line\">      document.writeln(&#x27;&lt;script src=&quot;https://as.alipayobjects.com/g/component/es6-promise/3.2.2/es6-promise.min.js&quot;&#x27;+&#x27;&gt;&#x27;+&#x27;&lt;&#x27;+&#x27;/&#x27;+&#x27;script&gt;&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>组件使用实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; Button &#125; from &#x27;antd-mobile&#x27;;</span><br><span class=\"line\">ReactDOM.render(&lt;Button&gt;Start&lt;/Button&gt;, mountNode);</span><br></pre></td></tr></table></figure>\n\n<p>引入样式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#x27;antd-mobile/dist/antd-mobile.css&#x27;;  // or &#x27;antd-mobile/dist/antd-mobile.less&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-按需加载\"><a href=\"#4-按需加载\" class=\"headerlink\" title=\"4. 按需加载\"></a>4. 按需加载</h3><p>注意：强烈推荐使用。</p>\n<p>下面两种方式都可以只加载用到的组件，选择其中一种方式即可。</p>\n<ul>\n<li>使用 <a href=\"https://github.com/ant-design/babel-plugin-import\">babel-plugin-import</a>（推荐）。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// .babelrc or babel-loader option</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">    [&quot;import&quot;, &#123; libraryName: &quot;antd-mobile&quot;, style: &quot;css&quot; &#125;] // `style: true` 会加载 less 文件</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">然后只需从 antd-mobile 引入模块即可，无需单独引入样式。</span><br><span class=\"line\"></span><br><span class=\"line\">// babel-plugin-import 会帮助你加载 JS 和 CSS</span><br><span class=\"line\">import &#123; DatePicker &#125; from &#x27;antd-mobile&#x27;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>手动引入</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import DatePicker from &#x27;antd-mobile/lib/date-picker&#x27;;  // 加载 JS</span><br><span class=\"line\">import &#x27;antd-mobile/lib/date-picker/style/css&#x27;;        // 加载 CSS</span><br><span class=\"line\">// import &#x27;antd-mobile/lib/date-picker/style&#x27;;         // 加载 LESS</span><br></pre></td></tr></table></figure>\n\n<p><strong>更多增强 (非必须)：</strong></p>\n<blockquote>\n<p>如何自定义主题？<a href=\"https://github.com/ant-design/ant-design-mobile/blob/master/docs/react/theme-config.zh-CN.md\">见此文档</a>， 基于 antd-mobile 的自定义 UI 库：<a href=\"https://github.com/ant-design/antd-mobile-samples/tree/master/web-custom-ui\">web-custom-ui</a> &#x2F; <a href=\"https://github.com/ant-design/antd-mobile-samples/tree/master/web-custom-ui-pro\">web-custom-ui-pro</a></p>\n</blockquote>\n<h1 id=\"antd-常用组件的问题及实现\"><a href=\"#antd-常用组件的问题及实现\" class=\"headerlink\" title=\"antd 常用组件的问题及实现\"></a>antd 常用组件的问题及实现</h1><p>在基于 react 的 web 后台开发中，常常会使用到 antd 组件，可以使用现有所提供的，也可以自己再次封装使用。基于平时开发中遇到较多关于 antd 组件问题的情况，记录一下平时常用的代码实现。</p>\n<h2 id=\"1-Radio\"><a href=\"#1-Radio\" class=\"headerlink\" title=\"1.Radio\"></a>1.Radio</h2><p>单选框</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;FormItem &#123;...formItemLayout&#125; label=&quot;是否启用&quot; required&gt;</span><br><span class=\"line\">  &#123;getFieldDecorator(&#x27;enabled&#x27;,&#123;</span><br><span class=\"line\">    initialValue: data.enabled,</span><br><span class=\"line\">    rules: [&#123; required: true, message: &#x27;请选择是否启用&#x27; &#125;],</span><br><span class=\"line\">  &#125;)(</span><br><span class=\"line\">    &lt;RadioGroup&gt;</span><br><span class=\"line\">      &lt;Radio value=&#123;true&#125;&gt;启用&lt;/Radio&gt;</span><br><span class=\"line\">      &lt;Radio value=&#123;false&#125;&gt;禁用&lt;/Radio&gt;</span><br><span class=\"line\">    &lt;/RadioGroup&gt;</span><br><span class=\"line\">  )&#125;</span><br><span class=\"line\">&lt;/FormItem&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-Select\"><a href=\"#2-Select\" class=\"headerlink\" title=\"2.Select\"></a>2.Select</h2><p>下拉选择，数据源根据接口获取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;FormItem &#123;...formItemLayout&#125; label=&#x27;xxx&#x27;&gt;</span><br><span class=\"line\">   &#123;getFieldDecorator(&#x27;feedHabit&#x27;, &#123;</span><br><span class=\"line\">     initialValue: (detail &amp;&amp; detail.feedHabit) || undefined,</span><br><span class=\"line\">     rules: [</span><br><span class=\"line\">       &#123; required: false, message: &#x27;xxx&#x27; &#125;</span><br><span class=\"line\">     ]</span><br><span class=\"line\">     &#125;)(</span><br><span class=\"line\">       &lt;Select</span><br><span class=\"line\">         showSearch</span><br><span class=\"line\">         allowClear</span><br><span class=\"line\">         placeholder=&#x27;xxx&#x27;</span><br><span class=\"line\">         filterOption=&#123;(inputValue, option) =&gt; option.props.children.indexOf(inputValue) &gt; -1&#125;</span><br><span class=\"line\">         notFoundContent=&#123;</span><br><span class=\"line\">           &lt;Empty</span><br><span class=\"line\">             image=&#123;Empty.PRESENTED_IMAGE_SIMPLE&#125;</span><br><span class=\"line\">             style=&#123;&#123; margin: 8 &#125;&#125;</span><br><span class=\"line\">           &gt;</span><br><span class=\"line\">             &lt;Button</span><br><span class=\"line\">               type=&#x27;primary&#x27;</span><br><span class=\"line\">               onClick=&#123;() =&gt; dispatch(&#123; type: `$&#123;namespace&#125;/getFeedHabitList` &#125;)&#125;</span><br><span class=\"line\">             &gt;刷新</span><br><span class=\"line\">             &lt;/Button&gt;</span><br><span class=\"line\">           &lt;/Empty&gt;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &gt;</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           feedHabitList &amp;&amp; feedHabitList.map((item, index) =&gt; (</span><br><span class=\"line\">             &lt;Select.Option key=&#123;item.code&#125; value=&#123;item.code&#125;&gt;&#123;item.name&#125;&lt;/Select.Option&gt;</span><br><span class=\"line\">           ))</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &lt;/Select&gt;</span><br><span class=\"line\">     )&#125;</span><br><span class=\"line\"> &lt;/FormItem&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-Switch\"><a href=\"#3-Switch\" class=\"headerlink\" title=\"3.Switch\"></a>3.Switch</h2><p>开发的切换</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Form.Item &#123;...formItemLayout&#125; label=&#x27;xxx&#x27;&gt;</span><br><span class=\"line\">  &#123;getFieldDecorator(&#x27;enabledAutoFeed&#x27;, &#123;</span><br><span class=\"line\">    initialValue: (detail &amp;&amp; detail.enabledAutoFeed) || undefined,</span><br><span class=\"line\">    valuePropName: &#x27;checked&#x27;, // 记得加上这个属性</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;required: false, message: &#x27;xxx&#x27;&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;)(</span><br><span class=\"line\">    &lt;Switch</span><br><span class=\"line\">      checkedChildren=&#x27;是&#x27;</span><br><span class=\"line\">      unCheckedChildren=&#x27;否&#x27;</span><br><span class=\"line\">      onChange=&#123;(val, event) =&gt; &#123;</span><br><span class=\"line\">        event.preventDefault();</span><br><span class=\"line\">        event.stopPropagation();</span><br><span class=\"line\">        this.setState(&#123; enabledAutoFeed: val &#125;)\t\t// 将当前改变的值存至state中，提交时直接用state中存储的值就好了</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  )&#125;</span><br><span class=\"line\">&lt;/Form.Item&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-Cascader\"><a href=\"#4-Cascader\" class=\"headerlink\" title=\"4.Cascader\"></a>4.Cascader</h2><h3 id=\"情况一：只有两个层级数\"><a href=\"#情况一：只有两个层级数\" class=\"headerlink\" title=\"情况一：只有两个层级数\"></a>情况一：只有两个层级数</h3><p>此情况组件用例是在一个新增&#x2F;编辑的弹出框中使用，新增时不带数据，可选择；编辑时带出默认数据，也可选择；层级是 2 级。<br>开发思路：</p>\n<ul>\n<li>（1）新增时，不带默认数据出来，但是已经请求到第一层级的数据，点击第一层级中的某一项 item 时，加载请求第二层级的数据给到 item 的 children 中，这样就可以显示第二层级的数据了；</li>\n<li>（2）编辑时，带出默认数据，此时 defaultMaterialIds 应该是有两个 id 值的，如：[parentId, sonId]，但是在点编辑弹出弹框而还没有点击级联组件时，只显示了第一层级的数据，因为此时页面起始已经有第一层级的数据源，而不知道第二层级的数据源，只单纯的有第二层级项的 id（也就是 sonId），是不知道它的 label（或 name）的，思路是：在点击编辑的时候，拿到它的第一层级 id（也就是 parentId），请求第二层级的数据就好了（其实就是点击编辑时再次调用 loadData 方法~~~）</li>\n</ul>\n<p>附上实现逻辑代码：</p>\n<p>1.弹框中（editModal.jsx）：</p>\n<p>render 中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Form.Item &#123;...formItemLayout&#125; label=&#x27;物料名称&#x27;&gt;</span><br><span class=\"line\">    &#123;getFieldDecorator(`materialId`, &#123;</span><br><span class=\"line\">      // defaultMaterialIds 是默认的数据（一个数组形式），如：[parentId, sonId]</span><br><span class=\"line\">      initialValue: defaultMaterialIds || []</span><br><span class=\"line\">      &#125;)(</span><br><span class=\"line\">        &lt;Cascader</span><br><span class=\"line\">          fieldNames=&#123;fieldNames&#125;</span><br><span class=\"line\">          options=&#123;materialLabel&#125;</span><br><span class=\"line\">          loadData=&#123;this.loadData&#125;</span><br><span class=\"line\">          onChange=&#123;this.onChange&#125;</span><br><span class=\"line\">          placeholder=&#x27;请选择物料名称&#x27;</span><br><span class=\"line\">          changeOnSelect</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      )&#125;</span><br><span class=\"line\">  &lt;/Form.Item&gt;</span><br></pre></td></tr></table></figure>\n\n<p>相应方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 级联-选择后的回调</span><br><span class=\"line\">  onChange = (value, selectedOptions) =&gt; &#123;</span><br><span class=\"line\">    const &#123; dispatch, namespace &#125; = this.props;</span><br><span class=\"line\">    const name = [];</span><br><span class=\"line\">    const id = [];</span><br><span class=\"line\">    const code = [];</span><br><span class=\"line\">    // console.log(value, selectedOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">    selectedOptions.map((v) =&gt; &#123;</span><br><span class=\"line\">      name.push(v.name);</span><br><span class=\"line\">      id.push(v.id);</span><br><span class=\"line\">      code.push(v.code)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      currentId: value</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  // 动态加载选项</span><br><span class=\"line\">  loadData = (selectedOptions) =&gt; &#123;</span><br><span class=\"line\">    const &#123; dispatch, namespace, materialLabel, form: &#123; setFieldsValue &#125;, &#125; = this.props;</span><br><span class=\"line\">    const targetOption = selectedOptions[selectedOptions.length - 1];</span><br><span class=\"line\">    targetOption.loading = true;</span><br><span class=\"line\">    // 异步加载数据，targetOption 是选中的那一项数据</span><br><span class=\"line\">    dispatch(&#123;</span><br><span class=\"line\">      type:`$&#123;namespace&#125;/getMaterialList`,</span><br><span class=\"line\">      payload:&#123; targetOption &#125;,</span><br><span class=\"line\">      callback:(res)=&gt;&#123;</span><br><span class=\"line\">        targetOption.loading = false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.view.jsx 中（editModal 在 view 中被引用）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 点击编辑时，传第一级id，请求第二级数据显示</span><br><span class=\"line\">loadData = (parentId) =&gt; &#123;</span><br><span class=\"line\">const &#123; dispatch, pigfarmConfListIndexMod: &#123; materialLabel &#125; &#125;= this.props;</span><br><span class=\"line\">// materialLabel为第一层级数据源</span><br><span class=\"line\">const targetOption = materialLabel.find(item =&gt; item.id === parentId)</span><br><span class=\"line\"></span><br><span class=\"line\">// 异步加载数据</span><br><span class=\"line\">dispatch(&#123;</span><br><span class=\"line\">  type:`$&#123;namespace&#125;/getMaterialList`,</span><br><span class=\"line\">  payload:&#123; targetOption &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 点击编辑时调用的方法</span><br><span class=\"line\">showModal = (&#123;data = null, type = &#x27;add&#x27; &#125;) =&gt; &#123;</span><br><span class=\"line\">    const &#123; dispatch &#125; = this.props;</span><br><span class=\"line\">    if(type === &#x27;add&#x27;) &#123;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: `$&#123;namespace&#125;/updateStore`,</span><br><span class=\"line\">        payload: &#123; showModal: true, detail: data, modalType: type,  &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">      // 编辑时拿到parentId请求第二层级数据</span><br><span class=\"line\">      this.loadData(data.parentId);</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: `$&#123;namespace&#125;/updateStore`,</span><br><span class=\"line\">        payload: &#123; showModal: true, detail: data, defaultMaterialIds: [data.parentId, data.materialId], modalType: type,  &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.mod.js 中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 获取物料列表---这是第二层级</span><br><span class=\"line\">*getMaterialList(&#123; payload, callback &#125;, &#123; put, call, select &#125;) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  // targetOption 是点击的第一层级的项</span><br><span class=\"line\">  let targetOption = payload.targetOption;</span><br><span class=\"line\">  const children = [];</span><br><span class=\"line\">  // 第一层级数据源materialLabel是一个对象数组，数组中的每一项都是一个对象，带有id,name等属性</span><br><span class=\"line\">  const _materialLabel = [...materialLabel]</span><br><span class=\"line\">  // payload.targetOption.id是点击的第一层级的项，用来获取第二层级的数据源</span><br><span class=\"line\">  const result = yield call(urlMaterialList, &#123;id: payload.targetOption.id&#125;);</span><br><span class=\"line\">  // idx是在第一层级中点击的项的位置</span><br><span class=\"line\">  const idx = _materialLabel.findIndex(item=&gt;item.id===targetOption.id)</span><br><span class=\"line\">  // 深拷贝第一层级中选中的项，后面会加上一个children属性，而children就是第二层级的数据源</span><br><span class=\"line\">  // 把这个第二层级数据源 替换掉 第一层级中选中的那个项</span><br><span class=\"line\">  // 然后赋值给整个第一层级的数据源，因为第一层级选中的那个项已经加上了children属性，可以显示第二层级的数据了</span><br><span class=\"line\"></span><br><span class=\"line\">  const materialItem = cloneDeep(targetOption);</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">    if(result.data.length &gt; 0) &#123;</span><br><span class=\"line\">      result.data.map(item =&gt; &#123;</span><br><span class=\"line\">        // 因为第2级就是末级了，所以isLeaf为true</span><br><span class=\"line\">        let obj = &#123; ...item, isLeaf: true &#125;;</span><br><span class=\"line\">        children.push(obj);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      // 当前项加上children ，loading 属性</span><br><span class=\"line\">      materialItem.children = children;</span><br><span class=\"line\">      materialItem.loading = false;</span><br><span class=\"line\">      // 然后替换第一层级中选中的那一项</span><br><span class=\"line\">      _materialLabel.splice(idx,1,materialItem)</span><br><span class=\"line\">      yield put(&#123;</span><br><span class=\"line\">        type: &#x27;updateStore&#x27;,</span><br><span class=\"line\">        payload: &#123;</span><br><span class=\"line\">          materialList: result.data,</span><br><span class=\"line\">          materialLabel:_materialLabel</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      callback &amp;&amp; callback();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"情况二：多个层级（以下例子为-4-级：地址的省-市-区-镇）\"><a href=\"#情况二：多个层级（以下例子为-4-级：地址的省-市-区-镇）\" class=\"headerlink\" title=\"情况二：多个层级（以下例子为 4 级：地址的省-市-区-镇）\"></a>情况二：多个层级（以下例子为 4 级：地址的省-市-区-镇）</h3><p>此情况是用于获取一个中国地区各省市级地址信息的获取及展示&#x2F;显示；<br>在平时开发项目中，一般会封装好一个组件，然后多个地方使用，提高开发效率。</p>\n<p><strong>开发思路</strong>：一开始获得第一层级的地址 a，将 a 的 id 传至后端请求 a 的第二层级 b，b 的 id 又请求第三层级 c…以此类推，将请求到的数据 b 每一项加上 isLeaf 属性（末级为 true，非末级为 false），然后将这个新的 b 赋值给 a 的 children，就可以显示第二层级 b 的数据了，依此类推，第三第四级也是…</p>\n<p>以下是有关子组件及父组件的逻辑及实现：（主要看注释吧~）</p>\n<h4 id=\"1-子组件中（封装-export-名为-CascaderAddress-）：\"><a href=\"#1-子组件中（封装-export-名为-CascaderAddress-）：\" class=\"headerlink\" title=\"1.子组件中（封装 export 名为 CascaderAddress ）：\"></a>1.子组件中（封装 export 名为 CascaderAddress ）：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Cascader</span><br><span class=\"line\">\t// 在实际编辑器中，应该不能这样注释的，这里是为理解外加的注释</span><br><span class=\"line\">   &#123;...options&#125; \t// 可选项配置，如placeHolder,changeOnSelect等，当然也可直接分开写</span><br><span class=\"line\">  value=&#123;defaultAddress&#125;\t// 指定的或默认的数据</span><br><span class=\"line\">  options=&#123;addressOptions&#125;\t// 级联地址的数据源</span><br><span class=\"line\">  loadData=&#123;this.loadAddressData&#125;\t// 动态加载数据（如点击第一层，加载第二层...）</span><br><span class=\"line\">  onChange=&#123;this.onChangeAddress&#125;\t// 点击/选择完成后的回调</span><br><span class=\"line\">  fieldNames=&#123;fieldNames&#125;\t// 自定义数据源options的label,value,children</span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 地址选择</span><br><span class=\"line\">  onChangeAddress = (value, selectedOptions) =&gt; &#123;</span><br><span class=\"line\">    const &#123; changeCallback &#125; = this.props;</span><br><span class=\"line\">    const dataString = [];</span><br><span class=\"line\">    const ids = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    selectedOptions.map((v) =&gt; &#123;</span><br><span class=\"line\">      dataString.push(v.areaName);</span><br><span class=\"line\">      ids.push(v.id);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">\t// 选择完成后的回调，将选择地址的id,name,以及其他信息存起来备用</span><br><span class=\"line\">    changeCallback(&#123;data: selectedOptions, ids, dataString&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取地址</span><br><span class=\"line\">  loadAddressData = selectedOptions =&gt; &#123;</span><br><span class=\"line\">    const &#123; loadData, addressOptions &#125; = this.props;</span><br><span class=\"line\">    const targetOption = selectedOptions[selectedOptions.length - 1];</span><br><span class=\"line\">    targetOption.loading = true;</span><br><span class=\"line\">\t// 将当前选择项的id请求后端拿到下一层级数据（加上isLeaf属性），赋给当前选择项的children，就可以显示出下一层级的数据了</span><br><span class=\"line\">    this.getAddressOptions(targetOption.id, (list) =&gt; &#123;</span><br><span class=\"line\">      targetOption.loading = false;</span><br><span class=\"line\">      targetOption.children = list;</span><br><span class=\"line\"></span><br><span class=\"line\">      loadData(addressOptions);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 请求地址数据</span><br><span class=\"line\">  getAddressOptions = (parentId, callback) =&gt; &#123;</span><br><span class=\"line\">    const &#123; max &#125; = this.state;</span><br><span class=\"line\">    const &#123; request, url &#125; = this.props;</span><br><span class=\"line\">    const params = &#123;</span><br><span class=\"line\">      &#x27;id&#x27;: parentId || &#x27;0&#x27;,\t// &#x27;0&#x27;表示请求第一层级，看后端需要传什么</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    request(&#123;</span><br><span class=\"line\">      // 拿点击的那一项的id请求下一层级的数据（也就是children）</span><br><span class=\"line\">      url: `$&#123;url&#125;/$&#123;params.id&#125;`,</span><br><span class=\"line\">      method: &#x27;get&#x27;,</span><br><span class=\"line\">      data: params,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">      .then((res) =&gt; &#123;</span><br><span class=\"line\">        if(res.code === &#x27;000000&#x27;) &#123;</span><br><span class=\"line\">          let list = []</span><br><span class=\"line\">          if(res.data &amp;&amp; res.data.length) &#123;</span><br><span class=\"line\">          // 判断是否为末级，为每一项加上isLeaf属性</span><br><span class=\"line\">            list = res.data.map(item =&gt; (&#123; ...item, isLeaf: item.areaLevel &gt; max &#125;));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">\t\t// 回调显示当前list数据</span><br><span class=\"line\">          callback(list);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          message.error(res.msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-父组件中引用：\"><a href=\"#2-父组件中引用：\" class=\"headerlink\" title=\"2.父组件中引用：\"></a>2.父组件中引用：</h4><p>（1）view.jsx</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 注意farmAddress为当前级联控件的唯一标识</span><br><span class=\"line\">&lt;Form.Item &#123;...formItemLayout&#125; label=&#x27;地址&#x27;&gt;</span><br><span class=\"line\">   &#123;getFieldDecorator(&#x27;farmAddress&#x27;, &#123;</span><br><span class=\"line\">     initialValue: defaultAddressIds || undefined,</span><br><span class=\"line\">     rules: [</span><br><span class=\"line\">       &#123; required: true, message: &#x27;请输入地址&#x27; &#125;,</span><br><span class=\"line\">     ],</span><br><span class=\"line\">   &#125;)(</span><br><span class=\"line\">     &lt;CascaderAddress &#123;...cascaderProps&#125;/&gt;</span><br><span class=\"line\">   )&#125;</span><br><span class=\"line\">&lt;/Form.Item&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 级联数据值名称配置</span><br><span class=\"line\">  const cascaderOptionLabel = &#123;</span><br><span class=\"line\">    label: &#x27;areaName&#x27;,\t// 显示的是label，自定义为areaName</span><br><span class=\"line\">    value: &#x27;id&#x27;, // 传值的是value，自定义为id</span><br><span class=\"line\">    children: &#x27;children&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 级联地址选择配置项目</span><br><span class=\"line\">  const cascaderProps = &#123;</span><br><span class=\"line\">    request,</span><br><span class=\"line\">    url: `xxx`,</span><br><span class=\"line\">    addressOptions,\t// 数据源</span><br><span class=\"line\">    defaultAddress: defaultAddressIds,\t// 默认数据，</span><br><span class=\"line\">    fieldNames: cascaderOptionLabel,\t// 自定义配置项</span><br><span class=\"line\">    loadData: (data) =&gt; &#123;\t// 动态加载数据</span><br><span class=\"line\">      dispatch(&#123; type: `$&#123;namespace&#125;/updateStore`, payload: &#123; addressOptions: [...data] &#125; &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 选择之后的回调，farmAddress为表单控件中存储的数据，可直接/处理之后提交~</span><br><span class=\"line\">    changeCallback: (&#123;data, dataString, ids&#125;) =&gt; &#123;</span><br><span class=\"line\">      setFieldsValue(&#123; farmAddress: ids &#125;); // 设置form表单数据</span><br><span class=\"line\">      dispatch(&#123; type: `$&#123;namespace&#125;/updateStore`, payload: &#123; defaultAddressIds: ids &#125; &#125;); // 存储至mod备用</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">      placeholder: &#x27;请选择地址&#x27;,</span><br><span class=\"line\">      changeOnSelect: true,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）mod.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 获取地址列表</span><br><span class=\"line\">*getAddressOptions(&#123; payload = &#123; id: &#x27;&#x27; &#125;, callback &#125;, &#123; put, call, select &#125;) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">  // ...假设调用接口请求到数据存至res.data</span><br><span class=\"line\">    let addressOptions = []</span><br><span class=\"line\">    if(res.data &amp;&amp; res.data.length) &#123;</span><br><span class=\"line\">      addressOptions = res.data.map(item =&gt; (&#123; id: item.id, value: item.id, areaName: item.areaName, isLeaf: false &#125;))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    yield put(&#123;</span><br><span class=\"line\">      type: &#x27;updateStore&#x27;,</span><br><span class=\"line\">      payload: &#123;</span><br><span class=\"line\">        addressOptions,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> // 根据ID获取该地址信息包含各级数据</span><br><span class=\"line\">* getAreaInfo(&#123; payload, callback &#125;, &#123; call, put, select &#125;) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> // ...</span><br><span class=\"line\">    let addressOptions = [];</span><br><span class=\"line\">    if(result.data &amp;&amp; result.data.length) &#123;</span><br><span class=\"line\">      addressOptions = result.data[0].list;</span><br><span class=\"line\"></span><br><span class=\"line\">      addressOptions.map( v =&gt; &#123; // 省</span><br><span class=\"line\">        v.isLeaf = false;</span><br><span class=\"line\">        if(v.id === result.data[0].selected.id) &#123;</span><br><span class=\"line\">          v.children = result.data[1].list;</span><br><span class=\"line\"></span><br><span class=\"line\">          v.children.map( v1 =&gt; &#123; // 市</span><br><span class=\"line\">            v1.isLeaf = false;</span><br><span class=\"line\">            if(v1.id === result.data[1].selected.id) &#123;</span><br><span class=\"line\">              v1.children = result.data[2].list;</span><br><span class=\"line\"></span><br><span class=\"line\">              v1.children.map( v2 =&gt; &#123; // 区</span><br><span class=\"line\">                v2.isLeaf = false;</span><br><span class=\"line\">                if(v2.id === result.data[2].selected.id) &#123;</span><br><span class=\"line\">                  v2.children = result.data[3].list;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    yield put(&#123;</span><br><span class=\"line\">      type: &#x27;updateStore&#x27;,</span><br><span class=\"line\">      payload: &#123;</span><br><span class=\"line\">        addressOptions,</span><br><span class=\"line\">        detailAddress: result.data,</span><br><span class=\"line\">        // 后端返回的默认地址id，组成一个数组展示</span><br><span class=\"line\">        defaultAddressIds: [detail.addressProvince, detail.addressCity, detail.addressZone, detail.addressTown]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    callback &amp;&amp; callback();</span><br><span class=\"line\"> // ...</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实两个情况很类似的，都是将取到的下一级的数据，每一项都加上 isLeaf 属性，然后将这个新的数据加上 children，loading 属性，替换上一级中被选择的那一项，就可以显示下一级的数据了~~~</p>\n<h3 id=\"5-Table\"><a href=\"#5-Table\" class=\"headerlink\" title=\"5.Table\"></a>5.Table</h3><p>某些列表，后端不做分页，需要前端分页时，table 的一般配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Table</span><br><span class=\"line\">\tbordered\t// 给整个table加上边框</span><br><span class=\"line\">\tdataSource=&#123;tableList&#125;</span><br><span class=\"line\">\tcolumns=&#123;tableColumns&#125;</span><br><span class=\"line\">\trowkey=&#123;record =&gt; record.id&#125;</span><br><span class=\"line\">\tpagination=&#123;&#123;</span><br><span class=\"line\">\t\tshowQuickJumper: true,</span><br><span class=\"line\">\t\tshowSizeChanger: true,</span><br><span class=\"line\">\t\tshowTotal: total =&gt; `共$&#123;total&#125;条`,</span><br><span class=\"line\">\t\tpageSizeOptions:[&#x27;10&#x27;,&#x27;20&#x27;,&#x27;50&#x27;,&#x27;100&#x27;],</span><br><span class=\"line\">\t\t// pageSize: 5, // 固定5条一页，有pageSize就不用pageSizeOptions了</span><br><span class=\"line\">\t&#125;&#125;</span><br><span class=\"line\"> /&gt;</span><br></pre></td></tr></table></figure>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"Chrome Devtool — Performance","url":"/2022/10/24/Chrome-Devtool-%E2%80%94-Performance/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Performance 一个在前端开发领域中，无法被忽视的存在。使用 Chrome DevTools 的 performance 面板可以记录和分析页面在运行时的所有活动。本文将详细介绍如何使用 performance 面板解决性能瓶颈。</p>\n<h3 id=\"一、Performance-工具优点\"><a href=\"#一、Performance-工具优点\" class=\"headerlink\" title=\"一、Performance 工具优点\"></a>一、Performance 工具优点</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- 可视化图形界面</span><br><span class=\"line\">- 每毫秒做的事情</span><br><span class=\"line\">- 文件的执行加载的顺序</span><br><span class=\"line\">- 每毫秒界面展示的效果</span><br><span class=\"line\">- 每个方法执行的顺序和时间（由下至上）</span><br><span class=\"line\">- 倒置的事件火焰图（由下至上）</span><br><span class=\"line\">- 数据总结</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、熟悉-Performance-面板\"><a href=\"#二、熟悉-Performance-面板\" class=\"headerlink\" title=\"二、熟悉 Performance 面板\"></a>二、熟悉 Performance 面板</h3><p><img src=\"https://img-blog.csdnimg.cn/20200225113413787.png\" alt=\"image\"></p>\n<h3 id=\"三、工具栏\"><a href=\"#三、工具栏\" class=\"headerlink\" title=\"三、工具栏\"></a>三、工具栏</h3><blockquote>\n<p>【3.1】录制: 点击 Record （按 Ctrl+E），这时候 Devtools 就开始录制各种性能指标。记录时，Record 按钮会变成红色。然后按 Record 按钮或再次键入键盘快捷键停止记录；</p>\n<p>【3.2】刷新: 刷新页面分析；</p>\n<p>【3.3】清除: 清除页面分析结果；</p>\n<p>【3.4】上下箭头: 用来上传和下载每一次性能检测报告；</p>\n<p>【3.5】Screendshots: 显示屏幕快照，是用来查看在每个时间段界面的变化；</p>\n<p>【3.6】Memory: 存储调用栈的大小，在不同时间段的不同大小；</p>\n<p>【3.7】Disable Javascript samples: 禁用 JavaScript 调用栈；</p>\n<p>【3.8】Enable advanced paint instrumentation(slow): 记录渲染事件的细节；</p>\n<p>【3.9】Network: 模拟不同的网络环境；</p>\n<p>【3.10】CPU: 模拟不同的 CPU 运行速度；</p>\n</blockquote>\n<h3 id=\"四、overview-页面性能高级汇总\"><a href=\"#四、overview-页面性能高级汇总\" class=\"headerlink\" title=\"四、overview(页面性能高级汇总)\"></a>四、overview(页面性能高级汇总)</h3><p>这里最主要是整体的界面渲染的时候，每个时间段执行的事件顺序，我们就能知道我们每个时间段（精确到毫秒）都做了什么，当鼠标放上去的时候，我们还可以大图的形式去查看我们每个时间段界面的渲染情况：</p>\n<p><strong>【4.1】FPS</strong>: 全称 Frames Per Second，表示每秒传输帧数，是速度单位，用来分析动画的一个主要性能指标。如果能够达到 &gt;&#x3D;60fps(帧)&#x2F;s 的刷新频率，就可以避免出现卡顿。能保持在 60 的 FPS 的话，那么用户体验就是不错的。</p>\n<blockquote>\n<p><strong>为什么是 60fps?</strong></p>\n<p>我们的目标是保证页面要有高于每秒 60fps(帧)的刷新频率，这和目前大多数显示器的刷新率相吻合(60Hz)。如果网页动画能够做到每秒 60 帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行 60 次重新渲染，每次重新渲染的时间不能超过 1&#x2F;60&#x3D;0.01666s（秒）， 0.01666s*1000&#x3D;16.66ms（毫秒）。</p>\n</blockquote>\n<blockquote>\n<p><strong>不同帧的体验</strong>：<br>帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；<br>帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；<br>帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；<br>帧率波动很大的动画，亦会使人感觉到卡顿。</p>\n</blockquote>\n<p>如下图所示，绿色的长条越高，说明 FPS 越高，用户体验越好。 如果你发现了一个红色的长条，那么就说明这些帧存在严重问题，有可能导致非常差的用户体验。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225141647281.png\" alt=\"image\"></p>\n<p><strong>【4.2】CPU</strong>: CPU 资源。CPU 图表中的各种颜色代表着在这个时间段内，CPU 在各种处理上所花费的时间。如果你看到了某个处理占用了大量的时间，那么这可能就是一个可以找到性能瓶颈的线索。</p>\n<blockquote>\n<p>**下图中颜色分别为(与 Summary 面板里的颜色是相互对应的)**：</p>\n<p><strong>蓝色(Loading)</strong>: 表示网络通信和 HTML 解析时间<br><strong>黄色(Scripting)</strong>: 表示 JavaScript 执行时间<br><strong>紫色(Rendering)</strong>: 表示样式计算和布局（重排）时间<br><strong>绿色(Painting</strong>): 表示重绘时间<br><strong>灰色(other)</strong>: 表示其它事件花费的时间<br><strong>白色(Idle)</strong>: 表示空闲时间</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225142026718.png\" alt=\"image\"></p>\n<p><strong>【4.3】NET</strong>: 每条彩色横杠表示一种资源。横杠越长，检索资源所需的时间越长。 每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间）。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225142049962.png\" alt=\"image\"></p>\n<p><strong>【4.4】HEAP</strong>: JavaScript 执行的时间分布。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2020022514210719.png\" alt=\"image\"></p>\n<h3 id=\"五、火焰图-CPU-堆叠追踪的可视化\"><a href=\"#五、火焰图-CPU-堆叠追踪的可视化\" class=\"headerlink\" title=\"五、火焰图(CPU 堆叠追踪的可视化)\"></a>五、火焰图(CPU 堆叠追踪的可视化)</h3><p><img src=\"https://img-blog.csdnimg.cn/20200225151854312.png\" alt=\"image\"></p>\n<p><strong>【5.1】Network</strong>: 表示每个服务器资源的加载情况，什么时间加载了什么资源，通过这里，我们更直观的可以知道，资源是并行加载的</p>\n<p><strong>【5.2】Frames</strong>: 表示每幅帧的运行情况</p>\n<p><strong>【5.3】Timings</strong>: 上图中有 4 条虚线，分别表示如下：</p>\n<blockquote>\n<ul>\n<li><strong>DCL(DOMContentLoaded)</strong>: 表示 HTML 文档加载完成事件。当初始 HTML 文档完全加载并解析之后触发，无需等待样式、图片、子 frame 结束。作为明显的对比，load 事件是当个页面完全被加载时才触发</li>\n<li><strong>FP(First Paint)</strong>: 首屏绘制，页面刚开始渲染的时间</li>\n<li><strong>FCP(First Contentful Paint)</strong>: 首屏内容绘制，首次绘制任何文本，图像，非空白 canvas 或 SVG 的时间点</li>\n<li><strong>FMP(First Meaningful Paint)</strong>: 首屏有意义的内容绘制，这个“有意义”没有权威的规定，本质上是通过一种算法来猜测某个时间点可能是 FMP。有的理解为是最大元素绘制的时间，即同 LCP(Largest Contentful Paint）</li>\n<li><strong>L(Onload)</strong>: 页面所有资源加载完成事件。</li>\n<li><strong>LCP(Largest Contentful Paint)</strong>: 最大内容绘制，页面上尺寸最大的元素绘制时间。<br>其中 FP、FCP、FMP 是同一条虚线，三者时间不一致。比如首次渲染过后，有可能出现 JS 阻塞，这种情况下 FCP 就会大于 FP</li>\n</ul>\n</blockquote>\n<p><strong>【5.4】Main</strong>: 表示主线程</p>\n<blockquote>\n<p><strong>主要负责</strong>：</p>\n<ul>\n<li>Javascript 的计算与执行</li>\n<li>CSS 样式计算</li>\n<li>Layout 布局计算</li>\n<li>将页面元素绘制成位图（paint），也就是光栅化（Raster）</li>\n<li>将位图给合成线程</li>\n</ul>\n</blockquote>\n<p><strong>【5.5】Raster</strong>: 光栅化（处理光栅图，即位图）</p>\n<p><strong>【5.6】GPU</strong>: 表示 GPU 占用情况</p>\n<p><strong>【5.7】Chrome_childIOThread</strong>: 子线程</p>\n<p><strong>【5.8】Compositor</strong>: 合成线程</p>\n<blockquote>\n<p><strong>主要负责</strong>：</p>\n<ul>\n<li>将位图（GraphicsLayer 层）以纹理（texture）的形式上传给 GPU</li>\n<li>计算页面的可见部分和即将可见部分（滚动）</li>\n<li>CSS 动画处理</li>\n<li>通知 GPU 绘制位图到屏幕上</li>\n</ul>\n</blockquote>\n<p><strong>【5.9】Memory</strong>: 上面有提到 Memory 选项，在勾选后，就会显示该事件折线图，通过该图，可以看出我们在不同的时间段，不同事件的执行情况</p>\n<blockquote>\n<ul>\n<li><strong>JS Heap:</strong> 表示 JS 占用的内存大小。</li>\n<li><strong>Documents</strong>: 表示文档数。</li>\n<li><strong>Nodes:</strong> 表示 Node 节点数</li>\n<li><strong>Listeners:</strong> 表示监听数。</li>\n<li><strong>GPU Memory:</strong> 表示 GPU 占用数<br>4 条折线图是以上 4 个指标（没有 GPU 消耗）对应的时间消耗的内存大小与节点数量。若将某项指标前面的勾选去掉则不会出现对应的折线。注意这个折线图只有在点击 Main 主线程的时候才会有，选择其他的指标时折线图区域是空白。</li>\n</ul>\n</blockquote>\n<h3 id=\"六、统计汇总-以图表的形式汇总数据\"><a href=\"#六、统计汇总-以图表的形式汇总数据\" class=\"headerlink\" title=\"六、统计汇总(以图表的形式汇总数据)\"></a>六、统计汇总(以图表的形式汇总数据)</h3><p><img src=\"https://img-blog.csdnimg.cn/20200225155545507.png\" alt=\"image\"></p>\n<p><strong>【6.1】Summary</strong>: 表示各指标时间占用统计报表</p>\n<blockquote>\n<ul>\n<li>Loading: 加载时间</li>\n<li>Scripting: js 计算时间</li>\n<li>Rendering: 渲染时间</li>\n<li>Painting: 绘制时间</li>\n<li>Other: 其他时间</li>\n<li>Idle: 浏览器闲置时间</li>\n</ul>\n</blockquote>\n<p><strong>【6.2】Bottom-Up</strong>: 表示事件时长排序列表（倒序）</p>\n<p>这里和 Main 里面看见的，其实是一个对应着的关系，从这里，我们可以看见所有的事件列表，还有每个事件的 Self Time(自己调用的时间） 、Total Time(总调用时间，包括子项调用时间） 、Activity(行为，包括调用该事件的位置）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225160433232.png\" alt=\"image\"></p>\n<p><strong>【6.3】Call Tree</strong>: 表示事件调用顺序列表</p>\n<p>其实这里和 Bottom-Up 部分是一样的，就不做太多的说明了</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225160516378.png\" alt=\"image\"></p>\n<p><strong>【6.4】Event Log</strong>: 表示事件发生的顺序列表</p>\n<p>这里比前面的 Bottom-Up 和 Call Tree 相比，多了一个 Start Time 属性，这个属性其实就是开始的时间，从什么时间开始执行的什么事件</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200225160545704.png\" alt=\"image\"></p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"Docker 常用命令","url":"/2022/12/16/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"<h2 id=\"一、docker-的命令的解释\"><a href=\"#一、docker-的命令的解释\" class=\"headerlink\" title=\"一、docker 的命令的解释\"></a>一、docker 的命令的解释</h2><h3 id=\"1、命令解释\"><a href=\"#1、命令解释\" class=\"headerlink\" title=\"1、命令解释\"></a>1、命令解释</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d -p 80:80 nginx</span><br><span class=\"line\"></span><br><span class=\"line\">run （创建并运行一个容器）</span><br><span class=\"line\">-d 放在后台</span><br><span class=\"line\">-p 端口映射</span><br><span class=\"line\">nginx docker镜像的名字</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、配置-docker-镜像加速\"><a href=\"#2、配置-docker-镜像加速\" class=\"headerlink\" title=\"2、配置 docker 镜像加速\"></a>2、配置 docker 镜像加速</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/docker/daemon.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、docker-容器是一种软件的打包技术，接下来我们体验一下\"><a href=\"#3、docker-容器是一种软件的打包技术，接下来我们体验一下\" class=\"headerlink\" title=\"3、docker 容器是一种软件的打包技术，接下来我们体验一下\"></a>3、docker 容器是一种软件的打包技术，接下来我们体验一下</h3><p>1、传统编译安装 nginx：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">官网下载Nginx源码包wget</span><br><span class=\"line\">tar解压源码包</span><br><span class=\"line\">创建Nginx用户</span><br><span class=\"line\">安装依赖包</span><br><span class=\"line\">编译安装三部曲configure，make，make install</span><br><span class=\"line\">修改nginx配置文件</span><br><span class=\"line\">启动nginx</span><br></pre></td></tr></table></figure>\n\n<p>2、docker 容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、镜像常用命令\"><a href=\"#二、镜像常用命令\" class=\"headerlink\" title=\"二、镜像常用命令\"></a>二、镜像常用命令</h2><h3 id=\"1、搜索镜像：\"><a href=\"#1、搜索镜像：\" class=\"headerlink\" title=\"1、搜索镜像：\"></a>1、搜索镜像：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker search</span><br></pre></td></tr></table></figure>\n\n<p>选镜像的建议：</p>\n<ol>\n<li>优先考虑官方</li>\n<li>stars 数量多</li>\n</ol>\n<h3 id=\"2、获取镜像\"><a href=\"#2、获取镜像\" class=\"headerlink\" title=\"2、获取镜像:\"></a>2、获取镜像:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull（push）</span><br></pre></td></tr></table></figure>\n\n<p>镜像加速器：阿里云加速器，daocloud 加速器，中科大加速器，Docker 中国官方镜像加速：<a href=\"https://registry.docker-cn.com/\">https://registry.docker-cn.com</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull centos:6.8（没有指定版本，默认会下载最新版）</span><br><span class=\"line\">docker pull daocloud.io/huangzhichong/alpine-cn:latest</span><br></pre></td></tr></table></figure>\n\n<p>扩展：查询 docker 镜像所有版本 <a href=\"https://hub.docker.com/r/library/\">https://hub.docker.com/r/library/</a></p>\n<h3 id=\"3、查看删除导出\"><a href=\"#3、查看删除导出\" class=\"headerlink\" title=\"3、查看删除导出\"></a>3、查看删除导出</h3><p>1、查看镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n\n<p>2、删除镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker rmi 例子：docker image rm centos:latest</span><br></pre></td></tr></table></figure>\n\n<p>3、导出镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker save 例子：docker image save centos &gt; docker-centos7.4.tar.gz&lt;br&gt;docker save mysql:5.7&gt; mysql-5.7.tar.gz</span><br></pre></td></tr></table></figure>\n\n<p>4、导入镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker load 例子：docker load -i docker-centos7.4.tar.gz</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、容器常用命令\"><a href=\"#三、容器常用命令\" class=\"headerlink\" title=\"三、容器常用命令\"></a>三、容器常用命令</h2><h3 id=\"1、运行一个容器\"><a href=\"#1、运行一个容器\" class=\"headerlink\" title=\"1、运行一个容器\"></a>1、运行一个容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d -p 80:80 nginx:latest</span><br><span class=\"line\">run （创建并运行一个容器）</span><br><span class=\"line\">-d 放在后台</span><br><span class=\"line\">-p 端口映射</span><br><span class=\"line\">nginx:latest docker镜像的名字和版本</span><br><span class=\"line\">还有很多其他的参数</span><br><span class=\"line\"></span><br><span class=\"line\">docker run == docker create + docker start</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、进入到容器\"><a href=\"#2、进入到容器\" class=\"headerlink\" title=\"2、进入到容器\"></a>2、进入到容器</h3><p>进入容器的目的：排错，调试</p>\n<p>进入容器的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class=\"line\">例子：</span><br><span class=\"line\">docker exec -it 容器id或容器名字 /bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">docker attach [OPTIONS] CONTAINER</span><br><span class=\"line\">例子：</span><br><span class=\"line\">docker attach 容器id或容器名字</span><br><span class=\"line\"></span><br><span class=\"line\">nsenter(安装yum install -y util-linux 弃用)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、停止删除容器命令\"><a href=\"#3、停止删除容器命令\" class=\"headerlink\" title=\"3、停止删除容器命令\"></a>3、停止删除容器命令</h3><p>1、停止容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker stop CONTAINER_ID</span><br></pre></td></tr></table></figure>\n\n<p>2、杀死容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker kill container_name</span><br></pre></td></tr></table></figure>\n\n<p>3、查看容器列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker ps</span><br><span class=\"line\">docker ps –a</span><br><span class=\"line\"></span><br><span class=\"line\">docker ps –a  -l</span><br></pre></td></tr></table></figure>\n\n<p>4、删除容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker rm</span><br></pre></td></tr></table></figure>\n\n<p>5、批量删除容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker rm -f `docker ps -a -q`</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、要获取所有容器名称及其-IP-地址只需一个命令。\"><a href=\"#4、要获取所有容器名称及其-IP-地址只需一个命令。\" class=\"headerlink\" title=\"4、要获取所有容器名称及其 IP 地址只需一个命令。\"></a>4、要获取所有容器名称及其 IP 地址只需一个命令。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker inspect -f &#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;.NetworkSettings.IPAddress &#125;&#125;&#x27; $(docker ps -aq)</span><br></pre></td></tr></table></figure>\n\n<p>如果使用 docker-compose 命令将是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker inspect -f &#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; $(docker ps -aq)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、显示容器的所有-IP\"><a href=\"#5、显示容器的所有-IP\" class=\"headerlink\" title=\"5、显示容器的所有 IP\"></a>5、显示容器的所有 IP</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker inspect --format=&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; $(docker ps -aq)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、容器网络访问常用命令\"><a href=\"#四、容器网络访问常用命令\" class=\"headerlink\" title=\"四、容器网络访问常用命令\"></a>四、容器网络访问常用命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -it --name centos6 centos:6.8 /bin/bash</span><br><span class=\"line\">-it 分配交互式的终端</span><br><span class=\"line\">--name 指定容器的名字</span><br><span class=\"line\">/bin/sh 覆盖容器的初始命令</span><br><span class=\"line\"></span><br><span class=\"line\">--cpus 指定cpu的数量</span><br><span class=\"line\">--memory 限定内存的大小</span><br><span class=\"line\">-h 指定容器的主机名</span><br></pre></td></tr></table></figure>\n\n<p>docker 的本质是：在隔离的环境运行的一个进程</p>\n<p>所以：docker 容器内的第一个进程必须一直处于前台运行的状态（必须夯住），否则这个容器，就会处于退出状态！</p>\n<h3 id=\"1、运行容器为什么要使用端口映射？\"><a href=\"#1、运行容器为什么要使用端口映射？\" class=\"headerlink\" title=\"1、运行容器为什么要使用端口映射？\"></a>1、运行容器为什么要使用端口映射？</h3><p>默认情况下，容器使用的 ip 是 172.17.0.0&#x2F;16 网段的，外界的用户只能访问宿主机的 10.0.0.0&#x2F;24 网段，</p>\n<p>无法访问 172.17.0.0&#x2F;16 网段。我们运行容器的目的：是希望运行在容器中的服务，能够被外界访问，</p>\n<p>这里就涉及到了外网 10.0.0.0&#x2F;24 到容器内网 172.17.0.0&#x2F;16 网段的转换，所以需要做端口映射</p>\n<h3 id=\"2、指定映射-docker-自动添加一条-iptables-规则实现端口映射\"><a href=\"#2、指定映射-docker-自动添加一条-iptables-规则实现端口映射\" class=\"headerlink\" title=\"2、指定映射(docker 自动添加一条 iptables 规则实现端口映射)\"></a>2、指定映射(docker 自动添加一条 iptables 规则实现端口映射)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-p hostPort:containerPort</span><br><span class=\"line\">-p ip:hostPort:containerPort</span><br><span class=\"line\">-p ip::containerPort(随机端口)</span><br><span class=\"line\">-p hostPort:containerPort:udp</span><br><span class=\"line\">-p 81:80 -p 443:443 可以指定多个-p　</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、随机映射\"><a href=\"#3、随机映射\" class=\"headerlink\" title=\"3、随机映射\"></a>3、随机映射</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -P （随机端口）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、数据卷常用命令\"><a href=\"#五、数据卷常用命令\" class=\"headerlink\" title=\"五、数据卷常用命令\"></a>五、数据卷常用命令</h2><h3 id=\"1、数据卷的作用：\"><a href=\"#1、数据卷的作用：\" class=\"headerlink\" title=\"1、数据卷的作用：\"></a>1、数据卷的作用：</h3><ul>\n<li>持久化容器运行过程中产生的数据文件</li>\n<li>实现多个容器间的文件共享。</li>\n</ul>\n<p>正常情况下，删除容器，容器中所有的文件也会被删除</p>\n<h3 id=\"2、数据卷常用命令\"><a href=\"#2、数据卷常用命令\" class=\"headerlink\" title=\"2、数据卷常用命令\"></a>2、数据卷常用命令</h3><p>1、创建一个数据卷</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker volume create</span><br></pre></td></tr></table></figure>\n\n<p>2、查看数据卷列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker volume ls</span><br></pre></td></tr></table></figure>\n\n<p>3、删除一个数据卷</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker volume rm</span><br></pre></td></tr></table></figure>\n\n<p>4、查看一个数据卷的属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker volume inspect</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、docker-数据卷运用一\"><a href=\"#3、docker-数据卷运用一\" class=\"headerlink\" title=\"3、docker 数据卷运用一\"></a>3、docker 数据卷运用一</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker volume create luoahong</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -d -p 80:80 -v luoahong:/usr/share/nginx/html nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\">cd /var/lib/docker/volumes/luoahong/_data/</span><br><span class=\"line\">rm -f *</span><br><span class=\"line\">wget https://www.qstack.com.cn/xiaoniaofeifei.zip</span><br><span class=\"line\">unzip xiaoniaofeifei.zip</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -d -p 81:80 -v luoahong:/usr/share/nginx/html nginx:latest</span><br><span class=\"line\">docker run -d -p 82:80 -v luoahong:/usr/share/nginx/html nginx:latest</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、把宿主机的目录挂载到容器中\"><a href=\"#4、把宿主机的目录挂载到容器中\" class=\"headerlink\" title=\"4、把宿主机的目录挂载到容器中\"></a>4、把宿主机的目录挂载到容器中</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd /opt</span><br><span class=\"line\">mkdir xiaoniao</span><br><span class=\"line\">cd xiaoniao/</span><br><span class=\"line\">wget https://www.qstack.com.cn/xiaoniaofeifei.zip</span><br><span class=\"line\">unzip xiaoniaofeifei.zip</span><br></pre></td></tr></table></figure>\n\n<p>重点</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d -p 83:80 -v /opt/xiaoniao:/usr/share/nginx/html nginx:latest</span><br></pre></td></tr></table></figure>\n","categories":["常用指令合集"],"tags":["javascript"]},{"title":"DvaJS构建配置React项目与使用","url":"/2022/12/16/DvaJS%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AEReact%E9%A1%B9%E7%9B%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"<h2 id=\"一-介绍与需求分析\"><a href=\"#一-介绍与需求分析\" class=\"headerlink\" title=\"一,介绍与需求分析\"></a>一,介绍与需求分析</h2><h3 id=\"1-1-介绍\"><a href=\"#1-1-介绍\" class=\"headerlink\" title=\"1.1,介绍\"></a>1.1,介绍</h3><p>dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以 dva 是基于现有应用架构 (redux + react-router + redux-saga 等)的一层轻量封装。是由阿里架构师 sorrycc 带领 team 完成的一套前端框架。</p>\n<h3 id=\"1-2-需求\"><a href=\"#1-2-需求\" class=\"headerlink\" title=\"1.2,需求\"></a>1.2,需求</h3><p>快速搭建基于 react 的项目(PC 端,移动端)。</p>\n<h2 id=\"二-DvaJS-构建项目\"><a href=\"#二-DvaJS-构建项目\" class=\"headerlink\" title=\"二,DvaJS 构建项目\"></a>二,DvaJS 构建项目</h2><h3 id=\"2-1-初始化项目\"><a href=\"#2-1-初始化项目\" class=\"headerlink\" title=\"2.1,初始化项目\"></a>2.1,初始化项目</h3><p>第一步:安装 node</p>\n<p>第二步:安装最新版本 dva-cli</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 $ npm install dva-cli -g</span><br><span class=\"line\">2 $ dva -v</span><br></pre></td></tr></table></figure>\n\n<p>第三步:dva new 创建新应用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 $ dva new myapp</span><br></pre></td></tr></table></figure>\n\n<p>也可以在创建项目目录 myapp 后，用 dva init 初始化项目</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 $ dva init</span><br></pre></td></tr></table></figure>\n\n<p>第四步:运行项目</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 $ cd myapp</span><br><span class=\"line\">2 $ npm start</span><br></pre></td></tr></table></figure>\n\n<p>浏览器会自动打开一个窗口</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1040068/201812/1040068-20181213123909876-330673805.png\" alt=\"image\"></p>\n<h3 id=\"2-2-项目架构介绍\"><a href=\"#2-2-项目架构介绍\" class=\"headerlink\" title=\"2.2,项目架构介绍\"></a>2.2,项目架构介绍</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|-mock             //存放用于 mock 数据的文件</span><br><span class=\"line\">|-node_modules             //项目包</span><br><span class=\"line\">|-public             //一般用于存放静态文件，打包时会被直接复制到输出目录(./dist)</span><br><span class=\"line\">|-src               //项目源代码</span><br><span class=\"line\">  |  |-assets         //用于存放静态资源，打包时会经过 webpack 处理</span><br><span class=\"line\">  |  |-caches         //缓存</span><br><span class=\"line\">  |  |-components     //组件 存放 React 组件，一般是该项目公用的无状态组件</span><br><span class=\"line\">  |  |-entries        //入口</span><br><span class=\"line\">  |  |-models         //数据模型 存放模型文件</span><br><span class=\"line\">  |  |-pages          //页面视图</span><br><span class=\"line\">  |  |-routes         //路由 存放需要 connect model 的路由组件</span><br><span class=\"line\">  |  |-services       //服务 存放服务文件，一般是网络请求等</span><br><span class=\"line\">  |  |-test           //测试</span><br><span class=\"line\">  |  |-utils          //辅助工具 工具类库</span><br><span class=\"line\">|-package.json      //包管理代码</span><br><span class=\"line\">|-webpackrc.js   //开发配置</span><br><span class=\"line\">|-tsconfig.json     /// ts配置</span><br><span class=\"line\">|-webpack.config.js //webpack配置</span><br><span class=\"line\">|-.gitignore //Git忽略文件</span><br><span class=\"line\">在dva项目目录中主要分3层，models,services,components,其中models是最重要概念，这里放的是各种数据，与数据交互的应该都是在这里。services是请求后台接口的方法。components是组件了。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三-DvaJS-的使用\"><a href=\"#三-DvaJS-的使用\" class=\"headerlink\" title=\"三,DvaJS 的使用\"></a>三,DvaJS 的使用</h2><h3 id=\"3-1-DvaJS-的五个-Api\"><a href=\"#3-1-DvaJS-的五个-Api\" class=\"headerlink\" title=\"3.1,DvaJS 的五个 Api\"></a>3.1,DvaJS 的五个 Api</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import dva from &#x27;dva&#x27;;</span><br><span class=\"line\">import &#123;message&#125; from &#x27;antd&#x27;;</span><br><span class=\"line\">import &#x27;./index.css&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 1. Initialize 创建 dva 应用实例</span><br><span class=\"line\">const app = dva();</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. Plugins 装载插件（可选）</span><br><span class=\"line\">app.use(&#123;</span><br><span class=\"line\">  onError: function (error, action) &#123;</span><br><span class=\"line\">    message.error(error.message || &#x27;失败&#x27;, 5);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. Model 注册model</span><br><span class=\"line\"> app.model(require(&#x27;../models/example&#x27;).default);</span><br><span class=\"line\"></span><br><span class=\"line\">// 4. Router 配置路由</span><br><span class=\"line\">app.router(require(&#x27;../routes/router&#x27;).default);</span><br><span class=\"line\"></span><br><span class=\"line\">// 5. Start 启动应用</span><br><span class=\"line\">app.start(&#x27;#root&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default app._store; // eslint-disable-line 抛出</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-app-x3D-dva-Opts-：创建应用，返回-dva-实例。-注：dva-支持多实例\"><a href=\"#1-app-x3D-dva-Opts-：创建应用，返回-dva-实例。-注：dva-支持多实例\" class=\"headerlink\" title=\"1,app &#x3D; dva(Opts)：创建应用，返回 dva 实例。(注：dva 支持多实例)\"></a>1,app &#x3D; dva(Opts)：创建应用，返回 dva 实例。(注：dva 支持多实例)</h4><p>在 opts 可以配置所有的 hooks</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const app = dva(&#123;</span><br><span class=\"line\">     history,</span><br><span class=\"line\">     initialState,</span><br><span class=\"line\">     onError,</span><br><span class=\"line\">     onHmr,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里比较常用的是，history 的配置，一般默认的是 hashHistory，如果要配置 history 为 browserHistory，可以这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 import dva from &#x27;dva&#x27;;</span><br><span class=\"line\">2 import createHistory from &#x27;history/createBrowserHistory&#x27;;</span><br><span class=\"line\">3 const app = dva(&#123;</span><br><span class=\"line\">4   history: createHistory(),</span><br><span class=\"line\">5 &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>initialState：指定初始数据，优先级高于 model 中的 state，默认是 {}，但是基本上都在 modal 里面设置相应的 state</li>\n</ul>\n<h4 id=\"2-app-use-Hooks-：配置-hooks-或者注册插件。\"><a href=\"#2-app-use-Hooks-：配置-hooks-或者注册插件。\" class=\"headerlink\" title=\"2,app.use(Hooks)：配置 hooks 或者注册插件。\"></a>2,app.use(Hooks)：配置 hooks 或者注册插件。</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 app.use(&#123;</span><br><span class=\"line\">2   onError: function (error, action) &#123;</span><br><span class=\"line\">3     message.error(error.message || &#x27;失败&#x27;, 5);</span><br><span class=\"line\">4   &#125;</span><br><span class=\"line\">5 &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>可以根据自己的需要来选择注册相应的插件</p>\n<h4 id=\"3-app-model-ModelObject-：这里是数据逻辑处理，数据流动的地方。\"><a href=\"#3-app-model-ModelObject-：这里是数据逻辑处理，数据流动的地方。\" class=\"headerlink\" title=\"3,app.model(ModelObject)：这里是数据逻辑处理，数据流动的地方。\"></a>3,app.model(ModelObject)：这里是数据逻辑处理，数据流动的地方。</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  namespace: &#x27;example&#x27;,//model 的命名空间，同时也是他在全局 state 上的属性，只能用字符串，我们在发送 action 到相应的 reducer 时，就会需要用到 namespace</span><br><span class=\"line\"></span><br><span class=\"line\">  state: &#123;&#125;,//表示 Model 的状态数据，通常表现为一个 javascript 对象（当然它可以是任何值）</span><br><span class=\"line\"></span><br><span class=\"line\">  subscriptions: &#123;//语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action</span><br><span class=\"line\">    setup(&#123; dispatch, history &#125;) &#123;  // eslint-disable-line</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  effects: &#123;//Effect 被称为副作用，最常见的就是异步操作</span><br><span class=\"line\">    *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123;  // eslint-disable-line</span><br><span class=\"line\">      yield put(&#123; type: &#x27;save&#x27; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  reducers: &#123;//reducers 聚合积累的结果是当前 model 的 state 对象</span><br><span class=\"line\">    save(state, action) &#123;</span><br><span class=\"line\">      return &#123; ...state, ...action.payload &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-app-router-Function-：注册路由表，我们做路由跳转的地方\"><a href=\"#4-app-router-Function-：注册路由表，我们做路由跳转的地方\" class=\"headerlink\" title=\"4,app.router(Function)：注册路由表，我们做路由跳转的地方\"></a>4,app.router(Function)：注册路由表，我们做路由跳转的地方</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123; routerRedux, Route ,Switch&#125; from &#x27;dva/router&#x27;;</span><br><span class=\"line\">import &#123; LocaleProvider &#125; from &#x27;antd&#x27;;</span><br><span class=\"line\">import App from &#x27;../components/App/App&#x27;;</span><br><span class=\"line\">import Flex from &#x27;../components/Header/index&#x27;;</span><br><span class=\"line\">import Login from &#x27;../pages/Login/Login&#x27;;</span><br><span class=\"line\">import Home from &#x27;../pages/Home/Home&#x27;;</span><br><span class=\"line\">import zhCN from &#x27;antd/lib/locale-provider/zh_CN&#x27;;</span><br><span class=\"line\">const &#123;ConnectedRouter&#125; = routerRedux;</span><br><span class=\"line\"></span><br><span class=\"line\">function RouterConfig(&#123;history&#125;) &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;ConnectedRouter history=&#123;history&#125;&gt;</span><br><span class=\"line\">      &lt;Switch&gt;</span><br><span class=\"line\">        &lt;Route path=&quot;/login&quot;  component=&#123;Login&#125; /&gt;</span><br><span class=\"line\">        &lt;LocaleProvider locale=&#123;zhCN&#125;&gt;</span><br><span class=\"line\">        &lt;App&gt;</span><br><span class=\"line\">          &lt;Flex&gt;</span><br><span class=\"line\">            &lt;Switch&gt;</span><br><span class=\"line\">            &lt;Route path=&quot;/&quot;  exact component=&#123;Home&#125; /&gt;</span><br><span class=\"line\">            &lt;/Switch&gt;</span><br><span class=\"line\">          &lt;/Flex&gt;</span><br><span class=\"line\">        &lt;/App&gt;</span><br><span class=\"line\">        &lt;/LocaleProvider&gt;</span><br><span class=\"line\">      &lt;/Switch&gt;</span><br><span class=\"line\">    &lt;/ConnectedRouter&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default RouterConfig;</span><br></pre></td></tr></table></figure>\n\n<p>5,app.start([HTMLElement], opts)<br>启动我们自己的应用</p>\n<h3 id=\"3-2-DvaJS-的十个概念\"><a href=\"#3-2-DvaJS-的十个概念\" class=\"headerlink\" title=\"3.2,DvaJS 的十个概念\"></a>3.2,DvaJS 的十个概念</h3><h4 id=\"1-Model\"><a href=\"#1-Model\" class=\"headerlink\" title=\"1,Model\"></a>1,Model</h4><p>model 是 dva 中最重要的概念，Model 非 MVC 中的 M，而是领域模型，用于把数据相关的逻辑聚合到一起，几乎所有的数据，逻辑都在这边进行处理分发</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Model from &#x27;dva-model&#x27;;</span><br><span class=\"line\">// import effect from &#x27;dva-model/effect&#x27;;</span><br><span class=\"line\">import queryString from &#x27;query-string&#x27;;</span><br><span class=\"line\">import pathToRegexp from &#x27;path-to-regexp&#x27;;</span><br><span class=\"line\">import &#123;ManagementPage as namespace&#125; from &#x27;../../utils/namespace&#x27;;</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  getPages,</span><br><span class=\"line\">&#125; from &#x27;../../services/page&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Model(&#123;</span><br><span class=\"line\">  namespace,</span><br><span class=\"line\">  subscriptions: &#123;</span><br><span class=\"line\">    setup(&#123;dispatch, history&#125;) &#123;  // eslint-disable-line</span><br><span class=\"line\">      history.listen(location =&gt; &#123;</span><br><span class=\"line\">        const &#123;pathname, search&#125; = location;</span><br><span class=\"line\">        const query = queryString.parse(search);</span><br><span class=\"line\">        const match = pathToRegexp(namespace + &#x27;/:action&#x27;).exec(pathname);</span><br><span class=\"line\">        if (match) &#123;</span><br><span class=\"line\">           dispatch(&#123;</span><br><span class=\"line\">             type:&#x27;getPages&#x27;,</span><br><span class=\"line\">            payload:&#123;</span><br><span class=\"line\">               s:query.s || 10,</span><br><span class=\"line\">               p:query.p || 1,</span><br><span class=\"line\">               j_code:parseInt(query.j,10) || 1,</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reducers: &#123;</span><br><span class=\"line\">    getPagesSuccess(state, action) &#123;</span><br><span class=\"line\">      const &#123;list, total&#125; = action.result;</span><br><span class=\"line\">      return &#123;...state, list, loading: false, total&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  getPages,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-namespace\"><a href=\"#2-namespace\" class=\"headerlink\" title=\"2,namespace\"></a>2,namespace</h4><p>model 的命名空间，同时也是他在全局 state 上的属性，只能用字符串，我们在发送 action 到相应的 reducer 时，就会需要用到 namespace</p>\n<h4 id=\"3-State（状态）\"><a href=\"#3-State（状态）\" class=\"headerlink\" title=\"3,State（状态）\"></a>3,State（状态）</h4><p>初始值，我们在 dva() 初始化的时候和在 modal 里面的 state 对其两处进行定义，其中 modal 中的优先级低于传给 dva() 的 opts.initialState</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// dva()初始化</span><br><span class=\"line\">const app = dva(&#123;</span><br><span class=\"line\">  initialState: &#123; count: 1 &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// modal()定义事件</span><br><span class=\"line\">app.model(&#123;</span><br><span class=\"line\">  namespace: &#x27;count&#x27;,</span><br><span class=\"line\">  state: 0,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Model 中 state 的优先级比初始化的低，但是基本上项目中的 state 都是在这里定义的</p>\n<h4 id=\"4-Subscription\"><a href=\"#4-Subscription\" class=\"headerlink\" title=\"4,Subscription\"></a>4,Subscription</h4><p>Subscriptions 是一种从 源 获取数据的方法，它来自于 elm。语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">subscriptions: &#123; //触发器。setup表示初始化即调用。</span><br><span class=\"line\">    setup(&#123;dispatch, history&#125;) &#123;</span><br><span class=\"line\">      history.listen(location =&gt; &#123;//listen监听路由变化 调用不同的方法</span><br><span class=\"line\">        if (location.pathname === &#x27;/login&#x27;) &#123;</span><br><span class=\"line\">         //清除缓存</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          dispatch(&#123;</span><br><span class=\"line\">            type: &#x27;fetch&#x27;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-Effects\"><a href=\"#5-Effects\" class=\"headerlink\" title=\"5,Effects\"></a>5,Effects</h4><p>用于处理异步操作和业务逻辑，不直接修改 state，简单的来说，就是从服务端获取数据，并且发起一个 action 交给 reducer 的地方。其中它用到了 redux-saga 里面几个常用的函数。</p>\n<ul>\n<li>put 用来发起一条 action</li>\n<li>call 以异步的方式调用函数</li>\n<li>select 从 state 中获取相关的数据</li>\n<li>take 获取发送的数据</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">effects: &#123;</span><br><span class=\"line\">    *login(action, saga)&#123;</span><br><span class=\"line\">      const data = yield saga.call(effect(login, &#x27;loginSuccess&#x27;, authCache), action, saga);//call 用户调用异步逻辑 支持Promise</span><br><span class=\"line\">      if (data &amp;&amp; data.token) &#123;</span><br><span class=\"line\">        yield saga.put(routerRedux.replace(&#x27;/home&#x27;));//put 用于触发action 什么是action下面会讲到</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    *logout(action, saga)&#123;</span><br><span class=\"line\">      const state = yield saga.select(state =&gt; state);//select 从state里获取数据</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>如果 effect 与 reducers 中的 add 方法重合了，这里会陷入一个死循环，因为当组件发送一个 dispatch 的时候，model 会首先去找 effect 里面的方法，当又找到 add 的时候，就又会去请求 effect 里面的方法。</p>\n<p>这里的 delayDeal，是我这边写的一个延时的函数，我们在 utils 里面编写一个 utils.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *超时函数处理</span><br><span class=\"line\"> * @param timeout  ：timeout超时的时间参数</span><br><span class=\"line\"> * @returns &#123;*&#125; ：返回样式值</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function delayDeal(timeout) &#123;</span><br><span class=\"line\">  return new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(resolve, timeout);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>接着我们在 models&#x2F;example.js 导入这个 utils.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 import &#123; delayDeal&#125; from &#x27;../utils/utils&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-Reducer\"><a href=\"#6-Reducer\" class=\"headerlink\" title=\"6,Reducer\"></a>6,Reducer</h4><p>以 key&#x2F;value 格式定义 reducer，用于处理同步操作，唯一可以修改 state 的地方。由 action 触发。其实是一个纯函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1  reducers: &#123;</span><br><span class=\"line\">2     loginSuccess(state, action)&#123;</span><br><span class=\"line\">3       return &#123;...state, auth: action.result, loading: false&#125;;</span><br><span class=\"line\">4     &#125;,</span><br><span class=\"line\">5   &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-Router\"><a href=\"#7-Router\" class=\"headerlink\" title=\"7,Router\"></a>7,Router</h4><p>Router 表示路由配置信息，项目中的 router.js</p>\n<h4 id=\"8-RouteComponent\"><a href=\"#8-RouteComponent\" class=\"headerlink\" title=\"8,RouteComponent\"></a>8,RouteComponent</h4><p>RouteComponent 表示 Router 里匹配路径的 Component，通常会绑定 model 的数据</p>\n<h4 id=\"9-Action：表示操作事件，可以是同步，也可以是异步\"><a href=\"#9-Action：表示操作事件，可以是同步，也可以是异步\" class=\"headerlink\" title=\"9,Action：表示操作事件，可以是同步，也可以是异步\"></a>9,Action：表示操作事件，可以是同步，也可以是异步</h4><p>action 的格式如下，它需要有一个 type ，表示这个 action 要触发什么操作；payload 则表示这个 action 将要传递的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">     type: namespace + &#x27;/login&#x27;,</span><br><span class=\"line\">     payload: &#123;</span><br><span class=\"line\">          userName: payload.userName,</span><br><span class=\"line\">          password: payload.password</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>构建一个 Action 创建函数，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function goLogin(payload) &#123;</span><br><span class=\"line\">    let loginInfo = &#123;</span><br><span class=\"line\">        type: namespace + &#x27;/login&#x27;,</span><br><span class=\"line\">        payload: &#123;</span><br><span class=\"line\">          userName: payload.userName,</span><br><span class=\"line\">          password: payload.password</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return loginInfo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//我们直接dispatch(goLogin()),就发送了一个action。</span><br><span class=\"line\">dispatch(goLogin())</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"10-dispatch\"><a href=\"#10-dispatch\" class=\"headerlink\" title=\"10,dispatch\"></a>10,dispatch</h4><p>type dispatch &#x3D; (a: Action) &#x3D;&gt; Action</p>\n<p>dispatching function 是一个用于触发 action 的函数，action 是改变 State 的唯一途径，但是它只描述了一个行为，而 dipatch 可以看作是触发这个行为的方式，而 Reducer 则是描述如何改变数据的。</p>\n<p>在 dva 中，connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects，常见的形式如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 dispatch(&#123;</span><br><span class=\"line\">2    type: namespace + &#x27;/login&#x27;, // 如果在 model 外调用，需要添加 namespace,如果在model内调用 无需添加 namespace</span><br><span class=\"line\">3   payload: &#123;&#125;, // 需要传递的信息</span><br><span class=\"line\">4 &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-使用-antd\"><a href=\"#3-3-使用-antd\" class=\"headerlink\" title=\"3.3,使用 antd\"></a>3.3,使用 antd</h3><p>先安装 antd 和 babel-plugin-import</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 npm install antd babel-plugin-import --save</span><br><span class=\"line\">2 # 或</span><br><span class=\"line\">3 yarn add antd babel-plugin-import</span><br></pre></td></tr></table></figure>\n\n<p>babel-plugin-import 也可以通过 -D 参数安装到 devDependencies 中，它用于实现按需加载。然后在 .webpackrc 中添加如下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;extraBabelPlugins&quot;: [</span><br><span class=\"line\">    [&quot;import&quot;, &#123;</span><br><span class=\"line\">      &quot;libraryName&quot;: &quot;antd&quot;,</span><br><span class=\"line\">      &quot;libraryDirectory&quot;: &quot;es&quot;,</span><br><span class=\"line\">      &quot;style&quot;: true</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在就可以按需引入 antd 的组件了，如 import { Button } from ‘antd’，Button 组件的样式文件也会自动帮你引入。</p>\n<h3 id=\"3-4-配置-webpackrc\"><a href=\"#3-4-配置-webpackrc\" class=\"headerlink\" title=\"3.4,配置.webpackrc\"></a>3.4,配置.webpackrc</h3><p>1,entry 是入口文件配置</p>\n<p>单页类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 entry: &#x27;./src/entries/index.js&#x27;,</span><br></pre></td></tr></table></figure>\n\n<p>多页类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 &quot;entry&quot;: &quot;src/entries/*.js&quot;</span><br></pre></td></tr></table></figure>\n\n<p>2,extraBabelPlugins 定义额外的 babel plugin 列表，格式为数组。</p>\n<p>3,env 针对特定的环境进行配置。dev 的环境变量是 development，build 的环境变量是 production。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;extraBabelPlugins&quot;: [&quot;transform-runtime&quot;],</span><br><span class=\"line\">&quot;env&quot;: &#123;</span><br><span class=\"line\">  development: &#123;</span><br><span class=\"line\">      extraBabelPlugins: [&#x27;dva-hmr&#x27;],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    production: &#123;</span><br><span class=\"line\">      define: &#123;</span><br><span class=\"line\">        __CDN__: process.env.CDN ? &#x27;//cdn.dva.com/&#x27; : &#x27;/&#x27; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开发环境下的 extraBabelPlugins 是 [“transform-runtime”, “dva-hmr”]，而生产环境下是 [“transform-runtime”]</p>\n<p>4,配置 webpack 的 externals 属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 // 配置 @antv/data-set和 rollbar 不打入代码</span><br><span class=\"line\">2 &quot;externals&quot;: &#123;</span><br><span class=\"line\">3     &#x27;@antv/data-set&#x27;: &#x27;DataSet&#x27;,</span><br><span class=\"line\">4     rollbar: &#x27;rollbar&#x27;,</span><br><span class=\"line\">5 &#125;</span><br></pre></td></tr></table></figure>\n\n<p>5,配置 webpack-dev-server 的 proxy 属性。 如果要代理请求到其他服务器，可以这样配：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxy: &#123;</span><br><span class=\"line\">    &quot;/api&quot;: &#123;</span><br><span class=\"line\">      // &quot;target&quot;: &quot;http://127.0.0.1/&quot;,</span><br><span class=\"line\">      // &quot;target&quot;: &quot;http://127.0.0.1:9090/&quot;,</span><br><span class=\"line\">      &quot;target&quot;: &quot;http://localhost:8080/&quot;,</span><br><span class=\"line\">      &quot;changeOrigin&quot;: true,</span><br><span class=\"line\">     &quot;pathRewrite&quot;: &#123; &quot;^/api&quot; : &quot;&quot; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>6,disableDynamicImport</p>\n<p>禁用 import() 按需加载，全部打包在一个文件里，通过 <a href=\"https://github.com/seeden/babel-plugin-dynamic-import-node-sync\">babel-plugin-dynamic-import-node-sync</a> 实现。</p>\n<p>7,publicPath</p>\n<p>配置 webpack 的 <a href=\"https://webpack.js.org/configuration/output/#output-publicpath\">output.publicPath</a> 属性。</p>\n<p>8,extraBabelIncludes</p>\n<p>定义额外需要做 babel 转换的文件匹配列表，格式为数组</p>\n<p>9,outputPath</p>\n<p>配置 webpack 的 <a href=\"https://webpack.js.org/configuration/output/#output-path\">output.path</a> 属性。</p>\n<p>打包输出的文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 config[&quot;outputPath&quot;] = path.join(process.cwd(), &#x27;./build/&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>10,根据需求完整配置如下：</p>\n<p>文件名称是:.webpackrc.js,可根据实际情况添加如下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const path = require(&#x27;path&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">  entry: &#x27;./src/entries/index.js&#x27;,</span><br><span class=\"line\">  extraBabelPlugins: [[&#x27;import&#x27;, &#123; libraryName: &#x27;antd&#x27;, libraryDirectory: &#x27;es&#x27;, style: true &#125;]],</span><br><span class=\"line\">  env: &#123;</span><br><span class=\"line\">    development: &#123;</span><br><span class=\"line\">      extraBabelPlugins: [&#x27;dva-hmr&#x27;],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    production: &#123;</span><br><span class=\"line\">      define: &#123;</span><br><span class=\"line\">        __CDN__: process.env.CDN ? &#x27;//cdn.dva.com/&#x27; : &#x27;/&#x27; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  externals: &#123;</span><br><span class=\"line\">    &#x27;@antv/data-set&#x27;: &#x27;DataSet&#x27;,</span><br><span class=\"line\">    rollbar: &#x27;rollbar&#x27;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  lessLoaderOptions: &#123;</span><br><span class=\"line\">    javascriptEnabled: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  proxy: &#123;</span><br><span class=\"line\">    &quot;/api&quot;: &#123;</span><br><span class=\"line\">      // &quot;target&quot;: &quot;http://127.0.0.1/&quot;,</span><br><span class=\"line\">      // &quot;target&quot;: &quot;http://127.0.0.1:9090/&quot;,</span><br><span class=\"line\">      &quot;target&quot;: &quot;http://localhost:8080/&quot;,</span><br><span class=\"line\">      &quot;changeOrigin&quot;: true,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  es5ImcompatibleVersions:true,</span><br><span class=\"line\">  disableDynamicImport: true,</span><br><span class=\"line\">  publicPath: &#x27;/&#x27;,</span><br><span class=\"line\">  hash: false,</span><br><span class=\"line\">  extraBabelIncludes:[</span><br><span class=\"line\">    &quot;node_modules&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">if (module.exports.env !== &#x27;development&#x27;) &#123;</span><br><span class=\"line\">  config[&quot;outputPath&quot;] = path.join(process.cwd(), &#x27;./build/&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default config</span><br></pre></td></tr></table></figure>\n\n<p>更多 .webpackrc 的配置请参考<a href=\"https://github.com/sorrycc/roadhog/blob/master/README_zh-cn.md\"> roadhog 配置</a>。</p>\n<h3 id=\"3-5-使用-antd-mobile\"><a href=\"#3-5-使用-antd-mobile\" class=\"headerlink\" title=\"3.5,使用 antd-mobile\"></a>3.5,使用 antd-mobile</h3><p>先安装 antd-mobile 和 babel-plugin-import</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 npm install antd-mobile babel-plugin-import --save # 或</span><br><span class=\"line\">2 yarn add antd-mobile babel-plugin-import</span><br></pre></td></tr></table></figure>\n\n<p>babel-plugin-import 也可以通过 -D 参数安装到 devDependencies 中，它用于实现按需加载。然后在 .webpackrc 中添加如下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 &#123;</span><br><span class=\"line\">2   &quot;plugins&quot;: [</span><br><span class=\"line\">3     [&quot;import&quot;, &#123; libraryName: &quot;antd-mobile&quot;, style: &quot;css&quot; &#125;] // `style: true` 会加载 less 文件</span><br><span class=\"line\">4   ]</span><br><span class=\"line\">5 &#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在就可以按需引入 antd-mobile 的组件了，如 import { DatePicker} from ‘antd-mobile’，DatePicker 组件的样式文件也会自动帮你引入。</p>\n<h2 id=\"四-整体架构\"><a href=\"#四-整体架构\" class=\"headerlink\" title=\"四,整体架构\"></a>四,整体架构</h2><ul>\n<li>我们根据 url 访问相关的 Route-Component，在组件中我们通过 dispatch 发送 action 到 model 里面的 effect 或者直接 Reducer</li>\n<li>当我们将 action 发送给 Effect，基本上是取服务器上面请求数据的，服务器返回数据之后，effect 会发送相应的 action 给 reducer，由唯一能改变 state 的 reducer 改变 state ，然后通过 connect 重新渲染组件。</li>\n<li>当我们将 action 发送给 reducer，那直接由 reducer 改变 state，然后通过 connect 重新渲染组件。如下图所示:</li>\n</ul>\n<p><img src=\"https://img2018.cnblogs.com/blog/1040068/201812/1040068-20181213134636345-1589136271.png\" alt=\"image\"></p>\n<h3 id=\"数据流向\"><a href=\"#数据流向\" class=\"headerlink\" title=\"数据流向\"></a>数据流向</h3><p>数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State ，如果是异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State</p>\n<h3 id=\"重置-models-里的数据\"><a href=\"#重置-models-里的数据\" class=\"headerlink\" title=\"重置 models 里的数据:\"></a>重置 models 里的数据:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 dispatch(&#123;type:namespace+&#x27;/set&#x27;,payload:&#123;mdata:[]&#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>set 是内置的方法</p>\n<ul>\n<li><a href=\"https://dvajs.com/\">Dva 官方文档</a></li>\n<li><a href=\"https://www.cnblogs.com/jackson-zhangjiang/p/10273352.html\">nginx 代理部署 Vue 与 React 项目</a></li>\n</ul>\n<h2 id=\"五-问题记录\"><a href=\"#五-问题记录\" class=\"headerlink\" title=\"五,问题记录\"></a>五,问题记录</h2><h3 id=\"5-1-路由相关的问题\"><a href=\"#5-1-路由相关的问题\" class=\"headerlink\" title=\"5.1,路由相关的问题\"></a>5.1,路由相关的问题</h3><p>1,使用 match 后的路由跳转问题，版本 routerV4</p>\n<p>match 是一个匹配路径参数的对象，它有一个属性 params，里面的内容就是路径参数，除常用的 params 属性外，它还有 url、path、isExact 属性。</p>\n<p>问题描述:不能跳转新页面或匹配跳转后,刷新时 url 所传的值会被重置掉</p>\n<p>不能跳转的情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;ConnectedRouter&#125; = routerRedux;</span><br><span class=\"line\"></span><br><span class=\"line\">function RouterConfig(&#123;history&#125;) &#123;</span><br><span class=\"line\">const tests =(&#123;match&#125;) =&gt;(</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;Route exact path=&#123;`$&#123;match.url&#125;/:tab`&#125; component=&#123;Test&#125;/&gt;</span><br><span class=\"line\">      &lt;Route exact path=&#123;match.url&#125; component=&#123;Test&#125;/&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;ConnectedRouter history=&#123;history&#125;&gt;</span><br><span class=\"line\">      &lt;Switch&gt;</span><br><span class=\"line\">        &lt;Route path=&quot;/login&quot; component=&#123;Login&#125;/&gt;</span><br><span class=\"line\">        &lt;LocaleProvider locale=&#123;zhCN&#125;&gt;</span><br><span class=\"line\">          &lt;App&gt;</span><br><span class=\"line\">            &lt;Flex&gt;</span><br><span class=\"line\">              &lt;Switch&gt;</span><br><span class=\"line\">                &lt;Route path=&quot;/test&quot; component=&#123;tests &#125;/&gt;</span><br><span class=\"line\">               &lt;Route exact path=&quot;/test/bindTest&quot; component=&#123;BindTest&#125;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">              &lt;/Switch&gt;</span><br><span class=\"line\">            &lt;/Flex&gt;</span><br><span class=\"line\">          &lt;/App&gt;</span><br><span class=\"line\">        &lt;/LocaleProvider&gt;</span><br><span class=\"line\">      &lt;/Switch&gt;</span><br><span class=\"line\">    &lt;/ConnectedRouter&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>路由如上写法,使用下面方式不能跳转,但是地址栏路径变了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; routerRedux&#125; from &#x27;dva/router&#x27;;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">this.props.dispatch(routerRedux.push(&#123;</span><br><span class=\"line\">      pathname: &#x27;/test/bindTest&#x27;,</span><br><span class=\"line\">      search:queryString.stringify(&#123;</span><br><span class=\"line\">        // ...query,</span><br><span class=\"line\">        Code: code,</span><br><span class=\"line\">        Name: name</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>能跳转,但是刷新所传的参数被重置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;ConnectedRouter&#125; = routerRedux;</span><br><span class=\"line\"></span><br><span class=\"line\">function RouterConfig(&#123;history&#125;) &#123;</span><br><span class=\"line\">const tests =(&#123;match&#125;) =&gt;(</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;Route exact path=&#123;`$&#123;match.url&#125;/bindTest`&#125; component=&#123;BindTest&#125;/&gt;</span><br><span class=\"line\">      &lt;Route exact path=&#123;`$&#123;match.url&#125;/:tab`&#125; component=&#123;Test&#125;/&gt;</span><br><span class=\"line\">      &lt;Route exact path=&#123;match.url&#125; component=&#123;Test&#125;/&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;ConnectedRouter history=&#123;history&#125;&gt;</span><br><span class=\"line\">      &lt;Switch&gt;</span><br><span class=\"line\">        &lt;Route path=&quot;/login&quot; component=&#123;Login&#125;/&gt;</span><br><span class=\"line\">        &lt;LocaleProvider locale=&#123;zhCN&#125;&gt;</span><br><span class=\"line\">          &lt;App&gt;</span><br><span class=\"line\">            &lt;Flex&gt;</span><br><span class=\"line\">              &lt;Switch&gt;</span><br><span class=\"line\">                &lt;Route path=&quot;/test&quot; component=&#123;tests &#125;/&gt;</span><br><span class=\"line\">              &lt;/Switch&gt;</span><br><span class=\"line\">            &lt;/Flex&gt;</span><br><span class=\"line\">          &lt;/App&gt;</span><br><span class=\"line\">        &lt;/LocaleProvider&gt;</span><br><span class=\"line\">      &lt;/Switch&gt;</span><br><span class=\"line\">    &lt;/ConnectedRouter&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>路由如上写法,使用下面方式可以跳转,但是刷新时所传的参数会被 test 里所传的参数重置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">this.props.dispatch(routerRedux.push(&#123;</span><br><span class=\"line\">    pathname: &#x27;/test/bindTest&#x27;,</span><br><span class=\"line\">    search:queryString.stringify(&#123;</span><br><span class=\"line\">      // ...query,</span><br><span class=\"line\">      Code: code,</span><br><span class=\"line\">      Name: name</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>解决办法如下：地址多加一级,跳出以前的界面</p>\n<p>路由配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const &#123;ConnectedRouter&#125; = routerRedux;</span><br><span class=\"line\"></span><br><span class=\"line\">function RouterConfig(&#123;history&#125;) &#123;</span><br><span class=\"line\">const tests =(&#123;match&#125;) =&gt;(</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;Route exact path=&#123;`$&#123;match.url&#125;/bind/test`&#125; component=&#123;BindTest&#125;/&gt;</span><br><span class=\"line\">      &lt;Route exact path=&#123;`$&#123;match.url&#125;/:tab`&#125; component=&#123;Test&#125;/&gt;</span><br><span class=\"line\">      &lt;Route exact path=&#123;match.url&#125; component=&#123;Test&#125;/&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;ConnectedRouter history=&#123;history&#125;&gt;</span><br><span class=\"line\">      &lt;Switch&gt;</span><br><span class=\"line\">        &lt;Route path=&quot;/test&quot; component=&#123;tests &#125;/&gt;</span><br><span class=\"line\">      &lt;/Switch&gt;</span><br><span class=\"line\">    &lt;/ConnectedRouter&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">this.props.dispatch(routerRedux.push(&#123;</span><br><span class=\"line\">  pathname: &#x27;/test/bind/test1&#x27;,</span><br><span class=\"line\">  search:queryString.stringify(&#123;</span><br><span class=\"line\">    // ...query,</span><br><span class=\"line\">    Code: code,</span><br><span class=\"line\">    Name: name</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-箭头函数-this-指向问题\"><a href=\"#5-2-箭头函数-this-指向问题\" class=\"headerlink\" title=\"5.2,箭头函数 this 指向问题\"></a>5.2,箭头函数 this 指向问题</h3><p>箭头函数的 this 定义：<strong>箭头函数的 this 是在定义函数时绑定的，不是在执行过程中绑定的。简单的说，函数在定义时，this 就继承了定义函数的对象</strong>。</p>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"Echarts学习笔记及查询文档","url":"/2022/12/16/Echarts%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3/","content":"<h2 id=\"Echarts\"><a href=\"#Echarts\" class=\"headerlink\" title=\"Echarts\"></a>Echarts</h2><p>一个使用 javascript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器，底层依赖矢量图形库 ZRebder，提供直观、交互丰富，可高度个性化定制的数据化图表。</p>\n<ul>\n<li>下载并引入 echarts</li>\n<li>准备一个具备大小的 DOM 容器</li>\n<li>初始化 echarts 实例对象</li>\n<li>指定配置项和数据</li>\n<li>将配置项设置给 echarts 实例对象</li>\n</ul>\n<p>第一个 echarts 实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;echarts使用示例&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">/*第二步：设置容器并设置容器大小*/</span><br><span class=\"line\">        .box&#123;</span><br><span class=\"line\">            width: 600px;</span><br><span class=\"line\">            height: 600px;</span><br><span class=\"line\">            background-color: darkkhaki;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;!--第一步：引入--&gt;</span><br><span class=\"line\">    &lt;script src=&quot;js/echarts.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;!--第三步：进行初始化--&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        /*初始化方法 echarts.init(dom容器)*/</span><br><span class=\"line\">        var myChart =  echarts.init(document.querySelector(&quot;.box&quot;));</span><br><span class=\"line\">/*第四步：指定配置项和数据*/</span><br><span class=\"line\">        var option = &#123;</span><br><span class=\"line\">            title: &#123;</span><br><span class=\"line\">                text: &#x27;第一个 ECharts 实例&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            tooltip: &#123;&#125;,</span><br><span class=\"line\">            legend: &#123;</span><br><span class=\"line\">                data:[&#x27;销量&#x27;]</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            xAxis: &#123;</span><br><span class=\"line\">                data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            yAxis: &#123;&#125;,</span><br><span class=\"line\">            series: [&#123;</span><br><span class=\"line\">                name: &#x27;销量&#x27;,</span><br><span class=\"line\">                type: &#x27;bar&#x27;,</span><br><span class=\"line\">                data: [5, 20, 36, 10, 10, 20]</span><br><span class=\"line\">            &#125;]</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">/*第五步：将配置项设置给echarts实例对象*/</span><br><span class=\"line\">        myChart.setOption(option);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Echarts-基础配置\"><a href=\"#Echarts-基础配置\" class=\"headerlink\" title=\"Echarts 基础配置\"></a>Echarts 基础配置</h2><p>需要了解的主要配置：series xAxis yAxis grid tooltip title legend color</p>\n<ul>\n<li>series<ul>\n<li>系列列表。每个系列通过 type 决定自己的图表类型</li>\n<li>大白话：图标数据，指定什么类型的图标，可以多个图表重叠。</li>\n</ul>\n</li>\n<li>xAxis：直角坐标系 grid 中的 x 轴<ul>\n<li>boundaryGap: 坐标轴两边留白策略 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。</li>\n</ul>\n</li>\n<li>yAxis：直角坐标系 grid 中的 y 轴</li>\n<li>grid：直角坐标系内绘图网格。</li>\n<li>title：标题组件</li>\n<li>tooltip：提示框组件</li>\n<li>legend：图例组件</li>\n<li>color：调色盘颜色列表<br>数据堆叠，同个类目轴上系列配置相同的 stack 值后 后一个系列的值会在前一个系列的值上相加。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">option = &#123;</span><br><span class=\"line\">// color设置我们线条的颜色 注意后面是个数组</span><br><span class=\"line\">color: [‘pink’, ‘red’, ‘green’, ‘skyblue’],</span><br><span class=\"line\">// 设置图表的标题</span><br><span class=\"line\">title: &#123;</span><br><span class=\"line\">    text: ‘折线图堆叠123’</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 图表的提示框组件</span><br><span class=\"line\">tooltip: &#123;</span><br><span class=\"line\">    // 触发方式</span><br><span class=\"line\">    trigger: ‘axis’</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 图例组件</span><br><span class=\"line\">legend: &#123;</span><br><span class=\"line\">// series里面有了 name值则 legend里面的data可以删掉</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 网格配置 grid可以控制线形图 柱状图 图表大小</span><br><span class=\"line\">grid: &#123;</span><br><span class=\"line\">    left: ‘3%’,</span><br><span class=\"line\">    right: ‘4%’,</span><br><span class=\"line\">    bottom: ‘3%’,</span><br><span class=\"line\">    // 是否显示刻度标签 如果是true 就显示 否则反之</span><br><span class=\"line\">    containLabel: true</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 工具箱组件 可以另存为图片等功能</span><br><span class=\"line\">toolbox: &#123;</span><br><span class=\"line\">    feature: &#123;</span><br><span class=\"line\">    saveAsImage: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 设置x轴的相关配置</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: ‘category’,</span><br><span class=\"line\">    // 是否让我们的线条和坐标轴有缝隙</span><br><span class=\"line\">    boundaryGap: false,</span><br><span class=\"line\">    data: [‘星期一’, ‘周二’, ‘周三’, ‘周四’, ‘周五’, ‘周六’, ‘周日’]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 设置y轴的相关配置</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">type: ‘value’</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 系列图表配置 它决定着显示那种类型的图表</span><br><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: ‘邮件营销’,</span><br><span class=\"line\">        type: ‘line’,</span><br><span class=\"line\">        data: [120, 132, 101, 134, 90, 230, 210]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &#x27;联盟广告&#x27;,</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\"></span><br><span class=\"line\">        data: [220, 182, 191, 234, 290, 330, 310]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &#x27;视频广告&#x27;,</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\"></span><br><span class=\"line\">        data: [150, 232, 201, 154, 190, 330, 410]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &#x27;直接访问&#x27;,</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\"></span><br><span class=\"line\">        data: [320, 332, 301, 334, 390, 330, 320]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">theme = &#123;</span><br><span class=\"line\">// 全图默认背景</span><br><span class=\"line\">// backgroundColor: ‘rgba(0,0,0,0)’,</span><br><span class=\"line\">// 默认色板</span><br><span class=\"line\">color: [&#x27;#ff7f50&#x27;,&#x27;#87cefa&#x27;,&#x27;#da70d6&#x27;,&#x27;#32cd32&#x27;,&#x27;#6495ed&#x27;,</span><br><span class=\"line\">        &#x27;#ff69b4&#x27;,&#x27;#ba55d3&#x27;,&#x27;#cd5c5c&#x27;,&#x27;#ffa500&#x27;,&#x27;#40e0d0&#x27;,</span><br><span class=\"line\">        &#x27;#1e90ff&#x27;,&#x27;#ff6347&#x27;,&#x27;#7b68ee&#x27;,&#x27;#00fa9a&#x27;,&#x27;#ffd700&#x27;,</span><br><span class=\"line\">        &#x27;#6699FF&#x27;,&#x27;#ff6666&#x27;,&#x27;#3cb371&#x27;,&#x27;#b8860b&#x27;,&#x27;#30e0e0&#x27;],</span><br><span class=\"line\"></span><br><span class=\"line\">// 图表标题</span><br><span class=\"line\">title: &#123;</span><br><span class=\"line\">    x: &#x27;left&#x27;,                 // 水平安放位置，默认为左对齐，可选为：</span><br><span class=\"line\">                               // &#x27;center&#x27; ¦ &#x27;left&#x27; ¦ &#x27;right&#x27;</span><br><span class=\"line\">                               // ¦ &#123;number&#125;（x坐标，单位px）</span><br><span class=\"line\">    y: &#x27;top&#x27;,                  // 垂直安放位置，默认为全图顶端，可选为：</span><br><span class=\"line\">                               // &#x27;top&#x27; ¦ &#x27;bottom&#x27; ¦ &#x27;center&#x27;</span><br><span class=\"line\">                               // ¦ &#123;number&#125;（y坐标，单位px）</span><br><span class=\"line\">    //textAlign: null          // 水平对齐方式，默认根据x设置自动调整</span><br><span class=\"line\">    backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,</span><br><span class=\"line\">    borderColor: &#x27;#ccc&#x27;,       // 标题边框颜色</span><br><span class=\"line\">    borderWidth: 0,            // 标题边框线宽，单位px，默认为0（无边框）</span><br><span class=\"line\">    padding: 5,                // 标题内边距，单位px，默认各方向内边距为5，</span><br><span class=\"line\">                               // 接受数组分别设定上右下左边距，同css</span><br><span class=\"line\">    itemGap: 10,               // 主副标题纵向间隔，单位px，默认为10，</span><br><span class=\"line\">    textStyle: &#123;</span><br><span class=\"line\">        fontSize: 18,</span><br><span class=\"line\">        fontWeight: &#x27;bolder&#x27;,</span><br><span class=\"line\">        color: &#x27;#333&#x27;          // 主标题文字颜色</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    subtextStyle: &#123;</span><br><span class=\"line\">        color: &#x27;#aaa&#x27;          // 副标题文字颜色</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 图例</span><br><span class=\"line\">legend: &#123;</span><br><span class=\"line\">    orient: &#x27;horizontal&#x27;,      // 布局方式，默认为水平布局，可选为：</span><br><span class=\"line\">                               // &#x27;horizontal&#x27; ¦ &#x27;vertical&#x27;</span><br><span class=\"line\">    x: &#x27;center&#x27;,               // 水平安放位置，默认为全图居中，可选为：</span><br><span class=\"line\">                               // &#x27;center&#x27; ¦ &#x27;left&#x27; ¦ &#x27;right&#x27;</span><br><span class=\"line\">                               // ¦ &#123;number&#125;（x坐标，单位px）</span><br><span class=\"line\">    y: &#x27;top&#x27;,                  // 垂直安放位置，默认为全图顶端，可选为：</span><br><span class=\"line\">                               // &#x27;top&#x27; ¦ &#x27;bottom&#x27; ¦ &#x27;center&#x27;</span><br><span class=\"line\">                               // ¦ &#123;number&#125;（y坐标，单位px）</span><br><span class=\"line\">    backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,</span><br><span class=\"line\">    borderColor: &#x27;#ccc&#x27;,       // 图例边框颜色</span><br><span class=\"line\">    borderWidth: 0,            // 图例边框线宽，单位px，默认为0（无边框）</span><br><span class=\"line\">    padding: 5,                // 图例内边距，单位px，默认各方向内边距为5，</span><br><span class=\"line\">                               // 接受数组分别设定上右下左边距，同css</span><br><span class=\"line\">    itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，</span><br><span class=\"line\">                               // 横向布局时为水平间隔，纵向布局时为纵向间隔</span><br><span class=\"line\">    itemWidth: 20,             // 图例图形宽度</span><br><span class=\"line\">    itemHeight: 14,            // 图例图形高度</span><br><span class=\"line\">    textStyle: &#123;</span><br><span class=\"line\">        color: &#x27;#333&#x27;          // 图例文字颜色</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 值域</span><br><span class=\"line\">dataRange: &#123;</span><br><span class=\"line\">    orient: &#x27;vertical&#x27;,        // 布局方式，默认为垂直布局，可选为：</span><br><span class=\"line\">                               // &#x27;horizontal&#x27; ¦ &#x27;vertical&#x27;</span><br><span class=\"line\">    x: &#x27;left&#x27;,                 // 水平安放位置，默认为全图左对齐，可选为：</span><br><span class=\"line\">                               // &#x27;center&#x27; ¦ &#x27;left&#x27; ¦ &#x27;right&#x27;</span><br><span class=\"line\">                               // ¦ &#123;number&#125;（x坐标，单位px）</span><br><span class=\"line\">    y: &#x27;bottom&#x27;,               // 垂直安放位置，默认为全图底部，可选为：</span><br><span class=\"line\">                               // &#x27;top&#x27; ¦ &#x27;bottom&#x27; ¦ &#x27;center&#x27;</span><br><span class=\"line\">                               // ¦ &#123;number&#125;（y坐标，单位px）</span><br><span class=\"line\">    backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,</span><br><span class=\"line\">    borderColor: &#x27;#ccc&#x27;,       // 值域边框颜色</span><br><span class=\"line\">    borderWidth: 0,            // 值域边框线宽，单位px，默认为0（无边框）</span><br><span class=\"line\">    padding: 5,                // 值域内边距，单位px，默认各方向内边距为5，</span><br><span class=\"line\">                               // 接受数组分别设定上右下左边距，同css</span><br><span class=\"line\">    itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，</span><br><span class=\"line\">                               // 横向布局时为水平间隔，纵向布局时为纵向间隔</span><br><span class=\"line\">    itemWidth: 20,             // 值域图形宽度，线性渐变水平布局宽度为该值 * 10</span><br><span class=\"line\">    itemHeight: 14,            // 值域图形高度，线性渐变垂直布局高度为该值 * 10</span><br><span class=\"line\">    splitNumber: 5,            // 分割段数，默认为5，为0时为线性渐变</span><br><span class=\"line\">    color:[&#x27;#1e90ff&#x27;,&#x27;#f0ffff&#x27;],//颜色</span><br><span class=\"line\">    //text:[&#x27;高&#x27;,&#x27;低&#x27;],         // 文本，默认为数值文本</span><br><span class=\"line\">    textStyle: &#123;</span><br><span class=\"line\">        color: &#x27;#333&#x27;          // 值域文字颜色</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">toolbox: &#123;</span><br><span class=\"line\">    orient: &#x27;horizontal&#x27;,      // 布局方式，默认为水平布局，可选为：</span><br><span class=\"line\">                               // &#x27;horizontal&#x27; ¦ &#x27;vertical&#x27;</span><br><span class=\"line\">    x: &#x27;right&#x27;,                // 水平安放位置，默认为全图右对齐，可选为：</span><br><span class=\"line\">                               // &#x27;center&#x27; ¦ &#x27;left&#x27; ¦ &#x27;right&#x27;</span><br><span class=\"line\">                               // ¦ &#123;number&#125;（x坐标，单位px）</span><br><span class=\"line\">    y: &#x27;top&#x27;,                  // 垂直安放位置，默认为全图顶端，可选为：</span><br><span class=\"line\">                               // &#x27;top&#x27; ¦ &#x27;bottom&#x27; ¦ &#x27;center&#x27;</span><br><span class=\"line\">                               // ¦ &#123;number&#125;（y坐标，单位px）</span><br><span class=\"line\">    color : [&#x27;#1e90ff&#x27;,&#x27;#22bb22&#x27;,&#x27;#4b0082&#x27;,&#x27;#d2691e&#x27;],</span><br><span class=\"line\">    backgroundColor: &#x27;rgba(0,0,0,0)&#x27;, // 工具箱背景颜色</span><br><span class=\"line\">    borderColor: &#x27;#ccc&#x27;,       // 工具箱边框颜色</span><br><span class=\"line\">    borderWidth: 0,            // 工具箱边框线宽，单位px，默认为0（无边框）</span><br><span class=\"line\">    padding: 5,                // 工具箱内边距，单位px，默认各方向内边距为5，</span><br><span class=\"line\">                               // 接受数组分别设定上右下左边距，同css</span><br><span class=\"line\">    itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，</span><br><span class=\"line\">                               // 横向布局时为水平间隔，纵向布局时为纵向间隔</span><br><span class=\"line\">    itemSize: 16,              // 工具箱图形宽度</span><br><span class=\"line\">    featureImageIcon : &#123;&#125;,     // 自定义图片icon</span><br><span class=\"line\">    featureTitle : &#123;</span><br><span class=\"line\">        mark : &#x27;辅助线开关&#x27;,</span><br><span class=\"line\">        markUndo : &#x27;删除辅助线&#x27;,</span><br><span class=\"line\">        markClear : &#x27;清空辅助线&#x27;,</span><br><span class=\"line\">        dataZoom : &#x27;区域缩放&#x27;,</span><br><span class=\"line\">        dataZoomReset : &#x27;区域缩放后退&#x27;,</span><br><span class=\"line\">        dataView : &#x27;数据视图&#x27;,</span><br><span class=\"line\">        lineChart : &#x27;折线图切换&#x27;,</span><br><span class=\"line\">        barChart : &#x27;柱形图切换&#x27;,</span><br><span class=\"line\">        restore : &#x27;还原&#x27;,</span><br><span class=\"line\">        saveAsImage : &#x27;保存为图片&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 提示框</span><br><span class=\"line\">tooltip: &#123;</span><br><span class=\"line\">    trigger: &#x27;item&#x27;,           // 触发类型，默认数据触发，见下图，可选为：&#x27;item&#x27; ¦ &#x27;axis&#x27;</span><br><span class=\"line\">    showDelay: 20,             // 显示延迟，添加显示延迟可以避免频繁切换，单位ms</span><br><span class=\"line\">    hideDelay: 100,            // 隐藏延迟，单位ms</span><br><span class=\"line\">    transitionDuration : 0.4,  // 动画变换时间，单位s</span><br><span class=\"line\">    backgroundColor: &#x27;rgba(0,0,0,0.7)&#x27;,     // 提示背景颜色，默认为透明度为0.7的黑色</span><br><span class=\"line\">    borderColor: &#x27;#333&#x27;,       // 提示边框颜色</span><br><span class=\"line\">    borderRadius: 4,           // 提示边框圆角，单位px，默认为4</span><br><span class=\"line\">    borderWidth: 0,            // 提示边框线宽，单位px，默认为0（无边框）</span><br><span class=\"line\">    padding: 5,                // 提示内边距，单位px，默认各方向内边距为5，</span><br><span class=\"line\">                               // 接受数组分别设定上右下左边距，同css</span><br><span class=\"line\">    axisPointer : &#123;            // 坐标轴指示器，坐标轴触发有效</span><br><span class=\"line\">        type : &#x27;line&#x27;,         // 默认为直线，可选为：&#x27;line&#x27; | &#x27;shadow&#x27;</span><br><span class=\"line\">        lineStyle : &#123;          // 直线指示器样式设置</span><br><span class=\"line\">            color: &#x27;#48b&#x27;,</span><br><span class=\"line\">            width: 2,</span><br><span class=\"line\">            type: &#x27;solid&#x27;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        shadowStyle : &#123;                       // 阴影指示器样式设置</span><br><span class=\"line\">            width: &#x27;auto&#x27;,                   // 阴影大小</span><br><span class=\"line\">            color: &#x27;rgba(150,150,150,0.3)&#x27;  // 阴影颜色</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    textStyle: &#123;</span><br><span class=\"line\">        color: &#x27;#fff&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 区域缩放控制器</span><br><span class=\"line\">dataZoom: &#123;</span><br><span class=\"line\">    orient: &#x27;horizontal&#x27;,      // 布局方式，默认为水平布局，可选为：</span><br><span class=\"line\">                               // &#x27;horizontal&#x27; ¦ &#x27;vertical&#x27;</span><br><span class=\"line\">    // x: &#123;number&#125;,            // 水平安放位置，默认为根据grid参数适配，可选为：</span><br><span class=\"line\">                               // &#123;number&#125;（x坐标，单位px）</span><br><span class=\"line\">    // y: &#123;number&#125;,            // 垂直安放位置，默认为根据grid参数适配，可选为：</span><br><span class=\"line\">                               // &#123;number&#125;（y坐标，单位px）</span><br><span class=\"line\">    // width: &#123;number&#125;,        // 指定宽度，横向布局时默认为根据grid参数适配</span><br><span class=\"line\">    // height: &#123;number&#125;,       // 指定高度，纵向布局时默认为根据grid参数适配</span><br><span class=\"line\">    backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,       // 背景颜色</span><br><span class=\"line\">    dataBackgroundColor: &#x27;#eee&#x27;,            // 数据背景颜色</span><br><span class=\"line\">    fillerColor: &#x27;rgba(144,197,237,0.2)&#x27;,   // 填充颜色</span><br><span class=\"line\">    handleColor: &#x27;rgba(70,130,180,0.8)&#x27;     // 手柄颜色</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 网格</span><br><span class=\"line\">grid: &#123;</span><br><span class=\"line\">    x: 80,</span><br><span class=\"line\">    y: 60,</span><br><span class=\"line\">    x2: 80,</span><br><span class=\"line\">    y2: 60,</span><br><span class=\"line\">    // width: &#123;totalWidth&#125; - x - x2,</span><br><span class=\"line\">    // height: &#123;totalHeight&#125; - y - y2,</span><br><span class=\"line\">    backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,</span><br><span class=\"line\">    borderWidth: 1,</span><br><span class=\"line\">    borderColor: &#x27;#ccc&#x27;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 类目轴</span><br><span class=\"line\">categoryAxis: &#123;</span><br><span class=\"line\">    position: &#x27;bottom&#x27;,    // 位置</span><br><span class=\"line\">    nameLocation: &#x27;end&#x27;,   // 坐标轴名字位置，支持&#x27;start&#x27; | &#x27;end&#x27;</span><br><span class=\"line\">    boundaryGap: true,     // 类目起始和结束两端空白策略</span><br><span class=\"line\">    axisLine: &#123;            // 坐标轴线</span><br><span class=\"line\">        show: true,        // 默认显示，属性show控制显示与否</span><br><span class=\"line\">        lineStyle: &#123;       // 属性lineStyle控制线条样式</span><br><span class=\"line\">            color: &#x27;#48b&#x27;,</span><br><span class=\"line\">            width: 2,</span><br><span class=\"line\">            type: &#x27;solid&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisTick: &#123;            // 坐标轴小标记</span><br><span class=\"line\">        show: true,       // 属性show控制显示与否，默认不显示</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        // onGap: null,</span><br><span class=\"line\">        inside : false,    // 控制小标记是否在grid里</span><br><span class=\"line\">        length :5,         // 属性length控制线长</span><br><span class=\"line\">        lineStyle: &#123;       // 属性lineStyle控制线条样式</span><br><span class=\"line\">            color: &#x27;#333&#x27;,</span><br><span class=\"line\">            width: 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisLabel: &#123;           // 坐标轴文本标签，详见axis.axisLabel</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        rotate: 0,</span><br><span class=\"line\">        margin: 8,</span><br><span class=\"line\">        // formatter: null,</span><br><span class=\"line\">        textStyle: &#123;       // 其余属性默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            color: &#x27;#333&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;           // 分隔线</span><br><span class=\"line\">        show: true,        // 默认显示，属性show控制显示与否</span><br><span class=\"line\">        // onGap: null,</span><br><span class=\"line\">        lineStyle: &#123;       // 属性lineStyle（详见lineStyle）控制线条样式</span><br><span class=\"line\">            color: [&#x27;#ccc&#x27;],</span><br><span class=\"line\">            width: 1,</span><br><span class=\"line\">            type: &#x27;solid&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitArea: &#123;           // 分隔区域</span><br><span class=\"line\">        show: false,       // 默认不显示，属性show控制显示与否</span><br><span class=\"line\">        // onGap: null,</span><br><span class=\"line\">        areaStyle: &#123;       // 属性areaStyle（详见areaStyle）控制区域样式</span><br><span class=\"line\">            color: [&#x27;rgba(250,250,250,0.3)&#x27;,&#x27;rgba(200,200,200,0.3)&#x27;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 数值型坐标轴默认参数</span><br><span class=\"line\">valueAxis: &#123;</span><br><span class=\"line\">    position: &#x27;left&#x27;,      // 位置</span><br><span class=\"line\">    nameLocation: &#x27;end&#x27;,   // 坐标轴名字位置，支持&#x27;start&#x27; | &#x27;end&#x27;</span><br><span class=\"line\">    nameTextStyle: &#123;&#125;,     // 坐标轴文字样式，默认取全局样式</span><br><span class=\"line\">    boundaryGap: [0, 0],   // 数值起始和结束两端空白策略</span><br><span class=\"line\">    splitNumber: 5,        // 分割段数，默认为5</span><br><span class=\"line\">    axisLine: &#123;            // 坐标轴线</span><br><span class=\"line\">        show: true,        // 默认显示，属性show控制显示与否</span><br><span class=\"line\">        lineStyle: &#123;       // 属性lineStyle控制线条样式</span><br><span class=\"line\">            color: &#x27;#48b&#x27;,</span><br><span class=\"line\">            width: 2,</span><br><span class=\"line\">            type: &#x27;solid&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisTick: &#123;            // 坐标轴小标记</span><br><span class=\"line\">        show: false,       // 属性show控制显示与否，默认不显示</span><br><span class=\"line\">        inside : false,    // 控制小标记是否在grid里</span><br><span class=\"line\">        length :5,         // 属性length控制线长</span><br><span class=\"line\">        lineStyle: &#123;       // 属性lineStyle控制线条样式</span><br><span class=\"line\">            color: &#x27;#333&#x27;,</span><br><span class=\"line\">            width: 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisLabel: &#123;           // 坐标轴文本标签，详见axis.axisLabel</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        rotate: 0,</span><br><span class=\"line\">        margin: 8,</span><br><span class=\"line\">        // formatter: null,</span><br><span class=\"line\">        textStyle: &#123;       // 其余属性默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            color: &#x27;#333&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;           // 分隔线</span><br><span class=\"line\">        show: true,        // 默认显示，属性show控制显示与否</span><br><span class=\"line\">        lineStyle: &#123;       // 属性lineStyle（详见lineStyle）控制线条样式</span><br><span class=\"line\">            color: [&#x27;#ccc&#x27;],</span><br><span class=\"line\">            width: 1,</span><br><span class=\"line\">            type: &#x27;solid&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitArea: &#123;           // 分隔区域</span><br><span class=\"line\">        show: false,       // 默认不显示，属性show控制显示与否</span><br><span class=\"line\">        areaStyle: &#123;       // 属性areaStyle（详见areaStyle）控制区域样式</span><br><span class=\"line\">            color: [&#x27;rgba(250,250,250,0.3)&#x27;,&#x27;rgba(200,200,200,0.3)&#x27;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">polar : &#123;</span><br><span class=\"line\">    center : [&#x27;50%&#x27;, &#x27;50%&#x27;],    // 默认全局居中</span><br><span class=\"line\">    radius : &#x27;75%&#x27;,</span><br><span class=\"line\">    startAngle : 90,</span><br><span class=\"line\">    splitNumber : 5,</span><br><span class=\"line\">    name : &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;       // 其余属性默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            color: &#x27;#333&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisLine: &#123;            // 坐标轴线</span><br><span class=\"line\">        show: true,        // 默认显示，属性show控制显示与否</span><br><span class=\"line\">        lineStyle: &#123;       // 属性lineStyle控制线条样式</span><br><span class=\"line\">            color: &#x27;#ccc&#x27;,</span><br><span class=\"line\">            width: 1,</span><br><span class=\"line\">            type: &#x27;solid&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisLabel: &#123;           // 坐标轴文本标签，详见axis.axisLabel</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        textStyle: &#123;       // 其余属性默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            color: &#x27;#333&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitArea : &#123;</span><br><span class=\"line\">        show : true,</span><br><span class=\"line\">        areaStyle : &#123;</span><br><span class=\"line\">            color: [&#x27;rgba(250,250,250,0.3)&#x27;,&#x27;rgba(200,200,200,0.3)&#x27;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine : &#123;</span><br><span class=\"line\">        show : true,</span><br><span class=\"line\">        lineStyle : &#123;</span><br><span class=\"line\">            width : 1,</span><br><span class=\"line\">            color : &#x27;#ccc&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 柱形图默认参数</span><br><span class=\"line\">bar: &#123;</span><br><span class=\"line\">    barMinHeight: 0,          // 最小高度改为0</span><br><span class=\"line\">    // barWidth: null,        // 默认自适应</span><br><span class=\"line\">    barGap: &#x27;30%&#x27;,            // 柱间距离，默认为柱形宽度的30%，可设固定值</span><br><span class=\"line\">    barCategoryGap : &#x27;20%&#x27;,   // 类目间柱形距离，默认为类目间距的20%，可设固定值</span><br><span class=\"line\">    itemStyle: &#123;</span><br><span class=\"line\">        normal: &#123;</span><br><span class=\"line\">            // color: &#x27;各异&#x27;,</span><br><span class=\"line\">            barBorderColor: &#x27;#fff&#x27;,       // 柱条边线</span><br><span class=\"line\">            barBorderRadius: 0,           // 柱条边线圆角，单位px，默认为0</span><br><span class=\"line\">            barBorderWidth: 1,            // 柱条边线线宽，单位px，默认为1</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">                // position: 默认自适应，水平布局为&#x27;top&#x27;，垂直布局为&#x27;right&#x27;，可选为</span><br><span class=\"line\">                //           &#x27;inside&#x27;|&#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            // color: &#x27;各异&#x27;,</span><br><span class=\"line\">            barBorderColor: &#x27;rgba(0,0,0,0)&#x27;,   // 柱条边线</span><br><span class=\"line\">            barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0</span><br><span class=\"line\">            barBorderWidth: 1,                 // 柱条边线线宽，单位px，默认为1</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">                // position: 默认自适应，水平布局为&#x27;top&#x27;，垂直布局为&#x27;right&#x27;，可选为</span><br><span class=\"line\">                //           &#x27;inside&#x27;|&#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 折线图默认参数</span><br><span class=\"line\">line: &#123;</span><br><span class=\"line\">    itemStyle: &#123;</span><br><span class=\"line\">        normal: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">                // position: 默认自适应，水平布局为&#x27;top&#x27;，垂直布局为&#x27;right&#x27;，可选为</span><br><span class=\"line\">                //           &#x27;inside&#x27;|&#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            lineStyle: &#123;</span><br><span class=\"line\">                width: 2,</span><br><span class=\"line\">                type: &#x27;solid&#x27;,</span><br><span class=\"line\">                shadowColor : &#x27;rgba(0,0,0,0)&#x27;, //默认透明</span><br><span class=\"line\">                shadowBlur: 5,</span><br><span class=\"line\">                shadowOffsetX: 3,</span><br><span class=\"line\">                shadowOffsetY: 3</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">                // position: 默认自适应，水平布局为&#x27;top&#x27;，垂直布局为&#x27;right&#x27;，可选为</span><br><span class=\"line\">                //           &#x27;inside&#x27;|&#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //smooth : false,</span><br><span class=\"line\">    //symbol: null,         // 拐点图形类型</span><br><span class=\"line\">    symbolSize: 2,          // 拐点图形大小</span><br><span class=\"line\">    //symbolRotate : null,  // 拐点图形旋转控制</span><br><span class=\"line\">    showAllSymbol: false    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// K线图默认参数</span><br><span class=\"line\">k: &#123;</span><br><span class=\"line\">    // barWidth : null          // 默认自适应</span><br><span class=\"line\">    // barMaxWidth : null       // 默认自适应</span><br><span class=\"line\">    itemStyle: &#123;</span><br><span class=\"line\">        normal: &#123;</span><br><span class=\"line\">            color: &#x27;#fff&#x27;,          // 阳线填充颜色</span><br><span class=\"line\">            color0: &#x27;#00aa11&#x27;,      // 阴线填充颜色</span><br><span class=\"line\">            lineStyle: &#123;</span><br><span class=\"line\">                width: 1,</span><br><span class=\"line\">                color: &#x27;#ff3200&#x27;,   // 阳线边框颜色</span><br><span class=\"line\">                color0: &#x27;#00aa11&#x27;   // 阴线边框颜色</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            // color0: 各异</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 散点图默认参数</span><br><span class=\"line\">scatter: &#123;</span><br><span class=\"line\">    //symbol: null,      // 图形类型</span><br><span class=\"line\">    symbolSize: 4,       // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2</span><br><span class=\"line\">    //symbolRotate : null,  // 图形旋转控制</span><br><span class=\"line\">    large: false,        // 大规模散点图</span><br><span class=\"line\">    largeThreshold: 2000,// 大规模阀值，large为true且数据量&gt;largeThreshold才启用大规模模式</span><br><span class=\"line\">    itemStyle: &#123;</span><br><span class=\"line\">        normal: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">                // position: 默认自适应，水平布局为&#x27;top&#x27;，垂直布局为&#x27;right&#x27;，可选为</span><br><span class=\"line\">                //           &#x27;inside&#x27;|&#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            // color: &#x27;各异&#x27;</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">                // position: 默认自适应，水平布局为&#x27;top&#x27;，垂直布局为&#x27;right&#x27;，可选为</span><br><span class=\"line\">                //           &#x27;inside&#x27;|&#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 雷达图默认参数</span><br><span class=\"line\">radar : &#123;</span><br><span class=\"line\">    itemStyle: &#123;</span><br><span class=\"line\">        normal: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            lineStyle: &#123;</span><br><span class=\"line\">                width: 2,</span><br><span class=\"line\">                type: &#x27;solid&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //symbol: null,         // 拐点图形类型</span><br><span class=\"line\">    symbolSize: 2           // 可计算特性参数，空数据拖拽提示图形大小</span><br><span class=\"line\">    //symbolRotate : null,  // 图形旋转控制</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 饼图默认参数</span><br><span class=\"line\">pie: &#123;</span><br><span class=\"line\">    center : [&#x27;50%&#x27;, &#x27;50%&#x27;],    // 默认全局居中</span><br><span class=\"line\">    radius : [0, &#x27;75%&#x27;],</span><br><span class=\"line\">    clockWise : false,          // 默认逆时针</span><br><span class=\"line\">    startAngle: 90,</span><br><span class=\"line\">    minAngle: 0,                // 最小角度改为0</span><br><span class=\"line\">    selectedOffset: 10,         // 选中是扇区偏移量</span><br><span class=\"line\">    itemStyle: &#123;</span><br><span class=\"line\">        normal: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            borderColor: &#x27;#fff&#x27;,</span><br><span class=\"line\">            borderWidth: 1,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: true,</span><br><span class=\"line\">                position: &#x27;outer&#x27;</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            labelLine: &#123;</span><br><span class=\"line\">                show: true,</span><br><span class=\"line\">                length: 20,</span><br><span class=\"line\">                lineStyle: &#123;</span><br><span class=\"line\">                    // color: 各异,</span><br><span class=\"line\">                    width: 1,</span><br><span class=\"line\">                    type: &#x27;solid&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            borderColor: &#x27;rgba(0,0,0,0)&#x27;,</span><br><span class=\"line\">            borderWidth: 1,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">                // position: &#x27;outer&#x27;</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            labelLine: &#123;</span><br><span class=\"line\">                show: false,</span><br><span class=\"line\">                length: 20,</span><br><span class=\"line\">                lineStyle: &#123;</span><br><span class=\"line\">                    // color: 各异,</span><br><span class=\"line\">                    width: 1,</span><br><span class=\"line\">                    type: &#x27;solid&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">map: &#123;</span><br><span class=\"line\">    mapType: &#x27;china&#x27;,   // 各省的mapType暂时都用中文</span><br><span class=\"line\">    mapLocation: &#123;</span><br><span class=\"line\">        x : &#x27;center&#x27;,</span><br><span class=\"line\">        y : &#x27;center&#x27;</span><br><span class=\"line\">        // width    // 自适应</span><br><span class=\"line\">        // height   // 自适应</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showLegendSymbol : true,       // 显示图例颜色标识（系列标识的小圆点），存在legend时生效</span><br><span class=\"line\">    itemStyle: &#123;</span><br><span class=\"line\">        normal: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            borderColor: &#x27;#fff&#x27;,</span><br><span class=\"line\">            borderWidth: 1,</span><br><span class=\"line\">            areaStyle: &#123;</span><br><span class=\"line\">                color: &#x27;#ccc&#x27;//rgba(135,206,250,0.8)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false,</span><br><span class=\"line\">                textStyle: &#123;</span><br><span class=\"line\">                    color: &#x27;rgba(139,69,19,1)&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;                 // 也是选中样式</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            borderColor: &#x27;rgba(0,0,0,0)&#x27;,</span><br><span class=\"line\">            borderWidth: 1,</span><br><span class=\"line\">            areaStyle: &#123;</span><br><span class=\"line\">                color: &#x27;rgba(255,215,0,0.8)&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false,</span><br><span class=\"line\">                textStyle: &#123;</span><br><span class=\"line\">                    color: &#x27;rgba(139,69,19,1)&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">force : &#123;</span><br><span class=\"line\">    // 数据map到圆的半径的最小值和最大值</span><br><span class=\"line\">    minRadius : 10,</span><br><span class=\"line\">    maxRadius : 20,</span><br><span class=\"line\">    density : 1.0,</span><br><span class=\"line\">    attractiveness : 1.0,</span><br><span class=\"line\">    // 初始化的随机大小位置</span><br><span class=\"line\">    initSize : 300,</span><br><span class=\"line\">    // 向心力因子，越大向心力越大</span><br><span class=\"line\">    centripetal : 1,</span><br><span class=\"line\">    // 冷却因子</span><br><span class=\"line\">    coolDown : 0.99,</span><br><span class=\"line\">    // 分类里如果有样式会覆盖节点默认样式</span><br><span class=\"line\">    itemStyle: &#123;</span><br><span class=\"line\">        normal: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            nodeStyle : &#123;</span><br><span class=\"line\">                brushType : &#x27;both&#x27;,</span><br><span class=\"line\">                color : &#x27;#f08c2e&#x27;,</span><br><span class=\"line\">                strokeColor : &#x27;#5182ab&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            linkStyle : &#123;</span><br><span class=\"line\">                strokeColor : &#x27;#5182ab&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            // color: 各异,</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            nodeStyle : &#123;&#125;,</span><br><span class=\"line\">            linkStyle : &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">chord : &#123;</span><br><span class=\"line\">    radius : [&#x27;65%&#x27;, &#x27;75%&#x27;],</span><br><span class=\"line\">    center : [&#x27;50%&#x27;, &#x27;50%&#x27;],</span><br><span class=\"line\">    padding : 2,</span><br><span class=\"line\">    sort : &#x27;none&#x27;, // can be &#x27;none&#x27;, &#x27;ascending&#x27;, &#x27;descending&#x27;</span><br><span class=\"line\">    sortSub : &#x27;none&#x27;, // can be &#x27;none&#x27;, &#x27;ascending&#x27;, &#x27;descending&#x27;</span><br><span class=\"line\">    startAngle : 90,</span><br><span class=\"line\">    clockWise : false,</span><br><span class=\"line\">    showScale : false,</span><br><span class=\"line\">    showScaleText : false,</span><br><span class=\"line\">    itemStyle : &#123;</span><br><span class=\"line\">        normal : &#123;</span><br><span class=\"line\">            label : &#123;</span><br><span class=\"line\">                show : true</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            lineStyle : &#123;</span><br><span class=\"line\">                width : 0,</span><br><span class=\"line\">                color : &#x27;#000&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            chordStyle : &#123;</span><br><span class=\"line\">                lineStyle : &#123;</span><br><span class=\"line\">                    width : 1,</span><br><span class=\"line\">                    color : &#x27;#666&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis : &#123;</span><br><span class=\"line\">            lineStyle : &#123;</span><br><span class=\"line\">                width : 0,</span><br><span class=\"line\">                color : &#x27;#000&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            chordStyle : &#123;</span><br><span class=\"line\">                lineStyle : &#123;</span><br><span class=\"line\">                    width : 2,</span><br><span class=\"line\">                    color : &#x27;#333&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">island: &#123;</span><br><span class=\"line\">    r: 15,</span><br><span class=\"line\">    calculateStep: 0.1  // 滚轮可计算步长 0.1 = 10%</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">markPoint : &#123;</span><br><span class=\"line\">    symbol: &#x27;pin&#x27;,         // 标注类型</span><br><span class=\"line\">    symbolSize: 10,        // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2</span><br><span class=\"line\">    //symbolRotate : null, // 标注旋转控制</span><br><span class=\"line\">    itemStyle: &#123;</span><br><span class=\"line\">        normal: &#123;</span><br><span class=\"line\">            // color: 各异，</span><br><span class=\"line\">            // borderColor: 各异,     // 标注边线颜色，优先于color</span><br><span class=\"line\">            borderWidth: 2,            // 标注边线线宽，单位px，默认为1</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: true,</span><br><span class=\"line\">                position: &#x27;inside&#x27; // 可选为&#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;</span><br><span class=\"line\">                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            // color: 各异</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: true</span><br><span class=\"line\">                // position: &#x27;inside&#x27;  // &#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;</span><br><span class=\"line\">                // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">markLine : &#123;</span><br><span class=\"line\">    // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string</span><br><span class=\"line\">    symbol: [&#x27;circle&#x27;, &#x27;arrow&#x27;],</span><br><span class=\"line\">    // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2</span><br><span class=\"line\">    symbolSize: [2, 4],</span><br><span class=\"line\">    // 标线起始和结束的symbol旋转控制</span><br><span class=\"line\">    //symbolRotate : null,</span><br><span class=\"line\">    itemStyle: &#123;</span><br><span class=\"line\">        normal: &#123;</span><br><span class=\"line\">            // color: 各异,           // 标线主色，线色，symbol主色</span><br><span class=\"line\">            // borderColor: 随color,     // 标线symbol边框颜色，优先于color</span><br><span class=\"line\">            borderWidth: 2,          // 标线symbol边框线宽，单位px，默认为2</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false,</span><br><span class=\"line\">                // 可选为 &#x27;start&#x27;|&#x27;end&#x27;|&#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;</span><br><span class=\"line\">                position: &#x27;inside&#x27;,</span><br><span class=\"line\">                textStyle: &#123;         // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">                    color: &#x27;#333&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            lineStyle: &#123;</span><br><span class=\"line\">                // color: 随borderColor, // 主色，线色，优先级高于borderColor和color</span><br><span class=\"line\">                // width: 随borderWidth, // 优先于borderWidth</span><br><span class=\"line\">                type: &#x27;solid&#x27;,</span><br><span class=\"line\">                shadowColor : &#x27;rgba(0,0,0,0)&#x27;, //默认透明</span><br><span class=\"line\">                shadowBlur: 5,</span><br><span class=\"line\">                shadowOffsetX: 3,</span><br><span class=\"line\">                shadowOffsetY: 3</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            // color: 各异</span><br><span class=\"line\">            label: &#123;</span><br><span class=\"line\">                show: false</span><br><span class=\"line\">                // position: &#x27;inside&#x27; // &#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;</span><br><span class=\"line\">                // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            lineStyle : &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">textStyle: &#123;</span><br><span class=\"line\">    decoration: &#x27;none&#x27;,</span><br><span class=\"line\">    fontFamily: &#x27;Arial, Verdana, sans-serif&#x27;,</span><br><span class=\"line\">    fontFamily2: &#x27;微软雅黑&#x27;,    // IE8- 字体模糊并且不支持不同字体混排，额外指定一份</span><br><span class=\"line\">    fontSize: 12,</span><br><span class=\"line\">    fontStyle: &#x27;normal&#x27;,</span><br><span class=\"line\">    fontWeight: &#x27;normal&#x27;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">// 默认标志图形类型列表</span><br><span class=\"line\">symbolList : [</span><br><span class=\"line\">  &#x27;circle&#x27;, &#x27;rectangle&#x27;, &#x27;triangle&#x27;, &#x27;diamond&#x27;,</span><br><span class=\"line\">  &#x27;emptyCircle&#x27;, &#x27;emptyRectangle&#x27;, &#x27;emptyTriangle&#x27;, &#x27;emptyDiamond&#x27;</span><br><span class=\"line\">],</span><br><span class=\"line\">loadingText : &#x27;Loading...&#x27;,</span><br><span class=\"line\">// 可计算特性配置，孤岛，提示颜色</span><br><span class=\"line\">calculable: false,              // 默认关闭可计算特性</span><br><span class=\"line\">calculableColor: &#x27;rgba(255,165,0,0.6)&#x27;,       // 拖拽提示边框颜色</span><br><span class=\"line\">calculableHolderColor: &#x27;#ccc&#x27;, // 可计算占位提示颜色</span><br><span class=\"line\">nameConnector: &#x27; &amp; &#x27;,</span><br><span class=\"line\">valueConnector: &#x27; : &#x27;,</span><br><span class=\"line\">animation: true,</span><br><span class=\"line\">animationThreshold: 2500,       // 动画元素阀值，产生的图形原素超过2500不出动画</span><br><span class=\"line\">addDataAnimation: true,         // 动态数据接口是否开启动画效果</span><br><span class=\"line\">animationDuration: 2000,</span><br><span class=\"line\">animationEasing: &#x27;ExponentialOut&#x27;    //BounceOut</span><br></pre></td></tr></table></figure>\n","categories":["webGL总结"],"tags":["webGL"]},{"title":"Git 常用命令大全","url":"/2022/12/16/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","content":"<h2 id=\"1-远程仓库相关命令\"><a href=\"#1-远程仓库相关命令\" class=\"headerlink\" title=\"1) 远程仓库相关命令\"></a>1) 远程仓库相关命令</h2><p>检出仓库：$ git clone git:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery.git</p>\n<p>查看远程仓库：$ git remote -v</p>\n<p>添加远程仓库：$ git remote add [name] [url]</p>\n<p>删除远程仓库：$ git remote rm [name]</p>\n<p>修改远程仓库：$ git remote set-url –push [name] [newUrl]</p>\n<p>拉取远程仓库：$ git pull [remoteName] [localBranchName]</p>\n<p>推送远程仓库：$ git push [remoteName] [localBranchName]</p>\n<p>如果想把本地的某个分支 test 提交到远程仓库，并作为远程仓库的 master 分支，或者作为另外一个名叫 test 的分支，如下：</p>\n<p>$git push origin test:master &#x2F;&#x2F; 提交本地 test 分支作为远程的 master 分支</p>\n<p>$git push origin test:test &#x2F;&#x2F; 提交本地 test 分支作为远程的 test 分支</p>\n<h2 id=\"2）分支-branch-操作相关命令\"><a href=\"#2）分支-branch-操作相关命令\" class=\"headerlink\" title=\"2）分支(branch)操作相关命令\"></a>2）分支(branch)操作相关命令</h2><p>查看本地分支：$ git branch</p>\n<p>查看远程分支：$ git branch -r</p>\n<p>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</p>\n<p>切换分支：$ git checkout [name]</p>\n<p>创建新分支并立即切换到新分支：$ git checkout -b [name]</p>\n<p>删除分支：$ git branch -d [name] —- -d 选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D 选项</p>\n<p>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并</p>\n<p>创建远程分支(本地分支 push 到远程)：$ git push origin [name]</p>\n<p>删除远程分支：$ git push origin :heads&#x2F;[name] 或 $ git push origin :[name]</p>\n<p>创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)</p>\n<p>$git symbolic-ref HEAD refs&#x2F;heads&#x2F;[name]</p>\n<p>$rm .git&#x2F;index</p>\n<p>$git clean -fdx</p>\n<h2 id=\"3）版本-tag-操作相关命令\"><a href=\"#3）版本-tag-操作相关命令\" class=\"headerlink\" title=\"3）版本(tag)操作相关命令\"></a>3）版本(tag)操作相关命令</h2><p>查看版本：$ git tag</p>\n<p>创建版本：$ git tag [name]</p>\n<p>删除版本：$ git tag -d [name]</p>\n<p>查看远程版本：$ git tag -r</p>\n<p>创建远程版本(本地版本 push 到远程)：$ git push origin [name]</p>\n<p>删除远程版本：$ git push origin :refs&#x2F;tags&#x2F;[name]</p>\n<p>合并远程仓库的 tag 到本地：$ git pull origin –tags</p>\n<p>上传本地 tag 到远程仓库：$ git push origin –tags</p>\n<p>创建带注释的 tag：$ git tag -a [name] -m ‘yourMessage’</p>\n<h2 id=\"4-子模块-submodule-相关操作命令\"><a href=\"#4-子模块-submodule-相关操作命令\" class=\"headerlink\" title=\"4) 子模块(submodule)相关操作命令\"></a>4) 子模块(submodule)相关操作命令</h2><p>添加子模块：$ git submodule add [url] [path]</p>\n<p>如：$git submodule add git:&#x2F;&#x2F;github.com&#x2F;soberh&#x2F;ui-libs.git src&#x2F;main&#x2F;webapp&#x2F;ui-libs</p>\n<p>初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行</p>\n<p>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下</p>\n<p>删除子模块：（分 4 步走）</p>\n<ol>\n<li><p>$ git rm –cached [path]</p>\n</li>\n<li><p>编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</p>\n</li>\n<li><p>编辑“ .git&#x2F;config”文件，将子模块的相关配置节点删除掉</p>\n</li>\n<li><p>手动删除子模块残留的目录</p>\n</li>\n</ol>\n<h2 id=\"5）忽略一些文件、文件夹不提交\"><a href=\"#5）忽略一些文件、文件夹不提交\" class=\"headerlink\" title=\"5）忽略一些文件、文件夹不提交\"></a>5）忽略一些文件、文件夹不提交</h2><p>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如</p>\n<p>target</p>\n<p>bin</p>\n<p>*.db</p>\n<h2 id=\"Git-常用命令\"><a href=\"#Git-常用命令\" class=\"headerlink\" title=\"Git 常用命令\"></a>Git 常用命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch 查看本地所有分支</span><br><span class=\"line\">git status 查看当前状态</span><br><span class=\"line\">git commit 提交</span><br><span class=\"line\">git branch -a 查看所有的分支</span><br><span class=\"line\">git branch -r 查看本地所有分支</span><br><span class=\"line\">git commit -am &quot;init&quot; 提交并且加注释</span><br><span class=\"line\">git remote add origin git@192.168.1.119:ndshow</span><br><span class=\"line\">git push origin master 将文件给推到服务器上</span><br><span class=\"line\">git remote show origin 显示远程库origin里的资源</span><br><span class=\"line\">git push origin master:develop</span><br><span class=\"line\">git push origin master:hb-dev 将本地库与服务器上的库进行关联</span><br><span class=\"line\">git checkout --track origin/dev 切换到远程dev分支</span><br><span class=\"line\">git branch -D master develop 删除本地库develop</span><br><span class=\"line\">git checkout -b dev 建立一个新的本地分支dev</span><br><span class=\"line\">git merge origin/dev 将分支dev与当前分支进行合并</span><br><span class=\"line\">git checkout dev 切换到本地dev分支</span><br><span class=\"line\">git remote show 查看远程库</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git rm 文件名(包括路径) 从git中删除指定文件</span><br><span class=\"line\">git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来</span><br><span class=\"line\">git config --list 看所有用户</span><br><span class=\"line\">git ls-files 看已经被提交的</span><br><span class=\"line\">git rm [file name] 删除一个文件</span><br><span class=\"line\">git commit -a 提交当前repos的所有的改变</span><br><span class=\"line\">git add [file name] 添加一个文件到git index</span><br><span class=\"line\">git commit -v 当你用－v参数的时候可以看commit的差异</span><br><span class=\"line\">git commit -m &quot;This is the message describing the commit&quot; 添加commit信息</span><br><span class=\"line\">git commit -a -a是代表add，把所有的change加到git index里然后再commit</span><br><span class=\"line\">git commit -a -v 一般提交命令</span><br><span class=\"line\">git log 看你commit的日志</span><br><span class=\"line\">git diff 查看尚未暂存的更新</span><br><span class=\"line\">git rm a.a 移除文件(从暂存区和工作区中删除)</span><br><span class=\"line\">git rm --cached a.a 移除文件(只从暂存区中删除)</span><br><span class=\"line\">git commit -m &quot;remove&quot; 移除文件(从Git中删除)</span><br><span class=\"line\">git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)</span><br><span class=\"line\">git diff --cached 或 $ git diff --staged 查看尚未提交的更新</span><br><span class=\"line\">git stash push 将文件给push到一个临时空间中</span><br><span class=\"line\">git stash pop 将文件从临时空间pop下来</span><br><span class=\"line\">---------------------------------------------------------</span><br><span class=\"line\">git remote add origin git@github.com:username/Hello-World.git</span><br><span class=\"line\">git push origin master 将本地项目给提交到服务器中</span><br><span class=\"line\">-----------------------------------------------------------</span><br><span class=\"line\">git pull 本地与服务器端同步</span><br><span class=\"line\">-----------------------------------------------------------------</span><br><span class=\"line\">git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。</span><br><span class=\"line\">git push origin serverfix:awesomebranch</span><br><span class=\"line\">------------------------------------------------------------------</span><br><span class=\"line\">git fetch 相当于是从远程获取最新版本到本地，不会自动merge</span><br><span class=\"line\">git commit -a -m &quot;log_message&quot; (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：</span><br><span class=\"line\">git branch branch_0.1 master 从主分支master创建branch_0.1分支</span><br><span class=\"line\">git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0</span><br><span class=\"line\">git checkout branch_1.0/master 切换到branch_1.0/master分支</span><br><span class=\"line\">du -hs</span><br><span class=\"line\"></span><br><span class=\"line\">-----------------------------------------------------------</span><br><span class=\"line\">mkdir WebApp</span><br><span class=\"line\">cd WebApp</span><br><span class=\"line\">git init</span><br><span class=\"line\">touch README</span><br><span class=\"line\">git add README</span><br><span class=\"line\">git commit -m &#x27;first commit&#x27;</span><br><span class=\"line\">git remote add origin git@github.com:daixu/WebApp.git</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Git-常用命令图表\"><a href=\"#Git-常用命令图表\" class=\"headerlink\" title=\"Git 常用命令图表\"></a>Git 常用命令图表</h2><p><img src=\"https://pic002.cnblogs.com/img/1-2-3/201007/2010072023345292.png\" alt=\"image\"></p>\n","categories":["常用指令合集"],"tags":["javascript"]},{"title":"HTTP各版本的区别&HTTPS请求过程","url":"/2022/10/24/HTTP%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB-HTTPS%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/","content":"<h2 id=\"HTTP-各版本的区别\"><a href=\"#HTTP-各版本的区别\" class=\"headerlink\" title=\"HTTP 各版本的区别\"></a>HTTP 各版本的区别</h2><h3 id=\"什么是-HTTP-和-HTTPS？\"><a href=\"#什么是-HTTP-和-HTTPS？\" class=\"headerlink\" title=\"什么是 HTTP 和 HTTPS？\"></a>什么是 HTTP 和 HTTPS？</h3><p>HTTP 是浏览器与服务器之间以明文的方式传送内容的一种互联网通信协议。</p>\n<p>HTTPS 是在 HTTP 的基础上主要基于 SPDF 协议结合 SSL&#x2F;TLS 加密协议，客户端依靠证书验证服务器身份传递加密信息的通信协议。</p>\n<ul>\n<li>1991 年　　 HTTP&#x2F;0.9 仅支持 GET 请求，不支持请求头</li>\n<li>1996 年　　 HTTP&#x2F;1.0 默认短连接（一次请求建议一次 TCP 连接，请求完就断开），支持 GET、POST、 HEAD 请求</li>\n<li>1999 年　　 HTTP&#x2F;1.1 默认长连接（一次 TCP 连接可以多次请求）；支持 PUT、DELETE、PATCH 等六种请求；增加 host 头，支持虚拟主机；支持断点续传功能</li>\n<li>2015 年　　 HTTP&#x2F;2.0 多路复用，降低开销（一次 TCP 连接可以处理多个请求）；服务器主动推送（相关资源一个请求全部推送）；解析基于二进制，解析错误少，更高效（HTTP&#x2F;1.X 解析基于文本）；报头压缩，降低开销。</li>\n</ul>\n<h2 id=\"HTTPS-请求过程：（一次-HTTPS-请求要进行两次-HTTP-传输）\"><a href=\"#HTTPS-请求过程：（一次-HTTPS-请求要进行两次-HTTP-传输）\" class=\"headerlink\" title=\"HTTPS 请求过程：（一次 HTTPS 请求要进行两次 HTTP 传输）\"></a>HTTPS 请求过程：（一次 HTTPS 请求要进行两次 HTTP 传输）</h2><p>1.客户端发出 https 请求，请求服务端建立 SSL 连接；</p>\n<p>2.服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端；</p>\n<p>3.客户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥；</p>\n<p>4.客户端将公钥与客户端私钥进行对称加密后传给服务端；</p>\n<p>5.服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥；</p>\n<p>6.服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端；</p>\n<p>7.客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容。</p>\n<h2 id=\"HTTPS-怎么校验证书的有效性？\"><a href=\"#HTTPS-怎么校验证书的有效性？\" class=\"headerlink\" title=\"HTTPS 怎么校验证书的有效性？\"></a>HTTPS 怎么校验证书的有效性？</h2><p>证书里面包含了公钥+各种信息+签名，公钥加密私钥解，私钥加密公钥解，通过私钥将签名解密后得到的信息和证书里面的信息比对就可以验证证书的合法性了。</p>\n<p>签名是私钥和各种信息加密后形成的签名。</p>\n<h2 id=\"为什么-HTTPS-很安全却不普及？\"><a href=\"#为什么-HTTPS-很安全却不普及？\" class=\"headerlink\" title=\"为什么 HTTPS 很安全却不普及？\"></a>为什么 HTTPS 很安全却不普及？</h2><p>1.加密通信与普通的文本通信，要消耗更多的 CPU 和内存，缓存慢，通信成本较大；</p>\n<p>2.HTTPS 通信需要证书，而证书不是免费的。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"HTTP常用的14种状态码","url":"/2022/10/24/HTTP%E5%B8%B8%E7%94%A8%E7%9A%8414%E7%A7%8D%E7%8A%B6%E6%80%81%E7%A0%81/","content":"<p>状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误。</p>\n<p>状态码的类别：</p>\n<table>\n<thead>\n<tr>\n<th>~</th>\n<th>类别</th>\n<th>原因短语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td>Informational（信息性状态码）</td>\n<td>接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success（成功状态码）</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection（重定向状态码）</td>\n<td>需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error（客户端错误状态码）</td>\n<td>服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error（服务器错误状态码）</td>\n<td>服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<h2 id=\"2XX——表明请求被正常处理了\"><a href=\"#2XX——表明请求被正常处理了\" class=\"headerlink\" title=\"2XX——表明请求被正常处理了\"></a>2XX——表明请求被正常处理了</h2><p>1、200 OK：<strong>请求已正常处理</strong>。</p>\n<p>2、204 No Content：<strong>请求处理成功，但没有任何资源可以返回给客户端</strong>，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>\n<p>3、206 Partial Content：<strong>是对资源某一部分的请求</strong>，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>\n<h2 id=\"3XX——表明浏览器需要执行某些特殊的处理以正确处理请求\"><a href=\"#3XX——表明浏览器需要执行某些特殊的处理以正确处理请求\" class=\"headerlink\" title=\"3XX——表明浏览器需要执行某些特殊的处理以正确处理请求\"></a>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</h2><p>4、301 Moved Permanently：<strong>资源的 uri 已更新，你也更新下你的书签引用吧。永久性重定向</strong>，请求的资源已经被分配了新的 URI，以后应使用资源现在所指的 URI。</p>\n<p>5、302 Found：<strong>资源的 URI 已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向</strong>。和 301 相似，但 302 代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。</p>\n<p>6、303 See Other：<strong>资源的 URI 已更新，你是否能临时按新的 URI 访问</strong>。该状态码表示由于请求对应的资源存在着另一个 URL，应使用 GET 方法定向获取请求的资源。303 状态码和 302 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。</p>\n<p>当 301,302,303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。</p>\n<p>7、304 Not Modified：<strong>资源已找到，但未符合条件请求</strong>。该状态码表示客户端发送附带条件的请求时（采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回 304.。</p>\n<p>8、307 Temporary Redirect：<strong>临时重定向</strong>。与 302 有相同的含义。</p>\n<h2 id=\"4XX——表明客户端是发生错误的原因所在。\"><a href=\"#4XX——表明客户端是发生错误的原因所在。\" class=\"headerlink\" title=\"4XX——表明客户端是发生错误的原因所在。\"></a>4XX——表明客户端是发生错误的原因所在。</h2><p>9、400 Bad Request：<strong>服务器端无法理解客户端发送的请求</strong>，请求报文中可能存在语法错误。</p>\n<p>10、401 Unauthorized：<strong>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证，DIGEST 认证）的认证信息。</strong></p>\n<p>11、403 Forbidden：<strong>不允许访问那个资源</strong>。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权 IP 等）</p>\n<p>12、404 Not Found：<strong>服务器上没有请求的资源</strong>。路径错误等。</p>\n<h2 id=\"5XX——服务器本身发生错误\"><a href=\"#5XX——服务器本身发生错误\" class=\"headerlink\" title=\"5XX——服务器本身发生错误\"></a>5XX——服务器本身发生错误</h2><p>13、500 Internal Server Error：<strong>貌似内部资源出故障了</strong>。该状态码表明服务器端在执行请求时发生了错误。也有可能是 web 应用存在 bug 或某些临时故障。</p>\n<p>14、503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"Highcharts工作笔记","url":"/2022/12/16/Highcharts%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/","content":"<h2 id=\"一、单个数据源时\"><a href=\"#一、单个数据源时\" class=\"headerlink\" title=\"一、单个数据源时\"></a>一、单个数据源时</h2><p><img src=\"https://img-blog.csdn.net/20130712155158375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGluZmVuZ3Rpbmd5dTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdn.net/20130712160031250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGluZmVuZ3Rpbmd5dTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"image\"></p>\n<p>如上图，配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//绘制图表</span><br><span class=\"line\">function drawLineChart(data) &#123;</span><br><span class=\"line\">        var xAxisArr = [],</span><br><span class=\"line\">             yAxisArr = [];</span><br><span class=\"line\"></span><br><span class=\"line\">        $.each(data,function(key,value)&#123;</span><br><span class=\"line\">            xAxisArr.push(key);</span><br><span class=\"line\">            yAxisArr.push(value);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        //计算x轴的步长 （当数据较多时，x轴会显示不下，所以需要间隔显示）</span><br><span class=\"line\">        var xLen = xAxisArr.length,</span><br><span class=\"line\">            maxLabelNum = 20, //x轴上最多显示的label个数，过多就会挤在一起</span><br><span class=\"line\">            step = Math.round(xLen / maxLabelNum) &lt; 1 ? 1 : Math.round(xLen / maxLabelNum);</span><br><span class=\"line\"></span><br><span class=\"line\">        chart = new Highcharts.Chart(&#123;</span><br><span class=\"line\">                chart: &#123;</span><br><span class=\"line\">                    renderTo: &#x27;J_Diagram&#x27;,  //图表将要被渲染到哪个dom节点中</span><br><span class=\"line\">                    type: &#x27;line&#x27;,  //线性显示</span><br><span class=\"line\">                    marginRight: 100,  //图表距离右侧的距离,即上图中 &quot;该月的流量&quot;的显示宽度</span><br><span class=\"line\">                    marginBottom: 50 //图表距离下方的距离,即上图中 x轴 label的显示高度, 刚开始label一直显示不全,有一半被隐藏了, 后来发现将这个值变大就可以了</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                title: &#123;</span><br><span class=\"line\">                    text: &#x27;&#x27; //图表的标题, 此为图1的设置,设为空串则不显示title, 如果不配置此项,此会显示默认的title,如图2所示</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                xAxis: &#123;</span><br><span class=\"line\">                    categories: xAxisArr, //x轴显示的label,如果不设置此项,则会显示默认的数字,即1,2,...n</span><br><span class=\"line\">                    tickInterval: step,  //x轴上显示点的间隔,默认和y轴上的点的个数相同, 但这样会造成x轴过于密集</span><br><span class=\"line\">                       labels: &#123;</span><br><span class=\"line\">                           style: &#123;</span><br><span class=\"line\">                               width: &#x27;auto&#x27;,</span><br><span class=\"line\">                               height: &#x27;auto&#x27;</span><br><span class=\"line\">                           &#125;,</span><br><span class=\"line\">                           rotation: -30, //x轴label逆时针旋转30度</span><br><span class=\"line\">                          align: &#x27;right&#x27; //,</span><br><span class=\"line\">                         // step: step //x轴上label标签的间隔,即隔多少个点显示一个label,注意如果只设置此项则x轴上的点不会变,还是会每个都显示</span><br><span class=\"line\">                                             //,当设置了tickInterval时此值可以不设, 会和tickInterval相同</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                yAxis: &#123;</span><br><span class=\"line\">                    title: &#123;</span><br><span class=\"line\">                        text: &#x27;单位：GB&#x27;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    plotLines: [&#123;</span><br><span class=\"line\">                        value: 0,</span><br><span class=\"line\">                        width: 1,</span><br><span class=\"line\">                        color: &#x27;#808080&#x27;</span><br><span class=\"line\">                    &#125;]</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                credits: &#123;//图表右下角的水印，默认是highcharts.com,将其设为空串可以取消水印</span><br><span class=\"line\">                        text: &#x27;&#x27;,</span><br><span class=\"line\">                        fontSize: &#x27;0&#x27;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                tooltip: &#123; //当鼠标移动图表上的某个点上时,显示的提示信息</span><br><span class=\"line\">                    formatter: function() &#123;</span><br><span class=\"line\">                            return &#x27;&lt;b&gt;&#x27;+ this.series.name +&#x27;&lt;/b&gt;&lt;br/&gt;&#x27;+ this.x +&#x27;: &#x27;+ this.y +&#x27;GB&#x27;;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                legend: &#123; //图上 &#x27;该月的流量&#x27; 那部分的位置配置</span><br><span class=\"line\">                    layout: &#x27;vertical&#x27;,</span><br><span class=\"line\">                    align: &#x27;right&#x27;,</span><br><span class=\"line\">                    verticalAlign: &#x27;top&#x27;,</span><br><span class=\"line\">                    x: 10,</span><br><span class=\"line\">                    y: 100,</span><br><span class=\"line\">                    borderWidth: 0</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                series: [&#123;</span><br><span class=\"line\">                    name: &#x27;该&#x27;+ (queryParams.showBy == &#x27;month&#x27; ? &#x27;月&#x27; : &#x27;日&#x27;) +&#x27;的流量&#x27;,  //图上 &#x27;该月的流量&#x27; 那部分的文字配置</span><br><span class=\"line\">                    data: yAxisArr</span><br><span class=\"line\">                &#125;],</span><br><span class=\"line\">                plotOptions: &#123;</span><br><span class=\"line\">                    series:&#123;</span><br><span class=\"line\">                        marker: &#123; //数据线上的点，默认不显示，当鼠标hover时才显示, 注意图1和图2中是enable设为true时的效果</span><br><span class=\"line\">                            symbol: &#x27;triangle-down&#x27;, //点的样式, 可选的值有&quot;circle&quot;, &quot;square&quot;, &quot;diamond&quot;, &quot;triangle&quot;和&quot;triangle-down&quot;,默认是circle</span><br><span class=\"line\">                            enabled: false,</span><br><span class=\"line\">                            states: &#123;</span><br><span class=\"line\">                                hover: &#123;</span><br><span class=\"line\">                                    enabled: true</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、多个数据源时\"><a href=\"#二、多个数据源时\" class=\"headerlink\" title=\"二、多个数据源时\"></a>二、多个数据源时</h2><p><img src=\"https://img-blog.csdn.net/20130712161924906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGluZmVuZ3Rpbmd5dTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"image\"></p>\n<p>如上图,有多个数据需要显示时,配置如下,不再一一讲解,请对应单一数据源的讲解和官网 API 自己理解:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function drawLineChart(title, data)&#123;</span><br><span class=\"line\">    var    colors = [&#x27;#4572A7&#x27;,&#x27;#AA4643&#x27;, &#x27;#89A54E&#x27;, &#x27;#80699B&#x27;, &#x27;#3D96AE&#x27;, &#x27;#DB843D&#x27;, &#x27;#92A8CD&#x27;, &#x27;#A47D7C&#x27;, &#x27;#B5CA92&#x27; ],</span><br><span class=\"line\">        xAxis = [],</span><br><span class=\"line\">        yAxis = [&#123;</span><br><span class=\"line\">            title: &#123;</span><br><span class=\"line\">                text: &#x27;PV&#x27;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            labels: &#123;</span><br><span class=\"line\">                formatter: function()&#123;</span><br><span class=\"line\">                    return this.value;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            title: &#123;</span><br><span class=\"line\">                text: &#x27;UV&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            labels: &#123;</span><br><span class=\"line\">                formatter: function()&#123;</span><br><span class=\"line\">                    return this.value;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            opposite: true</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        ableskyPvData = [],</span><br><span class=\"line\">        ableskyUvData = [],</span><br><span class=\"line\">        wwwPvData = [],</span><br><span class=\"line\">        wwwUvData = [],</span><br><span class=\"line\">        orgPvData = [],</span><br><span class=\"line\">        orgUvDate = [];</span><br><span class=\"line\">    for(var i=0, l=data.length ; i&lt;l; i++)&#123;</span><br><span class=\"line\">        var d = new Date();</span><br><span class=\"line\">        d.setTime(data[i].statsDate.time);</span><br><span class=\"line\">        xAxis.push(d.getFullYear() + &#x27;-&#x27; + (d.getMonth()+1) + &#x27;-&#x27; + d.getDate());</span><br><span class=\"line\">        ableskyPvData.push(data[i].totalPv);</span><br><span class=\"line\">        ableskyUvData.push(data[i].totalUv);</span><br><span class=\"line\">        wwwPvData.push(data[i].asDomainPv);</span><br><span class=\"line\">        wwwUvData.push(data[i].asDomainUv);</span><br><span class=\"line\">        orgPvData.push(data[i].orgDomainPv);</span><br><span class=\"line\">        orgUvDate.push(data[i].orgDomainUv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var series = [&#123;</span><br><span class=\"line\">        name: &#x27;总PV&#x27;,</span><br><span class=\"line\">        data: ableskyPvData,</span><br><span class=\"line\">        yAxis: 0</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: &#x27;总UV&#x27;,</span><br><span class=\"line\">        data: ableskyUvData,</span><br><span class=\"line\">        yAxis: 1</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: &#x27;AS域名PV&#x27;,</span><br><span class=\"line\">        data: wwwPvData,</span><br><span class=\"line\">        yAxis: 0</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: &#x27;AS域名UV&#x27;,</span><br><span class=\"line\">        data: wwwUvData,</span><br><span class=\"line\">        yAxis: 1</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: &#x27;机构域名PV&#x27;,</span><br><span class=\"line\">        data: orgPvData,</span><br><span class=\"line\">        yAxis: 0</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: &#x27;机构域名UV&#x27;,</span><br><span class=\"line\">        data: orgUvDate,</span><br><span class=\"line\">        yAxis: 1</span><br><span class=\"line\">    &#125; ];</span><br><span class=\"line\">    var chart = new Highcharts.Chart(&#123;</span><br><span class=\"line\">        chart: &#123;</span><br><span class=\"line\">            renderTo: &#x27;chartContainer&#x27;,</span><br><span class=\"line\">            type: &#x27;line&#x27;,</span><br><span class=\"line\">            zoomType: &#x27;x&#x27;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        title: &#123;</span><br><span class=\"line\">            text: title,</span><br><span class=\"line\">               style: &#123;</span><br><span class=\"line\">                font: &#x27;bold 16px Verdana, sans-serif&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        credits: &#123;</span><br><span class=\"line\">                text: &#x27;www.ablesky.com&#x27;,</span><br><span class=\"line\">                href: &#x27;http://www.ablesky.com&#x27;,</span><br><span class=\"line\">                fontSize: &#x27;16px&#x27;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        colors: colors,</span><br><span class=\"line\">        xAxis: &#123;</span><br><span class=\"line\">            categories: xAxis,</span><br><span class=\"line\">            labels: &#123;</span><br><span class=\"line\">                rotation: -30,</span><br><span class=\"line\">                step: xAxis.length &gt; 35? Math.round(xAxis.length / 20) : 1,</span><br><span class=\"line\">                align: &#x27;right&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: yAxis,</span><br><span class=\"line\">        tooltip: &#123;</span><br><span class=\"line\">            formatter: function() &#123;</span><br><span class=\"line\">                    return &#x27;&lt;b&gt;&#x27;+ this.series.name +&#x27;&lt;/b&gt;&lt;br/&gt;&#x27;+</span><br><span class=\"line\">                    this.x +&#x27;: &#x27;+ this.y;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        plotOptions: &#123;</span><br><span class=\"line\">            series:&#123;</span><br><span class=\"line\">                marker: &#123;</span><br><span class=\"line\">                    enabled: false,</span><br><span class=\"line\">                    states: &#123;</span><br><span class=\"line\">                        hover: &#123;</span><br><span class=\"line\">                            enabled: true</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        series: series</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>附 1: 图 1 图 2 数据格式:</strong></p>\n<p><img src=\"https://img-blog.csdn.net/20130712163426937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGluZmVuZ3Rpbmd5dTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"image\"></p>\n<p><strong>附 2: 图 3 数据格式</strong></p>\n<p><img src=\"https://img-blog.csdn.net/20130712163227296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGluZmVuZ3Rpbmd5dTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"image\"></p>\n<p>附 3:</p>\n<ul>\n<li>Highcharts 官网: <a href=\"http://www.highcharts.com/\">http://www.highcharts.com/</a></li>\n<li>Highcharts API 地址: <a href=\"http://api.highcharts.com/highcharts\">http://api.highcharts.com/highcharts</a></li>\n<li>Highcharts demo: <a href=\"http://www.highcharts.com/demo/\">http://www.highcharts.com/demo/</a></li>\n</ul>\n","categories":["webGL总结"],"tags":["webGL"]},{"title":"JavaScript——链表相关","url":"/2022/12/16/JavaScript%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/","content":"<h2 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>\n<p>例如：</p>\n<p>输入：a-&gt;b-&gt;c-&gt;d-&gt;e</p>\n<p>输出：a&lt;-b&lt;-c&lt;-d&lt;-e</p>\n<p>反转链表示意图如下，链表的最后一个元素 next 指向 null。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190408161404713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3OTU0NjQz,size_16,color_FFFFFF,t_70\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*function ListNode(x)&#123;</span><br><span class=\"line\">    this.val = x;</span><br><span class=\"line\">    this.next = null;</span><br><span class=\"line\">&#125;*/</span><br><span class=\"line\"></span><br><span class=\"line\">function isEmptyObject(obj) &#123;// 判断输入参数链表是否为空</span><br><span class=\"line\">  for (var name in obj) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function ReverseList(pHead) &#123;</span><br><span class=\"line\">    if (isEmptyObject(pHead)) &#123;// 调用链表是否为空函数</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pre = null;//链表的最后一个元素</span><br><span class=\"line\">    var next = null;//初始化next为null，下面再赋值</span><br><span class=\"line\">    while (pHead != null) &#123;//pHead移动，直至到链表最后一个元素，指向null，结束循环</span><br><span class=\"line\">        next = pHead.next;//pHead.next值先赋给next，以免覆盖，next移动</span><br><span class=\"line\">        pHead.next = pre;//改变pHead指向，给pHead.next赋值，指向null</span><br><span class=\"line\">        pre = pHead;//pre移动</span><br><span class=\"line\">        pHead = next;//pHead移动</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单链表是否有环\"><a href=\"#单链表是否有环\" class=\"headerlink\" title=\"单链表是否有环\"></a>单链表是否有环</h2><ol>\n<li>创建哈希表,不过会占⽤较⼤的空间,不是最佳⽅法.( 时间复杂度 O(n) )</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function judge(list)&#123;</span><br><span class=\"line\">  var set =new Set();</span><br><span class=\"line\">  while(list)&#123;</span><br><span class=\"line\">    if(set.has(list))&#123;</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set.add(list)</span><br><span class=\"line\">    list=list.next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给节点添加 visited 访问标记 (时间复杂度 O(n)), 不需要额外的空间</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function LinkedList()&#123;</span><br><span class=\"line\">  var Node=function()&#123;</span><br><span class=\"line\">    this.element=element;</span><br><span class=\"line\">    this.next=null;</span><br><span class=\"line\">    this.visited=0; //访问标记</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function judge(list)&#123;</span><br><span class=\"line\">  while(list)&#123;</span><br><span class=\"line\">    if(list.visited==1)&#123;</span><br><span class=\"line\">     return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    list.visited=1</span><br><span class=\"line\">    list=list.next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>快慢指针法,设定快指针 fast,慢指针 slow,每次循环快指针 fast 移动两个位置,慢指针移动⼀个位置<br>(时间复杂度 O(n)) 需要额外的空间</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function judge(list)&#123;</span><br><span class=\"line\">  var fast=list.next.next,</span><br><span class=\"line\">  slow=list.next;</span><br><span class=\"line\">  while(fast)&#123;</span><br><span class=\"line\">    if(fast===slow)&#123;</span><br><span class=\"line\">          return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fast=fast.next.next</span><br><span class=\"line\">    slow=slow.next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"JavaScript变量提升和函数提升","url":"/2022/10/24/JavaScript%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/","content":"<h2 id=\"1-变量提升\"><a href=\"#1-变量提升\" class=\"headerlink\" title=\"1. 变量提升\"></a>1. 变量提升</h2><p>通常 JS 引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。(注：当前流行的 JS 引擎大都对源码进行了编译，由于引擎的不同，编译形式也会有所差异，我们这里说的预编译和提升其实是抽象出来的、易于理解的概念)</p>\n<p>下面的代码中，我们在函数中声明了一个变量，不过这个变量声明是在 if 语句块中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    if (!foo) &#123;</span><br><span class=\"line\">        var foo = 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<p>运行代码，我们会发现 foo 的值是 5，初学者可能对此不甚理解，如果外层作用域也存在一个 foo 变量，就更加困惑了，该不会是打印外层作用域中的 foo 变量吧？答案是：不会，如果当前作用域中存在此变量声明，无论它在什么地方声明，引用此变量时就会在当前作用域中查找，不会去外层作用域了。</p>\n<p>那么至于说打印结果，这要提到预编译机制了，经过一次预编译之后，上面的代码逻辑如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 预编译之后</span><br><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!foo) &#123;</span><br><span class=\"line\">        foo = 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<p>是的，引擎将变量声明提升到了函数顶部，初始值为 undefined，自然，if 语句块就会被执行，foo 变量赋值为 5，下面的打印也就是预期的结果了。</p>\n<p>类似的，还有下面一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    var foo = foo || 5;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<p>foo || 5 这个表达式的结果是 5 而不是 3，虽然外层作用域有个 foo 变量，但函数内是不会去引用的，因为预编译之后的代码逻辑是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// 预编译之后</span><br><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo = foo || 5;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<p>如果当前作用域中声明了多个同名变量，那么根据我们的推断，它们的同一个标识符会被提升至作用域顶部，其他部分按顺序执行，比如下面的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        var foo = 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<p>由于 JavaScript 没有块作用域，只有全局作用域和函数作用域，所以预编译之后的代码逻辑为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 预编译之后</span><br><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\">    var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        foo = 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-函数提升\"><a href=\"#2-函数提升\" class=\"headerlink\" title=\"2. 函数提升\"></a>2. 函数提升</h2><p>相信大家对下面这段代码都不陌生，实际开发当中也很常见：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    foo(); // output: I am hoisted</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(&#x27;I am hoisted&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n\n<p>为什么函数可以在声明之前就可以调用，并且跟变量声明不同的是，它还能得到正确的结果，其实引擎是把函数声明整个地提升到了当前作用域的顶部，预编译之后的代码逻辑如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 预编译之后</span><br><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(&#x27;I am hoisted&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // output: I am hoisted</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n\n<p>相似的，如果在同一个作用域中存在多个同名函数声明，后面出现的将会覆盖前面的函数声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // output: 2</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n\n<p>对于函数，除了使用上面的函数声明，更多时候，我们会使用函数表达式，下面是函数声明和函数表达式的对比：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 函数声明</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(&#x27;function declaration&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匿名函数表达式</span><br><span class=\"line\">var foo = function() &#123;</span><br><span class=\"line\">    console.log(&#x27;anonymous function expression&#x27;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 具名函数表达式</span><br><span class=\"line\">var foo = function bar() &#123;</span><br><span class=\"line\">    console.log(&#x27;named function expression&#x27;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，匿名函数表达式，其实是将一个不带名字的函数声明赋值给了一个变量，而具名函数表达式，则是带名字的函数赋值给一个变量，需要注意到是，这个函数名只能在此函数内部使用。我们也看到了，其实函数表达式可以通过变量访问，所以也存在变量提升同样的效果。</p>\n<p>那么当函数声明遇到函数表达式时，会有什么样的结果呢，先看下面这段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    foo(); // 2</span><br><span class=\"line\"></span><br><span class=\"line\">    var foo = function() &#123;</span><br><span class=\"line\">        console.log(1);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // 1</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n\n<p>运行后我们会发现，输出的结果依次是 2 1 1，为什么会有这样的结果呢？</p>\n<p>因为 JavaScript 中的函数是一等公民，函数声明的优先级最高，会被提升至当前作用域最顶端，所以第一次调用时实际执行了下面定义的函数声明，然后第二次调用时，由于前面的函数表达式与之前的函数声明同名，故将其覆盖，以后的调用也将会打印同样的结果。上面的过程经过预编译之后，代码逻辑如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 预编译之后</span><br><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo = function foo() &#123;</span><br><span class=\"line\">        console.log(2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // 2</span><br><span class=\"line\"></span><br><span class=\"line\">    foo = function() &#123;</span><br><span class=\"line\">        console.log(1);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // 1</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n\n<p>我们也不难理解，下面的函数和变量重名时，会如何执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">    console.log(foo); // function foo() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo = 5;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br><span class=\"line\">console.log(foo);     // 3</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，函数声明被提升至作用域最顶端，然后被赋值为 5，而外层的变量并没有被覆盖，经过预编译之后，上面代码的逻辑是这样的：</p>\n<p>&#x2F;&#x2F; 预编译之后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">function hoistFunction() &#123;</span><br><span class=\"line\">   var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">   foo = function foo() &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   console.log(foo); // function foo() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   foo = 5;</span><br><span class=\"line\"></span><br><span class=\"line\">   console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br><span class=\"line\">console.log(foo);    // 3</span><br></pre></td></tr></table></figure>\n\n<p>所以，函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行，这一点要牢记。</p>\n<h2 id=\"3-为什么要进行提升\"><a href=\"#3-为什么要进行提升\" class=\"headerlink\" title=\"3. 为什么要进行提升\"></a>3. 为什么要进行提升</h2><p>关于为什么进行变量提升和函数提升，这个问题一直没有明确的答案，不过最近读到 Dmitry Soshnikov 之前的一篇文章时，多少了解了一些，下面是 Dmitry Soshnikov 早些年的 twitter，他也对这个问题十分感兴趣：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160927084830453-161910040.png\" alt=\"image\"></p>\n<p>然后 Jeremy Ashkenas 想让 Brendan Eich 聊聊这个话题：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160927085003891-1035941947.png\" alt=\"image\"></p>\n<p>最后，Brendan Eich 给出了答案：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160927085032422-1936451758.png\" alt=\"image\"></p>\n<p>大致的意思就是：由于第一代 JS 虚拟机中的抽象纰漏导致的，编译器将变量放到了栈槽内并编入索引，然后在（当前作用域的）入口处将变量名绑定到了栈槽内的变量。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。）</p>\n<p>然后，Dmitry Soshnikov 又提到了函数提升，他提到了相互递归（就是 A 函数内会调用到 B 函数，而 B 函数也会调用到 A 函数）：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160928082258078-892410645.png\" alt=\"image\"></p>\n<p>随后 Brendan Eich 很热心的又给出了答案：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160928082526438-697971926.png\" alt=\"image\"></p>\n<p>Brendan Eich 很确定的说，函数提升就是为了解决相互递归的问题，大体上可以解决像 ML 语言这样自下而上的顺序问题。</p>\n<p>这里简单阐述一下相互递归，下面两个函数分别在自己的函数体内调用了对方：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 验证偶数</span><br><span class=\"line\">function isEven(n) &#123;</span><br><span class=\"line\">    if (n === 0) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isOdd(n - 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(isEven(2)); // true</span><br><span class=\"line\"></span><br><span class=\"line\">// 验证奇数</span><br><span class=\"line\">function isOdd(n) &#123;</span><br><span class=\"line\">    if (n === 0) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isEven(n - 1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有函数提升，而是按照自下而上的顺序，当 isEven 函数被调用时，isOdd 函数还未声明，所以当 isEven 内部无法调用 isOdd 函数。所以 Brendan Eich 设计了函数提升这一形式，将函数提升至当前作用域的顶部：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 验证偶数</span><br><span class=\"line\">function isEven(n) &#123;</span><br><span class=\"line\">    if (n === 0) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isOdd(n - 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 验证奇数</span><br><span class=\"line\">function isOdd(n) &#123;</span><br><span class=\"line\">    if (n === 0) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isEven(n - 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(isEven(2)); // true</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，问题就迎刃而解了。</p>\n<p>最后，Brendan Eich 还对变量提升和函数提升做了总结：<br><img src=\"https://images2015.cnblogs.com/blog/317749/201609/317749-20160928084223719-96754371.png\" alt=\"image\"><br>大概是说，变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。</p>\n<p>至此，关于变量提升和函数提升，相信大家已经明白其中的真相了。</p>\n<h2 id=\"4-最佳实践\"><a href=\"#4-最佳实践\" class=\"headerlink\" title=\"4. 最佳实践\"></a>4. 最佳实践</h2><p>理解变量提升和函数提升可以使我们更了解这门语言，更好地驾驭它，但是在开发中，我们不应该使用这些技巧，而是要规范我们的代码，做到可读性和可维护性。</p>\n<p>具体的做法是：无论变量还是函数，都必须先声明后使用。下面举了简单的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var name = &#x27;Scott&#x27;;</span><br><span class=\"line\">var sayHello = function(guest) &#123;</span><br><span class=\"line\">    console.log(name, &#x27;says hello to&#x27;, guest);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var i;</span><br><span class=\"line\">var guest;</span><br><span class=\"line\">var guests = [&#x27;John&#x27;, &#x27;Tom&#x27;, &#x27;Jack&#x27;];</span><br><span class=\"line\"></span><br><span class=\"line\">for (i = 0; i &lt; guests.length; i++) &#123;</span><br><span class=\"line\">    guest = guests[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    // do something on guest</span><br><span class=\"line\"></span><br><span class=\"line\">    sayHello(guest);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果对于新的项目，可以使用 let 替换 var，会变得更可靠，可维护性更高：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let name = &#x27;Scott&#x27;;</span><br><span class=\"line\">let sayHello = function(guest) &#123;</span><br><span class=\"line\">    console.log(name, &#x27;says hello to&#x27;, guest);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let guests = [&#x27;John&#x27;, &#x27;Tom&#x27;, &#x27;Jack&#x27;];</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; guests.length; i++) &#123;</span><br><span class=\"line\">    let guest = guests[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    // do something on guest</span><br><span class=\"line\"></span><br><span class=\"line\">    sayHello(guest);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得一提的是，ES6 中的 class 声明也存在提升，不过它和 let、const 一样，被约束和限制了，其规定，如果再声明位置之前引用，则是不合法的，会抛出一个异常。</p>\n<p>所以，无论是早期的代码，还是 ES6 中的代码，我们都需要遵循一点，先声明，后使用。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"Linux常用命令大全","url":"/2022/12/16/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","content":"<h2 id=\"1．Linux-管理文件和目录的命令\"><a href=\"#1．Linux-管理文件和目录的命令\" class=\"headerlink\" title=\"1．Linux 管理文件和目录的命令\"></a>1．Linux 管理文件和目录的命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pwd</td>\n<td>显示当前目录</td>\n<td>ls</td>\n<td>查看目录下的内容</td>\n</tr>\n<tr>\n<td>cd</td>\n<td>改变所在目录</td>\n<td>cat</td>\n<td>显示文件的内容</td>\n</tr>\n<tr>\n<td>grep</td>\n<td>在文件中查找某字符</td>\n<td>cp</td>\n<td>复制文件</td>\n</tr>\n<tr>\n<td>touch</td>\n<td>创建文件</td>\n<td>mv</td>\n<td>移动文件</td>\n</tr>\n<tr>\n<td>rm</td>\n<td>删除文件</td>\n<td>rmdir</td>\n<td>删除目录</td>\n</tr>\n<tr>\n<td>vi</td>\n<td>编辑文件</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"1-1-pwd-命令\"><a href=\"#1-1-pwd-命令\" class=\"headerlink\" title=\"1.1 pwd 命令\"></a>1.1 pwd 命令</h3><p>该命令的英文解释为 print working directory(打印工作目录)。输入 pwd 命令，Linux 会输出当前目录。</p>\n<h3 id=\"1-2-cd-命令\"><a href=\"#1-2-cd-命令\" class=\"headerlink\" title=\"1.2 cd 命令\"></a>1.2 cd 命令</h3><p>cd 命令用来改变所在目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd /      转到根目录中</span><br><span class=\"line\">cd ~     转到/home/user用户目录下</span><br><span class=\"line\">cd /usr 转到根目录下的usr目录中-------------绝对路径</span><br><span class=\"line\">cd test 转到当前目录下的test子目录中-------相对路径</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-ls-命令\"><a href=\"#1-3-ls-命令\" class=\"headerlink\" title=\"1.3 ls 命令\"></a>1.3 ls 命令</h3><p>ls 命令用来查看目录的内容。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>列举目录中的全部文件，包括隐藏文件</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>列举目录中的细节，包括权限、所有者、组群、大小、创建日期、文件是否是链接等</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>列举的文件显示文件类型</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>逆向，从后向前地列举目录中内容</td>\n</tr>\n<tr>\n<td>-R</td>\n<td>递归，该选项递归地列举当前目录下所有子目录内的内容</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>大小，按文件大小排序</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>以人类可读的方式显示文件的大小，如用 K、M、G 作单位</td>\n</tr>\n<tr>\n<td>ls -l examples.doc</td>\n<td>列举文件 examples.doc 的所有信息</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-4-cat-命令\"><a href=\"#1-4-cat-命令\" class=\"headerlink\" title=\"1.4 cat 命令\"></a>1.4 cat 命令</h3><p>cat 命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。</p>\n<p>cat snow.txt 该命令显示文件 snow.txt 的内容，ctrl+D 退出 cat。</p>\n<h3 id=\"1-5-grep-命令\"><a href=\"#1-5-grep-命令\" class=\"headerlink\" title=\"1.5 grep 命令\"></a>1.5 grep 命令</h3><p>grep 命令的最大功能是在一堆文件中查找一个特定的字符串。</p>\n<p>grep money test.txt</p>\n<p>以上命令在 test.txt 中查找 money 这个字符串，grep 查找是区分大小写的。</p>\n<h3 id=\"1-6-touch-命令\"><a href=\"#1-6-touch-命令\" class=\"headerlink\" title=\"1.6 touch 命令\"></a>1.6 touch 命令</h3><p>touch 命令用来创建新文件，他可以创建一个空白的文件，可以在其中添加文本和数据。</p>\n<p>touch newfile 该命令创建一个名为 newfile 的空白文件。</p>\n<h3 id=\"1-7-cp-命令\"><a href=\"#1-7-cp-命令\" class=\"headerlink\" title=\"1.7 cp 命令\"></a>1.7 cp 命令</h3><p>cp 命令用来拷贝文件，要复制文件，输入命令：</p>\n<p>cp <source filename> <targetfilename></p>\n<p>cp t.txt Document&#x2F;t 该命令将把文件 t.txt 复制到 Document 目录下，并命名为 t。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-i</td>\n<td>互动：如果文件将覆盖目标中的文件，他会提示确认</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归：这个选项会复制整个目录树、子目录以及其他</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>详细：显示文件的复制进度</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-8-mv-命令\"><a href=\"#1-8-mv-命令\" class=\"headerlink\" title=\"1.8 mv 命令\"></a>1.8 mv 命令</h3><p>mv 命令用来移动文件。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-i</td>\n<td>互动：如果选择的文件会覆盖目标中的文件，他会提示确认</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>强制：它会超越互动模式，不提示地移动文件，属于很危险的选项</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>详细：显示文件的移动进度</td>\n</tr>\n</tbody></table>\n<p>mv t.txt Document 把文件 t.txt 移动到目录 Document 中。</p>\n<h3 id=\"1-9-rm-命令\"><a href=\"#1-9-rm-命令\" class=\"headerlink\" title=\"1.9 rm 命令\"></a>1.9 rm 命令</h3><p>rm 命令用来删除文件。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-i</td>\n<td>互动：提示确认删除</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>强制：代替互动模式，不提示确认删除</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>详细：显示文件的删除进度</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归：将删除某个目录以及其中所有的文件和子目录</td>\n</tr>\n</tbody></table>\n<p>rm t.txt 该命令删除文件 t.txt</p>\n<h3 id=\"1-10-rmdir-命令\"><a href=\"#1-10-rmdir-命令\" class=\"headerlink\" title=\"1.10 rmdir 命令\"></a>1.10 rmdir 命令</h3><p>rmdir 命令用来删除目录。</p>\n<h3 id=\"1-11-vi-编辑文件（补充）\"><a href=\"#1-11-vi-编辑文件（补充）\" class=\"headerlink\" title=\"1.11 vi 编辑文件（补充）\"></a>1.11 vi 编辑文件（补充）</h3><p>vi 命令是 UNIX 操作系统和类 UNIX 操作系统中最通用的全屏幕纯文本编辑器。Linux 中的 vi 编辑器叫 vim，它是 vi 的增强版（vi Improved），与 vi 编辑器完全兼容，而且实现了很多增强功能。</p>\n<p><strong>进入 vi 的命令</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi filename :打开或新建文件,并将光标置于第一行首</span><br><span class=\"line\">vi n filename ：打开文件,并将光标置于第n行首</span><br><span class=\"line\">vi /pattern filename：打开文件,并将光标置于第一个与pattern匹配的串处</span><br><span class=\"line\">vi -r filename ：在上次正用vi编辑时发生系统崩溃,恢复filename</span><br><span class=\"line\">vi filename....filename ：打开多个文件,依次进行编辑</span><br></pre></td></tr></table></figure>\n\n<p><strong>屏幕翻滚类命令</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Ctrl u：向文件首翻半屏</span><br><span class=\"line\">Ctrl d：向文件尾翻半屏</span><br><span class=\"line\">Ctrl f：向文件尾翻一屏</span><br><span class=\"line\">Ctrl＋b；向文件首翻一屏</span><br><span class=\"line\">nz：将第n行滚至屏幕顶部,不指定n时将当前行滚至屏幕顶部.</span><br></pre></td></tr></table></figure>\n\n<p><strong>插入文本类命令</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">i ：在光标前</span><br><span class=\"line\">I ：在当前行首</span><br><span class=\"line\">a：光标后</span><br><span class=\"line\">A：在当前行尾</span><br><span class=\"line\">o：在当前行之下新开一行</span><br><span class=\"line\">O：在当前行之上新开一行</span><br><span class=\"line\">r：替换当前字符</span><br><span class=\"line\">R：替换当前字符及其后的字符,直至按ESC键</span><br><span class=\"line\">s：从当前光标位置处开始,以输入的文本替代指定数目的字符</span><br></pre></td></tr></table></figure>\n\n<p><strong>保存命令</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">按ESC键 跳到命令模式，然后：</span><br><span class=\"line\"></span><br><span class=\"line\">:w   保存文件但不退出vi</span><br><span class=\"line\">:w file 将修改另外保存到file中，不退出vi</span><br><span class=\"line\">:w!   强制保存，不推出vi</span><br><span class=\"line\">:wq  保存文件并退出vi</span><br><span class=\"line\">:wq! 强制保存文件，并退出vi</span><br><span class=\"line\">:q  不保存文件，退出vi</span><br><span class=\"line\">:q! 不保存文件，强制退出vi</span><br><span class=\"line\">:e! 放弃所有修改，从上次保存文件开始再编辑</span><br></pre></td></tr></table></figure>\n\n<p>之后，回车，ok!</p>\n<h2 id=\"2-有关磁盘空间的命令\"><a href=\"#2-有关磁盘空间的命令\" class=\"headerlink\" title=\"2.有关磁盘空间的命令\"></a>2.有关磁盘空间的命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mount</td>\n<td>挂载文件系统</td>\n</tr>\n<tr>\n<td>umount</td>\n<td>卸载已挂载上的文件系统</td>\n</tr>\n<tr>\n<td>df</td>\n<td>检查各个硬盘分区和已挂上来的文件系统的磁盘空间</td>\n</tr>\n<tr>\n<td>du</td>\n<td>显示文件目录和大小</td>\n</tr>\n<tr>\n<td>fsck</td>\n<td>主要是检查和修复 Linux 文件系统</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-1-mount-命令\"><a href=\"#2-1-mount-命令\" class=\"headerlink\" title=\"2.1 mount 命令\"></a>2.1 mount 命令</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mount命令的功能是挂载文件系统，可以挂载硬盘、光盘、软盘，也可以挂载NFS网络文件系统。这个命令的标准用法如下：</span><br><span class=\"line\"></span><br><span class=\"line\">mount –t 设备类型存放目录</span><br><span class=\"line\">mount IP地址：/所提供的目录存放目录</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>(无)</td>\n<td>不加任何参数，直接输入命令可以显示已挂载的文件系统和目录</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>挂上&#x2F;etc&#x2F;fstab 下的全部文件系统</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>指定所挂上来的文件系统的名称，所有系统支持的文件系统，这个信息可以在&#x2F;proc&#x2F;filesystems 这个文件里看到</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>挂上文件系统，但是不把文件系统的数据写入&#x2F;etc&#x2F;mtlab 这个文件</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>将文件系统设为可读写</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>挂上来的文件系统设为只读</td>\n</tr>\n</tbody></table>\n<p>在目录&#x2F;mnt 下，挂上 iso9660 文件系统。输入命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mount –t iso9660 /dev/hdb /cdrom</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-umount-命令\"><a href=\"#2-2-umount-命令\" class=\"headerlink\" title=\"2.2 umount 命令\"></a>2.2 umount 命令</h3><p>umount 命令的功能是卸载已挂上的文件系统，在关闭系统前应该把所有挂载上的文件系统卸载。这个命令和 mount 命令是相对的。用法：</p>\n<p>umount 已挂上的目录或设备</p>\n<p>卸载已挂上的&#x2F;cdrom 目录，输入命令：</p>\n<p>umount &#x2F;cdrom</p>\n<p>卸载已挂上的某个分区，输入命令：</p>\n<p>umount &#x2F;dev&#x2F;hdb1</p>\n<h3 id=\"2-3-df-命令\"><a href=\"#2-3-df-命令\" class=\"headerlink\" title=\"2.3 df 命令\"></a>2.3 df 命令</h3><p>df 命令用来检查硬盘分区和已挂载的文件系统的磁盘空间，也就是说，检查硬盘的使用量。标准用法如下：</p>\n<p>df [-选项]</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>把全部的文件系统和各分区的硬盘使用情形列出来，包括 0 区块的，例如&#x2F;proc 这个文件系统</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>列出 I-nodes 的使用量</td>\n</tr>\n<tr>\n<td>-k</td>\n<td>把各分区的大小和挂上来的文件分区的大小用 k 表示</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>列出某一文件系统的所有分区磁盘空间使用量</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>列出不是某一文件系统的所有分区磁盘空间使用量，和-t 选项相反</td>\n</tr>\n<tr>\n<td>-T</td>\n<td>列出每个分区所属文件系统的名称</td>\n</tr>\n</tbody></table>\n<p>例如，要列出全部文件系统和各分区的磁盘使用情况，输入命令：</p>\n<p>df –a</p>\n<h3 id=\"2-4-du-命令\"><a href=\"#2-4-du-命令\" class=\"headerlink\" title=\"2.4 du 命令\"></a>2.4 du 命令</h3><p>du 命令的功能是用于显示文件目录或大小。标准用法：</p>\n<p>du [-选项]</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>显示全部目录及其次目录下的每个文件所占的磁盘空间</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>显示目录和文件的大小，以 B 为单位</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>最后再加上一个总计</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>以 KB、MB、GB 为单位，提高信息可读性</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>只列出各文件大小的总和</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>只计算属于同一文件系统的文件</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-5-fsck-命令\"><a href=\"#2-5-fsck-命令\" class=\"headerlink\" title=\"2.5 fsck 命令\"></a>2.5 fsck 命令</h3><p>fsck 命令的功能是检查和修复 Linux 文件系统，这个命令最好在没有人或是没有分区挂上来时使用，其实每次开机系统都会做一次检查，看是否有坏轨或数据流失的现象。用法：</p>\n<p>fsck (-选项) 分区名称</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>自动修复文件系统，不询问任何问题，比较危险</td>\n</tr>\n<tr>\n<td>-A</td>\n<td>依照&#x2F;etc&#x2F;fstab 配置文件的内容，检查该文件内所列全部文件系统。若没有附加参数”-P”，则会先检查&#x2F;目录的文件系统，而不会同时检查所有文件系统</td>\n</tr>\n<tr>\n<td>-R</td>\n<td>采取互动方式，在修复时询问问题，让用户确认并决定处理方式</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>依次检查作业而不是同时执行。当依次指定多个文件系统且采用互动的方式进行检查时，请使用此参数以便顺序执行，否则 fsck 可能会同时询问数个问题，让人不知所措</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示命令执行的过程</td>\n</tr>\n<tr>\n<td>-T</td>\n<td>指定要检查的文件系统的类型</td>\n</tr>\n<tr>\n<td>-N</td>\n<td>不是真正执行指令，仅列出实际执行时会进行的动作</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-文件备份和压缩命令\"><a href=\"#3-文件备份和压缩命令\" class=\"headerlink\" title=\"3.文件备份和压缩命令\"></a>3.文件备份和压缩命令</h2><p>在 Linux 中，常用的文件压缩工具有 gzip、bzip2、zip。bzip2 是最理想的压缩工具，它提供了最大限度的压缩。zip 兼容性好，Windows 也支持。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bzip2&#x2F;bunzip2</td>\n<td>扩展名为 bz2 的压缩&#x2F;解压缩工具</td>\n</tr>\n<tr>\n<td>gzip&#x2F;gunzip</td>\n<td>扩展名为 gz 的压缩&#x2F;解压缩工具</td>\n</tr>\n<tr>\n<td>zip&#x2F;unzip</td>\n<td>扩展名为 zip 的压缩&#x2F;解压缩工具</td>\n</tr>\n<tr>\n<td>tar</td>\n<td>创建备份和归档</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-1-bzip2-命令\"><a href=\"#3-1-bzip2-命令\" class=\"headerlink\" title=\"3.1 bzip2 命令\"></a>3.1 bzip2 命令</h3><p>要使用 bzip2 来压缩文件，在 shell 提示下输入命令：</p>\n<p>bzip2 filename</p>\n<p>文件即会被压缩，并被保存为 filename.bz2。</p>\n<p>要解压缩文件，输入命令：</p>\n<p>bunzip2 filename.bz2</p>\n<p>filename.bz2 会被删除，而以 filename 代替。</p>\n<p>bzip2 filename.bz2 file1 file2 file3&#x2F;usr&#x2F;work&#x2F;school</p>\n<p>上面的命令把 file1、file2、file3 以及&#x2F;usr&#x2F;work&#x2F;school 目录中的内容压缩起来放入 filename.bz2。</p>\n<h3 id=\"3-2-gzip-命令\"><a href=\"#3-2-gzip-命令\" class=\"headerlink\" title=\"3.2 gzip 命令\"></a>3.2 gzip 命令</h3><p>要使用 gzip 来压缩文件，输入命令：</p>\n<p>gzip filename</p>\n<p>文件即会被压缩，并被保存为 filename.gz。</p>\n<p>要解压缩文件，输入命令：</p>\n<p>gunzip filename.gz</p>\n<p>filename.gz 会被删除，而以 filename 代替。</p>\n<p>gzip -r filename.gz file1 file2 file3&#x2F;usr&#x2F;work&#x2F;school</p>\n<p>上面的命令把 file1、file2、file3 以及&#x2F;usr&#x2F;work&#x2F;school 目录中的内容压缩起来放入 filename.gz。</p>\n<h3 id=\"3-3-zip-命令\"><a href=\"#3-3-zip-命令\" class=\"headerlink\" title=\"3.3 zip 命令\"></a>3.3 zip 命令</h3><p>zip 命令的使用方法同 gzip。</p>\n<h3 id=\"3-4-tar-命令\"><a href=\"#3-4-tar-命令\" class=\"headerlink\" title=\"3.4 tar 命令\"></a>3.4 tar 命令</h3><p>tar 命令最早是用来做磁带备份的，但是由于硬盘容量越来越大，因此现在主要用这个命令来备份所有的文件。tar 这个命令把大量的文件和目录打包成一个文件。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-c</td>\n<td>创建一个新归档</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>当与-c 选项一起使用时，创建的 tar 文件使用该选项指定的文件名；当与-x 选项一起使用时，则解除该选项指定的归档</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>显示包括在 tar 文件中的文件列表</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示文件的归档进度</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>从归档中抽取文件</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>使用 gzip 压缩 tar 文件</td>\n</tr>\n<tr>\n<td>-j</td>\n<td>使用 bzip2 压缩 tar 文件</td>\n</tr>\n</tbody></table>\n<p>要创建一个 tar 文件，输入命令：</p>\n<p>tar –cvf filename.tar directory&#x2F;file&#x2F;home&#x2F;mine</p>\n<p>上面的命令将 directory&#x2F;file、&#x2F;home&#x2F;mine 放入归档文件中。</p>\n<p>要列出 tar 文件的内容，输入命令：</p>\n<p>tar –tvf filename.tar</p>\n<p>要抽取 tar 文件的命令，输入命令：</p>\n<p>tar –xvf filename.tar</p>\n<p>这个命令不会删除 tar 文件，但会把解除归档的内容复制到当前工作目录下，并保留归档文件所使用的任何目录结构。</p>\n<p>请记住，tar 默认不压缩文件。要创建一个使用 tar 和 bzip2 来归档压缩的文件，使用-j 选项：</p>\n<p>tar –cjvf filename.tbz file</p>\n<p>如果使用 bunzip2 命令解压 filename.tbz 文件，则 filename.tbz 会被删除，以 filename.tar 代替。</p>\n<p>要扩展并解除归档 bzip tar 文件，输入命令：</p>\n<p>tar –xjvf filename.tbz</p>\n<p>要创建一个用 tar 和 gzip 归档并压缩的文件，使用-z 选项：</p>\n<p>tar –czvf filename.tgz file</p>\n<p>如果使用 gunzip 命令解压 filename.tgz 文件，则 filename.tgz 会被删除，以 filename.tar 代替。</p>\n<h2 id=\"4-有关关机和查看系统信息的命令\"><a href=\"#4-有关关机和查看系统信息的命令\" class=\"headerlink\" title=\"4.有关关机和查看系统信息的命令\"></a>4.有关关机和查看系统信息的命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>shutdown</td>\n<td>正常关机</td>\n</tr>\n<tr>\n<td>reboot</td>\n<td>重启计算机</td>\n</tr>\n<tr>\n<td>ps</td>\n<td>查看目前程序执行的情况</td>\n</tr>\n<tr>\n<td>top</td>\n<td>查看目前程序执行的情景和内存使用的情况</td>\n</tr>\n<tr>\n<td>kill</td>\n<td>终止一个进程</td>\n</tr>\n<tr>\n<td>date</td>\n<td>更改或查看目前日期</td>\n</tr>\n<tr>\n<td>cal</td>\n<td>显示月历及年历</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-1-shutdown-命令\"><a href=\"#4-1-shutdown-命令\" class=\"headerlink\" title=\"4.1 shutdown 命令\"></a>4.1 shutdown 命令</h3><p>要使用这个命令必须保证是根用户，否则使用 su 命令改变为根用户。命令格式如下：</p>\n<p>shutdown –(选项)</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-k</td>\n<td>不是真正的关机，只是发出警告命令</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>关机后重启（这个用的最多）</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>在规定的时间内关机</td>\n</tr>\n</tbody></table>\n<p>加入要在 2min 内关机，输入命令：</p>\n<p>shutdown –t 2</p>\n<p>如果是关机后重启，输入命令：</p>\n<p>shutdown –r</p>\n<h3 id=\"4-2-reboot-命令\"><a href=\"#4-2-reboot-命令\" class=\"headerlink\" title=\"4.2 reboot 命令\"></a>4.2 reboot 命令</h3><p>这个命令也是一个关机命令，只有输入，不加任何参数，系统会以最快的速度关机，且不将内存或缓冲区里的东西写回硬盘。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-d</td>\n<td>不把记录写到&#x2F;var&#x2F;log&#x2F;wtmp 档案里(-n 这个参数包含了-d)</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>不把记录写到&#x2F;var&#x2F;log&#x2F;wtmp 档案里(-n 这个参数包含了-d)</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>在重开机前不做将记忆体资料写回硬盘</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>并不会真的重开机，只是把记录写到&#x2F;var&#x2F;log&#x2F;wtmp 档案里</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-3-ps-命令\"><a href=\"#4-3-ps-命令\" class=\"headerlink\" title=\"4.3 ps 命令\"></a>4.3 ps 命令</h3><p>ps 命令用来查看在计算机系统中有哪些程序正在执行，及其执行的情况。这是一个相当强大的命令，可以用它来找出所有的 process id 和名称。另外，ps 命令也可以用来列出所有程序占用内存的情况。用法如下：</p>\n<p>ps –(选项)</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-l</td>\n<td>用长格式列出</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>列出使用者的名称和使用时间</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>列出内存分布的情况</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>只列出正在执行的前台程序，不列出其他信息</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>列出所有程序，包括那些没有终端机的程序</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-4-top-命令\"><a href=\"#4-4-top-命令\" class=\"headerlink\" title=\"4.4 top 命令\"></a>4.4 top 命令</h3><p>top 命令可以查看目前程序的执行情景和内存使用。它和 ps 类似，不过，它会几秒钟更新一次系统状态，方便追踪。要离开这个程序，按 Ctrl+C 键就可以了。</p>\n<h3 id=\"4-5-kill-命令\"><a href=\"#4-5-kill-命令\" class=\"headerlink\" title=\"4.5 kill 命令\"></a>4.5 kill 命令</h3><p>kill 命令用来终止一个正在执行中的进程。如果一个程序执行过程中失败了，可以把这个程序终止，避免留在内存中占用系统资源。不过，它的实际意义是送一个信号给这个正在执行的程序，叫它自杀。可以送很多信号给这些程序，也可以让他们收到信号后做很多事情。标准用法：</p>\n<p>kill –(选项) pid</p>\n<p>在执行 kill 命令前。可以先用 ps 命令查一下某宕掉程序的 pid，然后使用 kill 除去某个程序。例如，终止 pid 为 90 的程序：</p>\n<p>kill 90</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>选项</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-l</td>\n<td>列出所有可用的信号名称</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>印出 pid 并不发送信号</td>\n</tr>\n<tr>\n<td>-signal</td>\n<td>其中可用的讯号有 HUP (1), KILL (9), TERM (15), 分别代表着重跑, 砍掉, 结束</td>\n</tr>\n</tbody></table>\n<p>将 pid 为 323 的行程砍掉 (kill) ：</p>\n<p>kill -9 323</p>\n<p>将 pid 为 456 的行程重跑 (restart) ：</p>\n<p>kill -HUP 456</p>\n<h3 id=\"4-6-date-命令\"><a href=\"#4-6-date-命令\" class=\"headerlink\" title=\"4.6 date 命令\"></a>4.6 date 命令</h3><p>date 命令用来显示、设定和修改现在的时间和日期。标准用法：</p>\n<p>date –(选项) 显示时间格式(以+号开头，后加格式)<br>date 设定时间格式</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-u</td>\n<td>使用格林尼治时间</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>最后一次修改文件的时间</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>设置时间</td>\n</tr>\n</tbody></table>\n<p>常用的几种时间格式如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%a</td>\n<td>星期几的简称，例如一、二、三</td>\n</tr>\n<tr>\n<td>%A</td>\n<td>星期几的全名，例如星期一、星期二</td>\n</tr>\n<tr>\n<td>%D</td>\n<td>日期(mm&#x2F;dd&#x2F;yy 格式)</td>\n</tr>\n<tr>\n<td>%T</td>\n<td>显示时间格式，24 小时制(hh:mm:ss)</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>显示日期的格式(mm&#x2F;dd&#x2F;yy)</td>\n</tr>\n<tr>\n<td>%y</td>\n<td>年的最后两个数字</td>\n</tr>\n<tr>\n<td>%Y</td>\n<td>年(如 2007、2008)</td>\n</tr>\n<tr>\n<td>%r</td>\n<td>时间(hh:mm:ss 上午或下午)</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>显示上午或下午</td>\n</tr>\n</tbody></table>\n<p>如果输入命令：</p>\n<p>date “+%x,%r”</p>\n<p>系统返回如下信息：</p>\n<p>2010 年 3 月 26 日，下午 18 时 06 分 49 秒</p>\n<h3 id=\"4-7-cal-命令\"><a href=\"#4-7-cal-命令\" class=\"headerlink\" title=\"4.7 cal 命令\"></a>4.7 cal 命令</h3><p>cal 命令有两种功能：显示月历以及年历。</p>\n<p>直接输入 cal 命令则系统会显示目前月份的月历。</p>\n<p>若要显示一整年的年历，可以在 cal 命令后加 4 位数的公元年份。例如要显示 2008 年的年历，必须输入：</p>\n<p>cal 2008</p>\n<p>若输入 cal 08 ，则最显示公元 8 年的年历。</p>\n<p>若只需要查看某一年份中某一月份的月历，可以输入：cal 月份公元年份。例如输入：”cal 12 2004”。</p>\n<h2 id=\"5-管理使用者和设立权限的命令\"><a href=\"#5-管理使用者和设立权限的命令\" class=\"headerlink\" title=\"5.管理使用者和设立权限的命令\"></a>5.管理使用者和设立权限的命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>chmod</td>\n<td>用来改变权限</td>\n<td>useradd</td>\n<td>用来增加用户</td>\n</tr>\n<tr>\n<td>su</td>\n<td>用来修改用户</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"5-1-chmod-命令\"><a href=\"#5-1-chmod-命令\" class=\"headerlink\" title=\"5.1 chmod 命令\"></a>5.1 chmod 命令</h3><p>chmod 命令用来改变许可权限。读取、写入和执行是许可权限中的三个主要设置。因为用户在他们的账号被创建时就被编入一个组群，所以还可以指定那些组群可以读取、写入或执行某一文件。其中：</p>\n<p>r—文件可以被读取<br>w—文件可以被写入<br>x—文件可以被执行，如果文件是程序的话</p>\n<p>可以使用带有-l 的 ls 命令来仔细查看一个文件的许多细节。</p>\n<p>chmod 命令用来设定文件的权限。标准用法：</p>\n<p>chmod 文件的使用者(u,g,o,a)增减(+,-,&#x3D;)权限名称(r,w,x) 文件</p>\n<table>\n<thead>\n<tr>\n<th>文件的使用者</th>\n<th>说明</th>\n<th>权限</th>\n<th>说明</th>\n<th>增减</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u</td>\n<td>拥有文件的用户</td>\n<td>r</td>\n<td>读取权</td>\n<td>+</td>\n<td>添加权限</td>\n</tr>\n<tr>\n<td>g</td>\n<td>所有者所在的组群</td>\n<td>w</td>\n<td>写入权</td>\n<td>-</td>\n<td>删除权限</td>\n</tr>\n<tr>\n<td>o</td>\n<td>其他人</td>\n<td>x</td>\n<td>执行权</td>\n<td>&#x3D;</td>\n<td>是它称为唯一权限</td>\n</tr>\n<tr>\n<td>a</td>\n<td>全部(u,g 和 o)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>删除某一文件的所有权限，输入命令：</p>\n<p>chmod a-rwx test.txt</p>\n<p>为文件所有者添加权限，输入命令：</p>\n<p>chmod u+rwx test</p>\n<p>还可以用数字表示权限：4——读取，2——写入，1——执行。下面的两个命令等价：</p>\n<p>chmod 751 filename<br>chmod u+rwx,g&#x3D;rx,0&#x3D;x filename</p>\n<h3 id=\"5-2-su-命令\"><a href=\"#5-2-su-命令\" class=\"headerlink\" title=\"5.2 su 命令\"></a>5.2 su 命令</h3><p>su 命令用来修改用户。这个命令非常重要，它可以让一个普通的使用者拥有超级用户或其他使用者的权限。不过，这个命令必须具有超级用户或其他使用者的口令才能成为超级用户或其他使用者。如果要离开，可以输入 exit。标准用法：</p>\n<p>su 用户名 (如果没有输入用户名则预设为 root)</p>\n<p>举例说明，假设当前用户 user01，想要转变为 user02，则输入命令：</p>\n<p>su user02</p>\n<p>系统返回：</p>\n<p>password：</p>\n<p>此时，输入 user02 的指令，就会变为 user02。</p>\n<h3 id=\"5-3-useradd-命令\"><a href=\"#5-3-useradd-命令\" class=\"headerlink\" title=\"5.3 useradd 命令\"></a>5.3 useradd 命令</h3><p>useradd 命令用来增加用户，只有根用户才能增加用户。如果没有登录为根用户，输入 su，再输入根口令即可。</p>\n<p>要增加用户，输入命令：</p>\n<p>useradd 用户名</p>\n<p>然后，根据提示为新用户输入一个口令即可。</p>\n<h2 id=\"6-线上查询的命令\"><a href=\"#6-线上查询的命令\" class=\"headerlink\" title=\"6.线上查询的命令\"></a>6.线上查询的命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>man</td>\n<td>查询和解释一个命令的使用方法，以及这个命令的说明事项</td>\n</tr>\n<tr>\n<td>locate</td>\n<td>定位文件和目录</td>\n</tr>\n<tr>\n<td>whatis</td>\n<td>寻找某个命令的含义</td>\n</tr>\n</tbody></table>\n<h3 id=\"6-1-man-命令\"><a href=\"#6-1-man-命令\" class=\"headerlink\" title=\"6.1 man 命令\"></a>6.1 man 命令</h3><p>man 命令用来查询和解释一个命令的使用方法和这个命令的注意事项。这个查询在每个 Linux 上都有。通常，使用者只要输入命令 man 和这个命令的名称 shell 就会列出一份完整的说明。标准用法：</p>\n<p>man 命令的名称</p>\n<p>要查询 ls 命令的说明书页，输入命令：</p>\n<p>man ls</p>\n<p>要翻阅说明书页，可以使用 Page Up 和 Page Down 键，或使用空格键向后翻一页，使用 b 向前翻。要退出说明书页，输入命令 q。要在说明书页中搜索关键字，输入命令&#x2F;和要搜索的关键字或短语，然后按 Enter 键即可。所有出现在说明书页中的关键字都会被突出显示，允许快速地阅读上下文中的关键字。</p>\n<h3 id=\"6-2-locate-命令\"><a href=\"#6-2-locate-命令\" class=\"headerlink\" title=\"6.2 locate 命令\"></a>6.2 locate 命令</h3><p>locate 命令的主要功能是定位文件和目录。有时候，只知道某一文件或目录存在，却不知道在哪儿，就可以用 locate 来定位文件和目录。使用 locate 命令，将会看到每一个包括搜索中间的文件和目录。例如，如果想要搜索带有 test 的这个词的文件，输入命令：</p>\n<p>locate test</p>\n<p>locate 命令使用数据库来定位带有 test 这个词的文件或目录。</p>\n<h3 id=\"6-3-whatis-命令\"><a href=\"#6-3-whatis-命令\" class=\"headerlink\" title=\"6.3 whatis 命令\"></a>6.3 whatis 命令</h3><p>whatis 命令用来查询某个命令的含义。用法简单，也不需要什么参数，直接在 whatis 命令后加上所要查询的命令就可以了，但是却很实用。</p>\n<p>要查询 mv 命令的含义，输入命令：</p>\n<p>whatis mv</p>\n<h2 id=\"7-文件阅读的命令\"><a href=\"#7-文件阅读的命令\" class=\"headerlink\" title=\"7.文件阅读的命令\"></a>7.文件阅读的命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>head</td>\n<td>查看文件的开头部分</td>\n</tr>\n<tr>\n<td>tail</td>\n<td>查看文件结尾的 10 行</td>\n</tr>\n<tr>\n<td>less</td>\n<td>less 是一个分页工具，它允许一页一页地(或一个屏幕一个屏幕地)查看信息</td>\n</tr>\n<tr>\n<td>more</td>\n<td>more 是一个分页工具，它允许一页一页地(或一个屏幕一个屏幕地)查看信息</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-1-head-命令\"><a href=\"#7-1-head-命令\" class=\"headerlink\" title=\"7.1 head 命令\"></a>7.1 head 命令</h3><p>head 命令可以用来查看文件的开头部分。此命令的格式是：</p>\n<p>head 文件名</p>\n<p>默认设置，它只查看文件的前 10 行。但可以通过指定一个数字选项来改变要显示的行数，命令如下：</p>\n<p>head –20 文件名</p>\n<p>这个命令将会查看文件的前 20 行。</p>\n<h3 id=\"7-2-tail-命令\"><a href=\"#7-2-tail-命令\" class=\"headerlink\" title=\"7.2 tail 命令\"></a>7.2 tail 命令</h3><p>tail 命令和 head 命令恰恰相反。使用 tail 命令，可以查看文件结尾的 10 行。这有助于查看日志文件的最后 10 行来阅读重要的系统信息。还可以使用 tail 观察日志文件更新的过程。使用-f 选项，tail 会自动实时地把打开文件中的新信息显示到屏幕上。例如，要活跃地观察&#x2F;var&#x2F;log&#x2F;messages，以根用户身份在 shell 下输入以下命令：</p>\n<p>tail –f &#x2F;var&#x2F;log&#x2F;messages</p>\n<h3 id=\"7-3-less-命令\"><a href=\"#7-3-less-命令\" class=\"headerlink\" title=\"7.3 less 命令\"></a>7.3 less 命令</h3><p>less 命令与 more 命令相似。</p>\n<h3 id=\"7-4-more-命令\"><a href=\"#7-4-more-命令\" class=\"headerlink\" title=\"7.4 more 命令\"></a>7.4 more 命令</h3><p>more 和 less 的主要区别是，less 允许使用箭头来前后移动，而 more 使用空格键和 b 键来前后移动。使用 ls 和 more 来列举&#x2F;etc 目录下的内容：</p>\n<p>ls –al &#x2F;etc | more</p>\n<p>要使用 more 在文本文件中搜索关键字，按&#x2F;键并输入命令搜索条目：</p>\n<p>&#x2F;foo</p>\n<p>使用空格键来先前翻阅页码。按 q 键退出。</p>\n<p>more 命令标准格式为：</p>\n<p>more [选项] [fileNames]</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-num</td>\n<td>一次显示的行数</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>提示使用者，在画面下方显示[Press space to continue, q to quit.]，如果使用者按错键，则会显示[Press h for instructions.]而不是哔声</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>取消遇见特殊字元^L(送纸字元)时会暂停的功能</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>计算行数时，以实际上的行数，而非自动换行过后的行数(有些单行字数太长的会被扩展为两行或两行以上)</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>不以卷动的方式显示每一页，而是先清除荧幕后再显示内容</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>跟-p 相似，不同的是先显示内容再清除其他旧资料</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>当遇到有连续两行以上的空白行，就代换为一行的空白行</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>不显示下引号(根据环境变数 TERM 指定的 terminal 而有所不同)</td>\n</tr>\n<tr>\n<td>+&#x2F;</td>\n<td>在每个档案显示前搜寻该字串(pattern)，然后从该字串之后开始显示</td>\n</tr>\n<tr>\n<td>+num</td>\n<td>从第 num 行开始显示</td>\n</tr>\n<tr>\n<td>fileNames</td>\n<td>欲显示内容的档案，可为复数个数</td>\n</tr>\n</tbody></table>\n<p>例如：</p>\n<p>more -s testfile 逐页显示 testfile 之档案内容，如有连续两行以上空白行则以一行空白行显示。<br>more +20 testfile 从第 20 行开始显示 testfile 之档案内容。</p>\n<h2 id=\"8-网络操作命令\"><a href=\"#8-网络操作命令\" class=\"headerlink\" title=\"8.网络操作命令\"></a>8.网络操作命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ftp</td>\n<td>传送文件</td>\n<td>telnet</td>\n<td>远端登陆</td>\n</tr>\n<tr>\n<td>bye</td>\n<td>结束连线并结束程序</td>\n<td>rlogin</td>\n<td>远端登入</td>\n</tr>\n<tr>\n<td>ping</td>\n<td>检测主机</td>\n<td>netstat</td>\n<td>显示网络状态</td>\n</tr>\n</tbody></table>\n<h3 id=\"8-1-ftp-命令\"><a href=\"#8-1-ftp-命令\" class=\"headerlink\" title=\"8.1 ftp 命令\"></a>8.1 ftp 命令</h3><p>ftp 命令用来传输文件，非常重要。如果在网络上看到一个很重要的文件，就可以用这个命令把那个文件传到自己的机器上来。</p>\n<p>标准用法：</p>\n<p>ftp (-选项) 主机名称或 IP 地址</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-D</td>\n<td>详细显示命令的执行过程，便于排错和分析程序的执行情况</td>\n</tr>\n<tr>\n<td>-I</td>\n<td>关闭互动模式，不询问任何问题</td>\n</tr>\n<tr>\n<td>-G</td>\n<td>关闭本地主机文件名称支持特殊字符的扩充特征</td>\n</tr>\n<tr>\n<td>-N</td>\n<td>不适用自动登录。FTP 在启动时，会尝试自动登录远端系统，它会从用户的转述目录中读取.netrc 文件的内容，以便自行登录。若该文件不存在，FTP 会放弃自动登录，并询问用户的账号名称</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示命令的执行过程</td>\n</tr>\n</tbody></table>\n<p>举例说明，用 ftp 登录 ftp.dark.com 主机，输入命令：</p>\n<p>ftp ftp.dark.com</p>\n<p>注意：用户必须有相应的存取权限，否则不能从远程系统中获得文件或向远程系统中传输文件。为了使用 ftp 来传输文件，用户必须知道远程计算机上的合法用户名和口令。</p>\n<h3 id=\"8-2-bye-命令\"><a href=\"#8-2-bye-命令\" class=\"headerlink\" title=\"8.2 bye 命令\"></a>8.2 bye 命令</h3><p>在 ftp 模式下，输入 bye 即可中断目前的连线作业，并结束 ftp 的执行，没有选项。</p>\n<h3 id=\"8-3-ping-命令\"><a href=\"#8-3-ping-命令\" class=\"headerlink\" title=\"8.3 ping 命令\"></a>8.3 ping 命令</h3><p>执行 ping 命令，它会使用 ICMP 传输协议，发出要求回应的信息，若远程主机的网络没有什么问题，就会回应信息，因而得知该主机运作正常。</p>\n<p>标准用法：</p>\n<p>ping (-选项) 主机名称或 IP 地址</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>c 次数</td>\n<td>设置完成要求回应的次数。ping 命令会反复发出信息，直到达到设定的次数为止</td>\n</tr>\n<tr>\n<td>D</td>\n<td>使用 Socket 的 SO_DEBUG 功能</td>\n</tr>\n<tr>\n<td>F</td>\n<td>大量而且快速地送网络封包给一台机器，看它的回应。一般不到几秒钟，送出去的封包就会超过两千个</td>\n</tr>\n<tr>\n<td>I 秒数</td>\n<td>指定收发信息的间隔时间，单位为 s，预置位 1s。与参数 f 不兼容</td>\n</tr>\n<tr>\n<td>S bytes</td>\n<td>设置数据包的大小。预设置为 56B，加上 8B ICMP 头文件，共 64B</td>\n</tr>\n<tr>\n<td>R</td>\n<td>忽略网关，直接将数据包送到远程主机上。如果该主机并非局域网的一份子，就会传回错误信息</td>\n</tr>\n<tr>\n<td>Q</td>\n<td>不显示命令的执行过程，只显示结果</td>\n</tr>\n<tr>\n<td>V</td>\n<td>详细显示命令的执行过程，包括非回应信息和其它信息</td>\n</tr>\n<tr>\n<td>T 存活数值</td>\n<td>设置存活数值 TTL 的大小。TTL 是 IP 协议包中的一个值，它告诉网络，数据包在网络中的时间是否太长而应被丢弃</td>\n</tr>\n</tbody></table>\n<p>举例说明，检测 des.bllod.net 主机网络功能是否正常，送出去的信息需完成 5 次回应，每次间隔 10s，数据包的大小为 512B，输入命令：</p>\n<p>ping –c 5 –i 10 –s 504 –t 64 des.blood.net</p>\n<h3 id=\"8-4-telnet-命令\"><a href=\"#8-4-telnet-命令\" class=\"headerlink\" title=\"8.4 telnet 命令\"></a>8.4 telnet 命令</h3><p>telnet 命令的主要功能是进行远程登录。该命令允许用户在使用 telnet 协议的远程计算机之间进行通信，用户可以通过网络在远程计算机上登录，就像登录到本地机上执行命令一样。为了通过 telnet 登录计算机，必须知道远程计算机上的合法用户名和口令。telnet 只为普通终端提供终端仿真，而不支持 X Window 等图形环境。</p>\n<p>标准用法：</p>\n<p>telnet 主机名或 IP</p>\n<p>例如登录 IP 地址为 140.114.63.12 的计算机，输入命令：</p>\n<p>telnet 140.114.63.12</p>\n<p>一旦 telnet 成功连接到远程系统上，就显示登录信息，并提示用户输入用户名和口令。如果用户名和口令正确，就能成功登录并在远程系统上工作。用户结束了远程会话后，一定要确保使用 logout 命令退出远程系统。然后 telnet 报告远程会话被关闭，并返回到用户本地机的 shell 提示符下。</p>\n<h3 id=\"8-5-rlogin-命令\"><a href=\"#8-5-rlogin-命令\" class=\"headerlink\" title=\"8.5 rlogin 命令\"></a>8.5 rlogin 命令</h3><p>rlogin 也是用来远程登录的。它的英文含义是 remote login。该命令与 telnet 命令很相似，允许用户启动远程系统上的交互命令会话。用法：</p>\n<p>rlogin (-选项) host</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8</td>\n<td>允许输入 8 位字符数据</td>\n</tr>\n<tr>\n<td>e</td>\n<td>为 rlogin 会话设置转义字符，默认的转义字符是“~”，用户可以指定一个文字字符或一个&#x2F;nnn 形式的八进制数</td>\n</tr>\n<tr>\n<td>E</td>\n<td>停止任何转义字符。当与-8 选项一起使用时，它提供一个完全透明的链接</td>\n</tr>\n<tr>\n<td>l 用户名称</td>\n<td>指定要登入远端主机的用户名称</td>\n</tr>\n<tr>\n<td>L</td>\n<td>使用 litout 模式进行远端登入操作</td>\n</tr>\n</tbody></table>\n<p>例如，要登入别人的计算机。输入命令：</p>\n<p>rlogin –l inin 140.114.125.24</p>\n<h3 id=\"8-6-netstat-命令\"><a href=\"#8-6-netstat-命令\" class=\"headerlink\" title=\"8.6 netstat 命令\"></a>8.6 netstat 命令</h3><p>netstat 命令的主要功能是了解 Linux 系统的网络情况。假设没有指定任何参数给 netstat 命令，则效果和指定-F 参数相同。</p>\n<p>用法：</p>\n<p>netstat (-选项)</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>a</td>\n<td>显示所有连线中的 Socket</td>\n</tr>\n<tr>\n<td>F</td>\n<td>显示 FIB</td>\n</tr>\n<tr>\n<td>a</td>\n<td>全部列出，包括正在等待的程序</td>\n</tr>\n<tr>\n<td>c</td>\n<td>持续列出网络状态</td>\n</tr>\n<tr>\n<td>i</td>\n<td>显示网络界面信息</td>\n</tr>\n<tr>\n<td>n</td>\n<td>使用网络 ip 地址代替名称</td>\n</tr>\n<tr>\n<td>o</td>\n<td>显示计时器</td>\n</tr>\n<tr>\n<td>r</td>\n<td>显示网络路径表</td>\n</tr>\n<tr>\n<td>t</td>\n<td>显示 TCP 协议的连接情形</td>\n</tr>\n<tr>\n<td>u</td>\n<td>显示 UDP 协议的连接情形</td>\n</tr>\n<tr>\n<td>v</td>\n<td>显示版本信息</td>\n</tr>\n<tr>\n<td>w</td>\n<td>显示 RAW 传输协议的连接情形</td>\n</tr>\n</tbody></table>\n<p><strong>which</strong></p>\n<p>语法</p>\n<p>which command</p>\n<p>说明</p>\n<p>依序从 path 环境变量所列的目录中找出 command 的位置，并显示完整路径的名称。在找到第一个符合条件的程序文件时，就立刻停止搜索，省略其余未搜索目录。</p>\n<p>范例，找出 ls 命令的程序文件的位置：</p>\n<p>which ls</p>\n<p>系统输出：</p>\n<p>&#x2F;usr&#x2F;bin&#x2F;ls</p>\n<p><strong>whereis</strong></p>\n<p>语法</p>\n<p>whereis [option] name</p>\n<p>说明</p>\n<p>找出特定程序的可执行文件、源代码文件以及 manpage 的路径。你所提供的 name 会被先除去前置的路径以及任何.ext 形式的扩展名。</p>\n<p>whereis 只会在标准的 Linux 目录中进行搜索。</p>\n<p>常用选项</p>\n<p>-b</p>\n<p>只搜索可执行文件。</p>\n<p>-m</p>\n<p>只搜索 manpage。</p>\n<p>-s</p>\n<p>只搜索源代码文件。</p>\n<p>-B directory</p>\n<p>更改或限定搜索可执行的文件的目录。</p>\n<p>-M directory</p>\n<p>更改或限定搜索 manpage 的目录。</p>\n<p>-S directory</p>\n<p>更改或限定搜索源代码文件的目录。</p>\n<p><strong>find</strong></p>\n<p>语法</p>\n<p>find paths expression [action]</p>\n<p>说明</p>\n<p>以 paths 为搜索起点逐层往下找出每一个符合 expression 条件的文件，并对该文件执行 action 所代表的动作。expression 是搜索条件，它由一个代表匹配项目的选项以及一个代表匹配模式的参数构成。</p>\n<p>action 是处理动作，它有一个代表“处理方式”的选项以及一个操作参数构成。若不指定 action，则默认动作是显示出文件名。</p>\n<p>常用的搜索条件</p>\n<p>-name pattern<br>-path pattern<br>-lname pattern</p>\n<p>找出名称、路径名称或符号链接的目标匹配 pattern 模式的文件。pattern 可以包含 shell 的文件名通配符，路径是相对于搜索起点的。</p>\n<p>常见处理动作</p>\n<p>-print</p>\n<p>显示出文件的相对路径（相对于搜索起点）。</p>\n<p>-exec cmd &#x2F;;</p>\n<p>执行指定的 shell 命令。若 cmd 含有任何 shell 特殊字符，则他们之前都必须加上&#x2F;符号，以免 shell 立刻执行他们。在 cmd 里，可以用”{}”符号(包括双引号)表示 find 所找出的文件。</p>\n<p><strong>locate</strong></p>\n<p>语法</p>\n<p>locate patterns</p>\n<p>说明</p>\n<p>第一次执行 locate 时，它会建立一个索引数据库，当往后再次执行时，它便从索引数据库中迅速找出文件的位置。locate 很适合用来反复搜索很少变动的目录树，但是对于刚改名的旧文件以及新建的文件，locate 就找不到了，除非重建数据库。</p>\n<p>updatedb</p>\n<p>语法</p>\n<p>updatedb [option]</p>\n<p>说明</p>\n<p>更新 slocate 的索引数据库。</p>\n<p>选项</p>\n<p>-e directories</p>\n<p>略过 directories 所列的目录。</p>\n<h2 id=\"9-其他命令\"><a href=\"#9-其他命令\" class=\"headerlink\" title=\"9.其他命令\"></a>9.其他命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>echo</td>\n<td>显示一字串</td>\n<td>passwd</td>\n<td>修改密码</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>清除显示器</td>\n<td>lpr</td>\n<td>打印</td>\n</tr>\n<tr>\n<td>lpq</td>\n<td>查看在打印队列中等待的作业</td>\n<td>lprm</td>\n<td>取消打印队列中的作业</td>\n</tr>\n</tbody></table>\n<h3 id=\"9-1-echo-命令\"><a href=\"#9-1-echo-命令\" class=\"headerlink\" title=\"9.1 echo 命令\"></a>9.1 echo 命令</h3><p>echo 命令用来在显示器上输出一段文字，这个命令常用来输出一些提示信息，因此这个命令的意义在于输出一些文字。它的用法也很简单：</p>\n<p>echo –(参数) 字串 (可以用””，也可以不用，显示略有区别)</p>\n<p>参数 n 代表输出文字后不换行，如果不加参数会自动换行。</p>\n<p>输入命令：</p>\n<p>echo “welcome to use Linux”</p>\n<p>输出结果为：</p>\n<p>welcome to use Linux</p>\n<p>如果不加””，则输出结果为：</p>\n<p>welcome to use Linux</p>\n<p>它们的区别在于后一个输出，每两个输出之间只隔一个空格，这是因为 echo 把这些输出看做字串的缘故。</p>\n<h3 id=\"9-2-clear-命令\"><a href=\"#9-2-clear-命令\" class=\"headerlink\" title=\"9.2 clear 命令\"></a>9.2 clear 命令</h3><p>clear 命令的主要功能是清除显示器，这个命令很简单，只要输入 clear 即可。</p>\n<h3 id=\"9-3-passwd-命令\"><a href=\"#9-3-passwd-命令\" class=\"headerlink\" title=\"9.3 passwd 命令\"></a>9.3 passwd 命令</h3><p>passwd 命令用来修改用户的密码。</p>\n<p>在 shell 下输入</p>\n<p>passwd</p>\n<p>然后，根据提示输入旧密码和新密码即可。</p>\n<h3 id=\"9-4-lpr-命令\"><a href=\"#9-4-lpr-命令\" class=\"headerlink\" title=\"9.4 lpr 命令\"></a>9.4 lpr 命令</h3><p>lpr 命令的功能是把指定的文件发送到打印队列中。例如，lpr foo.txt 会打印 foo.txt 文件。</p>\n<p>标准用法：</p>\n<p>lpr filename</p>\n<p>要查看在打印队列中等待的作业，在命令行中输入命令 lpq。系统返回如下信息：</p>\n<p>active root 389 foo.txt</p>\n<p>在这个例子中，389 是作业号码。还可以取消打印队列中的作业，格式是：</p>\n<p>lprm 作业号码</p>\n<p>输入命令：</p>\n<p>lprm 389</p>\n<p>这样就去修改了 foo.txt 打印作业。</p>\n<h2 id=\"10-bash-常用命令\"><a href=\"#10-bash-常用命令\" class=\"headerlink\" title=\"10.bash 常用命令\"></a>10.bash 常用命令</h2><p><img src=\"https://img-blog.csdn.net/20180604105254836\" alt=\"image\"></p>\n","categories":["常用指令合集"],"tags":["javascript"]},{"title":"MongoDB常用操作命令大全","url":"/2022/12/16/MongoDB%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","content":"<p>成功启动 MongoDB 后，再打开一个命令行窗口输入 mongo，就可以进行数据库的一些操作。输入 help 可以看到基本操作命令，只是 MongoDB 没有创建数据库的命令，但有类似的命令。</p>\n<p>如：如果你想创建一个“myTest”的数据库，先运行 use myTest 命令，之后就做一些操作（如：db.createCollection(‘user’)）,这样就可以创建一个名叫“myTest”的数据库。</p>\n<h2 id=\"一、数据库常用命令\"><a href=\"#一、数据库常用命令\" class=\"headerlink\" title=\"一、数据库常用命令\"></a>一、数据库常用命令</h2><h3 id=\"1、Help-查看命令提示\"><a href=\"#1、Help-查看命令提示\" class=\"headerlink\" title=\"1、Help 查看命令提示\"></a>1、Help 查看命令提示</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">help</span><br><span class=\"line\">db.help();</span><br><span class=\"line\">db.yourColl.help();</span><br><span class=\"line\">db.youColl.find().help();</span><br><span class=\"line\">rs.help();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、切换-x2F-创建数据库\"><a href=\"#2、切换-x2F-创建数据库\" class=\"headerlink\" title=\"2、切换&#x2F;创建数据库\"></a>2、切换&#x2F;创建数据库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">use yourDB; 当创建一个集合(table)的时候会自动创建当前数据库</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、查询所有数据库\"><a href=\"#3、查询所有数据库\" class=\"headerlink\" title=\"3、查询所有数据库\"></a>3、查询所有数据库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">show dbs;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、删除当前使用数据库\"><a href=\"#4、删除当前使用数据库\" class=\"headerlink\" title=\"4、删除当前使用数据库\"></a>4、删除当前使用数据库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.dropDatabase();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、从指定主机上克隆数据库\"><a href=\"#5、从指定主机上克隆数据库\" class=\"headerlink\" title=\"5、从指定主机上克隆数据库\"></a>5、从指定主机上克隆数据库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.cloneDatabase(“127.0.0.1”); 将指定机器上的数据库的数据克隆到当前数据库</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、从指定的机器上复制指定数据库数据到某个数据库\"><a href=\"#6、从指定的机器上复制指定数据库数据到某个数据库\" class=\"headerlink\" title=\"6、从指定的机器上复制指定数据库数据到某个数据库\"></a>6、从指定的机器上复制指定数据库数据到某个数据库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.copyDatabase(&quot;mydb&quot;, &quot;temp&quot;, &quot;127.0.0.1&quot;);将本机的mydb的数据复制到temp数据库中</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7、修复当前数据库\"><a href=\"#7、修复当前数据库\" class=\"headerlink\" title=\"7、修复当前数据库\"></a>7、修复当前数据库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.repairDatabase();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8、查看当前使用的数据库\"><a href=\"#8、查看当前使用的数据库\" class=\"headerlink\" title=\"8、查看当前使用的数据库\"></a>8、查看当前使用的数据库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getName();</span><br><span class=\"line\">db; db和getName方法是一样的效果，都可以查询当前使用的数据库</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9、显示当前-db-状态\"><a href=\"#9、显示当前-db-状态\" class=\"headerlink\" title=\"9、显示当前 db 状态\"></a>9、显示当前 db 状态</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.stats();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10、当前-db-版本\"><a href=\"#10、当前-db-版本\" class=\"headerlink\" title=\"10、当前 db 版本\"></a>10、当前 db 版本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.version();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11、查看当前-db-的链接机器地址\"><a href=\"#11、查看当前-db-的链接机器地址\" class=\"headerlink\" title=\"11、查看当前 db 的链接机器地址\"></a>11、查看当前 db 的链接机器地址</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getMongo();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、Collection-聚集集合\"><a href=\"#二、Collection-聚集集合\" class=\"headerlink\" title=\"二、Collection 聚集集合\"></a>二、Collection 聚集集合</h2><h3 id=\"1、创建一个聚集集合（table）\"><a href=\"#1、创建一个聚集集合（table）\" class=\"headerlink\" title=\"1、创建一个聚集集合（table）\"></a>1、创建一个聚集集合（table）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.createCollection(“collName”, &#123;size: 20, capped: 5, max: 100&#125;);//创建成功会显示&#123;“ok”:1&#125;</span><br><span class=\"line\">//判断集合是否为定容量db.collName.isCapped();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、得到指定名称的聚集集合（table）\"><a href=\"#2、得到指定名称的聚集集合（table）\" class=\"headerlink\" title=\"2、得到指定名称的聚集集合（table）\"></a>2、得到指定名称的聚集集合（table）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&quot;account&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、得到当前-db-的所有聚集集合\"><a href=\"#3、得到当前-db-的所有聚集集合\" class=\"headerlink\" title=\"3、得到当前 db 的所有聚集集合\"></a>3、得到当前 db 的所有聚集集合</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollectionNames();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、显示当前-db-所有聚集索引的状态\"><a href=\"#4、显示当前-db-所有聚集索引的状态\" class=\"headerlink\" title=\"4、显示当前 db 所有聚集索引的状态\"></a>4、显示当前 db 所有聚集索引的状态</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.printCollectionStats();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、用户相关\"><a href=\"#三、用户相关\" class=\"headerlink\" title=\"三、用户相关\"></a>三、用户相关</h2><h3 id=\"1、添加一个用户\"><a href=\"#1、添加一个用户\" class=\"headerlink\" title=\"1、添加一个用户\"></a>1、添加一个用户</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.addUser(&quot;name&quot;);</span><br><span class=\"line\">db.addUser(&quot;userName&quot;, &quot;pwd123&quot;, true); 添加用户、设置密码、是否只读</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、数据库认证、安全模式\"><a href=\"#2、数据库认证、安全模式\" class=\"headerlink\" title=\"2、数据库认证、安全模式\"></a>2、数据库认证、安全模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.auth(&quot;userName&quot;, &quot;123123&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、显示当前所有用户\"><a href=\"#3、显示当前所有用户\" class=\"headerlink\" title=\"3、显示当前所有用户\"></a>3、显示当前所有用户</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">show users;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、删除用户\"><a href=\"#4、删除用户\" class=\"headerlink\" title=\"4、删除用户\"></a>4、删除用户</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.removeUser(&quot;userName&quot;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、聚集集合查询\"><a href=\"#四、聚集集合查询\" class=\"headerlink\" title=\"四、聚集集合查询\"></a>四、聚集集合查询</h2><h3 id=\"1、查询所有记录\"><a href=\"#1、查询所有记录\" class=\"headerlink\" title=\"1、查询所有记录\"></a>1、查询所有记录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find();</span><br><span class=\"line\">相当于：select* from userInfo;</span><br></pre></td></tr></table></figure>\n\n<p>默认每页显示 20 条记录，当显示不下的情况下，可以用 it 迭代命令查询下一页数据。注意：键入 it 命令不能带“；”<br>但是你可以设置每页显示数据的大小，用 DBQuery.shellBatchSize&#x3D; 50;这样每页就显示 50 条记录了。</p>\n<h3 id=\"2、查询去掉后的当前聚集集合中的某列的重复数据\"><a href=\"#2、查询去掉后的当前聚集集合中的某列的重复数据\" class=\"headerlink\" title=\"2、查询去掉后的当前聚集集合中的某列的重复数据\"></a>2、查询去掉后的当前聚集集合中的某列的重复数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.distinct(&quot;name&quot;);</span><br><span class=\"line\">会过滤掉name中的相同数据</span><br><span class=\"line\">相当于：select distict name from userInfo;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、查询-age-x3D-22-的记录\"><a href=\"#3、查询-age-x3D-22-的记录\" class=\"headerlink\" title=\"3、查询 age &#x3D; 22 的记录\"></a>3、查询 age &#x3D; 22 的记录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;&quot;age&quot;: 22&#125;);</span><br><span class=\"line\">相当于： select * from userInfo where age = 22;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、查询-age-gt-22-的记录\"><a href=\"#4、查询-age-gt-22-的记录\" class=\"headerlink\" title=\"4、查询 age &gt; 22 的记录\"></a>4、查询 age &gt; 22 的记录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;age: &#123;$gt: 22&#125;&#125;);</span><br><span class=\"line\">相当于：select * from userInfo where age &gt;22;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、查询-age-lt-22-的记录\"><a href=\"#5、查询-age-lt-22-的记录\" class=\"headerlink\" title=\"5、查询 age &lt; 22 的记录\"></a>5、查询 age &lt; 22 的记录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;age: &#123;$lt: 22&#125;&#125;);</span><br><span class=\"line\">相当于：select * from userInfo where age &lt;22;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、查询-age-gt-x3D-25-的记录\"><a href=\"#6、查询-age-gt-x3D-25-的记录\" class=\"headerlink\" title=\"6、查询 age &gt;&#x3D; 25 的记录\"></a>6、查询 age &gt;&#x3D; 25 的记录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;);</span><br><span class=\"line\">相当于：select * from userInfo where age &gt;= 25;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7、查询-age-lt-x3D-25-的记录\"><a href=\"#7、查询-age-lt-x3D-25-的记录\" class=\"headerlink\" title=\"7、查询 age &lt;&#x3D; 25 的记录\"></a>7、查询 age &lt;&#x3D; 25 的记录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;age: &#123;$lte: 25&#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8、查询-age-gt-x3D-23-并且-age-lt-x3D-26\"><a href=\"#8、查询-age-gt-x3D-23-并且-age-lt-x3D-26\" class=\"headerlink\" title=\"8、查询 age &gt;&#x3D; 23 并且 age &lt;&#x3D; 26\"></a>8、查询 age &gt;&#x3D; 23 并且 age &lt;&#x3D; 26</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;age: &#123;$gte: 23, $lte: 26&#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9、查询-name-中包含-mongo-的数据\"><a href=\"#9、查询-name-中包含-mongo-的数据\" class=\"headerlink\" title=\"9、查询 name 中包含 mongo 的数据\"></a>9、查询 name 中包含 mongo 的数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;name: /mongo/&#125;);</span><br><span class=\"line\">//相当于%%</span><br><span class=\"line\">[code]select * from userInfo where name like ‘%mongo%&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10、查询-name-中以-mongo-开头的\"><a href=\"#10、查询-name-中以-mongo-开头的\" class=\"headerlink\" title=\"10、查询 name 中以 mongo 开头的\"></a>10、查询 name 中以 mongo 开头的</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;name: /^mongo/&#125;);</span><br><span class=\"line\">select * from userInfo where name like ‘mongo%&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11、查询指定列-name、age-数据\"><a href=\"#11、查询指定列-name、age-数据\" class=\"headerlink\" title=\"11、查询指定列 name、age 数据\"></a>11、查询指定列 name、age 数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;&#125;, &#123;name: 1, age: 1&#125;);</span><br><span class=\"line\">相当于：select name, age from userInfo;</span><br></pre></td></tr></table></figure>\n\n<p>当然 name 也可以用 true 或 false,当用 true 的情况下和 name:1 效果一样，如果用 false 就是排除 name，显示 name 以外的列信息。</p>\n<h3 id=\"12、查询指定列-name、age-数据-age-gt-25\"><a href=\"#12、查询指定列-name、age-数据-age-gt-25\" class=\"headerlink\" title=\"12、查询指定列 name、age 数据, age &gt; 25\"></a>12、查询指定列 name、age 数据, age &gt; 25</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;age: &#123;$gt: 25&#125;&#125;, &#123;name: 1, age: 1&#125;);</span><br><span class=\"line\">相当于：select name, age from userInfo where age &gt;25;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13、按照年龄排序\"><a href=\"#13、按照年龄排序\" class=\"headerlink\" title=\"13、按照年龄排序\"></a>13、按照年龄排序</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">升序：db.userInfo.find().sort(&#123;age: 1&#125;);</span><br><span class=\"line\">降序：db.userInfo.find().sort(&#123;age: -1&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14、查询-name-x3D-zhangsan-age-x3D-22-的数据\"><a href=\"#14、查询-name-x3D-zhangsan-age-x3D-22-的数据\" class=\"headerlink\" title=\"14、查询 name &#x3D; zhangsan, age &#x3D; 22 的数据\"></a>14、查询 name &#x3D; zhangsan, age &#x3D; 22 的数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;name: &#x27;zhangsan&#x27;, age: 22&#125;);</span><br><span class=\"line\">相当于：select * from userInfo where name = ‘zhangsan&#x27; and age = ‘22&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15、查询前-5-条数据\"><a href=\"#15、查询前-5-条数据\" class=\"headerlink\" title=\"15、查询前 5 条数据\"></a>15、查询前 5 条数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find().limit(5);</span><br><span class=\"line\">相当于：selecttop 5 * from userInfo;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16、查询-10-条以后的数据\"><a href=\"#16、查询-10-条以后的数据\" class=\"headerlink\" title=\"16、查询 10 条以后的数据\"></a>16、查询 10 条以后的数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find().skip(10);</span><br><span class=\"line\">相当于：select * from userInfo where id not in (</span><br><span class=\"line\">selecttop 10 * from userInfo</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"17、查询在-5-10-之间的数据\"><a href=\"#17、查询在-5-10-之间的数据\" class=\"headerlink\" title=\"17、查询在 5-10 之间的数据\"></a>17、查询在 5-10 之间的数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find().limit(10).skip(5);</span><br></pre></td></tr></table></figure>\n\n<p>可用于分页，limit 是 pageSize，skip 是第几页</p>\n<h3 id=\"18、or-与-查询\"><a href=\"#18、or-与-查询\" class=\"headerlink\" title=\"18、or 与 查询\"></a>18、or 与 查询</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;$or: [&#123;age: 22&#125;, &#123;age: 25&#125;]&#125;);</span><br><span class=\"line\">相当于：select * from userInfo where age = 22 or age = 25;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"19、查询第一条数据\"><a href=\"#19、查询第一条数据\" class=\"headerlink\" title=\"19、查询第一条数据\"></a>19、查询第一条数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.findOne();</span><br><span class=\"line\">相当于：selecttop 1 * from userInfo;</span><br><span class=\"line\">db.userInfo.find().limit(1);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20、查询某个结果集的记录条数\"><a href=\"#20、查询某个结果集的记录条数\" class=\"headerlink\" title=\"20、查询某个结果集的记录条数\"></a>20、查询某个结果集的记录条数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;).count();</span><br><span class=\"line\">相当于：select count(*) from userInfo where age &gt;= 20;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"21、按照某列进行排序\"><a href=\"#21、按照某列进行排序\" class=\"headerlink\" title=\"21、按照某列进行排序\"></a>21、按照某列进行排序</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.find(&#123;sex: &#123;$exists: true&#125;&#125;).count();</span><br><span class=\"line\">相当于：select count(sex) from userInfo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、索引\"><a href=\"#五、索引\" class=\"headerlink\" title=\"五、索引\"></a>五、索引</h2><h3 id=\"1、创建索引\"><a href=\"#1、创建索引\" class=\"headerlink\" title=\"1、创建索引\"></a>1、创建索引</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.ensureIndex(&#123;name: 1&#125;);</span><br><span class=\"line\">db.userInfo.ensureIndex(&#123;name: 1, ts: -1&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、查询当前聚集集合所有索引\"><a href=\"#2、查询当前聚集集合所有索引\" class=\"headerlink\" title=\"2、查询当前聚集集合所有索引\"></a>2、查询当前聚集集合所有索引</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.getIndexes();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、查看总索引记录大小\"><a href=\"#3、查看总索引记录大小\" class=\"headerlink\" title=\"3、查看总索引记录大小\"></a>3、查看总索引记录大小</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.userInfo.totalIndexSize();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、读取当前集合的所有-index-信息\"><a href=\"#4、读取当前集合的所有-index-信息\" class=\"headerlink\" title=\"4、读取当前集合的所有 index 信息\"></a>4、读取当前集合的所有 index 信息</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.users.reIndex();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、删除指定索引\"><a href=\"#5、删除指定索引\" class=\"headerlink\" title=\"5、删除指定索引\"></a>5、删除指定索引</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.users.dropIndex(&quot;name_1&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、删除所有索引\"><a href=\"#6、删除所有索引\" class=\"headerlink\" title=\"6、删除所有索引\"></a>6、删除所有索引</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.users.dropIndexes();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、修改、添加、删除集合数据\"><a href=\"#六、修改、添加、删除集合数据\" class=\"headerlink\" title=\"六、修改、添加、删除集合数据\"></a>六、修改、添加、删除集合数据</h2><h3 id=\"1、添加\"><a href=\"#1、添加\" class=\"headerlink\" title=\"1、添加\"></a>1、添加</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.users.save(&#123;name: ‘zhangsan&#x27;, age: 25, sex: true&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>添加的数据的数据列，没有固定，根据添加的数据为准</p>\n<h3 id=\"2、修改\"><a href=\"#2、修改\" class=\"headerlink\" title=\"2、修改\"></a>2、修改</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.users.update(&#123;age: 25&#125;, &#123;$set: &#123;name: &#x27;changeName&#x27;&#125;&#125;, false, true);</span><br><span class=\"line\">相当于：update users set name = ‘changeName&#x27; where age = 25;</span><br><span class=\"line\">db.users.update(&#123;name: &#x27;Lisi&#x27;&#125;, &#123;$inc: &#123;age: 50&#125;&#125;, false, true);</span><br><span class=\"line\">相当于：update users set age = age + 50 where name = ‘Lisi&#x27;;</span><br><span class=\"line\">db.users.update(&#123;name: &#x27;Lisi&#x27;&#125;, &#123;$inc: &#123;age: 50&#125;, $set: &#123;name: &#x27;hoho&#x27;&#125;&#125;, false, true);</span><br><span class=\"line\">相当于：update users set age = age + 50, name = ‘hoho&#x27; where name = ‘Lisi&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、删除\"><a href=\"#3、删除\" class=\"headerlink\" title=\"3、删除\"></a>3、删除</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.users.remove(&#123;age: 132&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、查询修改删除\"><a href=\"#4、查询修改删除\" class=\"headerlink\" title=\"4、查询修改删除\"></a>4、查询修改删除</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.users.findAndModify(&#123;</span><br><span class=\"line\">    query: &#123;age: &#123;$gte: 25&#125;&#125;,</span><br><span class=\"line\">    sort: &#123;age: -1&#125;,</span><br><span class=\"line\">    update: &#123;$set: &#123;name: &#x27;a2&#x27;&#125;, $inc: &#123;age: 2&#125;&#125;,</span><br><span class=\"line\">    remove: true</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">db.runCommand(&#123; findandmodify : &quot;users&quot;,</span><br><span class=\"line\">    query: &#123;age: &#123;$gte: 25&#125;&#125;,</span><br><span class=\"line\">    sort: &#123;age: -1&#125;,</span><br><span class=\"line\">    update: &#123;$set: &#123;name: &#x27;a2&#x27;&#125;, $inc: &#123;age: 2&#125;&#125;,</span><br><span class=\"line\">    remove: true</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">update 或 remove 其中一个是必须的参数; 其他参数可选。</span><br><span class=\"line\">参数    详解     默认值</span><br><span class=\"line\">query    查询过滤条件    &#123;&#125;</span><br><span class=\"line\">sort    如果多个文档符合查询过滤条件，将以该参数指定的排列方式选择出排在首位的对象，该对象将被操作    &#123;&#125;</span><br><span class=\"line\">remove    若为true，被选中对象将在返回前被删除    N/A</span><br><span class=\"line\">update    一个 修改器对象</span><br><span class=\"line\">N/A</span><br><span class=\"line\">new    若为true，将返回修改后的对象而不是原始对象。在删除操作中，该参数被忽略。    false</span><br><span class=\"line\">fields    参见Retrieving a Subset of Fields (1.5.0+)</span><br><span class=\"line\">All fields</span><br><span class=\"line\">upsert    创建新对象若查询结果为空。 示例 (1.5.4+)</span><br><span class=\"line\">false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、语句块操作\"><a href=\"#七、语句块操作\" class=\"headerlink\" title=\"七、语句块操作\"></a>七、语句块操作</h2><h3 id=\"1、简单-Hello-World\"><a href=\"#1、简单-Hello-World\" class=\"headerlink\" title=\"1、简单 Hello World\"></a>1、简单 Hello World</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">print(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>这种写法调用了 print 函数，和直接写入”Hello World!”的效果是一样的；</p>\n<h3 id=\"2、将一个对象转换成-json\"><a href=\"#2、将一个对象转换成-json\" class=\"headerlink\" title=\"2、将一个对象转换成 json\"></a>2、将一个对象转换成 json</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">tojson(new Object());</span><br><span class=\"line\">tojson(new Object(&#x27;a&#x27;));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、循环添加数据\"><a href=\"#3、循环添加数据\" class=\"headerlink\" title=\"3、循环添加数据\"></a>3、循环添加数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; for (var i = 0; i &lt; 30; i++) &#123;</span><br><span class=\"line\">... db.users.save(&#123;name: &quot;u_&quot; + i, age: 22 + i, sex: i % 2&#125;);</span><br><span class=\"line\">... &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这样就循环添加了 30 条数据，同样也可以省略括号的写法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; for (var i = 0; i &lt; 30; i++) db.users.save(&#123;name: &quot;u_&quot; + i, age: 22 + i, sex: i % 2&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>也是可以的，当你用 db.users.find()查询的时候，显示多条数据而无法一页显示的情况下，可以用 it 查看下一页的信息；</p>\n<h3 id=\"4、find-游标查询\"><a href=\"#4、find-游标查询\" class=\"headerlink\" title=\"4、find 游标查询\"></a>4、find 游标查询</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;var cursor = db.users.find();</span><br><span class=\"line\">&gt; while (cursor.hasNext()) &#123;</span><br><span class=\"line\">    printjson(cursor.next());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就查询所有的 users 信息，同样可以这样写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var cursor = db.users.find();</span><br><span class=\"line\">while (cursor.hasNext()) &#123; printjson(cursor.next); &#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样可以省略{}号</p>\n<h3 id=\"5、forEach-迭代循环\"><a href=\"#5、forEach-迭代循环\" class=\"headerlink\" title=\"5、forEach 迭代循环\"></a>5、forEach 迭代循环</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.users.find().forEach(printjson);</span><br></pre></td></tr></table></figure>\n\n<p>forEach 中必须传递一个函数来处理每条迭代的数据信息</p>\n<h3 id=\"6、将-find-游标当数组处理\"><a href=\"#6、将-find-游标当数组处理\" class=\"headerlink\" title=\"6、将 find 游标当数组处理\"></a>6、将 find 游标当数组处理</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var cursor = db.users.find();</span><br><span class=\"line\">cursor[4];</span><br></pre></td></tr></table></figure>\n\n<p>取得下标索引为 4 的那条数据<br>既然可以当做数组处理，那么就可以获得它的长度：cursor.length();或者 cursor.count();<br>那样我们也可以用循环显示数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (var i = 0, len = c.length(); i &lt; len; i++) printjson(c[i]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7、将-find-游标转换成数组\"><a href=\"#7、将-find-游标转换成数组\" class=\"headerlink\" title=\"7、将 find 游标转换成数组\"></a>7、将 find 游标转换成数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; var arr = db.users.find().toArray();</span><br><span class=\"line\">&gt; printjson(arr[2]);</span><br></pre></td></tr></table></figure>\n\n<p>用 toArray 方法将其转换为数组</p>\n<h3 id=\"8、定制我们自己的查询结果\"><a href=\"#8、定制我们自己的查询结果\" class=\"headerlink\" title=\"8、定制我们自己的查询结果\"></a>8、定制我们自己的查询结果</h3><p>只显示 age &lt;&#x3D; 28 的并且只显示 age 这列数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: 1&#125;).forEach(printjson);</span><br><span class=\"line\">db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: true&#125;).forEach(printjson);</span><br></pre></td></tr></table></figure>\n\n<p>排除 age 的列</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: false&#125;).forEach(printjson);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9、forEach-传递函数显示信息\"><a href=\"#9、forEach-传递函数显示信息\" class=\"headerlink\" title=\"9、forEach 传递函数显示信息\"></a>9、forEach 传递函数显示信息</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.things.find(&#123;x:4&#125;).forEach(function(x) &#123;print(tojson(x));&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"八、其他\"><a href=\"#八、其他\" class=\"headerlink\" title=\"八、其他\"></a>八、其他</h2><h3 id=\"1、查询之前的错误信息\"><a href=\"#1、查询之前的错误信息\" class=\"headerlink\" title=\"1、查询之前的错误信息\"></a>1、查询之前的错误信息</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getPrevError();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、清除错误记录\"><a href=\"#2、清除错误记录\" class=\"headerlink\" title=\"2、清除错误记录\"></a>2、清除错误记录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.resetError();</span><br></pre></td></tr></table></figure>\n\n<p>查看聚集集合基本信息</p>\n<ol>\n<li>查看帮助 db.yourColl.help();</li>\n<li>查询当前集合的数据条数 db.yourColl.count();</li>\n<li>查看数据空间大小 db.userInfo.dataSize();</li>\n<li>得到当前聚集集合所在的 db db.userInfo.getDB();</li>\n<li>得到当前聚集的状态 db.userInfo.stats();</li>\n<li>得到聚集集合总大小 db.userInfo.totalSize();</li>\n<li>聚集集合储存空间大小 db.userInfo.storageSize();</li>\n<li>Shard 版本信息 db.userInfo.getShardVersion()</li>\n<li>聚集集合重命名 db.userInfo.renameCollection(“users”); 将 userInfo 重命名为 users</li>\n<li>删除当前聚集集合 db.userInfo.drop();</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">show dbs:显示数据库列表</span><br><span class=\"line\">show collections：显示当前数据库中的集合（类似关系数据库中的表）</span><br><span class=\"line\">show users：显示用户</span><br><span class=\"line\">use &lt;db name&gt;：切换当前数据库，这和MS-SQL里面的意思一样</span><br><span class=\"line\">db.help()：显示数据库操作命令，里面有很多的命令</span><br><span class=\"line\">db.foo.help()：显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令</span><br><span class=\"line\">db.foo.find()：对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据）</span><br><span class=\"line\">db.foo.find( &#123; a : 1 &#125; )：对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1</span><br></pre></td></tr></table></figure>\n","categories":["常用指令合集"],"tags":["javascript"]},{"title":"Next.js快速入门","url":"/2022/12/16/Next-js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","content":"<h2 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h2><p>Next.js 是一个用于 React 应用的极简的服务端渲染框架。框架中集成了 Webpack，Babel 等一系列 React 相关的工具并进行了默认的配置。因此省去了复杂的配置过程，实现了一键搭建开发环境和打包构建。同时提供了自定义配置接口，可以在默认配置的基础上对工具进行自定义配置，满足个性化需求。</p>\n<h2 id=\"二、基本用法\"><a href=\"#二、基本用法\" class=\"headerlink\" title=\"二、基本用法\"></a>二、基本用法</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 npm 安装： npm install next –save</p>\n<p>为了方便的使用 next 提供的命令，把命令写在 package.json 文件的 scripts 中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;dev&quot;: &quot;next&quot;,  // 运行开发服务器，并监控源代码，具备hod reload功能</span><br><span class=\"line\">    &quot;build&quot;: &quot;next build&quot;, // 以生产模式打包代码</span><br><span class=\"line\">    &quot;start&quot;: &quot;next start&quot;  // 启动Next服务器，可以自定义服务器和端口</span><br><span class=\"line\">    &quot;init&quot;: &quot;next init&quot; // 初始化项目，创建基础的文件夹和index页面文件</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后，在项目的根目录下创建 pages 文件夹和 static 文件夹，分别用来放对应的页面资源和静态资源。</p>\n<p><strong>Note</strong>：也可以使用 npm run init 命令自动生成。</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p>如果使用 npm run init 命令的话，现在 pages 文件夹下已经有了 index.js 文件，如果是手动创建 pages 文件夹的话，现在在该文件下创建一个 index.js 文件，内容为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default () =&gt; &lt;p&gt;Hello, world&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p>接着执行 npm run dev 命令并在浏览器中打开 <a href=\"http://localhost:3000。\">http://localhost:3000。</a></p>\n<p>现在，就得到了一个采用服务端渲染的极简 React 应用，这个应用还实现了自动代码分割，保证每个页面只会加载自身的依赖，不会有依赖冗余。</p>\n<p>Next 的核心就是 pages 和 static 文件夹。其中 pages 文件夹用于存放每个页面的顶层组件，static 用于存放项目中的静态资源。</p>\n<p>Next 会将 pages 中的文件结构自动映射为对应的路由结构，例如现在该文件夹下有两个文件:pages&#x2F;index.js 和 pages&#x2F;about.js。则对应的路由分别为&#x2F;和&#x2F;about。并且支持多级目录，例如 page&#x2F;foo&#x2F;bar.js 对应的路由为&#x2F;foo&#x2F;bar。</p>\n<p>static 文件夹用来存放静态文件，例如现在有一个图片文件 static&#x2F;image.png，使用的时候引用&#x2F;static&#x2F;image.png 就可以了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">  &lt;img src=&quot;/static/image.png&quot; /&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>打包完成后，Next 会在项目根目录生成一个.next 文件夹，其中的两个文件夹 dist 和 bundles，dist 文件夹中存放着编译后的源代码，用于服务端渲染。bunldes 文件夹中存放着 pages 中每个页面打包后的整体代码的 JSON 格式。在应用的初始页面，会使用 dist 文件夹中的代码进行服务端渲染，而其他使用路由到达的页面，则将 bundles 文件夹中的对应 JSON 格式的代码返回客户端执行渲染。</p>\n<p>Next 的出现大大简化了 React 应用开发的配置和构建工作，使开发者能够专注于组件的开发，而不需要在 Webpack，Babel 等工具上花费过多的精力。基于简单的文件系统，就可以创建包含路由功能和服务端渲染的 React 应用。需要注意的是：创建的应用中只有初始页面采用服务端渲染，其他通过路由操作到达的页面均为客户端渲染。</p>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><p>Next 对 React 组件的 getInitialProps 生命周期方法做了改造，传入一个上下文对象，该对象在服务端渲染和客户端渲染时，具有不同的属性：</p>\n<ul>\n<li>req: HTTP 请求对象（服务端渲染独有）</li>\n<li>res: HTTP 响应对象（服务端渲染独有）</li>\n<li>pathname: URL 中的路径部分</li>\n<li>query：URL 中的查询字符串部分解析出的对象</li>\n<li>err：错误对象，如果在渲染时发生了错误</li>\n<li>xhr：XMLHttpRequest 对象（客户端渲染独有）</li>\n</ul>\n<p>因此，可以在组件的 getInitialProps 方法中处理上下文对象，控制传入组件的 props 数据。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\">export default class extends React.Component &#123;</span><br><span class=\"line\">  static async getInitialProps (&#123; req &#125;) &#123;</span><br><span class=\"line\">    return req</span><br><span class=\"line\">      ? &#123; userAgent: req.headers[&#x27;user-agent&#x27;] &#125;</span><br><span class=\"line\">      : &#123; userAgent: navigator.userAgent &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    return &lt;div&gt;</span><br><span class=\"line\">      Hello World &#123;this.props.userAgent&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子根据是否有 req 对象来判断是服务端渲染还是客户端渲染，然后采用对应的方式取得用户代码数据并传入组件的 props 中。</p>\n<h3 id=\"获取数据\"><a href=\"#获取数据\" class=\"headerlink\" title=\"获取数据\"></a>获取数据</h3><p>组件的 getInitialProps 还可以用来获取数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import &#x27;isomorphic-fetch&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class extends Component &#123;</span><br><span class=\"line\">  static async getInitialProps() &#123;</span><br><span class=\"line\">    const res = await fetch(&#x27;https://api.github.com/repos/zeit/next.js&#x27;);</span><br><span class=\"line\">    const json = await res.json();</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      stars: json.stargazers_count</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;div&gt;&#123;this.props.stars&#125;&lt;/div&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的一点是，getInitialProps 方法执行完毕之后，才会执行组件的 render 方法。这也就导致了如果网络状况不佳的情况下，会出现长时间的等待。并且只有每个页面的顶层组件的 getInitialProps 会被执行，所以想在子组件中获取数据的话只能在其他生命周期函数例如 componentDidMount 配合组件的 state 实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default class extends Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      stars: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  async componentDidMount() &#123;</span><br><span class=\"line\">    const res = await fetch(&#x27;https://api.github.com/repos/zeit/next.js&#x27;);</span><br><span class=\"line\">    const json = await res.json();</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      stars: json.stargazers_count</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;div&gt;&#123;this.state.stars&#125;&lt;/div&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、CSS\"><a href=\"#三、CSS\" class=\"headerlink\" title=\"三、CSS\"></a>三、CSS</h2><p>NEXT 组件中声明 CSS，目前主要有两种方式：</p>\n<ol>\n<li>内嵌 CSS</li>\n<li>CSS-in-JS</li>\n</ol>\n<h3 id=\"内嵌（Built-in）CSS\"><a href=\"#内嵌（Built-in）CSS\" class=\"headerlink\" title=\"内嵌（Built-in）CSS\"></a>内嵌（Built-in）CSS</h3><p>Next 采用的内嵌 CSS 方案是 styled-jsx 库，也是 Next 所推荐的 CSS 声明方式。优点是具有组件级的独立作用域，避免了样式污染问题。并且支持完整的 CSS 功能，如:hover 等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    Hello world</span><br><span class=\"line\">    &lt;p&gt;scoped!&lt;/p&gt;</span><br><span class=\"line\">    &lt;style jsx&gt;&#123;`</span><br><span class=\"line\">      p &#123;</span><br><span class=\"line\">        color: blue;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      div &#123;</span><br><span class=\"line\">        background: red;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      div:hover &#123;</span><br><span class=\"line\">        background: blue;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      @media (max-width: 600px) &#123;</span><br><span class=\"line\">        div &#123;</span><br><span class=\"line\">          background: blue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    `&#125;&lt;/style&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CSS-in-JS\"><a href=\"#CSS-in-JS\" class=\"headerlink\" title=\"CSS-in-JS\"></a>CSS-in-JS</h3><p>Next 支持多种 CSS-in-JS 方案，例如基本的在组件 style 属性中写样式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">  &lt;div style=&#123;&#123;color: red&#125;&#125;&gt;</span><br><span class=\"line\">    Hello world</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>还有其他的 CSS-in-JS 库，可以根据自己的需要和喜好灵活选择。</p>\n<h2 id=\"四、路由系统\"><a href=\"#四、路由系统\" class=\"headerlink\" title=\"四、路由系统\"></a>四、路由系统</h2><h3 id=\"Link-组件\"><a href=\"#Link-组件\" class=\"headerlink\" title=\"Link 组件\"></a>Link 组件</h3><p>Next 中提供了一个组件，用来实现路由功能。例如，我们的应用有两个页面：pages&#x2F;index.js 和 pages&#x2F;about.js，想要实现页面跳转，只需要：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// pages/index.js</span><br><span class=\"line\">import Link from &#x27;next/link&#x27;</span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">  &lt;div&gt;Click &lt;Link href=&quot;/about&quot;&gt;&lt;a&gt;here&lt;/a&gt;&lt;/Link&gt; to read more&lt;/div&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// pages/about.js</span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">  &lt;p&gt;Welcome to About!&lt;/p&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<Link>组件的工作流程和浏览器很相似：\n\n<ol>\n<li>获取新的组件</li>\n<li>如果新组件定义了 getInitialProps，则获取数据，如果发生错误，则渲染_error.js</li>\n<li>步骤 1，2 完成之后，执行 pushState 并渲染新组件<br>每个顶层组件中还会传入一个 url 对象，提供了几个路由相关的方法：</li>\n</ol>\n<ul>\n<li>pathname：String-当前 URL 不包括查询字符串的 path 部分</li>\n<li>query：Object-当前 URL 中查询字符串解析成的对象</li>\n<li>back-后退</li>\n<li>push(url, as&#x3D;url)-使用传入的 url（字符串）执行 pushState 操作</li>\n<li>replace(url, as&#x3D;url)-使用传入的 url（字符串）执行 replaceState 操作 注意：push 和 replace 方法中的第二个参数 as 为可选项，只有在服务端配置了自定义路由才有作用。</li>\n</ul>\n<h3 id=\"Router-对象\"><a href=\"#Router-对象\" class=\"headerlink\" title=\"Router 对象\"></a>Router 对象</h3><p>除了使用<Link>组件之外，Next 还提供了一个 Router 对象满足命令式写法的需要：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Router from &#x27;next/router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">  &lt;div&gt;Click &lt;span onClick=&#123;() =&gt; Router.push(&#x27;/about&#x27;)&#125;&gt;here&lt;/span&gt; to read more&lt;/div&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>与 url 对象相比，Router 对象多了一个 route 属性，值为当前的路由。 需要注意的是，Router 对象中的属性和方法仅可以在客户端部分使用，服务端渲染的页面无法使用，否则会报错。</p>\n<h3 id=\"路由事件\"><a href=\"#路由事件\" class=\"headerlink\" title=\"路由事件\"></a>路由事件</h3><p>Router 对象还提供了三个路由事件方法：</p>\n<ul>\n<li>routeChangeStart(url) - 路由变化开始时触发</li>\n<li>routeChangeComplete(url) - 路由变化完成时触发</li>\n<li>routeChangeError(err, url) - 路由变化发生错误时触发 如果使用 Router.push(url, as)或相似的方法并传入了 as 参数，则路由事件方法中的 url 参数值为 as 的值，否则，url 参数的值是路由跳转目标的 URL</li>\n</ul>\n<p><strong>注意</strong>：与 Router 对象中其他的属性和方法不同的是，这三个路由事件方法可以在服务端渲染的页面使用。</p>\n<p>监听路由变化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Router.onRouteChangeStart = (url) =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;App is changing to: &#x27;, url)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>取消监听：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Router.onRouteChangeStart = null;</span><br></pre></td></tr></table></figure>\n\n<p>如果路由加载取消了（连续快速点击两个链接），就会触发 routeChangeError 的回调，传入的 err 参数中将包含一个 cancelled 属性，值为 true。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Router.onRouteChangeError = (err, url) =&gt; &#123;</span><br><span class=\"line\">  if (err.cancelled) &#123;</span><br><span class=\"line\">    console.log(`Route to $&#123;url&#125; was cancelled!`)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、预获取页面\"><a href=\"#五、预获取页面\" class=\"headerlink\" title=\"五、预获取页面\"></a>五、预获取页面</h2><p>Next 提供了一个基于 ServiceWorker 实现的，具有预获取页面功能的模块：next&#x2F;prefetch。 使用预获取功能，可以使 APP 预加载那些可能到达的页面，提升网站的使用体验和性能。当然，前提是你的浏览器必须支持 ServiceWorker。并且预获取功能只支持应用内的页面，不支持外部链接。</p>\n<h3 id=\"组件-1\"><a href=\"#组件-1\" class=\"headerlink\" title=\"组件\"></a><Link>组件</h3><p>next&#x2F;prefetch 模块也提供了一个具有预获取功能的<Link>组件，代替路由系统中的<Link>组件，使用方法一致：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Link from &#x27;next/prefetch&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">  &lt;nav&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li&gt;&lt;Link href=&#x27;/&#x27;&gt;&lt;a&gt;Home&lt;/a&gt;&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">      &lt;li&gt;&lt;Link href=&#x27;/about&#x27;&gt;&lt;a&gt;About&lt;/a&gt;&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">      &lt;li&gt;&lt;Link href=&#x27;/contact&#x27;&gt;&lt;a&gt;Contact&lt;/a&gt;&lt;/Link&gt;&lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">  &lt;/nav&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>此外预获取功能可以精确控制到每个<Link>标签，使用 prefetch 属性来控制开关：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Link href=&#x27;/contact&#x27; prefetch=&#123;false&#125;&gt;&lt;a&gt;Home&lt;/a&gt;&lt;/Link&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"prefetch-方法\"><a href=\"#prefetch-方法\" class=\"headerlink\" title=\"prefetch 方法\"></a>prefetch 方法</h3><p>和路由器一样，预获取模块也提供了一个 prefetch 方法，用来方便命令式的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; prefetch &#125; from &#x27;next/prefetch&#x27;</span><br><span class=\"line\">export default (&#123; url &#125;) =&gt; (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;a onClick=&#123; () =&gt; setTimeout(() =&gt; url.pushTo(&#x27;/dynamic&#x27;), 100) &#125;&gt;</span><br><span class=\"line\">      100ms后执行路由跳转</span><br><span class=\"line\">    &lt;/a&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      预获取页面</span><br><span class=\"line\">      prefetch(&#x27;/dynamic&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义配置\"><a href=\"#自定义配置\" class=\"headerlink\" title=\"自定义配置\"></a>自定义配置</h3><p>如果默认的配置无法满足需要的话，Next 还提供了诸多的自定义配置接口，可以根据自己的需求灵活配置。</p>\n<h3 id=\"自定义服务器和路由\"><a href=\"#自定义服务器和路由\" class=\"headerlink\" title=\"自定义服务器和路由\"></a>自定义服务器和路由</h3><p>默认的服务器和路由系统可能无法满足需要，比如，我需要把&#x2F;a 的路由解析到 pages&#x2F;b.js，把&#x2F;b 的路由解析到 pages&#x2F;a.js，此时，就需要通过自定义，手动控制页面渲染来实现，在项目根目录下创建 server.js 文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// server.js</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; createServer &#125; = require(&#x27;http&#x27;)</span><br><span class=\"line\">const &#123; parse &#125; = require(&#x27;url&#x27;)</span><br><span class=\"line\">const next = require(&#x27;next&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">const dev = process.env.NODE_ENV !== &#x27;production&#x27;</span><br><span class=\"line\">const app = next(&#123; dev &#125;)</span><br><span class=\"line\">const handle = app.getRequestHandler()</span><br><span class=\"line\"></span><br><span class=\"line\">app.prepare().then(() =&gt; &#123;</span><br><span class=\"line\">  createServer((req, res) =&gt; &#123;</span><br><span class=\"line\">    const parsedUrl = parse(req.url, true)</span><br><span class=\"line\">    const &#123; pathname, query &#125; = parsedUrl</span><br><span class=\"line\"></span><br><span class=\"line\">    if (pathname === &#x27;/a&#x27;) &#123;</span><br><span class=\"line\">      app.render(req, res, &#x27;/b&#x27;, query)</span><br><span class=\"line\">    &#125; else if (pathname === &#x27;/b&#x27;) &#123;</span><br><span class=\"line\">      app.render(req, res, &#x27;/a&#x27;, query)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      handle(req, res, parsedUrl)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .listen(3000, (err) =&gt; &#123;</span><br><span class=\"line\">    if (err) throw err</span><br><span class=\"line\">    console.log(&#x27;&gt; Ready on http://localhost:3000&#x27;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>你可以选择自己喜欢的服务端框架，express 或者 koa 等，进行自定义。</p>\n<h3 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义<head></h3><p>Next 提供了<HEAD>组件，可以自定义页面<head>标签中的内容。每个组件都可以在内部自定义<head>的内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Head from &#x27;next/head&#x27;</span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;Head&gt;</span><br><span class=\"line\">      &lt;title&gt;My page title&lt;/title&gt;</span><br><span class=\"line\">      &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, width=device-width&quot; /&gt;</span><br><span class=\"line\">    &lt;/Head&gt;</span><br><span class=\"line\">    &lt;p&gt;Hello world!&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>每个页面组件只需要定义本页面需要的<head>内容，并且对于相同的标签，例如<title>。会按照组件渲染的顺序，后定义的覆盖先定义的内容。</p>\n<h3 id=\"自定义-1\"><a href=\"#自定义-1\" class=\"headerlink\" title=\"自定义\"></a>自定义<Document></h3><p>在前面的例子中，服务端渲染时，所有的页面我们只需要写内容组件，这是因为使用了默认的<Document>模板。当然，可以自定义自己的服务端渲染模板。首先，创建 pages&#x2F;_document.js 文件，写上内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// pages/_document.js</span><br><span class=\"line\">import Document, &#123; Head, Main, NextScript &#125; from &#x27;next/document&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class MyDocument extends Document &#123;</span><br><span class=\"line\">  static async getInitialProps (ctx) &#123;</span><br><span class=\"line\">    const props = await Document.getInitialProps(ctx)</span><br><span class=\"line\">    return &#123; ...props, customValue: &#x27;hi there!&#x27; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">     &lt;html&gt;</span><br><span class=\"line\">       &lt;Head&gt;</span><br><span class=\"line\">         &lt;style&gt;&#123;`body &#123; margin: 0 &#125; /* custom! */`&#125;&lt;/style&gt;</span><br><span class=\"line\">       &lt;/Head&gt;</span><br><span class=\"line\">       &lt;body className=&quot;custom_class&quot;&gt;</span><br><span class=\"line\">         &#123;this.props.customValue&#125;</span><br><span class=\"line\">         &lt;Main /&gt;</span><br><span class=\"line\">         &lt;NextScript /&gt;</span><br><span class=\"line\">       &lt;/body&gt;</span><br><span class=\"line\">     &lt;/html&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中的 ctx 对象与其他组件中的 getInitialProps 方法中收到的参数一样，只不过多了一个额外的方法：renderPage()。</p>\n<h3 id=\"自定义错误处理\"><a href=\"#自定义错误处理\" class=\"headerlink\" title=\"自定义错误处理\"></a>自定义错误处理</h3><p>Next 中，有一个默认组件 error.js，负责处理 404 或者 500 这种错误。当然，你也可以自定义一个_error.js 组件覆盖默认的错误处理组件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// _error.js</span><br><span class=\"line\"></span><br><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\">export default class Error extends React.Component &#123;</span><br><span class=\"line\">  static getInitialProps (&#123; res, xhr &#125;) &#123;</span><br><span class=\"line\">    const statusCode = res ? res.statusCode : (xhr ? xhr.status : null)</span><br><span class=\"line\">    return &#123; statusCode &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;p&gt;&#123;</span><br><span class=\"line\">        this.props.statusCode</span><br><span class=\"line\">        ? `An error $&#123;this.props.statusCode&#125; occurred on server`</span><br><span class=\"line\">        : &#x27;An error occurred on client&#x27;</span><br><span class=\"line\">      &#125;&lt;/p&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义配置-1\"><a href=\"#自定义配置-1\" class=\"headerlink\" title=\"自定义配置\"></a>自定义配置</h3><p>相对 Next 进行自定义配置的话，可以在项目根目录下创建一个 next.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// next.config.js</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  /* 自定义配置 */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义-Webpack-配置\"><a href=\"#自定义-Webpack-配置\" class=\"headerlink\" title=\"自定义 Webpack 配置\"></a>自定义 Webpack 配置</h3><p>在创建好的 next.config.js 文件中，可以扩展 Webpack 配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  webpack: (config, &#123; dev &#125;) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修改config对象</span><br><span class=\"line\"></span><br><span class=\"line\">    return config</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该函数接收默认的 Webpack config 对象作为参数，返回修改后的 config 对象。需要注意的是，next.config.js 文件会被直接执行，因为只能使用本机安装的 Node.js 所支持的 JS 语法。</p>\n<p><strong>警告：不建议</strong>在自定义 Webpack 配置中添加 loader 以支持新的文件类型！因为只有客户端渲染的代码会经过打包，而服务端执行的是源代码，并没有经过 Webpack 处理，因此新的 loader 对服务端渲染不起作用。所以最好是使用 Babel 插件来处理新的文件类型，因为无论是客户端还是服务端渲染的代码，都会经过 Babel 处理。</p>\n<h3 id=\"自定义-Babel-配置\"><a href=\"#自定义-Babel-配置\" class=\"headerlink\" title=\"自定义 Babel 配置\"></a>自定义 Babel 配置</h3><p>自定义 Babel 配置，只需要在项目根目录下创建.babelrc 文件，因为自定义配置会覆盖默认配置，而不是扩展默认配置。因此需要把 next preset 写到.babelrc 中。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    &quot;next/babel&quot;,  // Next默认配置</span><br><span class=\"line\">    &quot;stage-0&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p>生产模式下，需要先使用生产模式构建代码，再启动服务器。因此，需要两条命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">next build</span><br><span class=\"line\">next start</span><br></pre></td></tr></table></figure>\n\n<p>Next 官方推荐使用<a href=\"https://zeit.co/now\">now</a>作为部署工具，只要在 package.json 文件中写入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;my-app&quot;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;next&quot;: &quot;latest&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;dev&quot;: &quot;next&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;next build&quot;,</span><br><span class=\"line\">    &quot;start&quot;: &quot;next start&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着运行 now 命令，就可以实现一键部署。</p>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"Mysql常用命令行大全","url":"/2022/12/16/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/","content":"<h2 id=\"1、连接-Mysql\"><a href=\"#1、连接-Mysql\" class=\"headerlink\" title=\"1、连接 Mysql\"></a>1、连接 Mysql</h2><p>格式： mysql -h 主机地址 -u 用户名 －p 用户密码</p>\n<p><strong>1、连接到本机上的 MYSQL。</strong><br>首先打开 DOS 窗口，然后进入目录 mysql\\bin，再键入命令 mysql -u root -p，回车后提示你输密码.注意用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码。</p>\n<p>如果刚安装好 MYSQL，超级用户 root 是没有密码的，故直接回车即可进入到 MYSQL 中了，MYSQL 的提示符是： mysql&gt;</p>\n<p><strong>2、连接到远程主机上的 MYSQL</strong>。假设远程主机的 IP 为：110.110.110.110，用户名为 root,密码为 abcd123。则键入以下命令：<br>mysql -h110.110.110.110 -u root -p 123;（注:u 与 root 之间可以不用加空格，其它也一样）</p>\n<p><strong>3、退出 MYSQL 命令：</strong> exit （回车）</p>\n<h2 id=\"2、修改密码\"><a href=\"#2、修改密码\" class=\"headerlink\" title=\"2、修改密码\"></a>2、修改密码</h2><p>格式：mysqladmin -u 用户名 -p 旧密码 password 新密码</p>\n<p><strong>1、给 root 加个密码 ab12。</strong><br>首先在 DOS 下进入目录 mysql\\bin，然后键入以下命令<br>mysqladmin -u root -password ab12<br>注：因为开始时 root 没有密码，所以-p 旧密码一项就可以省略了。</p>\n<p><strong>2、再将 root 的密码改为 djg345。</strong><br>mysqladmin -u root -p ab12 password djg345</p>\n<h2 id=\"3、增加新用户\"><a href=\"#3、增加新用户\" class=\"headerlink\" title=\"3、增加新用户\"></a>3、增加新用户</h2><p>注意：和上面不同，下面的因为是 MYSQL 环境中的命令，所以后面都带一个分号作为命令结束符</p>\n<p>格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码”</p>\n<p><strong>1、增加一个用户 test1 密码为 abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用 root 用户连入 MYSQL，然后键入以下命令</strong>：</p>\n<pre><code>grant select,insert,update,delete on *.* to [email=test1@”%]test1@”%[/email]” Identified by “abc”;\n</code></pre>\n<p>但增加的用户是十分危险的，你想如某个人知道 test1 的密码，那么他就可以在 internet 上的任何一台电脑上登录你的 mysql 数据库并对你的数据可以为所欲为了，解决办法见 2。</p>\n<p><strong>2、增加一个用户 test2 密码为 abc,让他只可以在 localhost 上登录，并可以对数据库 mydb 进行查询、插入、修改、删除的操作（localhost 指本地主机，即 MYSQL 数据库所在的那台主机）</strong>，这样用户即使用知道 test2 的密码，他也无法从 internet 上直接访问数据库，只能通过 MYSQL 主机上的 web 页来访问了。</p>\n<pre><code>grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “abc”;\n</code></pre>\n<p>如果你不想 test2 有密码，可以再打一个命令将密码消掉。</p>\n<pre><code>grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “”;\n</code></pre>\n<h2 id=\"4-数据库操作\"><a href=\"#4-数据库操作\" class=\"headerlink\" title=\"4. 数据库操作\"></a>4. 数据库操作</h2><h3 id=\"4-1-创建数据库\"><a href=\"#4-1-创建数据库\" class=\"headerlink\" title=\"4.1 创建数据库\"></a>4.1 创建数据库</h3><p>注意：创建数据库之前要先连接 Mysql 服务器</p>\n<p>命令：create database &lt;数据库名&gt;</p>\n<p><strong>例 1：建立一个名为 xhkdb 的数据库</strong><br>mysql&gt; create database xhkdb;</p>\n<p><strong>例 2：创建数据库并分配用户</strong></p>\n<p>①CREATE DATABASE 数据库名;</p>\n<p>②GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON 数据库名.* TO 数据库名@localhost IDENTIFIED BY ‘密码’;</p>\n<p>③SET PASSWORD FOR ‘数据库名‘@’localhost’ &#x3D; OLD_PASSWORD(‘密码’);</p>\n<p>依次执行 3 个命令完成数据库创建。注意：中文 “密码”和“数据库”是户自己需要设置的。</p>\n<h3 id=\"4-2-显示数据库\"><a href=\"#4-2-显示数据库\" class=\"headerlink\" title=\"4.2 显示数据库\"></a>4.2 显示数据库</h3><p>命令：show databases （注意：最后有个 s）<br>mysql&gt; show databases;</p>\n<p>注意：为了不再显示的时候乱码，要修改数据库默认编码。以下以 GBK 编码页面为例进行说明：</p>\n<p><strong>1、修改 MYSQL 的配置文件</strong>：my.ini 里面修改 default-character-set&#x3D;gbk</p>\n<p><strong>2、代码运行时修改</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">①Java代码：jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=gbk</span><br><span class=\"line\"></span><br><span class=\"line\">②PHP代码：header(&quot;Content-Type:text/html;charset=gb2312&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">③C语言代码：int mysql_set_character_set( MYSQL * mysql, char * csname)；</span><br></pre></td></tr></table></figure>\n\n<p>该函数用于为当前连接设置默认的字符集。字符串 csname 指定了 1 个有效的字符集名称。连接校对成为字符集的默认校对。该函数的工作方式与 SET NAMES 语句类似，但它还能设置</p>\n<p>mysql- &gt; charset 的值，从而影响了由 mysql_real_escape_string() 设置的字符集。</p>\n<h3 id=\"4-3-删除数据库\"><a href=\"#4-3-删除数据库\" class=\"headerlink\" title=\"4.3 删除数据库\"></a>4.3 删除数据库</h3><p>命令：drop database &lt;数据库名&gt;<br>例如：删除名为 xhkdb 的数据库<br>mysql&gt; drop database xhkdb;</p>\n<p>例子 1：删除一个已经确定存在的数据库<br>mysql&gt; drop database drop_database;<br>Query OK, 0 rows affected (0.00 sec)</p>\n<p>例子 2：删除一个不确定存在的数据库<br>mysql&gt; drop database drop_database;<br>ERROR 1008 (HY000): Can’t drop database ‘drop_database’; database doesn’t exist<br>&#x2F;&#x2F;发生错误，不能删除’drop_database’数据库，该数据库不存在。</p>\n<p>mysql&gt; drop database if exists drop_database;<br>Query OK, 0 rows affected, 1 warning (0.00 sec)&#x2F;&#x2F;产生一个警告说明此数据库不存在</p>\n<p>mysql&gt; create database drop_database;<br>Query OK, 1 row affected (0.00 sec)</p>\n<p>mysql&gt; drop database if exists drop_database;&#x2F;&#x2F;if exists<br>判断数据库是否存在，不存在也不产生错误 Query OK, 0 rows affected (0.00 sec)</p>\n<h3 id=\"4-4-连接数据库\"><a href=\"#4-4-连接数据库\" class=\"headerlink\" title=\"4.4 连接数据库\"></a>4.4 连接数据库</h3><p>命令： use &lt;数据库名&gt;</p>\n<p>例如：如果 xhkdb 数据库存在，尝试存取它：<br>mysql&gt; use xhkdb;<br>屏幕提示：Database changed</p>\n<p><strong>use 语句可以通告 MySQL 把 db_name 数据库作为默认（当前）数据库使用，用于后续语句。</strong><br>该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的 USE 语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; USE db1;</span><br><span class=\"line\">mysql&gt; SELECT COUNT(*) FROM mytable;   # selects from db1.mytable</span><br><span class=\"line\">  mysql&gt; USE db2;</span><br><span class=\"line\">  mysql&gt; SELECT COUNT(*) FROM mytable;   # selects from db2.mytable</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用 USE 语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表</strong>。下面的例子可以从 db1 数据库访问作者表，并从 db2 数据库访问编辑表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; USE db1;</span><br><span class=\"line\">   mysql&gt; SELECT author_name,editor_name FROM author,db2.editor</span><br><span class=\"line\">       -&gt;        WHERE author.editor_id = db2.editor.editor_id;</span><br></pre></td></tr></table></figure>\n\n<p>USE 语句被设立出来，用于与 Sybase 相兼容。</p>\n<p>有些网友问到，连接以后怎么退出。其实，不用退出来，use 数据库后，使用 show databases 就能查询所有数据库，如果想跳到其他数据库，用<br>use 其他数据库名字<br>就可以了。</p>\n<h3 id=\"4-5-当前选择的数据库\"><a href=\"#4-5-当前选择的数据库\" class=\"headerlink\" title=\"4.5 当前选择的数据库\"></a>4.5 当前选择的数据库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">命令：mysql&gt; select database();</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL中SELECT命令类似于其他编程语言里的print或者write，你可以用它来显示一个字符串、数字、数学表达式的结果等等。如何使用MySQL中SELECT命令的特殊功能？</span><br><span class=\"line\"></span><br><span class=\"line\">1.显示MYSQL的版本</span><br><span class=\"line\">mysql&gt; select version();</span><br><span class=\"line\">+-----------------------+</span><br><span class=\"line\">| version()             |</span><br><span class=\"line\">+-----------------------+</span><br><span class=\"line\">| 6.0.4-alpha-community |</span><br><span class=\"line\">+-----------------------+</span><br><span class=\"line\">1 row in set (0.02 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">2. 显示当前时间</span><br><span class=\"line\">mysql&gt; select now();</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">| now()               |</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">| 2009-09-15 22:35:32 |</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">1 row in set (0.04 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">3. 显示年月日</span><br><span class=\"line\">SELECT DAYOFMONTH(CURRENT_DATE);</span><br><span class=\"line\">+--------------------------+</span><br><span class=\"line\">| DAYOFMONTH(CURRENT_DATE) |</span><br><span class=\"line\">+--------------------------+</span><br><span class=\"line\">|                       15 |</span><br><span class=\"line\">+--------------------------+</span><br><span class=\"line\">1 row in set (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT MONTH(CURRENT_DATE);</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">| MONTH(CURRENT_DATE) |</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">|                   9 |</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT YEAR(CURRENT_DATE);</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| YEAR(CURRENT_DATE) |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">|               2009 |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">4. 显示字符串</span><br><span class=\"line\">mysql&gt; SELECT &quot;welecome to my blog!&quot;;</span><br><span class=\"line\">+----------------------+</span><br><span class=\"line\">| welecome to my blog! |</span><br><span class=\"line\">+----------------------+</span><br><span class=\"line\">| welecome to my blog! |</span><br><span class=\"line\">+----------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">5. 当计算器用</span><br><span class=\"line\">select ((4 * 4) / 10 ) + 25;</span><br><span class=\"line\">+----------------------+</span><br><span class=\"line\">| ((4 * 4) / 10 ) + 25 |</span><br><span class=\"line\">+----------------------+</span><br><span class=\"line\">|                26.60 |</span><br><span class=\"line\">+----------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">6. 串接字符串</span><br><span class=\"line\">select CONCAT(f_name, &quot; &quot;, l_name)</span><br><span class=\"line\">AS Name</span><br><span class=\"line\">from employee_data</span><br><span class=\"line\">where title = &#x27;Marketing Executive&#x27;;</span><br><span class=\"line\">+---------------+</span><br><span class=\"line\">| Name          |</span><br><span class=\"line\">+---------------+</span><br><span class=\"line\">| Monica Sehgal |</span><br><span class=\"line\">| Hal Simlai    |</span><br><span class=\"line\">| Joseph Irvine |</span><br><span class=\"line\">+---------------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br><span class=\"line\">注意：这里用到CONCAT()函数，用来把字符串串接起来。另外，我们还用到以前学到的AS给结果列&#x27;CONCAT(f_name, &quot; &quot;, l_name)&#x27;起了个假名。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-数据表操作\"><a href=\"#5-数据表操作\" class=\"headerlink\" title=\"5. 数据表操作\"></a>5. 数据表操作</h2><h3 id=\"5-1-创建数据表\"><a href=\"#5-1-创建数据表\" class=\"headerlink\" title=\"5.1 创建数据表\"></a>5.1 创建数据表</h3><p>命令：create table &lt;表名&gt; ( &lt;字段名 1&gt; &lt;类型 1&gt; [,..&lt;字段名 n&gt; &lt;类型 n&gt;]);</p>\n<p>例如，建立一个名为 MyClass 的表，</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>数据类型</th>\n<th>数据宽度</th>\n<th>是否为空</th>\n<th>是否主键</th>\n<th>自动增加</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>int</td>\n<td>4</td>\n<td>否</td>\n<td>primary key</td>\n<td>auto_increment</td>\n<td></td>\n</tr>\n<tr>\n<td>name</td>\n<td>char</td>\n<td>20</td>\n<td>否</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sex</td>\n<td>int</td>\n<td>4</td>\n<td>否</td>\n<td></td>\n<td></td>\n<td>0</td>\n</tr>\n<tr>\n<td>degree</td>\n<td>double</td>\n<td>16</td>\n<td>是</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table MyClass(</span><br><span class=\"line\">&gt; id int(4) not null primary key auto_increment,</span><br><span class=\"line\">&gt; name char(20) not null,</span><br><span class=\"line\">&gt; sex int(4) not null default &#x27;0&#x27;,</span><br><span class=\"line\">&gt; degree double(16,2));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-删除数据表\"><a href=\"#5-2-删除数据表\" class=\"headerlink\" title=\"5.2 删除数据表\"></a>5.2 删除数据表</h3><p>命令：drop table &lt;表名&gt;</p>\n<p>例如：删除表名为 MyClass 的表</p>\n<p>mysql&gt; drop table MyClass;</p>\n<p>DROP TABLE 用于取消一个或多个表。您必须有每个表的 DROP 权限。所有的表数据和表定义会被取消，所以使用本语句要小心！</p>\n<p>注意：对于一个带分区的表，DROP TABLE 会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。DROP TABLE 还会取消与被取消的表有关联的分区定义（.par）文件。</p>\n<p>对于不存在的表，使用 IF EXISTS 用于防止错误发生。当使用 IF EXISTS 时，对于每个不存在的表，会生成一个 NOTE。</p>\n<p>RESTRICT 和 CASCADE 可以使分区更容易。目前，RESTRICT 和 CASCADE 不起作用。</p>\n<h3 id=\"5-3-表插入数据\"><a href=\"#5-3-表插入数据\" class=\"headerlink\" title=\"5.3 表插入数据\"></a>5.3 表插入数据</h3><p>命令：insert into &lt;表名&gt; [( &lt;字段名 1&gt;[,..&lt;字段名 n &gt; ])] values ( 值 1 )[, ( 值 n )]</p>\n<p>例如：往表 MyClass 中插入二条记录, 这二条记录表示：编号为 1 的名为 Tom 的成绩为 96.45, 编号为 2 的名为 Joan 的成绩为 82.99， 编号为 3 的名为 Wang 的成绩为 96.5。<br>mysql&gt; insert into MyClass values(1,’Tom’,96.45),(2,’Joan’,82.99), (2,’Wang’, 96.59);</p>\n<p>注意：insert into 每次只能向表中插入一条记录</p>\n<h3 id=\"5-4-查询表中的数据\"><a href=\"#5-4-查询表中的数据\" class=\"headerlink\" title=\"5.4 查询表中的数据\"></a>5.4 查询表中的数据</h3><p><strong>1)、查询所有行</strong><br>命令： select &lt;字段 1，字段 2，…&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt;<br>例如：查看表 MyClass 中所有数据<br>mysql&gt; select * from MyClass;</p>\n<p><strong>2）、查询前几行数据</strong><br>例如：查看表 MyClass 中前 2 行数据<br>mysql&gt; select * from MyClass order by id limit 0,2;</p>\n<p>select 一般配合 where 使用，以查询更精确更复杂的数据。</p>\n<h3 id=\"5-5-删除表中数据\"><a href=\"#5-5-删除表中数据\" class=\"headerlink\" title=\"5.5 删除表中数据\"></a>5.5 删除表中数据</h3><p>命令：delete from 表名 where 表达式</p>\n<p>例如：删除表 MyClass 中编号为 1 的记录</p>\n<p>mysql&gt; delete from MyClass where id&#x3D;1;</p>\n<p>下面是一个删除数据前后表的对比。</p>\n<table>\n<thead>\n<tr>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Peter</td>\n<td>Griffin</td>\n<td>35</td>\n</tr>\n<tr>\n<td>Glenn</td>\n<td>Quagmire</td>\n<td>33</td>\n</tr>\n</tbody></table>\n<p>下面以 PHP 代码为例删除 “Persons” 表中所有 LastName&#x3D;’Griffin’ 的记录：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">   $con = mysql_connect(&quot;localhost&quot;,&quot;peter&quot;,&quot;abc123&quot;);</span><br><span class=\"line\">   if (!$con)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      die(&#x27;Could not connect: &#x27; . mysql_error());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   mysql_select_db(&quot;my_db&quot;, $con);</span><br><span class=\"line\">   mysql_query(&quot;DELETE FROM Persons WHERE LastName=&#x27;Griffin&#x27;&quot;); mysql_close($con);</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在这次删除之后，表是这样的：</p>\n<table>\n<thead>\n<tr>\n<th>FirstName</th>\n<th>LastName</th>\n<th>Age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Glenn</td>\n<td>Quagmire</td>\n<td>33</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-6-修改表中数据\"><a href=\"#5-6-修改表中数据\" class=\"headerlink\" title=\"5.6 修改表中数据\"></a>5.6 修改表中数据</h3><p>语法：update 表名 set 字段&#x3D;新值,… where 条件<br>mysql&gt; update MyClass set name&#x3D;’Mary’ where id&#x3D;1;</p>\n<p><strong>例子 1：单表的 MySQL UPDATE 语句：</strong></p>\n<p>UPDATE [LOW_PRIORITY] [IGNORE] tbl_name SET col_name1&#x3D;expr1 [, col_name2&#x3D;expr2 …] [WHERE where_definition] [ORDER BY …] [LIMIT row_count]</p>\n<p><strong>例子 2：多表的 UPDATE 语句：</strong></p>\n<p>UPDATE [LOW_PRIORITY] [IGNORE] table_references SET col_name1&#x3D;expr1 [, col_name2&#x3D;expr2 …] [WHERE where_definition]</p>\n<p>UPDATE 语法可以用新值更新原有表行中的各列。SET 子句指示要修改哪些列和要给予哪些值。WHERE 子句指定应更新哪些行。如果没有 WHERE 子句，则更新所有的行。如果指定了 ORDER BY 子句，则按照被指定的顺序对行进行更新。LIMIT 子句用于给定一个限值，限制可以被更新的行的数目。</p>\n<h3 id=\"5-7-增加字段\"><a href=\"#5-7-增加字段\" class=\"headerlink\" title=\"5.7 增加字段\"></a>5.7 增加字段</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">命令：alter table 表名 add字段 类型 其他;</span><br><span class=\"line\">例如：在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0</span><br><span class=\"line\">   mysql&gt; alter table MyClass add passtest int(4) default &#x27;0&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">加索引</span><br><span class=\"line\">   mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]);</span><br><span class=\"line\">例子： mysql&gt; alter table employee add index emp_name (name);</span><br><span class=\"line\"></span><br><span class=\"line\">加主关键字的索引</span><br><span class=\"line\">  mysql&gt; alter table 表名 add primary key (字段名);</span><br><span class=\"line\">例子： mysql&gt; alter table employee add primary key(id);</span><br><span class=\"line\"></span><br><span class=\"line\">加唯一限制条件的索引</span><br><span class=\"line\">   mysql&gt; alter table 表名 add unique 索引名 (字段名);</span><br><span class=\"line\">例子： mysql&gt; alter table employee add unique emp_name2(cardnumber);</span><br><span class=\"line\"></span><br><span class=\"line\">删除某个索引</span><br><span class=\"line\">   mysql&gt; alter table 表名 drop index 索引名;</span><br><span class=\"line\">例子： mysql&gt;alter table employee drop index emp_name;</span><br><span class=\"line\"></span><br><span class=\"line\">增加字段：</span><br><span class=\"line\">mysql&gt; ALTER TABLE table_name ADD field_name field_type;</span><br><span class=\"line\"></span><br><span class=\"line\">修改原字段名称及类型：</span><br><span class=\"line\">mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type;</span><br><span class=\"line\"></span><br><span class=\"line\">删除字段：</span><br><span class=\"line\">MySQL ALTER TABLE table_name DROP field_name;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-8-修改表名\"><a href=\"#5-8-修改表名\" class=\"headerlink\" title=\"5.8 修改表名\"></a>5.8 修改表名</h3><p>命令：rename table 原表名 to 新表名;</p>\n<p>例如：在表 MyClass 名字更改为 YouClass<br>mysql&gt; rename table MyClass to YouClass;</p>\n<p>当你执行 RENAME 时，你不能有任何锁定的表或活动的事务。你同样也必须有对原初表的 ALTER 和 DROP 权限，以及对新表的 CREATE 和 INSERT 权限。</p>\n<p>如果在多表更名中，MySQL 遭遇到任何错误，它将对所有被更名的表进行倒退更名，将每件事物退回到最初状态。</p>\n<p>RENAME TABLE 在 MySQL 3.23.23 中被加入。</p>\n<h2 id=\"6、备份数据库\"><a href=\"#6、备份数据库\" class=\"headerlink\" title=\"6、备份数据库\"></a>6、备份数据库</h2><p>命令在 DOS 的[url&#x3D;file:&#x2F;&#x2F;\\mysql\\bin]\\mysql\\bin[&#x2F;url]目录下执行</p>\n<p>1.导出整个数据库<br>导出文件默认是存在 mysql\\bin 目录下<br>mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名<br>mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql</p>\n<p>2.导出一个表<br>mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名<br>mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql</p>\n<p>3.导出一个数据库结构<br>mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql<br>-d 没有数据 –add-drop-table 在每个 create 语句之前增加一个 drop table</p>\n<p>4.带语言参数导出<br>mysqldump -uroot -p –default-character-set&#x3D;latin1 –set-charset&#x3D;gbk –skip-opt database_name &gt; outfile_name.sql</p>\n<p>例如，将 aaa 库备份到文件 back_aaa 中：<br>　　[root@test1 root]# cd 　&#x2F;home&#x2F;data&#x2F;mysql<br>　　[root@test1 mysql]# mysqldump -u root -p –opt aaa &gt; back_aaa</p>\n<h2 id=\"7-实例\"><a href=\"#7-实例\" class=\"headerlink\" title=\"7. 实例\"></a>7. 实例</h2><h3 id=\"7-1-一个建库和建表的实例-1\"><a href=\"#7-1-一个建库和建表的实例-1\" class=\"headerlink\" title=\"7.1 一个建库和建表的实例 1\"></a>7.1 一个建库和建表的实例 1</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">drop database if exists school; //如果存在SCHOOL则删除</span><br><span class=\"line\">create database school; //建立库SCHOOL</span><br><span class=\"line\">use school; //打开库SCHOOL</span><br><span class=\"line\">create table teacher //建立表TEACHER</span><br><span class=\"line\">(</span><br><span class=\"line\">    id int(3) auto_increment not null primary key,</span><br><span class=\"line\">    name char(10) not null,</span><br><span class=\"line\">    address varchar(50) default ‘深圳’,</span><br><span class=\"line\">    year date</span><br><span class=\"line\">); //建表结束</span><br><span class=\"line\"></span><br><span class=\"line\">//以下为插入字段</span><br><span class=\"line\">insert into teacher values(”,’allen’,&#x27;大连一中’,&#x27;1976-10-10′);</span><br><span class=\"line\">insert into teacher values(”,’jack’,&#x27;大连二中’,&#x27;1975-12-23′);</span><br><span class=\"line\"></span><br><span class=\"line\">如果你在mysql提示符键入上面的命令也可以，但不方便调试。</span><br><span class=\"line\">1、你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\\\\下，并在DOS状态进入目录[url=file://\\\\mysql\\\\bin]\\\\mysql\\\\bin[/url]，然后键入以下命令：</span><br><span class=\"line\">    mysql -uroot -p密码 &lt; c:\\\\school.sql</span><br><span class=\"line\">如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。</span><br><span class=\"line\"></span><br><span class=\"line\">2、或者进入命令行后使用 mysql&gt; source c:\\\\school.sql; 也可以将school.sql文件导入数据库中。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-一个建库和建表的实例-2\"><a href=\"#7-2-一个建库和建表的实例-2\" class=\"headerlink\" title=\"7.2 一个建库和建表的实例 2\"></a>7.2 一个建库和建表的实例 2</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">drop database if exists school; //如果存在SCHOOL则删除</span><br><span class=\"line\">create database school; //建立库SCHOOL</span><br><span class=\"line\">use school; //打开库SCHOOL</span><br><span class=\"line\">create table teacher //建立表TEACHER</span><br><span class=\"line\">(</span><br><span class=\"line\">    id int(3) auto_increment not null primary key,</span><br><span class=\"line\">    name char(10) not null,</span><br><span class=\"line\">    address varchar(50) default &#x27;&#x27;深圳&#x27;&#x27;,</span><br><span class=\"line\">    year date</span><br><span class=\"line\">); //建表结束</span><br><span class=\"line\"></span><br><span class=\"line\">//以下为插入字段</span><br><span class=\"line\">insert into teacher values(&#x27;&#x27;&#x27;&#x27;,&#x27;&#x27;glchengang&#x27;&#x27;,&#x27;&#x27;深圳一中&#x27;&#x27;,&#x27;&#x27;1976-10-10&#x27;&#x27;);</span><br><span class=\"line\">insert into teacher values(&#x27;&#x27;&#x27;&#x27;,&#x27;&#x27;jack&#x27;&#x27;,&#x27;&#x27;深圳一中&#x27;&#x27;,&#x27;&#x27;1975-12-23&#x27;&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>注：在建表中</p>\n<p>1、将 ID 设为长度为 3 的数字字段:int(3)；并让它每个记录自动加一:auto_increment；并不能为空:not null；而且让他成为主字段 primary key。</p>\n<p>2、将 NAME 设为长度为 10 的字符字段</p>\n<p>3、将 ADDRESS 设为长度 50 的字符字段，而且缺省值为深圳。</p>\n<p>4、将 YEAR 设为日期字段。</p>\n<h2 id=\"8、Mysql-语句记录\"><a href=\"#8、Mysql-语句记录\" class=\"headerlink\" title=\"8、Mysql 语句记录\"></a>8、Mysql 语句记录</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">use mysql;</span><br><span class=\"line\">set password for &#x27;root&#x27;@&#x27;localhost&#x27;=password(&#x27;123456&#x27;);</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure>\n","categories":["常用指令合集"],"tags":["javascript"]},{"title":"NodeJs基础知识点","url":"/2022/12/16/NodeJs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"<h2 id=\"1-nodejs-的特点\"><a href=\"#1-nodejs-的特点\" class=\"headerlink\" title=\"1.nodejs 的特点\"></a>1.nodejs 的特点</h2><h3 id=\"1-单线程\"><a href=\"#1-单线程\" class=\"headerlink\" title=\"1)单线程\"></a>1)单线程</h3><p>在 Java、PHP 等服务器语言中，会为每一个客户端创建一个新的线程，而每个线程需要消耗大约 2MB 的内存。也就是说，一个 8GB 的内存可以满足 4000 人</p>\n<p>的访问连接，这样就增加了服务器的硬件成本。Nodejs 不需要为每个用户的连接创建一个新的线程，而仅仅使用一个线程，一个 8GB 的内存可以满足<br>40000 人的连接。</p>\n<ul>\n<li>好处：操作系统不会再有创建线程、销毁线程的开销。</li>\n<li>坏处：如果一个用户导致了线程的奔溃，那么整个服务就奔溃了。</li>\n</ul>\n<h3 id=\"2-非阻塞-I-x2F-O\"><a href=\"#2-非阻塞-I-x2F-O\" class=\"headerlink\" title=\"2)非阻塞 I&#x2F;O\"></a>2)非阻塞 I&#x2F;O</h3><p>由于 Nodejs 采用了非阻塞 I&#x2F;O 机制，因此在执行访问数据库的代码后，立即转而执行其后的代码，把数据库返回结果的代码处理放在了回调函数中，从而提高了<br>程序的执行效率。</p>\n<p>当某个 I&#x2F;O 执行完毕时，将以事件的形式通知执行 I&#x2F;O 的线程，线程执行这个事件的回调函数，为了处理这个异步 I&#x2F;O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。</p>\n<h3 id=\"3-事件驱动\"><a href=\"#3-事件驱动\" class=\"headerlink\" title=\"3)事件驱动\"></a>3)事件驱动</h3><p>在 nodejs 中，客户端请求建立连接，数据提交等行为，会触发相应的事件。在 nodejs 中，在一个时刻只能执行一个事件的回调函数，但是在执行一个事件回调函数<br>的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为‘事件环’机制。</p>\n<h2 id=\"2-nodejs-适合开发什么样的业务？\"><a href=\"#2-nodejs-适合开发什么样的业务？\" class=\"headerlink\" title=\"2.nodejs 适合开发什么样的业务？\"></a>2.nodejs 适合开发什么样的业务？</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">当应用程序需要处理大量并发的I/O，而在向客户端响应之前，应用程序内部不需要进行非常复杂处理的时候，nodejs非常合适。nodejs也非常适合与websocket</span><br><span class=\"line\">配合，开发长连接的实时交互应用程序。</span><br><span class=\"line\">总之，nodejs擅长任务的调度，善于I/O，不善于计算。</span><br><span class=\"line\">比如：1)用户表单收集  2)考试系统 3)聊天室 4)图文直播 5)提供JSON的api</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-第一个简单的-node-程序\"><a href=\"#3-第一个简单的-node-程序\" class=\"headerlink\" title=\"3.第一个简单的 node 程序\"></a>3.第一个简单的 node 程序</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let http = require(&#x27;http&#x27;);</span><br><span class=\"line\">// 创建服务器，参数是一个回调函数，表示如果有请求进来要做什么</span><br><span class=\"line\"> let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">     // 设置http头部，状态码是200，文件类型是html，字符集是utf8</span><br><span class=\"line\">     res.writeHead(200,&#123;&quot;Content-type&quot;:&quot;text/html;charset=UTF-8&quot;&#125;);</span><br><span class=\"line\">     res.end(&#x27;这是我的第一个Node页面&#x27;);</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"> // 运行服务器</span><br><span class=\"line\"> server.listen(3000,&#x27;192.168.124.15&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>问：如何将 html 页面展示到浏览器中呢</strong>？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">利用引入fs模块</span><br><span class=\"line\">let http = require(&#x27;http&#x27;);</span><br><span class=\"line\">let fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\">let path = require(&#x27;path&#x27;);</span><br><span class=\"line\">let PULIC_PATH = path.resolve(__dirname,&#x27;01_helloWorld.html&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建服务器，参数是一个回调函数，表示如果有请求进来要做什么</span><br><span class=\"line\">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">    fs.readFile(PULIC_PATH,(err,data)=&gt;&#123;</span><br><span class=\"line\">        console.log(&#x27;data&#x27;,data,err);</span><br><span class=\"line\">        // 设置http头部，状态码是200，文件类型是html，字符集是utf8</span><br><span class=\"line\">        res.writeHead(200,&#123;&quot;Content-type&quot;:&quot;text/html;charset=UTF-8&quot;&#125;);</span><br><span class=\"line\">        res.end(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 运行服务器</span><br><span class=\"line\">server.listen(3000,&#x27;192.168.1.9&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>问：如何根据不同的路由展示不同的页面？</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let http = require(&#x27;http&#x27;);</span><br><span class=\"line\">let fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\">let PUBILC_PATH = require(&#x27;path&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建服务器，参数是一个回调函数，表示如果有请求进来要做什么</span><br><span class=\"line\">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">    if (req.url == &#x27;/sqaure&#x27;) &#123;</span><br><span class=\"line\">        let path = PUBILC_PATH.resolve(__dirname,&#x27;01_helloWorld.html&#x27;);</span><br><span class=\"line\">        fs.readFile(path,(err,data)=&gt;&#123;</span><br><span class=\"line\">            console.log(&#x27;data&#x27;,data,err);</span><br><span class=\"line\">            // 设置http头部，状态码是200，文件类型是html，字符集是utf8</span><br><span class=\"line\">            res.writeHead(200,&#123;&quot;Content-type&quot;:&quot;text/html;charset=UTF-8&quot;&#125;);</span><br><span class=\"line\">            res.end(data);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; else if (req.url == &#x27;/circle&#x27;) &#123;</span><br><span class=\"line\">        let path = PUBILC_PATH.resolve(__dirname,&#x27;01_helloWorld_circle.html&#x27;);</span><br><span class=\"line\">        fs.readFile(path,(err,data)=&gt;&#123;</span><br><span class=\"line\">            console.log(&#x27;data&#x27;,data,err);</span><br><span class=\"line\">            // 设置http头部，状态码是200，文件类型是html，字符集是utf8</span><br><span class=\"line\">            res.writeHead(200,&#123;&quot;Content-type&quot;:&quot;text/html;charset=UTF-8&quot;&#125;);</span><br><span class=\"line\">            res.end(data);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        res.writeHead(404,&#123;&quot;Content-type&quot;:&quot;text/html;charset=UTF-8&quot;&#125;);</span><br><span class=\"line\">        res.end(&#x27;没有这个页面哦&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 运行服务器</span><br><span class=\"line\">server.listen(3000,&#x27;192.168.1.9&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">说明：在浏览器中输入http://192.168.1.9:3000/circle即可</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-http-模块与-url-模块\"><a href=\"#4-http-模块与-url-模块\" class=\"headerlink\" title=\"4.http 模块与 url 模块\"></a>4.http 模块与 url 模块</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">实例：</span><br><span class=\"line\">    let http = require(&#x27;http&#x27;);</span><br><span class=\"line\">    let url = require(&#x27;url&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">        let path = url.parse(req.url);</span><br><span class=\"line\">        /*</span><br><span class=\"line\">            Url &#123;</span><br><span class=\"line\">                protocol: null,</span><br><span class=\"line\">                slashes: null,</span><br><span class=\"line\">                auth: null,</span><br><span class=\"line\">                host: null,</span><br><span class=\"line\">                port: null,</span><br><span class=\"line\">                hostname: null,</span><br><span class=\"line\">                hash: null,</span><br><span class=\"line\">                search: &#x27;?name=wq&amp;age=20&#x27;,</span><br><span class=\"line\">                query: &#x27;name=wq&amp;age=20&#x27;,</span><br><span class=\"line\">                pathname: &#x27;/user&#x27;,</span><br><span class=\"line\">                path: &#x27;/user?name=wq&amp;age=20&#x27;,</span><br><span class=\"line\">                href: &#x27;/user?name=wq&amp;age=20&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        */</span><br><span class=\"line\">        console.log(&#x27;服务器接收到了请求1：&#x27;,path);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将第二个参数设为true，就把query参数变为Object</span><br><span class=\"line\">        let path2 = url.parse(req.url,true);</span><br><span class=\"line\">        /*</span><br><span class=\"line\">            Url &#123;</span><br><span class=\"line\">                protocol: null,</span><br><span class=\"line\">                slashes: null,</span><br><span class=\"line\">                auth: null,</span><br><span class=\"line\">                host: null,</span><br><span class=\"line\">                port: null,</span><br><span class=\"line\">                hostname: null,</span><br><span class=\"line\">                hash: null,</span><br><span class=\"line\">                search: &#x27;?name=wq&amp;age=20&#x27;,</span><br><span class=\"line\">                query: [Object: null prototype] &#123; name: &#x27;wq&#x27;, age: &#x27;20&#x27; &#125;,</span><br><span class=\"line\">                pathname: &#x27;/user&#x27;,</span><br><span class=\"line\">                path: &#x27;/user?name=wq&amp;age=20&#x27;,</span><br><span class=\"line\">                href: &#x27;/user?name=wq&amp;age=20&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        */</span><br><span class=\"line\">        console.log(&#x27;服务器接收到了请求2：&#x27;,path2);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 设置一个相应头</span><br><span class=\"line\">        res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/html;charset=UTF-8&quot;&#125;);</span><br><span class=\"line\">        // 每个请求都应该加上.end()方法，不然，浏览器请求会一直转菊花等待后端结束</span><br><span class=\"line\">        res.end(&#x27;&lt;h1&gt;响应头&lt;/h1&gt;&#x27;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.listen(3000,&#x27;192.168.1.9&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>实操：做一个简单的表单提交</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;form action=&quot;http://192.168.1.9:3000&quot; method=&quot;GET&quot;&gt;</span><br><span class=\"line\">       &lt;input name=&#x27;name&#x27; /&gt;</span><br><span class=\"line\">       &lt;input name=&#x27;age&#x27; /&gt;</span><br><span class=\"line\">       &lt;input name=&#x27;sex&#x27; /&gt;</span><br><span class=\"line\">       &lt;input type=&quot;submit&quot;&gt;</span><br><span class=\"line\">   &lt;/form&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   let http = require(&#x27;http&#x27;);</span><br><span class=\"line\">   let url = require(&#x27;url&#x27;);</span><br><span class=\"line\">   let queryString = require(&#x27;querystring&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">   let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">       let queryObj = url.parse(req.url,true).query;</span><br><span class=\"line\">       // querystring的作用与上句作用一样</span><br><span class=\"line\">       let queryObj2 = queryString.parse(req.url.split(&#x27;?&#x27;)[1]);</span><br><span class=\"line\">       console.log(&#x27;参数&#x27;,queryObj,queryObj2);</span><br><span class=\"line\"></span><br><span class=\"line\">       res.end(&#x27;服务器收到了参数&#x27;);</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">   server.listen(3000,&#x27;192.168.1.9&#x27;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-fs-模块\"><a href=\"#5-fs-模块\" class=\"headerlink\" title=\"5.fs 模块\"></a>5.fs 模块</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let http = require(&#x27;http&#x27;);</span><br><span class=\"line\">let fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    let userID = parseInt(Math.random()*89999)+10000;</span><br><span class=\"line\">    console.log(userID+&#x27;进入连接...&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">    res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html;charset=utf-8&#x27;,&#x27;Access-Control-Allow-Origin&#x27;:&#x27;*&#x27;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 读取文件</span><br><span class=\"line\">    fs.readFile(&#x27;../笔记.txt&#x27;,(error,data)=&gt;&#123;</span><br><span class=\"line\">        console.log(error,data);</span><br><span class=\"line\">        if (error) &#123;</span><br><span class=\"line\">            throw error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        console.log(userID+&#x27;读取完毕...&#x27;)</span><br><span class=\"line\">        res.end();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建文件夹</span><br><span class=\"line\">    fs.mkdir(`./image/$&#123;userID&#125;`);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 读取文件状态</span><br><span class=\"line\">    fs.stat(&#x27;../笔记.txt&#x27;,(error,stats)=&gt;&#123;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">            Stats &#123;</span><br><span class=\"line\">                dev: 580307240,</span><br><span class=\"line\">                mode: 33206,</span><br><span class=\"line\">                nlink: 1,</span><br><span class=\"line\">                uid: 0,</span><br><span class=\"line\">                gid: 0,</span><br><span class=\"line\">                rdev: 0,</span><br><span class=\"line\">                blksize: 4096,</span><br><span class=\"line\">                ino: 10696049115206348,</span><br><span class=\"line\">                size: 7275,   // 文件的大小（以字节为单位）</span><br><span class=\"line\">                blocks: 16,</span><br><span class=\"line\">                atimeMs: 1579832397095.3948, // 表明上次访问此文件的时间戳</span><br><span class=\"line\">                mtimeMs: 1579872595571.8716, // 表明上次修改此文件的时间戳</span><br><span class=\"line\">                ctimeMs: 1579872595571.8716,  // 表明上次更改文件状态的时间戳</span><br><span class=\"line\">                birthtimeMs: 1579832397095.3948, // 表明此文件的创建时间的时间戳</span><br><span class=\"line\">                atime: 2020-01-24T02:19:57.095Z,</span><br><span class=\"line\">                mtime: 2020-01-24T13:29:55.572Z,</span><br><span class=\"line\">                ctime: 2020-01-24T13:29:55.572Z,</span><br><span class=\"line\">                birthtime: 2020-01-24T02:19:57.095Z</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        */</span><br><span class=\"line\">        console.log(&#x27;读取文件状态&#x27;,stats);</span><br><span class=\"line\">        console.log(&#x27;是否是文件夹：&#x27;,stats.isDirectory());</span><br><span class=\"line\">        console.log(&#x27;是否是文件：&#x27;,stats.isFile());</span><br><span class=\"line\">        res.end();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 存储所有文件夹名</span><br><span class=\"line\">    let dictionary = [];</span><br><span class=\"line\">    // 查看文件夹中有多少文件</span><br><span class=\"line\">    fs.readdir(&#x27;../node&#x27;,(error,files)=&gt;&#123;</span><br><span class=\"line\">        // 以数组的形式输出node文件夹中所有的文件名</span><br><span class=\"line\">        /*</span><br><span class=\"line\">            [</span><br><span class=\"line\">                &#x27;01_helloWorld.html&#x27;,</span><br><span class=\"line\">                &#x27;01_helloWorld.js&#x27;,</span><br><span class=\"line\">                &#x27;01_helloWorld_circle.html&#x27;,</span><br><span class=\"line\">                &#x27;02_helloWorld.js&#x27;,</span><br><span class=\"line\">                &#x27;02_表单提交.html&#x27;,</span><br><span class=\"line\">                &#x27;03_router.js&#x27;,</span><br><span class=\"line\">                &#x27;04_EventLoop.js&#x27;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        */</span><br><span class=\"line\">        console.log(&#x27;node文件夹下的文件名：&#x27;,files);</span><br><span class=\"line\">        files.map(item =&gt; &#123;</span><br><span class=\"line\">            fs.stat(`./$&#123;item&#125;`,(error,stats)=&gt;&#123;</span><br><span class=\"line\">                if (stats.isDirectory()) &#123;</span><br><span class=\"line\">                    dictionary.push(item);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                console.log(&#x27;文件夹：&#x27;+dictionary);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        res.end();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(3000,&#x27;192.168.1.9&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 实例：获取某个文件夹中所有文件(夹)的名字</span><br><span class=\"line\">let http = require(&#x27;http&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">    fs.readdir(&#x27;../node&#x27;,(error,files)=&gt;&#123;</span><br><span class=\"line\">        // 存放文件夹的数组</span><br><span class=\"line\">        let dictionary = [];</span><br><span class=\"line\">        (function iterator(i)&#123;</span><br><span class=\"line\">            if (i == files.length) &#123;</span><br><span class=\"line\">                res.end(&#x27;获取目录结束...&#x27;);</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fs.stat(`../node/$&#123;files[i]&#125;`,(err,stats)=&gt;&#123;</span><br><span class=\"line\">                if (stats.isDirectory()) &#123;</span><br><span class=\"line\">                    dictionary.push(files[i]);</span><br><span class=\"line\">                    console.log(&#x27;dictionary&#x27;,dictionary)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                iterator(i+1);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)(0)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(3000,&#x27;192.168.1.9&#x27;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-制作一个静态资源文件管理\"><a href=\"#6-制作一个静态资源文件管理\" class=\"headerlink\" title=\"6.制作一个静态资源文件管理\"></a>6.制作一个静态资源文件管理</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 意思是：新建一个static文件夹，文件夹下有1.html文件，可以通过http://192.168.1.9:3000/1.html去访问</span><br><span class=\"line\">let http = require(&#x27;http&#x27;);</span><br><span class=\"line\">let url = require(&#x27;url&#x27;);</span><br><span class=\"line\">let fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\">let path = require(&#x27;path&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">    // 获取路径</span><br><span class=\"line\">    let pathName = url.parse(req.url).pathname;</span><br><span class=\"line\">    if (pathName == &#x27;/&#x27;) &#123;</span><br><span class=\"line\">        pathName = &#x27;index.html&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 获取文件拓展名</span><br><span class=\"line\">    let extname = path.extname(pathName);</span><br><span class=\"line\">    console.log(&#x27;获取文件拓展名&#x27;,extname);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取文件</span><br><span class=\"line\">    fs.readFile(&#x27;./static/&#x27;+pathName,(error,data)=&gt;&#123;</span><br><span class=\"line\">        if (error) &#123;</span><br><span class=\"line\">            fs.readFile(&#x27;./static/404.html&#x27;,(err,errData)=&gt;&#123;</span><br><span class=\"line\">                console.log(&#x27;errrr&#x27;,err,errData)</span><br><span class=\"line\">                res.writeHead(404,&#123;&#x27;Content-Type&#x27;:&#x27;text/html;charset=UTF8&#x27;&#125;);</span><br><span class=\"line\">                res.end(errData);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.writeHead(200,&#123;&quot;Content-Type&quot;:getMIME(extname)&#125;)</span><br><span class=\"line\">        res.end(data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(3000,&#x27;192.168.1.9&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">function getMIME(extname)&#123;</span><br><span class=\"line\">    switch(extname)&#123;</span><br><span class=\"line\">        case &quot;.html&quot;:</span><br><span class=\"line\">            return &quot;text/html&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &quot;.jpg&quot;:</span><br><span class=\"line\">            return &quot;image/jpg&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &quot;.css&quot;:</span><br><span class=\"line\">            return &quot;text/css&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-文件夹模块和-package-文件\"><a href=\"#7-文件夹模块和-package-文件\" class=\"headerlink\" title=\"7.文件夹模块和 package 文件\"></a>7.文件夹模块和 package 文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1)在js文件中引用，如果不写./ ， 会默认查找node_modules文件夹下的文件</span><br><span class=\"line\"></span><br><span class=\"line\">test.js文件</span><br><span class=\"line\">let foo = require(&#x27;foo.js&#x27;);</span><br><span class=\"line\">console.log(foo);</span><br><span class=\"line\"></span><br><span class=\"line\">node_modules文件夹下foo.js文件</span><br><span class=\"line\">let a = 200;</span><br><span class=\"line\">exports.b = b;</span><br><span class=\"line\"></span><br><span class=\"line\">2)在js文件中，如果引用不加扩展名，默认引用文件夹下index.js文件</span><br><span class=\"line\"></span><br><span class=\"line\">test.js文件</span><br><span class=\"line\">let a = &#x27;bar&#x27;;</span><br><span class=\"line\">exports.a = a;</span><br><span class=\"line\"></span><br><span class=\"line\">node_modules文件夹下bar文件夹下的index.js文件</span><br><span class=\"line\">let a = &#x27;bar&#x27;;</span><br><span class=\"line\">exports.a = a;</span><br><span class=\"line\"></span><br><span class=\"line\">问：如果修改bar文件夹下index.js文件夹名为app.js，如何修改才能正常引用？</span><br><span class=\"line\">在bar文件夹下新建文件package.json,</span><br><span class=\"line\">package.json文件</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;: &quot;app&quot;,</span><br><span class=\"line\">    &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class=\"line\">    &quot;main&quot;: &quot;app.js&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">3)package.json管理依赖</span><br><span class=\"line\">在根文件夹下执行命令npm init，会生成package.json文件</span><br><span class=\"line\">package.json中：</span><br><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;moment&quot;: &quot;^2.24.0&quot;   // ^在谁前面就表示谁不变，在这里就表示2的大版本保持不变</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">4)路径注意问题</span><br><span class=\"line\">前提：同级目录下有a.js文件和text文件夹，text文件夹下有b.js和c.js</span><br><span class=\"line\">引用：</span><br><span class=\"line\">    1.a引用b</span><br><span class=\"line\">        let b = require(&#x27;./text/b.js);</span><br><span class=\"line\">    2.b引用c</span><br><span class=\"line\">        let c = require(&#x27;./c.js);</span><br><span class=\"line\">注意：引用都是从当前文件寻找其他文件</span><br><span class=\"line\">问：如果b.js中需要引入像fs等第三方模块读取文件时，如何引用？</span><br><span class=\"line\">    使用绝对路径__dirname：</span><br><span class=\"line\">    fs.readFile(__dirname+&#x27;/1.txt&#x27;,()=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-POST-请求\"><a href=\"#8-POST-请求\" class=\"headerlink\" title=\"8.POST 请求\"></a>8.POST 请求</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input id=&#x27;name&#x27; /&gt;</span><br><span class=\"line\">&lt;input id=&#x27;age&#x27; /&gt;</span><br><span class=\"line\">&lt;input id=&#x27;submit&#x27; type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    document.getElementById(&#x27;submit&#x27;).onclick=()=&gt;&#123;</span><br><span class=\"line\">        let name = document.getElementById(&#x27;name&#x27;).value;</span><br><span class=\"line\">        let age = document.getElementById(&#x27;age&#x27;).value;</span><br><span class=\"line\"></span><br><span class=\"line\">        let xhr = new XMLHttpRequest();</span><br><span class=\"line\">        xhr.open(&#x27;POST&#x27;,&#x27;http://192.168.1.9:3000&#x27;);</span><br><span class=\"line\">        xhr.addEventListener(&#x27;load&#x27;,function()&#123;</span><br><span class=\"line\">            console.log(this.response);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        let obj = &#123;</span><br><span class=\"line\">            name,</span><br><span class=\"line\">            age</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        xhr.send(JSON.stringify(obj));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">let http = require(&#x27;http&#x27;);</span><br><span class=\"line\">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">    if (req.method == &quot;POST&quot;) &#123;</span><br><span class=\"line\">        let allData = &#x27;&#x27;;</span><br><span class=\"line\">        req.on(&#x27;data&#x27;,(chunk)=&gt;&#123;</span><br><span class=\"line\">            allData += chunk;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        req.on(&#x27;end&#x27;,()=&gt;&#123;</span><br><span class=\"line\">            res.writeHead(200,&#123;&#x27;Content-Type&#x27;:&#x27;text/html&#x27;,&#x27;Access-Control-Allow-Origin&#x27;:&#x27;*&#x27;&#125;);</span><br><span class=\"line\">            res.end(allData);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">server.listen(3000,&#x27;192.168.1.9&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">例：实现上传图片</span><br><span class=\"line\">前提：npm install formidable</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;form action=&quot;http://192.168.1.9:3000&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; name=&#x27;descript&#x27; /&gt;</span><br><span class=\"line\">    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</span><br><span class=\"line\">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">let http = require(&#x27;http&#x27;);</span><br><span class=\"line\">let formidable = require(&#x27;formidable&#x27;);</span><br><span class=\"line\">let fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\">let path = require(&#x27;path&#x27;);</span><br><span class=\"line\">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">    if (req.method == &quot;POST&quot;) &#123;</span><br><span class=\"line\">        let form = new formidable.IncomingForm();</span><br><span class=\"line\">        // 设置文件上传存储地址</span><br><span class=\"line\">        form.uploadDir = &#x27;./upLoads&#x27;;</span><br><span class=\"line\">        // 所有的文本域、单选框等都存放在fields中；所有的文件域都存放在files中</span><br><span class=\"line\">        form.parse(req,(err,fields,files)=&gt;&#123;</span><br><span class=\"line\">            // 修改文件名</span><br><span class=\"line\">            let oldPath = __dirname + &quot;/&quot; + files.file.path;</span><br><span class=\"line\">            let newPath = __dirname + &quot;/upLoads&quot; + &quot;/&quot; + fields.descript + path.extname(files.file.name);</span><br><span class=\"line\">            console.log(&#x27;修改文件名&#x27;,oldPath,newPath);</span><br><span class=\"line\">            fs.rename(oldPath,newPath,(error)=&gt;&#123;</span><br><span class=\"line\">                if (error) &#123;</span><br><span class=\"line\">                    throw Error(&#x27;改名失败！&#x27;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/plain;charset=utf-8&quot;&#125;);</span><br><span class=\"line\">                res.end(&#x27;上传成功&#x27;);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">server.listen(3000,&#x27;192.168.1.9&#x27;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-模板引擎\"><a href=\"#9-模板引擎\" class=\"headerlink\" title=\"9.模板引擎\"></a>9.模板引擎</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1)ejs模板引擎:是一种后端模板引擎</span><br><span class=\"line\"></span><br><span class=\"line\">let ejs = require(&#x27;ejs&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let str = &#x27;今天买了&lt;%= a %&gt;s&#x27;;</span><br><span class=\"line\">let data = &#123;</span><br><span class=\"line\">    a:6,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let html = ejs.render(str,data)</span><br><span class=\"line\">console.log(html);  // 今天买了6s</span><br><span class=\"line\"></span><br><span class=\"line\">问：如何读取ejs页面？</span><br><span class=\"line\"></span><br><span class=\"line\">index.ejs</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;今天买了&lt;%= a %&gt;s&lt;/h1&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">let ejs = require(&#x27;ejs&#x27;);</span><br><span class=\"line\">let fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\">let http = require(&#x27;http&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">    fs.readFile(&quot;./views/ejs01.ejs&quot;,(err,data)=&gt;&#123;</span><br><span class=\"line\">        let template = data.toString();</span><br><span class=\"line\">        let obj = &#123; a: 6&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        let html = ejs.render(template,obj);</span><br><span class=\"line\"></span><br><span class=\"line\">        res.writeHead(200,&#123;&#x27;Content-Type&#x27;:&#x27;text/html;charset=utf-8&#x27;,&#x27;Access-Control-Allow-Origin&#x27;:&#x27;*&#x27;&#125;);</span><br><span class=\"line\">        res.end(html);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">server.listen(8000,&#x27;127.0.0.1&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">2)Jade模板引擎：也是一种后端模板引擎，省略了html标签</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-Express-框架\"><a href=\"#10-Express-框架\" class=\"headerlink\" title=\"10.Express 框架\"></a>10.Express 框架</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Express是后端Node的框架。</span><br><span class=\"line\">前提：npm install express</span><br><span class=\"line\">1)初识Express</span><br><span class=\"line\">let express = require(&#x27;express&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// express路由能力</span><br><span class=\"line\">app.get(&quot;/index&quot;,(req,res)=&gt;&#123;</span><br><span class=\"line\">    res.send(&#x27;首页&#x27;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&quot;/my&quot;,(req,res)=&gt;&#123;</span><br><span class=\"line\">    res.send(&#x27;我的&#x27;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(/\\/student\\/([\\d]&#123;5&#125;)/,(req,res)=&gt;&#123;</span><br><span class=\"line\">    res.send(&quot;学生信息，学号：&quot;+req.params[0]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&quot;/teacher/:teacherID&quot;,(req,res)=&gt;&#123;</span><br><span class=\"line\">    res.send(&quot;老师信息，工号：&quot;+req.params.teacherID);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// express引用静态文件能力(即以前放入Apache中的包)</span><br><span class=\"line\">app.use(express.static(&#x27;./static&#x27;));</span><br><span class=\"line\"></span><br><span class=\"line\">// express引用模板引擎能力</span><br><span class=\"line\">app.set(&#x27;view engine&#x27;,&#x27;ejs&#x27;);</span><br><span class=\"line\">app.get(&#x27;/view&#x27;,(req,res)=&gt;&#123;</span><br><span class=\"line\">    res.render(&#x27;ejs01&#x27;,&#123;</span><br><span class=\"line\">        a: 11,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br><span class=\"line\"></span><br><span class=\"line\">2)如果想要处理任何类型的请求(get,post)就使用app.all</span><br><span class=\"line\">app.all(&quot;/&quot;,(req,res)=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">3)Restful路由设计：简单来说，就是同一个路由路径，根据不同的请求类型，展现出不同的功能</span><br><span class=\"line\"></span><br><span class=\"line\">4)中间件</span><br><span class=\"line\">如果GET、POST请求的回调函数中，没有next参数，那么就会匹配第一个路由，不会继续往下匹配；如果想要继续往下匹配，就需要next()</span><br><span class=\"line\"></span><br><span class=\"line\">let express = require(&#x27;express&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&#x27;/&#x27;,(req,res,next)=&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;1&#x27;);</span><br><span class=\"line\">    next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;2&#x27;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br><span class=\"line\"></span><br><span class=\"line\">1)app.use()是一个中间件，这与get/post不同的是，app.use()的网址不是精确匹配的，是可以扩展的</span><br><span class=\"line\">let express = require(&#x27;express&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(&quot;/admin&quot;,(req,res)=&gt;&#123;</span><br><span class=\"line\">    // 当用户输入 http://127.0.0.1:3000/admin/userinfo/001</span><br><span class=\"line\">    console.log(req.originalUrl);  // 用户输入访问的网址  /admin/userinfo/001</span><br><span class=\"line\">    console.log(req.baseUrl);      // use中的第一个参数   /admin</span><br><span class=\"line\">    console.log(req.path);         // 用户网址减去use中的第一个参数  /userinfo/001</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br><span class=\"line\"></span><br><span class=\"line\">2)当app.use不写路径时，实际上是相当于&quot;/&quot;，代表所有网址</span><br><span class=\"line\">app.use((req,res,next)=&gt;&#123;</span><br><span class=\"line\">    next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">3)静态服务</span><br><span class=\"line\">let express = require(&#x27;express&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">// 当用户访问http://127.0.0.1:3000/static/即可访问static文件夹下文件</span><br><span class=\"line\">app.use(&#x27;/static&#x27;,express.static(&#x27;./static&#x27;));</span><br><span class=\"line\"></span><br><span class=\"line\">// use函数会自动识别err这个参数，如果有就能自动捕获</span><br><span class=\"line\">app.use((req, res)=&gt;&#123;</span><br><span class=\"line\">    res.send(&#x27;不存在这个页面！&#x27;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br><span class=\"line\"></span><br><span class=\"line\">4)render()和send()</span><br><span class=\"line\">①大多数情况下，渲染内容用res.render()，将会根据views中的模板文件进行渲染。如果渲染不想使用views文件夹，可以：</span><br><span class=\"line\">    app.set(&#x27;views&#x27;,__dirname+&#x27;/Views2&#x27;);</span><br><span class=\"line\">②如果想写一个快速测试页，当然可是使用res.render()。这个函数将根据内容，自动帮我们设置了Content-Type头部和200状态码</span><br><span class=\"line\">③如果想要使用不同的状态码，可以：</span><br><span class=\"line\">    res.status(400).render(&#x27;we connot find it&#x27;)</span><br><span class=\"line\">④如果想要设置不同的Content-Type，可以：</span><br><span class=\"line\">    res.set(&#x27;Content-Type&#x27;,&#x27;text-html&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">5)express的GET和POST请求</span><br><span class=\"line\">①GET请求</span><br><span class=\"line\">let express = require(&#x27;express&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class=\"line\">    // 获取参数</span><br><span class=\"line\">    // 当访问http://127.0.0.1:3000/?name=wq&amp;id=1270837469</span><br><span class=\"line\">    console.log(req.query); // &#123; name: &#x27;wq&#x27;, id: &#x27;1270837469&#x27; &#125;</span><br><span class=\"line\">    res.send();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br><span class=\"line\">②POST请求</span><br><span class=\"line\"></span><br><span class=\"line\">前提：npm install body-parser</span><br><span class=\"line\">let bodyParser = require(&#x27;body-parser&#x27;);</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123;extended:false&#125;));</span><br><span class=\"line\">app.post(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class=\"line\">    res.send(JSON.stringify(req.body));</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-NoSQL\"><a href=\"#11-NoSQL\" class=\"headerlink\" title=\"11.NoSQL\"></a>11.NoSQL</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">定义：非结构性数据库，没有行和列的概念，用JSON来存储数据，代替了老牌数据库表和行的概念，分别使用集合和文档。</span><br><span class=\"line\"></span><br><span class=\"line\">mongodb的一些命令：</span><br><span class=\"line\">    mongo：使用数据库</span><br><span class=\"line\">    mongod：开机</span><br><span class=\"line\">    mongoimport：导入数据</span><br><span class=\"line\"></span><br><span class=\"line\">启动mongodb：</span><br><span class=\"line\">    新建一个文件夹我的目录是：F:\\mongo</span><br><span class=\"line\">    打开cmd，执行 mongod --dbpath F:\\mongo</span><br><span class=\"line\">    新打开一个cmd，执行 mongo</span><br><span class=\"line\"></span><br><span class=\"line\">mongodb命令：</span><br><span class=\"line\">    show dbs：展示当前所有数据库</span><br><span class=\"line\">    use 数据库名：使用指定数据库；或者新建数据库</span><br><span class=\"line\">    db：查看当前所在数据库</span><br><span class=\"line\">    插入数据：</span><br><span class=\"line\">        db.数据库名.insert(&#123;&quot;name&quot;:&quot;wq&quot;&#125;)</span><br><span class=\"line\">    查看当前数据库集合：</span><br><span class=\"line\">        show collections</span><br><span class=\"line\">    查看当前集合中的文档：</span><br><span class=\"line\">        db.数据库名.find()</span><br><span class=\"line\">    查询name字段为&#x27;wq&#x27;的文档：</span><br><span class=\"line\">        db.数据库名.find(&#123;&quot;name&quot;:&quot;wq&quot;&#125;)</span><br><span class=\"line\">    删除数据库：(当前所在的数据库)</span><br><span class=\"line\">        db.dropDatabase()</span><br><span class=\"line\">    导入数据库：</span><br><span class=\"line\">        mongoimport --db 数据库名 --collection 集合名 --drop --file 文件路径</span><br><span class=\"line\">            注意： --drop 代表删除之前集合中存在的数据</span><br><span class=\"line\">查询：</span><br><span class=\"line\">    数据结构：</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;:&quot;wq&quot;,</span><br><span class=\"line\">            &quot;age&quot;:23,</span><br><span class=\"line\">            &quot;hobby&quot;:[&quot;sleep&quot;,&quot;eat&quot;],</span><br><span class=\"line\">            &quot;score&quot;:&#123;</span><br><span class=\"line\">                &quot;yuwen&quot;:89,</span><br><span class=\"line\">                &quot;shuxue&quot;:100</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;points&quot;: [</span><br><span class=\"line\">                &#123; &quot;points&quot;: 78, &quot;bonus&quot;: 8 &#125;,</span><br><span class=\"line\">                &#123; &quot;points&quot;: 57, &quot;bonus&quot;: 7 &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">1)查询数学成绩为100的学生</span><br><span class=\"line\">     db.student.find(&#123;&quot;score.shuxue&quot;:100&#125;)</span><br><span class=\"line\">2)查询年龄为23并且数学成绩为100的学生</span><br><span class=\"line\">     db.student.find(&#123;&quot;score.shuxue&quot;:100,&quot;age&quot;:23&#125;)</span><br><span class=\"line\">3)查询语文成绩大于70分的学生($gt)</span><br><span class=\"line\">    db.student.find(&#123;&quot;score.yuwen&quot;:&#123;$gt:70&#125;&#125;)</span><br><span class=\"line\">4)查询语文成绩小于70分的学生($lt)</span><br><span class=\"line\">    db.student.find(&#123;&quot;score.yuwen&quot;:&#123;$lt:70&#125;&#125;)</span><br><span class=\"line\">4)查询语文成绩小于70或者年龄小于20岁的学生</span><br><span class=\"line\">    db.student.find(&#123;$or:[&#123;&quot;score.yuwen&quot;:&#123;$lt:70&#125;&#125;,&#123;&quot;age&quot;:&#123;$lt:20&#125;&#125;]&#125;)</span><br><span class=\"line\">5)查询年龄大于15岁的学生并且按照语文成绩升序排列(1代表升序，-1代表降序)，如果有两个参数，则先按前者排序，后按后者排序</span><br><span class=\"line\">    db.student.find(&#123;&quot;age&quot;:&#123;$gt:15&#125;&#125;).sort(&#123;&quot;age&quot;:1&#125;)</span><br><span class=\"line\">6)查询爱好为睡觉的学生</span><br><span class=\"line\">    db.student.find(&#123;&quot;hobby&quot;:&quot;sleep&quot;&#125;)</span><br><span class=\"line\">7)查询第二个爱好为eat的学生</span><br><span class=\"line\">    db.student.find(&#123;&quot;hobby.1&quot;:&quot;eat&quot;&#125;)</span><br><span class=\"line\">8)查询bonus大于7的学生</span><br><span class=\"line\">    db.student.find(&#123;&quot;points&quot;:&#123;$elemMatch:&#123;&quot;bonus&quot;:&#123;$gt:7&#125;&#125;&#125;&#125;)</span><br><span class=\"line\">9)查询hobby为eat和sleep的学生</span><br><span class=\"line\">    db.student.find(&#123;&quot;hobby&quot;:&#123;$all:[&quot;eat&quot;,&quot;sleep&quot;]&#125;&#125;)</span><br><span class=\"line\">10)查询爱好为2个的学生</span><br><span class=\"line\">    db.student.find(&#123;&quot;hobby&quot;:&#123;$size:2&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">删除</span><br><span class=\"line\">    1)删除集合</span><br><span class=\"line\">        db.集合名.drop()</span><br><span class=\"line\">    2)删除集合中名字为wq的学生</span><br><span class=\"line\">        db.student.remove(&#123;&quot;name&quot;:&quot;wq&quot;&#125;)</span><br><span class=\"line\">        注意：只删除一个添加&#123;justOne:true&#125;</span><br><span class=\"line\">            db.student.remove(&#123;&quot;name&quot;:&quot;wq&quot;&#125;,&#123;justOne:true&#125;)</span><br><span class=\"line\">修改</span><br><span class=\"line\">    1)修改名字为wq2的学生年龄为21</span><br><span class=\"line\">        db.student.update(&#123;&quot;name&quot;:&quot;wq2&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:21&#125;&#125;)</span><br><span class=\"line\">    2)修改名字满足wq\\d&#123;1,&#125;所有学生的年龄为33</span><br><span class=\"line\">        db.student.updateMany(&#123;&quot;name&quot;:/wq\\d&#123;1,&#125;/&#125;,&#123;$set:&#123;&quot;age&quot;:33&#125;&#125;)</span><br><span class=\"line\">    3)完全替换名字为wq2</span><br><span class=\"line\">        db.student.update(&#123;&quot;name&quot;:&quot;wq2&quot;&#125;,&#123;&quot;name&quot;:&quot;wq2&quot;,&quot;age&quot;:1&#125;)</span><br><span class=\"line\">    4)添加points</span><br><span class=\"line\">        db.students.update(&#123;&quot;name&quot;:&quot;wq&quot;&#125;,&#123;$addToSet:&#123;&quot;points&quot;:&#123; &quot;points&quot;: 58, &quot;bonus&quot;: 7 &#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-Nodejs-连接-Mongodb-数据库\"><a href=\"#12-Nodejs-连接-Mongodb-数据库\" class=\"headerlink\" title=\"12.Nodejs 连接 Mongodb 数据库\"></a>12.Nodejs 连接 Mongodb 数据库</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let express = require(&#x27;express&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">let app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">let MongoClient = require(&#x27;mongodb&#x27;).MongoClient;</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class=\"line\">    // itcase代表数据库</span><br><span class=\"line\">    let url = &quot;mongodb://127.0.0.1:27017/itcase&quot;;</span><br><span class=\"line\">    MongoClient.connect(url,(err,client)=&gt;&#123;</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">            console.log(&#x27;数据库连接失败！&#x27;)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        console.log(&#x27;数据库连接成功！&#x27;)</span><br><span class=\"line\">        let db = client.db(&quot;itcase&quot;);</span><br><span class=\"line\">        db.collection(&#x27;student&#x27;).insertOne(&#123;</span><br><span class=\"line\">            &quot;name&quot;:&quot;wcc&quot;,</span><br><span class=\"line\">            &quot;age&quot;:30</span><br><span class=\"line\">        &#125;,(error,result)=&gt;&#123;</span><br><span class=\"line\">            if (error) &#123;</span><br><span class=\"line\">                console.log(&#x27;数据插入失败！&#x27;)</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            console.log(&#x27;result&#x27;,result);</span><br><span class=\"line\">            res.send();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-nodejs-操作-mongodb-增删改查\"><a href=\"#13-nodejs-操作-mongodb-增删改查\" class=\"headerlink\" title=\"13.nodejs 操作 mongodb(增删改查)\"></a>13.nodejs 操作 mongodb(增删改查)</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let MongoClient = require(&#x27;mongodb&#x27;).MongoClient;</span><br><span class=\"line\"></span><br><span class=\"line\">// 连接数据库</span><br><span class=\"line\">function connectMongodb(dbName,callback)&#123;</span><br><span class=\"line\">    let url = `mongodb://127.0.0.1:27017/$&#123;dbName&#125;`;</span><br><span class=\"line\">    MongoClient.connect(url,callback)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 插入数据</span><br><span class=\"line\">exports.insertOne = (dbName,collectionName,data,callback) =&gt; &#123;</span><br><span class=\"line\">    connectMongodb(dbName,(err,client)=&gt;&#123;</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">            console.log(&#x27;数据库连接失败！&#x27;)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let db = client.db(dbName);</span><br><span class=\"line\">        db.collection(collectionName).insertOne(data,callback);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 查询数据</span><br><span class=\"line\">exports.find = (dbName,collectionName,condition,pageSize,pageNo,callback) =&gt;&#123;</span><br><span class=\"line\">    connectMongodb(dbName,(err,client)=&gt;&#123;</span><br><span class=\"line\">        let db = client.db(dbName);</span><br><span class=\"line\">        let cursor = db.collection(collectionName).find(condition).limit(pageSize).skip((pageNo-1)*pageSize);</span><br><span class=\"line\">        let result = [];</span><br><span class=\"line\">        cursor.each((error,doc)=&gt;&#123;</span><br><span class=\"line\">            if (doc!=null) &#123;</span><br><span class=\"line\">                result.push(doc);</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                callback(null,result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除数据</span><br><span class=\"line\">exports.delete = (dbName,collectionName,condition,callback)=&gt;&#123;</span><br><span class=\"line\">    connectMongodb(dbName,(err,client)=&gt;&#123;</span><br><span class=\"line\">        let db = client.db(dbName);</span><br><span class=\"line\">        db.collection(collectionName).deleteMany(condition,(error,result)=&gt;&#123;</span><br><span class=\"line\">            if(error)&#123;</span><br><span class=\"line\">                callback(&#x27;删除失败！&#x27;,null);</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            callback(null,result);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改数据</span><br><span class=\"line\">exports.update = (dbName,collectionName,searchCondition,updateData,callback)=&gt;&#123;</span><br><span class=\"line\">    connectMongodb(dbName,(err,client)=&gt;&#123;</span><br><span class=\"line\">        let db = client.db(dbName);</span><br><span class=\"line\">        db.collection(collectionName).updateOne(searchCondition,&#123;$set:updateData&#125;,(error,result)=&gt;&#123;</span><br><span class=\"line\">            if(error)&#123;</span><br><span class=\"line\">                callback(&#x27;修改失败！&#x27;,null);</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            callback(null,result);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-Cookie-和-Session\"><a href=\"#13-Cookie-和-Session\" class=\"headerlink\" title=\"13.Cookie 和 Session\"></a>13.Cookie 和 Session</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Cookie:</span><br><span class=\"line\">    1)Http是无状态协议，简单的说，当你浏览一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次访问都是没有关系的。</span><br><span class=\"line\">    2)Cookie是一个简单到爆的想法：当访问一个页面的时候，服务器在下行Http报文中，命令浏览器存储一个字符串；当浏览器再次访问同一个域的时候，将把这个字符串携带到</span><br><span class=\"line\">      上行Http请求中。</span><br><span class=\"line\">    特点：</span><br><span class=\"line\">        1)Cookie不加密，用户可以自由看到</span><br><span class=\"line\">        2)用户可以删除Cookie或者禁用它</span><br><span class=\"line\">        3)Cookie可以被篡改</span><br><span class=\"line\">        4)Cookie可以用于攻击</span><br><span class=\"line\">        5)Cookie的存储量小</span><br><span class=\"line\"></span><br><span class=\"line\">node中的Cookie:</span><br><span class=\"line\">    前提：npm install cookie-parser</span><br><span class=\"line\">    例子：</span><br><span class=\"line\">        let express = require(&#x27;express&#x27;);</span><br><span class=\"line\">        let cookieParser = require(&#x27;cookie-parser&#x27;);</span><br><span class=\"line\">        let app = express();</span><br><span class=\"line\">        app.use(cookieParser());</span><br><span class=\"line\"></span><br><span class=\"line\">        app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class=\"line\">            console.log(&#x27;请求Cookie&#x27;,req.cookies)</span><br><span class=\"line\">            // maxAge：Cookie的有效期</span><br><span class=\"line\">            res.cookie(&#x27;name&#x27;,&#x27;wq&#x27;,&#123;maxAge:24*60*60*1000&#125;);</span><br><span class=\"line\">            res.send();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        app.listen(3000);</span><br><span class=\"line\"></span><br><span class=\"line\">Session：</span><br><span class=\"line\">    Session不是一开始就有的技术，而是依赖Cookie。当浏览器禁用cookie或者用户清除cookie的时候登录效果就消失了。</span><br><span class=\"line\">    Session下发的乱码是乱码，并且服务器自己缓存一些东西，下次服务器带着乱码请求，与缓存比对，就知道请求用户是谁了。</span><br><span class=\"line\"></span><br><span class=\"line\">node中的Session：</span><br><span class=\"line\">    前提：npm install express-session</span><br><span class=\"line\">    let express = require(&#x27;express&#x27;);</span><br><span class=\"line\">    let app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">    let session = require(&#x27;express-session&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    app.use(session(&#123;</span><br><span class=\"line\">        secret:&#x27;wq&#x27;,</span><br><span class=\"line\">        resave:false,</span><br><span class=\"line\">        saveUninitialized:true</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">    app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class=\"line\">        if (req.session.userInfo) &#123;</span><br><span class=\"line\">            res.send(&#x27;欢迎您,&#x27;+req.session.userInfo);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.send(&#x27;您未登录，请先登录！！&#x27;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    app.get(&#x27;/login&#x27;,(req,res)=&gt;&#123;</span><br><span class=\"line\">        req.session.userInfo = &#x27;王清&#x27;;  // 设置Session</span><br><span class=\"line\">        res.send(&#x27;您已成功登录！&#x27;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    app.listen(3000);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-MD5-加密\"><a href=\"#14-MD5-加密\" class=\"headerlink\" title=\"14.MD5 加密\"></a>14.MD5 加密</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    MD5加密是函数型加密，就是每次加密的结果是一样的，没有随机位。</span><br><span class=\"line\">    特点：</span><br><span class=\"line\">    1)无论需要加密的文字多长多短，永远是32位。</span><br><span class=\"line\">    2)哪怕只改一个字，密文都会大变。</span><br><span class=\"line\"></span><br><span class=\"line\">node中的加密：</span><br><span class=\"line\">    前提：npm install crypto</span><br><span class=\"line\">    let express = require(&#x27;express&#x27;);</span><br><span class=\"line\">    let app = express();</span><br><span class=\"line\">    let crypto = require(&#x27;crypto&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class=\"line\">        // 选择加密方式，一般有：sha1,md5,sha256,sha512</span><br><span class=\"line\">        let md5 = crypto.createHash(&#x27;md5&#x27;);</span><br><span class=\"line\">        let password = md5.update(&#x27;wq&#x27;).digest(&#x27;base64&#x27;);</span><br><span class=\"line\">        res.send(&quot;加密之后的密码：&quot;+password);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    app.listen(3000);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"16-Mongoose\"><a href=\"#16-Mongoose\" class=\"headerlink\" title=\"16.Mongoose\"></a>16.Mongoose</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">简介：是一个将JavaScript对象与数据库产生联系的框架。Object Related Model(ORM:对象关系模型)。操作对象就是操作数据库</span><br><span class=\"line\">   前提：npm install mongoose</span><br><span class=\"line\">   例子demo：</span><br><span class=\"line\">       let mongoose = require(&#x27;mongoose&#x27;);</span><br><span class=\"line\">       // 连接数据库</span><br><span class=\"line\">       mongoose.connect(&#x27;mongodb://127.0.0.1/animals&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">       // 创建模型：相当于创建了一个类，每个Cat实例都有name和age属性，在mongo中相当于文档</span><br><span class=\"line\">       let Cat = mongoose.model(&#x27;cat&#x27;,&#123;name:String,age:Number&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       // 实例化</span><br><span class=\"line\">       let Ketty = new Cat(&#123;name:&#x27;Ketty&#x27;,age:12&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       // 保存到数据库</span><br><span class=\"line\">       Ketty.save((err,result)=&gt;&#123;</span><br><span class=\"line\">           console.log(err,result);</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">   封装增删改查：</span><br><span class=\"line\">       前提：在同一目录下新建models文件夹和app.js文件，models文件夹下新建db.js和student.js;</span><br><span class=\"line\">       代码：</span><br><span class=\"line\">           app.js：</span><br><span class=\"line\">               let db = require(&#x27;./models/db&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">               let Student = require(&#x27;./models/student&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">               // 添加方法一：</span><br><span class=\"line\">               let xiaoming = new Student(&#123;name:&#x27;小明&#x27;,age:18&#125;)</span><br><span class=\"line\">               xiaoming.save(()=&gt;&#123;console.log(&#x27;添加小明成功！&#x27;)&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">               // 添加方法二：</span><br><span class=\"line\">               Student.create(&#123;name:&#x27;小红&#x27;,age:20,sex:&#x27;女&#x27;&#125;,()=&gt;&#123;console.log(&#x27;添加小红成功！&#x27;)&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">               // 查找方法一：利用自定义的静态方法查找</span><br><span class=\"line\">               Student.findByName(&#x27;小红&#x27;,(err,result)=&gt;&#123;console.log(result)&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">               // 查找方法二：</span><br><span class=\"line\">               Student.find(&#123;name:&#x27;小红&#x27;&#125;,(err,result)=&gt;&#123;console.log(result)&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">               // 修改小红年龄为30岁:这里可以不用添加$set为&#123;$set:&#123;age:30&#125;&#125;</span><br><span class=\"line\">               Student.updateOne(&#123;name:&#x27;小红&#x27;&#125;,&#123;age:30&#125;,(err,result)=&gt;&#123;console.log(result)&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// 修改方法二:</span><br><span class=\"line\">               Student.find(&#123;name:&#x27;小红&#x27;&#125;,(err,result)=&gt;&#123;</span><br><span class=\"line\">                   let xiaohong = result[0];</span><br><span class=\"line\">                   xiaohong.age=30;</span><br><span class=\"line\">                   xiaohong.save();</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">               // 删除小红</span><br><span class=\"line\">               Student.deleteOne(&#123;name:&#x27;小红&#x27;&#125;,(err,result)=&gt;&#123;console.log(result)&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">               // 使用实例方法</span><br><span class=\"line\">\t\t\tlet xiaoqiang = new Student(&#123;name:&#x27;小强&#x27;,age:22&#125;);</span><br><span class=\"line\">\t\t\txiaoqiang.console();</span><br><span class=\"line\">           db.js：</span><br><span class=\"line\">               let mongoose = require(&#x27;mongoose&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">               // 创建连接，给每个用户都会创建一个连接</span><br><span class=\"line\">               let db = mongoose.createConnection(&#x27;mongodb://127.0.0.1:27017/school&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">               db.once(&#x27;open&#x27;,()=&gt;&#123;</span><br><span class=\"line\">                   console.log(&#x27;数据库连接成功！&#x27;);</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">               module.exports = db;</span><br><span class=\"line\">           student.js:</span><br><span class=\"line\">               let mongoose = require(&#x27;mongoose&#x27;);</span><br><span class=\"line\">               let db = require(&#x27;./db&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">               let studentSchema = new mongoose.Schema(&#123;</span><br><span class=\"line\">                   name  : &#123;type:String&#125;,</span><br><span class=\"line\">                   age   : &#123;type:Number&#125;,</span><br><span class=\"line\">                   sex   : &#123;type:String,default:&#x27;男&#x27;&#125;</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">               // 创建查询静态方法</span><br><span class=\"line\">               studentSchema.statics.findByName = (name,callback) =&gt; &#123;</span><br><span class=\"line\">                   db.model(&#x27;student&#x27;).find(&#123;name&#125;,callback);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               /**</span><br><span class=\"line\">               * 创建更改静态方法</span><br><span class=\"line\">               * conditions：修改条件</span><br><span class=\"line\">               * data：改成data</span><br><span class=\"line\">               * options:可选参数，它有如下属性</span><br><span class=\"line\">               *      safe ：（布尔型）安全模式（默认为架构中设置的值（true））</span><br><span class=\"line\">                       upsert ：（boolean）如果不匹配，是否创建文档（false）</span><br><span class=\"line\">                       multi ：（boolean）是否应该更新多个文档（false）</span><br><span class=\"line\">                       runValidators：如果为true，则在此命令上运行更新验证程序。更新验证器根据模型的模式验证更新操作。</span><br><span class=\"line\">                       strict：（布尔）覆盖strict此更新的选项</span><br><span class=\"line\">                       overwrite： （布尔）禁用只更新模式，允许您覆盖文档（false）</span><br><span class=\"line\">               */</span><br><span class=\"line\">               studentSchema.statics.update = (conditions,data,options,callback) =&gt; &#123;</span><br><span class=\"line\">                   db.model(&#x27;student&#x27;).update(conditions,&#123;$set:data&#125;,options,callback);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// 定义实例方法</span><br><span class=\"line\">\t\t\tstudentSchema.methods.console = ()=&gt;&#123;</span><br><span class=\"line\">\t\t\t    console.log(&#x27;这是实例方法&#x27;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               let studentModel = db.model(&#x27;student&#x27;,studentSchema);</span><br><span class=\"line\"></span><br><span class=\"line\">               module.exports = studentModel;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"17-WebSocket-和-Socket-IO-框架\"><a href=\"#17-WebSocket-和-Socket-IO-框架\" class=\"headerlink\" title=\"17.WebSocket 和 Socket.IO 框架\"></a>17.WebSocket 和 Socket.IO 框架</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">WebSocket允许客户端和服务器以全双工的方式进行通信；WebSocket的原理：利用HTTP请求产生握手之后，二者转用TCP协议进行交流(QQ协议)</span><br><span class=\"line\"></span><br><span class=\"line\">方法一：利用socket.io模块</span><br><span class=\"line\">前提：npm install socket.io</span><br><span class=\"line\">模拟websocket：</span><br><span class=\"line\">    前端代码studyWebsocket.html:</span><br><span class=\"line\">        &lt;h1&gt;模拟websocket&lt;/h1&gt;</span><br><span class=\"line\">        &lt;input id=&#x27;content&#x27; /&gt;&lt;button id=&#x27;send&#x27;&gt;发送&lt;/button&gt;</span><br><span class=\"line\">        &lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.dev.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">        &lt;script&gt;</span><br><span class=\"line\">            var socket = io.connect(&#x27;http://127.0.0.1:3000&#x27;);</span><br><span class=\"line\">            document.getElementById(&#x27;send&#x27;).onclick = ()=&gt;&#123;</span><br><span class=\"line\">                socket.emit(&#x27;question&#x27;,document.getElementById(&#x27;content&#x27;).value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            socket.on(&#x27;answer&#x27;,data=&gt;console.log(data));</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">    Node代码：</span><br><span class=\"line\">    \t(</span><br><span class=\"line\">\t\t\t如果使用express框架：</span><br><span class=\"line\">\t\t\t\tconst express = require(&#x27;express&#x27;);</span><br><span class=\"line\">\t\t\t\tconst app = express();</span><br><span class=\"line\">\t\t\t\tlet server = require(&#x27;http&#x27;).createServer(app);</span><br><span class=\"line\">\t\t\t\tlet io = require(&#x27;socket.io&#x27;)(server);</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">        let http = require(&#x27;http&#x27;);</span><br><span class=\"line\">        let fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">        let server = http.createServer((req,res)=&gt;&#123;</span><br><span class=\"line\">            if (req.url == &#x27;/&#x27;) &#123;</span><br><span class=\"line\">                fs.readFile(&#x27;./studyWebsocket.html&#x27;,(err,data)=&gt;&#123;</span><br><span class=\"line\">                    res.end(data);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        let io = require(&#x27;socket.io&#x27;)(server);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 监听连接事件</span><br><span class=\"line\">        // 对于前端和后端的socket对象，都有emit和on方法，emit发送请求，on接受请求</span><br><span class=\"line\">        io.on(&#x27;connection&#x27;,socket=&gt;&#123;</span><br><span class=\"line\">            socket.on(&#x27;question&#x27;,data=&gt;&#123;</span><br><span class=\"line\">                socket.emit(&#x27;answer&#x27;,data);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            // 广播：所有连接到此websocket上来的用户，如果其中一个用户发起thank请求，所有用户都能得到回应</span><br><span class=\"line\">            io.emit(&#x27;broadcast&#x27;,&#123;&#x27;say&#x27;:&#x27;谢谢&#x27;&#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        server.listen(3000,&#x27;127.0.0.1&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">方法二：利用ws模块</span><br><span class=\"line\">\t\t前端代码：</span><br><span class=\"line\">\t\t\t&lt;h1&gt;模拟websocket&lt;/h1&gt;</span><br><span class=\"line\">\t\t    &lt;input id=&#x27;content&#x27; /&gt;&lt;button id=&#x27;send&#x27;&gt;发送&lt;/button&gt;</span><br><span class=\"line\">\t\t    &lt;script&gt;</span><br><span class=\"line\">\t\t        var ws = new WebSocket(&#x27;ws://127.0.0.1:3000&#x27;);</span><br><span class=\"line\">\t\t        ws.addEventListener(&#x27;open&#x27;,()=&gt;&#123;</span><br><span class=\"line\">\t\t            ws.send(&#x27;连接成功...&#x27;);</span><br><span class=\"line\">\t\t        &#125;)</span><br><span class=\"line\">\t\t        document.getElementById(&#x27;send&#x27;).onclick = ()=&gt;&#123;</span><br><span class=\"line\">\t\t            // 给服务器发送一个字符串:</span><br><span class=\"line\">\t\t            ws.send(document.getElementById(&#x27;content&#x27;).value);</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t        ws.onmessage = result=&gt;&#123;</span><br><span class=\"line\">\t\t            console.log(result.data);</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t    &lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnode代码：</span><br><span class=\"line\">\t\t\tconst WebSocket = require(&#x27;ws&#x27;);</span><br><span class=\"line\">\t\t\t// 实例化:</span><br><span class=\"line\">\t\t\tconst wss = new WebSocket.Server(&#123;</span><br><span class=\"line\">\t\t\t    port: 3000</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// 监听连接事件</span><br><span class=\"line\">\t\t\twss.on(&#x27;connection&#x27;,(ws)=&gt;&#123;</span><br><span class=\"line\">\t\t\t    // 接受对方发送过来的信息</span><br><span class=\"line\">\t\t\t    ws.on(&#x27;message&#x27;,data=&gt;&#123;</span><br><span class=\"line\">\t\t\t        ws.send(data);</span><br><span class=\"line\">\t\t\t    &#125;)</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"Nuxt.js的踩坑指南","url":"/2022/12/16/Nuxt-js%E7%9A%84%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/","content":"<h2 id=\"1-路径匹配问题：\"><a href=\"#1-路径匹配问题：\" class=\"headerlink\" title=\"1.路径匹配问题：\"></a>1.路径匹配问题：</h2><p>In Nuxt.js, the path match is as follows:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@import url(&#x27;~assets/css/style.css&#x27;) //Error</span><br></pre></td></tr></table></figure>\n\n<p>This path matching is an error, and writing it like this is possible:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@import url(&#x27;~/assets/css/style.css&#x27;) //success</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，在最新版本更新中，官方修复了路径匹配问题：</p>\n<p>而官方推荐使用<code>~/assets</code>匹配路径，而不是使用在中文文档中的<code>~assets</code>去匹配路径。</p>\n<p>而在中文文档中，也并未见修复及更改此问题。</p>\n<h2 id=\"2-按需引入-UI-框架等等\"><a href=\"#2-按需引入-UI-框架等等\" class=\"headerlink\" title=\"2.按需引入(UI 框架等等)\"></a>2.按需引入(UI 框架等等)</h2><p>例如使用 UI 框架：element-ui</p>\n<p>我找了很多相关文章，并没有详细说明该如何引入。所以我要拿出来将他说明：</p>\n<p>先来看下，如果不按需引入 vendor.js 的体积大小为：</p>\n<p><img src=\"https://image-static.segmentfault.com/894/966/894966456-5adc42411f633_articlex\" alt=\"image\"></p>\n<blockquote>\n<p>第一步，下载依赖：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 先下载element-ui</span><br><span class=\"line\"></span><br><span class=\"line\">npm install element-ui --save</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果使用按需引入，必须安装babel-plugin-component(官网有需要下载说明，此插件根据官网规则不同，安装插件不同)</span><br><span class=\"line\"></span><br><span class=\"line\">npm install babel-plugin-component --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>安装好以后，按照 nuxt.js 中的规则，你需要在 plugins&#x2F; 目录下创建相应的插件文件</p>\n<p>在文件根目录创建(或已经存在)plugins&#x2F;目录，创建名为：element-ui.js 的文件，内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; Button &#125; from &#x27;element-ui&#x27;    //引入Button按钮</span><br><span class=\"line\"></span><br><span class=\"line\">export default ()=&gt;&#123;</span><br><span class=\"line\">    Vue.use(Button)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>第二步，引入插件</p>\n</blockquote>\n<p>在 nuxt.config.js 中，添加配置为：plugins</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">css:[</span><br><span class=\"line\">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class=\"line\">],</span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">&#x27;~/plugins/element-ui&#x27;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>默认为：开启 SSR,采用服务端渲染，也可以<strong>手动配置关闭 SSR</strong>，配置为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">css:[</span><br><span class=\"line\">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class=\"line\">],</span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        src:&#x27;~/plugins/element-ui&#x27;,</span><br><span class=\"line\">        ssr:false    //关闭ssr</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>第三步，配置 babel 选项</p>\n</blockquote>\n<p>在 nuxt.config.js 中，配置在 build 选项中，规则为官网规则：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">build: &#123;</span><br><span class=\"line\">      babel:&#123;        //配置按需引入规则</span><br><span class=\"line\">          &quot;plugins&quot;:[</span><br><span class=\"line\">              [</span><br><span class=\"line\">                  &quot;component&quot;,</span><br><span class=\"line\">                  &#123;</span><br><span class=\"line\">                      &quot;libraryName&quot;:&quot;element-ui&quot;,</span><br><span class=\"line\">                      &quot;styleLibraryName&quot;:&quot;theme-chalk&quot;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              ]</span><br><span class=\"line\">          ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     ** Run ESLINT on save</span><br><span class=\"line\">     */</span><br><span class=\"line\">    extend (config, ctx) &#123;</span><br><span class=\"line\">      if (ctx.isClient) &#123;</span><br><span class=\"line\">        config.module.rules.push(&#123;</span><br><span class=\"line\">           enforce: &#x27;pre&#x27;,</span><br><span class=\"line\">           test: /\\.(js|vue)$/,</span><br><span class=\"line\">           loader: &#x27;eslint-loader&#x27;,</span><br><span class=\"line\">           exclude: /(node_modules)/</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，我们在观察打包以后文件体积大小，如图：<br><img src=\"https://image-static.segmentfault.com/135/492/1354920410-5adc428eed953_articlex\" alt=\"image\"></p>\n<p>此时，我们成功完成了按需引入配置。</p>\n<h2 id=\"3-初始化脚手架的选择：\"><a href=\"#3-初始化脚手架的选择：\" class=\"headerlink\" title=\"3.初始化脚手架的选择：\"></a>3.初始化脚手架的选择：</h2><p>官网提供的初始化脚手架为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 基本的Nuxt.js项目模板</span><br><span class=\"line\"></span><br><span class=\"line\">vue init nuxt/starter template</span><br></pre></td></tr></table></figure>\n\n<p>而其实，官方也提供了更多的模板以便于我们使用，而我在中文文档并未发现有说明：</p>\n<ul>\n<li>nuxt&#x2F;starter 基本的 Nuxt.js 项目模板</li>\n<li>nuxt&#x2F;express Nuxt.js + Express</li>\n<li>nuxt&#x2F;koa Nuxt.js + Koa2</li>\n<li>nuxt&#x2F;adonuxt Nuxt.js + AdonisJS</li>\n<li>nuxt&#x2F;micro Nuxt.js + Micro</li>\n<li>nuxt&#x2F;nuxtent 适用于内容较重网站的 Nuxt.js + Nuxtent 模块</li>\n</ul>\n<p>而我们使用基础的模板进行初始化项目，部署方式为：</p>\n<blockquote>\n<p>第一步，打包：<br>在执行 npm run build 的时候，nuxt 会自动打包</p>\n</blockquote>\n<blockquote>\n<p>第二步，选择要部署的文件：</p>\n</blockquote>\n<ul>\n<li>.nuxt 文件夹</li>\n<li>package.json 文件</li>\n<li>nuxt.config.js 文件(如果你部署一些 proxy，则需要上传这个文件，个人建议把它传上去)<blockquote>\n<p>第三步，启动你的 nuxt （重要）</p>\n</blockquote>\n</li>\n</ul>\n<p>使用 pm2 启动你的 nuxt.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 start npm --name &quot;demo&quot; -- run start</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我发现个问题，如果你使用 window server 服务器，在使用 pm2 启动时候，会出现错误，错误如下：</p>\n<p><img src=\"https://image-static.segmentfault.com/166/822/1668224023-5adc47462ea06_articlex\" alt=\"image\"></p>\n<p>如果在 Linux 服务器下启动，同样的命令，同样的执行，则不会出现错误：<br>这里采用 Linux CentOS 7</p>\n<p><img src=\"https://image-static.segmentfault.com/284/057/2840577851-5adc47ba7502f_articlex\" alt=\"image\"></p>\n<p>所以，个人建议，在采用初始化模板的时候，请选用 express 或者 koa 进行初始化，理由如下：</p>\n<h3 id=\"1-采用基础模板初始化，观察-package-json-的启动方式如下：\"><a href=\"#1-采用基础模板初始化，观察-package-json-的启动方式如下：\" class=\"headerlink\" title=\"1.采用基础模板初始化，观察 package.json 的启动方式如下：\"></a>1.采用基础模板初始化，观察 package.json 的启动方式如下：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;dev&quot;: &quot;nuxt&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;nuxt build&quot;,</span><br><span class=\"line\">    &quot;start&quot;: &quot;nuxt start&quot;,</span><br><span class=\"line\">    &quot;generate&quot;: &quot;nuxt generate&quot;,</span><br><span class=\"line\">    &quot;lint&quot;: &quot;eslint --ext .js,.vue --ignore-path .gitignore .&quot;,</span><br><span class=\"line\">    &quot;precommit&quot;: &quot;npm run lint&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-采用-express-x2F-koa-初始化模板，观察-package-json-的启动方式如下：\"><a href=\"#2-采用-express-x2F-koa-初始化模板，观察-package-json-的启动方式如下：\" class=\"headerlink\" title=\"2.采用 express&#x2F;koa 初始化模板，观察 package.json 的启动方式如下：\"></a>2.采用 express&#x2F;koa 初始化模板，观察 package.json 的启动方式如下：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;dev&quot;: &quot;backpack dev&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;nuxt build &amp;&amp; backpack build&quot;,</span><br><span class=\"line\">    &quot;start&quot;: &quot;cross-env NODE_ENV=production node build/main.js&quot;,</span><br><span class=\"line\">    &quot;precommit&quot;: &quot;npm run lint&quot;,</span><br><span class=\"line\">    &quot;lint&quot;: &quot;eslint --ext .js,.vue --ignore-path .gitignore .&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 start 中，对比下，个人觉得 express&#x2F;koa 更灵活一些，它直接启动了 build&#x2F;main.js 文件，更能直观的启动方式，而关键在于，也可以在 windows server 下运行起来。</strong></p>\n<blockquote>\n<p>注意事项：如果采用 express&#x2F; koa 的模板初始化，服务器部署的时候，同时要上传 build&#x2F;目录！！！</p>\n</blockquote>\n<h2 id=\"4-插件中获取-vue-绑定\"><a href=\"#4-插件中获取-vue-绑定\" class=\"headerlink\" title=\"4.插件中获取 vue 绑定\"></a>4.插件中获取 vue 绑定</h2><p>我们需要在 axios 的插件中配置 Loading 加载效果，例如使用 element-ui 框架作为示例：</p>\n<blockquote>\n<p>1.创建插件<br>在文件根目录创建(或已经存在)plugins&#x2F;目录，创建名为：axios.js 的文件，内容如下：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;&#125;)    //获取vue实例</span><br><span class=\"line\"></span><br><span class=\"line\">export default function (&#123; $axios, redirect &#125;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  $axios.onRequest(config =&gt; &#123;</span><br><span class=\"line\">    if (process.browser) &#123;    //判断是否为客户端（必须）</span><br><span class=\"line\">        vm.$loading();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  $axios.onResponse(response=&gt;&#123;</span><br><span class=\"line\">      if (process.browser) &#123;    //判断是否为客户端（必须）</span><br><span class=\"line\">          let load = vm.$loading();</span><br><span class=\"line\">          load.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  $axios.onError(error =&gt; &#123;</span><br><span class=\"line\">    const code = parseInt(error.response &amp;&amp; error.response.status)</span><br><span class=\"line\">    if (code === 400) &#123;</span><br><span class=\"line\">      redirect(&#x27;/400&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如官方所说，并不需要像<strong>原生 axios</strong>一样，去 return 一个 config 出来。</p>\n<blockquote>\n<p>2.配置 nuxt.config.js 文件<br>在 plugins 选项添加：</p>\n</blockquote>\n<blockquote>\n<p>plugins:[‘~&#x2F;plugins&#x2F;axios’]</p>\n</blockquote>\n<p>添加 modules 选项并添加如下示例：</p>\n<blockquote>\n<p>modules:[‘@nuxtjs&#x2F;axios’]</p>\n</blockquote>\n<p>配置防止多次打包：</p>\n<p>在 build 选项中(nuxt.config.js 会默认配置)添加 vendor 配置项：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">build:&#123;</span><br><span class=\"line\">    vendor:[&#x27;axios&#x27;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以调用 loading 加载方法,并且愉快的使用了。</p>\n<p>（当然还有其他的方法去调用 vue 实例，每个人习惯不同，使用方式不同。）</p>\n<h2 id=\"5-Nuxt-js-中配置代理解决跨域\"><a href=\"#5-Nuxt-js-中配置代理解决跨域\" class=\"headerlink\" title=\"5.Nuxt.js 中配置代理解决跨域\"></a>5.Nuxt.js 中配置代理解决跨域</h2><p>我们知道在 vue-cli 中配置代理很方便，只需要在 config&#x2F;目录下的 index.js 中找到 proxyTable 添加即可，而在 nuxt 中同样需要修改 nuxt.config.js 配置文件。</p>\n<blockquote>\n<p>1.原始配置代理方式<br>使用@nuxtjs&#x2F;axios 和@nuxtjs&#x2F;proxy 进行代理解决跨域</p>\n</blockquote>\n<h3 id=\"1）-下载插件\"><a href=\"#1）-下载插件\" class=\"headerlink\" title=\"1）.下载插件\"></a>1）.下载插件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 下载插件</span><br><span class=\"line\"></span><br><span class=\"line\">npm install @nuxtjs/axios @nuxtjs/proxy --save</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）-配置插件\"><a href=\"#2）-配置插件\" class=\"headerlink\" title=\"2）.配置插件\"></a>2）.配置插件</h3><p>在 nuxt.config.js 添加配置项：modules 和 proxy。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    modules:[</span><br><span class=\"line\">        &#x27;@nuxtjs/axios&#x27;,</span><br><span class=\"line\">        &#x27;@nuxtjs/proxy&#x27;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    proxy:[</span><br><span class=\"line\">        [&#x27;/json.html&#x27;,&#123;target:&#x27;http://www.xxxx.com&#x27;&#125;]    //注意这也是一个数组</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照上面的方式已经完成了代理，可以进行跨域请求了。</p>\n<blockquote>\n<p>2.第二种方式的代理配置</p>\n</blockquote>\n<h3 id=\"1）-下载插件-1\"><a href=\"#1）-下载插件-1\" class=\"headerlink\" title=\"1）.下载插件\"></a>1）.下载插件</h3><p>这次只需要下载@nuxtjs&#x2F;axios 插件就可以。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 下载插件</span><br><span class=\"line\"></span><br><span class=\"line\">npm install @nuxtjs/axios --save</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）-配置插件-1\"><a href=\"#2）-配置插件-1\" class=\"headerlink\" title=\"2）.配置插件\"></a>2）.配置插件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  modules: [</span><br><span class=\"line\">    &#x27;@nuxtjs/axios&#x27;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  axios: &#123;</span><br><span class=\"line\">    proxy:true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  proxy:&#123;</span><br><span class=\"line\">    &#x27;/api&#x27;: &#x27;http://api.example.com&#x27;,</span><br><span class=\"line\">    &#x27;/api2&#x27;: &#x27;http://api.another-website.com&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>特别注意：此时，axios 选项为对象(object)，proxy 选项为对象(object)。</strong></p>\n<h2 id=\"6-nuxtjs-x2F-axios-的配置项\"><a href=\"#6-nuxtjs-x2F-axios-的配置项\" class=\"headerlink\" title=\"6.@nuxtjs&#x2F;axios 的配置项\"></a>6.@nuxtjs&#x2F;axios 的配置项</h2><h3 id=\"pathRewrite-选项-重写地址\"><a href=\"#pathRewrite-选项-重写地址\" class=\"headerlink\" title=\"pathRewrite 选项(重写地址)\"></a>pathRewrite 选项(重写地址)</h3><p>如果配置 pathRewrite 选项，可以采用第二种写法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxy: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x27;/api/&#x27;: &#123; target: &#x27;http://api.example.com&#x27;, pathRewrite: &#123;&#x27;^/api/&#x27;: &#x27;&#x27;&#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>&#x2F;api&#x2F;将被添加到 API 端点的所有请求中。可以使用 pathRewrite 选项删除。</p>\n<p>因为在 ajax 的 url 中加了前缀 &#x2F;api，而原本的接口是没有这个前缀的。</p>\n<p>所以需要通过 pathRewrite 来重写地址，将前缀 &#x2F;api 转为 &#x2F;或者是’’。</p>\n<p>如果本身的接口地址就有 &#x2F;api 这种通用前缀，就可以把 pathRewrite 删掉。</p>\n<h3 id=\"retry-选项-自动拦截失败请求\"><a href=\"#retry-选项-自动拦截失败请求\" class=\"headerlink\" title=\"retry 选项(自动拦截失败请求)\"></a>retry 选项(自动拦截失败请求)</h3><p>可以在 axios 选项中，配置 retry 配置项，自动拦截失败请求，默认为 3 次。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">axios: &#123;</span><br><span class=\"line\">  retry: &#123; retries: 3 &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"progress-选项-发出请求时显示加载栏\"><a href=\"#progress-选项-发出请求时显示加载栏\" class=\"headerlink\" title=\"progress 选项(发出请求时显示加载栏)\"></a>progress 选项(发出请求时显示加载栏)</h3><p>与 Nuxt.js 进度条集成，在发出请求时显示加载栏。（仅在浏览器上，当加载栏可用时。）</p>\n<p>您还可以使用 progress 配置为每个请求禁用进度条。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">this.$axios.$get(&#x27;URL&#x27;, &#123; progress: false &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"baseURL-选项（服务器端默认请求地址）\"><a href=\"#baseURL-选项（服务器端默认请求地址）\" class=\"headerlink\" title=\"baseURL 选项（服务器端默认请求地址）\"></a>baseURL 选项（服务器端默认请求地址）</h3><p>在服务器端使用和预先创建请求的基本 URL。</p>\n<h3 id=\"browserBaseURL-选项（客户端默认请求地址）\"><a href=\"#browserBaseURL-选项（客户端默认请求地址）\" class=\"headerlink\" title=\"browserBaseURL 选项（客户端默认请求地址）\"></a>browserBaseURL 选项（客户端默认请求地址）</h3><p>在客户端使用和预先创建请求的基本 URL。</p>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"React-router5.x 路由的使用及配置","url":"/2022/12/16/React-router5-x-%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%85%8D%E7%BD%AE/","content":"<p>在 React router 中通常使用的组件有三种：</p>\n<ul>\n<li>路由组件（作为根组件）: BrowserRouter（history 模式） 和 HashRouter（hash 模式）</li>\n<li>路径匹配组件: Route 和 Switch</li>\n<li>导航组件: Link 和 NavLink</li>\n</ul>\n<p>关于路由组件，如果我们的应用有服务器响应 web 的请求，建议使用<BrowserRouter>组件; 如果使用静态文件服务器，建议使用<HashRouter>组件</p>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install react-router-dom</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-实例\"><a href=\"#2-实例\" class=\"headerlink\" title=\"2. 实例\"></a>2. 实例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component, Fragment &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123; Provider &#125; from &#x27;react-redux&#x27;;</span><br><span class=\"line\">import &#123; BrowserRouter, Route &#125; from &#x27;react-router-dom&#x27;;</span><br><span class=\"line\">import store from &#x27;./store&#x27;;</span><br><span class=\"line\">import Header from &#x27;./common/header&#x27;;</span><br><span class=\"line\">import Home from &#x27;./pages/home&#x27;;</span><br><span class=\"line\">import Detail from &#x27;./pages/detail&#x27;;</span><br><span class=\"line\">import Login from &#x27;./pages/login&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">        &lt;Fragment&gt;</span><br><span class=\"line\">          &lt;BrowserRouter&gt;</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">              &lt;Header /&gt;</span><br><span class=\"line\">              &lt;Route path=&#x27;/&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">              &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">              &lt;Route path=&#x27;/detail/:id&#x27; exact component=&#123;Detail&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">          &lt;/BrowserRouter&gt;</span><br><span class=\"line\">        &lt;/Fragment&gt;</span><br><span class=\"line\">      &lt;/Provider&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default App;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-路由组件-BrowserRouter-和-HashRouter\"><a href=\"#3-路由组件-BrowserRouter-和-HashRouter\" class=\"headerlink\" title=\"3. 路由组件 BrowserRouter 和 HashRouter\"></a>3. 路由组件 BrowserRouter 和 HashRouter</h2><p>BrowserRouter（history 模式） 和 HashRouter（hash 模式）作为路由配置的最外层容器，是两种不同的模式，可根据需要选择。</p>\n<p><strong>history 模式：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;BrowserRouter&gt;</span><br><span class=\"line\">          &lt;Header /&gt;</span><br><span class=\"line\">          &lt;Route path=&#x27;/&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">          &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">          &lt;Route path=&#x27;/detail/:id&#x27; exact component=&#123;Detail&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">      &lt;/BrowserRouter&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>hash 模式：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;HashRouter&gt;</span><br><span class=\"line\">          &lt;Header /&gt;</span><br><span class=\"line\">          &lt;Route path=&#x27;/&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">          &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">          &lt;Route path=&#x27;/detail/:id&#x27; exact component=&#123;Detail&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">      &lt;/HashRouter&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-路径匹配组件-Route-和-Switch\"><a href=\"#4-路径匹配组件-Route-和-Switch\" class=\"headerlink\" title=\"4. 路径匹配组件: Route 和 Switch\"></a>4. 路径匹配组件: Route 和 Switch</h2><h3 id=\"一、Route-用来控制路径对应显示的组件\"><a href=\"#一、Route-用来控制路径对应显示的组件\" class=\"headerlink\" title=\"一、Route: 用来控制路径对应显示的组件\"></a>一、Route: 用来控制路径对应显示的组件</h3><p>有以下几个参数：</p>\n<ul>\n<li>4.1 path：指定路由跳转路径</li>\n<li>4.2 exact: 精确匹配路由</li>\n<li>4.3 component：路由对应的组件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import About from &#x27;./pages/about&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">··· ···</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Route path=&#x27;/about&#x27; exact component=&#123;About&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4.4 render： 通过写 render 函数返回具体的 dom：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Route path=&#x27;/about&#x27; exact render=&#123;() =&gt; (&lt;div&gt;about&lt;/div&gt;)&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure>\n\n<p>render 也可以直接返回 About 组件，像下面：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Route path=&#x27;/about&#x27; exact render=&#123;() =&gt; &lt;About /&gt; &#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是，这样写的好处是，不仅可以通过 render 方法传递 props 属性，并且可以传递自定义属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Route path=&#x27;/about&#x27; exact render=&#123;(props) =&gt; &#123;</span><br><span class=\"line\">    return &lt;About &#123;...props&#125; name=&#123;&#x27;cedric&#x27;&#125; /&gt;</span><br><span class=\"line\">&#125;&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后，就可在 About 组件中获取 props 和 name 属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    console.log(this.props)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// this.props：</span><br><span class=\"line\">// history: &#123;length: 9, action: &quot;POP&quot;, location: &#123;…&#125;, createHref: ƒ, push: ƒ, …&#125;</span><br><span class=\"line\">// location: &#123;pathname: &quot;/home&quot;, search: &quot;&quot;, hash: &quot;&quot;, state: undefined, key: &quot;ad7bco&quot;&#125;</span><br><span class=\"line\">// match: &#123;path: &quot;/home&quot;, url: &quot;/home&quot;, isExact: true, params: &#123;…&#125;&#125;</span><br><span class=\"line\">// name: &quot;cedric&quot;</span><br></pre></td></tr></table></figure>\n\n<p>render 方法也可用来进行权限认证：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Route path=&#x27;/user&#x27; exact render=&#123;(props) =&gt; &#123;</span><br><span class=\"line\">    // isLogin 从 redux 中拿到, 判断用户是否登录</span><br><span class=\"line\">    return isLogin ? &lt;User &#123;...props&#125; name=&#123;&#x27;cedric&#x27;&#125; /&gt; : &lt;div&gt;请先登录&lt;/div&gt;</span><br><span class=\"line\">&#125;&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4.5 location: 将 与当前历史记录位置以外的位置相匹配，则此功能在路由过渡动效中非常有用</li>\n<li>4.6 sensitive：是否区分路由大小写</li>\n<li>4.7 strict: 是否配置路由后面的 ‘&#x2F;‘</li>\n</ul>\n<h3 id=\"二、Switch\"><a href=\"#二、Switch\" class=\"headerlink\" title=\"二、Switch\"></a>二、Switch</h3><p>渲染与该地址匹配的第一个子节点<Route>或者<Redirect>。</p>\n<p>类似于选项卡，只是匹配到第一个路由后，就不再继续匹配：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/home&#x27;  component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/login&#x27;  component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/detail&#x27;  component=&#123;detail&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Redirect to=&quot;/home&quot; from=&#x27;/&#x27; /&gt;</span><br><span class=\"line\">&lt;/Switch&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 类似于：</span><br><span class=\"line\">// switch(Route.path) &#123;</span><br><span class=\"line\">//     case &#x27;/home&#x27;:</span><br><span class=\"line\">//         return Home</span><br><span class=\"line\">//     case &#x27;/login&#x27;:</span><br><span class=\"line\">//         return Login</span><br><span class=\"line\">//     ··· ···</span><br><span class=\"line\">// &#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，如果像下面这样:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/home&#x27;  component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/login&#x27;  component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/detail&#x27;  component=&#123;detail&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/detail/:id&#x27;  component=&#123;detailId&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Redirect to=&quot;/home&quot; from=&#x27;/&#x27; /&gt;</span><br><span class=\"line\">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当路由为&#x2F;detail&#x2F;1 时，只会访问匹配组件 detail, 所以需要在 detail 路由上加上 exact:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/home&#x27;  component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/login&#x27;  component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/detail&#x27; exact  component=&#123;detail&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/detail/:id&#x27;  component=&#123;detailId&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Redirect to=&quot;/home&quot; from=&#x27;/&#x27; /&gt;</span><br><span class=\"line\">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：如果路由 Route 外部包裹 Switch 时，路由匹配到对应的组件后，就不会继续渲染其他组件了。但是如果外部不包裹 Switch 时，所有路由组件会先渲染一遍，然后选择到匹配的路由进行显示。</strong></p>\n<h2 id=\"5-导航组件-Link-和-NavLink\"><a href=\"#5-导航组件-Link-和-NavLink\" class=\"headerlink\" title=\"5. 导航组件: Link 和 NavLink\"></a>5. 导航组件: Link 和 NavLink</h2><p>Link 和 NavLink 都可以用来指定路由跳转，NavLink 的可选参数更多。</p>\n<p><strong>Link</strong></p>\n<p>两种配置方式：</p>\n<p><strong>通过字符串执行跳转路由</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Link to=&#x27;/login&#x27;&gt;</span><br><span class=\"line\">    &lt;span&gt;登录&lt;/span&gt;</span><br><span class=\"line\">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>通过对象指定跳转路由</strong></p>\n<ul>\n<li>pathname: 表示要链接到的路径的字符串。</li>\n<li>search: 表示查询参数的字符串形式。</li>\n<li>hash: 放入网址的 hash，例如 #a-hash。</li>\n<li>state: 状态持续到 location。通常用于隐式传参（埋点），可以用来统计页面来源</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Link to=&#123;&#123;</span><br><span class=\"line\">        pathname: &#x27;/login&#x27;,</span><br><span class=\"line\">        search: &#x27;?name=cedric&#x27;,</span><br><span class=\"line\">        hash: &#x27;#someHash&#x27;,</span><br><span class=\"line\">        state: &#123; fromWechat: true &#125;</span><br><span class=\"line\">    &#125;&#125;&gt;</span><br><span class=\"line\">    &lt;span&gt;登录&lt;/span&gt;</span><br><span class=\"line\">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>\n\n<p>点击链接 进入 Login 页面后，就可以在 this.props.location.state 中看到 fromWechat: true</p>\n<p><strong>NavLink</strong></p>\n<p>可以看做 一个特殊版本的 Link，当它与当前 URL 匹配时，为其渲染元素添加样式属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Link to=&#x27;/login&#x27; activeClassName=&quot;selected&quot;&gt;</span><br><span class=\"line\">    &lt;span&gt;登录&lt;/span&gt;</span><br><span class=\"line\">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;NavLink</span><br><span class=\"line\">  to=&quot;/login&quot;</span><br><span class=\"line\">  activeStyle=&#123;&#123;</span><br><span class=\"line\">    fontWeight: &#x27;bold&#x27;,</span><br><span class=\"line\">    color: &#x27;red&#x27;</span><br><span class=\"line\">   &#125;&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">    &lt;span&gt;登录&lt;/span&gt;</span><br><span class=\"line\">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>exact: 如果为 true，则仅在位置完全匹配时才应用 active 的类&#x2F;样式。</li>\n<li>strict: 当为 true，要考虑位置是否匹配当前的 URL 时，pathname 尾部的斜线要考虑在内。</li>\n<li>location 接收一个 location 对象，当 url 满足这个对象的条件才会跳转</li>\n<li>isActive: 接收一个回调函数，只有当 active 状态变化时才能触发，如果返回 false 则跳转失败</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const oddEvent = (match, location) =&gt; &#123;</span><br><span class=\"line\">  if (!match) &#123;</span><br><span class=\"line\">    return false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const eventID = parseInt(match.params.eventID)</span><br><span class=\"line\">  return !isNaN(eventID) &amp;&amp; eventID % 2 === 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;NavLink</span><br><span class=\"line\">  to=&quot;/login&quot;</span><br><span class=\"line\">  isActive=&#123;oddEvent&#125;</span><br><span class=\"line\">&gt;login&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-Redirect\"><a href=\"#6-Redirect\" class=\"headerlink\" title=\"6. Redirect\"></a>6. Redirect</h2><p><Redirect> 将导航到一个新的地址。即重定向。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/home&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">    &lt;Redirect to=&quot;/home&quot; from=&#x27;/&#x27; exact /&gt;</span><br><span class=\"line\">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面，当访问路由‘&#x2F;’时，会直接重定向到‘&#x2F;home’。<br><Redirect> 常在用户是否登录：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Center extends PureComponent &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        const &#123; loginStatus &#125; = this.props;</span><br><span class=\"line\">        if (loginStatus) &#123;</span><br><span class=\"line\">            return (</span><br><span class=\"line\">                &lt;div&gt;个人中心&lt;/div&gt;</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return &lt;Redirect to=&#x27;/login&#x27; /&gt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可使用对象形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Redirect</span><br><span class=\"line\">  to=&#123;&#123;</span><br><span class=\"line\">    pathname: &quot;/login&quot;,</span><br><span class=\"line\">    search: &quot;?utm=your+face&quot;,</span><br><span class=\"line\">    state: &#123; referrer: currentLocation &#125;</span><br><span class=\"line\">  &#125;&#125;</span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-withRouter\"><a href=\"#7-withRouter\" class=\"headerlink\" title=\"7. withRouter\"></a>7. withRouter</h2><p>withRouter 可以将一个非路由组件包裹为路由组件，使这个非路由组件也能访问到当前路由的 match, location, history 对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; withRouter &#125; from &#x27;react-router-dom&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Detail extends Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        ··· ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const mapStateToProps = (state) =&gt; &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        ··· ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const mapDispatchToProps = (dispatch) =&gt; &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        ··· ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default connect(mapStateToProps, mapDispatchToProps)(withRouter(Detail));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-编程式导航-history-对象\"><a href=\"#8-编程式导航-history-对象\" class=\"headerlink\" title=\"8. 编程式导航 - history 对象\"></a>8. 编程式导航 - history 对象</h2><p>例如，点击 img 进入登录页：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Home extends PureComponent &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    goHome = () =&gt; &#123;</span><br><span class=\"line\">        console.log(this.props);</span><br><span class=\"line\"></span><br><span class=\"line\">        this.props.history.push(&#123;</span><br><span class=\"line\">            pathname: &#x27;/login&#x27;,</span><br><span class=\"line\">            state: &#123;</span><br><span class=\"line\">                identityId: 1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;img className=&#x27;banner-img&#x27; alt=&#x27;&#x27; src=&quot;img.png&quot; onClick=&#123;this.goHome&#125; /&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>history 对象通常会具有以下属性和方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">length - (number 类型) history 堆栈的条目数</span><br><span class=\"line\">action - (string 类型) 当前的操作(PUSH, REPLACE, POP)</span><br><span class=\"line\">location - (object 类型) 当前的位置。location 会具有以下属性：</span><br><span class=\"line\">pathname - (string 类型) URL 路径</span><br><span class=\"line\">search - (string 类型) URL 中的查询字符串</span><br><span class=\"line\">hash - (string 类型) URL 的哈希片段</span><br><span class=\"line\">state - (object 类型) 提供给例如使用 push(path, state) 操作将 location 放入堆栈时的特定 location 状态。只在浏览器和内存历史中可用。</span><br><span class=\"line\">push(path, [state]) - (function 类型) 在 history 堆栈添加一个新条目</span><br><span class=\"line\">replace(path, [state]) - (function 类型) 替换在 history 堆栈中的当前条目</span><br><span class=\"line\">go(n) - (function 类型) 将 history 堆栈中的指针调整 n</span><br><span class=\"line\">goBack() - (function 类型) 等同于 go(-1)</span><br><span class=\"line\">goForward() - (function 类型) 等同于 go(1)</span><br><span class=\"line\">block(prompt) - (function 类型) 阻止跳转。</span><br></pre></td></tr></table></figure>\n\n<p>注意，只有通过 Route 组件渲染的组件，才能在 this.props 上找到 history 对象<br>所以，如果想在路由组件的子组件中使用 history ，需要使用 withRouter 包裹:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; PureComponent &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123; withRouter &#125; from &#x27;react-router-dom&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class 子组件 extends PureComponent &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    goHome = () =&gt; &#123;</span><br><span class=\"line\">        this.props.history.push(&#x27;/home&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        console.log(this.props)</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div onClick=&#123;this.goHome&#125;&gt;子组件&lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default withRouter(子组件);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-路由过渡动画\"><a href=\"#9-路由过渡动画\" class=\"headerlink\" title=\"9. 路由过渡动画\"></a>9. 路由过渡动画</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; TransitionGroup, CSSTransition &#125; from &quot;react-transition-group&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">        &lt;Fragment&gt;</span><br><span class=\"line\">          &lt;BrowserRouter&gt;</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">              &lt;Header /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">              &#123;/* 最外部的&lt;Route&gt;&lt;/Route&gt;不进行任何路由匹配，仅仅是用来传递 location */&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              &lt;Route render=&#123;(&#123;location&#125;) =&gt; &#123;</span><br><span class=\"line\">                console.log(location);</span><br><span class=\"line\">                return (</span><br><span class=\"line\">                  &lt;TransitionGroup&gt;</span><br><span class=\"line\">                    &lt;CSSTransition</span><br><span class=\"line\">                      key=&#123;location.key&#125;</span><br><span class=\"line\">                      classNames=&#x27;fade&#x27;</span><br><span class=\"line\">                      timeout=&#123;300&#125;</span><br><span class=\"line\">                    &gt;</span><br><span class=\"line\">                      &lt;Switch&gt;</span><br><span class=\"line\">                        &lt;Redirect exact from=&#x27;/&#x27; to=&#x27;/home&#x27; /&gt;</span><br><span class=\"line\">                        &lt;Route path=&#x27;/home&#x27; exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">                        &lt;Route path=&#x27;/login&#x27; exact component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">                        &lt;Route path=&#x27;/write&#x27; exact component=&#123;Write&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">                        &lt;Route path=&#x27;/detail/:id&#x27; exact component=&#123;Detail&#125;&gt;&lt;/Route&gt;</span><br><span class=\"line\">                        &lt;Route render=&#123;() =&gt; &lt;div&gt;Not Found&lt;/div&gt;&#125; /&gt;</span><br><span class=\"line\">                      &lt;/Switch&gt;</span><br><span class=\"line\">                    &lt;/CSSTransition&gt;</span><br><span class=\"line\">                  &lt;/TransitionGroup&gt;</span><br><span class=\"line\">                )</span><br><span class=\"line\">              &#125;&#125;&gt;</span><br><span class=\"line\">              &lt;/Route&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">          &lt;/BrowserRouter&gt;</span><br><span class=\"line\">        &lt;/Fragment&gt;</span><br><span class=\"line\">      &lt;/Provider&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.fade-enter &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  z-index: 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.fade-enter.fade-enter-active &#123;</span><br><span class=\"line\">  opacity: 1;</span><br><span class=\"line\">  transition: opacity 300ms ease-in;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-打包部署的路由配置\"><a href=\"#10-打包部署的路由配置\" class=\"headerlink\" title=\"10. 打包部署的路由配置\"></a>10. 打包部署的路由配置</h2><p>项目执行 npm run build 后，将打包后的 build 文件，放置到 Nginx 配置的静态地址中。</p>\n<p>如果 react-router 路由 使用了 history 模式（即<BrowserRouter>），那么在 Nginx 配置中必须加上:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">        ··· ···</span><br><span class=\"line\">        try_files $uri /index.html;</span><br><span class=\"line\">        ··· ···</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 react-router 路由 使用了 hash 模式，那么在 Nginx 中不需要上面的配置。</p>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"React Hooks 用法详解","url":"/2022/12/16/React-Hooks-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/","content":"<p><strong>React 中提供的 hooks：</strong></p>\n<ul>\n<li><p>useState：setState</p>\n</li>\n<li><p>useReducer：setState，同时 useState 也是该方法的封装</p>\n</li>\n<li><p>useRef: ref</p>\n</li>\n<li><p>useImperativeHandle: 给 ref 分配特定的属性</p>\n</li>\n<li><p>useContext: context，需配合 createContext 使用</p>\n</li>\n<li><p>useMemo: 可以对 setState 的优化</p>\n</li>\n<li><p>useCallback: useMemo 的变形，对函数进行优化</p>\n</li>\n<li><p>useEffect: 类似 componentDidMount&#x2F;Update, componentWillUnmount，当效果为 componentDidMount&#x2F;Update 时，总是在整个更新周期的最后（页面渲染完成后）才执行</p>\n</li>\n<li><p>useLayoutEffect: 用法与 useEffect 相同，区别在于该方法的回调会在数据更新完成后，页面渲染之前进行，该方法会阻碍页面的渲染</p>\n</li>\n<li><p>useDebugValue：用于在 React 开发者工具中显示自定义 hook 的标签</p>\n</li>\n</ul>\n<h1 id=\"一、Hooks-初体验\"><a href=\"#一、Hooks-初体验\" class=\"headerlink\" title=\"一、Hooks 初体验\"></a>一、Hooks 初体验</h1><p>example:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useState  &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">function Example() &#123;</span><br><span class=\"line\">    // 声明一个名为“count”的新状态变量</span><br><span class=\"line\">    const [count, setCount] = useState(0);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class=\"line\">                Click me</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Example;</span><br></pre></td></tr></table></figure>\n\n<p>useState 就是一个 Hook，可以在我们不使用 class 组件的情况下，拥有自身的 state，并且可以通过修改 state 来控制 UI 的展示。</p>\n<h2 id=\"1、useState-状态\"><a href=\"#1、useState-状态\" class=\"headerlink\" title=\"1、useState 状态\"></a>1、useState 状态</h2><p>语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const [state, setState] = useState(initialState)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>传入唯一的参数: initialState，可以是数字，字符串等，也可以是对象或者数组。</li>\n<li>返回的是包含两个元素的数组：第一个元素，state 变量，setState 修改 state 值的方法。</li>\n</ul>\n<p>与在类中使用 setState 的异同点：</p>\n<ul>\n<li>相同点：在一次渲染周期中调用多次 setState，数据只改变一次。</li>\n<li>不同点：类中的 setState 是合并，而函数组件中的 setState 是替换。</li>\n</ul>\n<p>使用对比</p>\n<p>之前想要使用组件内部的状态，必须使用 class 组件，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class Example extends Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            count: 0</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class=\"line\">                Click me</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而现在，我们使用函数式组件也可以实现一样的功能了。也就意味着函数式组件内部也可以使用 state 了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">function Example() &#123;</span><br><span class=\"line\">    // 声明一个名为“count”的新状态变量</span><br><span class=\"line\">    const [count, setCount] = useState(0);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class=\"line\">                Click me</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Example;</span><br></pre></td></tr></table></figure>\n\n<p>优化</p>\n<p>创建初始状态是比较昂贵的，所以我们可以在使用 useState API 时，传入一个函数，就可以避免重新创建忽略的初始状态。</p>\n<p>普通的方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 直接传入一个值，在每次 render 时都会执行 createRows 函数获取返回值</span><br><span class=\"line\">const [rows, setRows] = useState(createRows(props.count));</span><br></pre></td></tr></table></figure>\n\n<p>优化后的方式（推荐）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// createRows 只会被执行一次</span><br><span class=\"line\">const [rows, setRows] = useState(() =&gt; createRows(props.count));</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2、useEffect-执行副作用操作\"><a href=\"#2、useEffect-执行副作用操作\" class=\"headerlink\" title=\"2、useEffect 执行副作用操作\"></a>2、useEffect 执行副作用操作</h1><ul>\n<li><strong>effect（副作用）：指那些没有发生在数据向视图转换过程中的逻辑，如 ajax 请求、访问原生 dom 元素、本地持久化缓存、绑定&#x2F;解绑事件、添加订阅、设置定时器、记录日志等</strong>。</li>\n<li><strong>副作用操作可以分两类：需要清除的和不需要清除的。</strong></li>\n<li><strong>需要清除的，比如开启的定时器，订阅外部数据源等，这些操作如果在组件消亡后不及时清除会导致内存泄漏。</strong></li>\n<li><strong>不需要清除的，比如发起网络请求，手动变更 DOM，记录日志等。</strong></li>\n<li>原先在函数组件内（这里指在 React 渲染阶段）改变 dom 、发送 ajax 请求以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性</li>\n<li>useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API</li>\n<li><strong>useEffect 接收一个函数，该函数会在组件渲染到屏幕之后才执行，该函数有要求：要么返回一个能清除副作用的函数，要么就不返回任何内容</strong></li>\n<li>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。</li>\n</ul>\n<p>语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1、useEffect(() =&gt; &#123; doSomething &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">2、useEffect(() =&gt; &#123; doSomething &#125;,[]);</span><br><span class=\"line\"></span><br><span class=\"line\">3、useEffect(() =&gt; &#123; doSomething &#125;,[count]);</span><br></pre></td></tr></table></figure>\n\n<p>第一个参数为 effect 函数，该函数将在 componentDidMount 时触发和 componentDidUpdate 时有条件触发（该添加为 useEffect 的第二个数组参数）</p>\n<p>第二个参数是可选的，根据条件限制看是否触发</p>\n<ul>\n<li><p>如果不传，如语法 1，则每次页面数据有更新（如 componentDidUpdate），都会触发 effect。</p>\n</li>\n<li><p>如果为空数组[]，如语法 2，则每次初始化的时候只执行一次 effect（如 componentDidMmount）</p>\n</li>\n<li><p>如果只需要在指定变量变化时触发 effect，将该变量放入数组。如语法 3，count 只要变化，就会执行 effect，如观察者监听</p>\n</li>\n</ul>\n<p>清除副作用</p>\n<p>副作用函数还可以通过返回一个函数来指定如何清除副作用，为防止内存泄漏，清除函数会在组件卸载前执行。如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已被清除。</p>\n<p><strong>例 1、比如 window.addEventListener(‘resize’, handleResize);：监听 resize 等</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">    window.addEventListener(&#x27;resize&#x27;, handleResize);</span><br><span class=\"line\">    window.addEventListener(&#x27;keydown&#x27;, onKeyDown);</span><br><span class=\"line\">    window.addEventListener(&#x27;keyup&#x27;, onKeyUp);</span><br><span class=\"line\">    return (() =&gt; &#123;</span><br><span class=\"line\">      window.removeEventListener(&#x27;resize&#x27;, handleResize);</span><br><span class=\"line\">      window.removeEventListener(&#x27;keydown&#x27;, onKeyDown);</span><br><span class=\"line\">      window.removeEventListener(&#x27;keyup&#x27;, onKeyUp);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, [globalRef]);</span><br></pre></td></tr></table></figure>\n\n<p><strong>例 2、清除定时器</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Counter()&#123;</span><br><span class=\"line\">    let [number,setNumber] = useState(0);</span><br><span class=\"line\">    let [text,setText] = useState(&#x27;&#x27;);</span><br><span class=\"line\">    useEffect(()=&gt;&#123;</span><br><span class=\"line\">        let $timer = setInterval(()=&gt;&#123;</span><br><span class=\"line\">            setNumber(number=&gt;number+1);</span><br><span class=\"line\">        &#125;,1000);</span><br><span class=\"line\">        // useEffect 如果返回一个函数的话，该函数会在组件卸载和更新时调用</span><br><span class=\"line\">        // useEffect 在执行副作用函数之前，会先调用上一次返回的函数</span><br><span class=\"line\">        // 如果要清除副作用，要么返回一个清除副作用的函数</span><br><span class=\"line\">       /*  return ()=&gt;&#123;</span><br><span class=\"line\">            console.log(&#x27;destroy effect&#x27;);</span><br><span class=\"line\">            clearInterval($timer);</span><br><span class=\"line\">        &#125; */</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // &#125;,[]);//要么在这里传入一个空的依赖项数组，这样就不会去重复执行</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">          &lt;input value=&#123;text&#125; onChange=&#123;(event)=&gt;setText(event.target.value)&#125;/&gt;</span><br><span class=\"line\">          &lt;p&gt;&#123;number&#125;&lt;/p&gt;</span><br><span class=\"line\">          &lt;button&gt;+&lt;/button&gt;</span><br><span class=\"line\">        &lt;/&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、useContext-组件之间传值\"><a href=\"#3、useContext-组件之间传值\" class=\"headerlink\" title=\"3、useContext 组件之间传值\"></a>3、useContext 组件之间传值</h1><p>语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const value = useContext(MyContext);</span><br></pre></td></tr></table></figure>\n\n<p>之前在用类声明组件时，父子组件的传值是通过组件属性和 props 进行的，那现在使用方法(Function)来声明组件，已经没有了 constructor 构造函数也就没有了 props 的接收，但是也可以直接收，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">组件：</span><br><span class=\"line\">&lt;SwitchList dataList=&#123;toolsList&#125; isReverse=&#123;false&#125;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">接收：</span><br><span class=\"line\">const SwitchList = (&#123;dataList = null, isReverse = false&#125;: any): React.ReactElement =&gt; &#123;</span><br><span class=\"line\">    //TODO</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>React Hooks 也为我们准备了 useContext。它可以帮助我们跨越组件层级直接传递变量，实现共享。</p>\n<h3 id=\"一：利用-createContext-创建上下文\"><a href=\"#一：利用-createContext-创建上下文\" class=\"headerlink\" title=\"一：利用 createContext 创建上下文\"></a>一：利用 createContext 创建上下文</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useState , createContext &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建一个 CountContext</span><br><span class=\"line\">const CountContext = createContext()</span><br><span class=\"line\"></span><br><span class=\"line\">function Example()&#123;</span><br><span class=\"line\">  const [ count , setCount ] = useState(0);</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/button&gt;</span><br><span class=\"line\">      &#123;/* 将 context 传递给 子组件,context 值由value props决定*/&#125;</span><br><span class=\"line\">      &lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class=\"line\">        &lt;Counter/&gt;</span><br><span class=\"line\">      &lt;/CountContext.Provider&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default Example;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二：使用-useContext-获取上下文\"><a href=\"#二：使用-useContext-获取上下文\" class=\"headerlink\" title=\"二：使用 useContext 获取上下文\"></a>二：使用 useContext 获取上下文</h3><p>对于要接收 context 的后代组件，只需引入 useContext() Hooks 即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Counter()&#123;</span><br><span class=\"line\">  const count = useContext(CountContext)  //一句话就可以得到count</span><br><span class=\"line\">  return (&lt;h2&gt;&#123;count&#125;&lt;/h2&gt;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>强调一点：<br>useContext 的参数必须是 context 对象本身：</p>\n<ul>\n<li>正确： useContext(MyContext)</li>\n<li>错误： useContext(MyContext.Consumer)</li>\n<li>错误： useContext(MyContext.Provider)</li>\n</ul>\n<p>当组件上层最近的<code> &lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>&lt;MyContext.Provider&gt; </code>的 context value 值。</p>\n<h1 id=\"4、useReducer-处理更为复杂-state-结构\"><a href=\"#4、useReducer-处理更为复杂-state-结构\" class=\"headerlink\" title=\"4、useReducer 处理更为复杂 state 结构\"></a>4、useReducer 处理更为复杂 state 结构</h1><p>语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>\n\n<p>useReducer 接收一个形如 (state, action) &#x3D;&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。</p>\n<p>我们可以使用 useReducer 来重新写我们开篇计数器的 demo：</p>\n<p>Example:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useReducer &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const initialState = &#123;count: 0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function reducer(state, action) &#123;</span><br><span class=\"line\">    switch (action.type) &#123;</span><br><span class=\"line\">        case &#x27;increment&#x27;:</span><br><span class=\"line\">            return &#123;count: state.count + 1&#125;;</span><br><span class=\"line\">        case &#x27;decrement&#x27;:</span><br><span class=\"line\">            return &#123;count: state.count - 1&#125;;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            throw new Error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default () =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 使用 useReducer 函数创建状态 state 以及更新状态的 dispatch 函数</span><br><span class=\"line\">    const [state, dispatch] = useReducer(reducer, initialState);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            Count: &#123;state.count&#125;</span><br><span class=\"line\">            &lt;br /&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class=\"line\">        &lt;/&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优化：延迟初始化</strong></p>\n<p>还可以懒惰地创建初始状态。为此，您可以将 init 函数作为第三个参数传递。初始状态将设置为 init(initialArg)。</p>\n<p>它允许您提取用于计算 reducer 外部的初始状态的逻辑。这对于稍后重置状态以响应操作也很方便：</p>\n<p>Example.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useReducer &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">function init(initialCount) &#123;</span><br><span class=\"line\">    return &#123;count: initialCount&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function reducer(state, action) &#123;</span><br><span class=\"line\">    switch (action.type) &#123;</span><br><span class=\"line\">        case &#x27;increment&#x27;:</span><br><span class=\"line\">            return &#123;count: state.count + 1&#125;;</span><br><span class=\"line\">        case &#x27;decrement&#x27;:</span><br><span class=\"line\">            return &#123;count: state.count - 1&#125;;</span><br><span class=\"line\">        case &#x27;reset&#x27;:</span><br><span class=\"line\">            return init(action.payload);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            throw new Error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default (&#123;initialCount = 0&#125;) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            Count: &#123;state.count&#125;</span><br><span class=\"line\">            &lt;br /&gt;</span><br><span class=\"line\">            &lt;button</span><br><span class=\"line\">                onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;</span><br><span class=\"line\">                Reset</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class=\"line\">        &lt;/&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与 useState 的区别</p>\n<ul>\n<li>当 state 状态值结构比较复杂时，使用 useReducer 更有优势。</li>\n<li><strong>使用 useState 获取的 setState 方法更新数据时是异步的；而使用 useReducer 获取的 dispatch 方法更新数据是同步的。</strong></li>\n</ul>\n<p>针对第二点区别，我们可以演示一下： 在上面 useState 用法的例子中，我们新增一个 button：</p>\n<p>useState 中的 Example.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">function Example() &#123;</span><br><span class=\"line\">    // 声明一个名为“count”的新状态变量</span><br><span class=\"line\">    const [count, setCount] = useState(0);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class=\"line\">                Click me</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class=\"line\">                setCount(count + 1);</span><br><span class=\"line\">                setCount(count + 1);</span><br><span class=\"line\">            &#125;&#125;&gt;</span><br><span class=\"line\">                测试能否连加两次</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Example;</span><br></pre></td></tr></table></figure>\n\n<p>点击 测试能否连加两次 按钮，会发现，点击一次， count 还是只增加了 1，由此可见，useState 确实是 异步 更新数据；</p>\n<p>在上面 useReducer 用法的例子中，我们新增一个 button： useReducer 中的 Example.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useReducer &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const initialState = &#123;count: 0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function reducer(state, action) &#123;</span><br><span class=\"line\">    switch (action.type) &#123;</span><br><span class=\"line\">        case &#x27;increment&#x27;:</span><br><span class=\"line\">            return &#123;count: state.count + 1&#125;;</span><br><span class=\"line\">        case &#x27;decrement&#x27;:</span><br><span class=\"line\">            return &#123;count: state.count - 1&#125;;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            throw new Error();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default () =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 使用 useReducer 函数创建状态 state 以及更新状态的 dispatch 函数</span><br><span class=\"line\">    const [state, dispatch] = useReducer(reducer, initialState);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            Count: &#123;state.count&#125;</span><br><span class=\"line\">            &lt;br /&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class=\"line\">                dispatch(&#123;type: &#x27;increment&#x27;&#125;);</span><br><span class=\"line\">                dispatch(&#123;type: &#x27;increment&#x27;&#125;);</span><br><span class=\"line\">            &#125;&#125;&gt;</span><br><span class=\"line\">                测试能否连加两次</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">        &lt;/&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>点击 测试能否连加两次 按钮，会发现，点击一次， count 增加了 2，由此可见，每次 dispatch 一个 action 就会更新一次数据，useReducer 确实是 同步 更新数据；</p>\n<p>对于 useReducer 和 useState 的区别主要是以下两点：</p>\n<ul>\n<li>当 state 状态值结构比较复杂时，使用 useReducer 更有优势。</li>\n<li>使用 useState 获取的 setState 方法更新数据时是异步的；而使用 useReducer 获取的 dispatch 方法更新数据是同步的。</li>\n</ul>\n<h1 id=\"5、useMemo-性能优化\"><a href=\"#5、useMemo-性能优化\" class=\"headerlink\" title=\"5、useMemo 性能优化\"></a>5、useMemo 性能优化</h1><p>语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>\n\n<p>返回一个 memoized 值。 传递“创建”函数和依赖项数组。useMemo 只会在其中一个依赖项发生更改时重新计算 memoized 值。此优化有助于避免在每个渲染上进行昂贵的计算。</p>\n<blockquote>\n<p>useMemo 在渲染过程中传递的函数会运行。不要做那些在渲染时通常不会做的事情。例如，副作用属于 useEffect，而不是 useMemo。</p>\n</blockquote>\n<p>用法</p>\n<p>useMemo 可以帮助我们优化子组件的渲染，比如这种场景： 在 A 组件中有两个子组件 B 和 C，当 A 组件中传给 B 的 props 发生变化时，A 组件状态会改变，重新渲染。此时 B 和 C 也都会重新渲染。其实这种情况是比较浪费资源的，现在我们就可以使用 useMemo 进行优化，B 组件用到的 props 变化时，只有 B 发生改变，而 C 却不会重新渲染。</p>\n<p>例子：</p>\n<p>ExampleA.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default (&#123; text &#125;) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&#x27;Example A：&#x27;, &#x27;render&#x27;);</span><br><span class=\"line\">    return &lt;div&gt;Example A 组件：&#123; text &#125;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ExampleB.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default (&#123; text &#125;) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&#x27;Example B：&#x27;, &#x27;render&#x27;);</span><br><span class=\"line\">    return &lt;div&gt;Example B 组件：&#123; text &#125;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>App.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import ExampleA from &#x27;./ExampleA&#x27;;</span><br><span class=\"line\">import ExampleB from &#x27;./ExampleB&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#x27;./App.css&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default () =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const [a, setA] = useState(&#x27;ExampleA&#x27;);</span><br><span class=\"line\">    const [b, setB] = useState(&#x27;ExampleB&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;ExampleA text=&#123; a &#125; /&gt;</span><br><span class=\"line\">            &lt;ExampleB text=&#123; b &#125; /&gt;</span><br><span class=\"line\">            &lt;br /&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123; () =&gt; setA(&#x27;修改后的 ExampleA&#x27;) &#125;&gt;修改传给 ExampleA 的属性&lt;/button&gt;</span><br><span class=\"line\">            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class=\"line\">            &lt;button onClick=&#123; () =&gt; setB(&#x27;修改后的 ExampleB&#x27;) &#125;&gt;修改传给 ExampleB 的属性&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们点击上面任意一个按钮，都会看到控制台打印了两条输出， A 和 B 组件都会被重新渲染。</p>\n<p>现在我们使用 useMemo 进行优化</p>\n<p>App.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useState, useMemo &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import ExampleA from &#x27;./ExampleA&#x27;;</span><br><span class=\"line\">import ExampleB from &#x27;./ExampleB&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#x27;./App.css&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default () =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const [a, setA] = useState(&#x27;ExampleA&#x27;);</span><br><span class=\"line\">    const [b, setB] = useState(&#x27;ExampleB&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">+    const exampleA = useMemo(() =&gt; &lt;ExampleA /&gt;, [a]);</span><br><span class=\"line\">+    const exampleB = useMemo(() =&gt; &lt;ExampleB /&gt;, [b]);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">+            &#123;/* &lt;ExampleA text=&#123; a &#125; /&gt;</span><br><span class=\"line\">+            &lt;ExampleB text=&#123; b &#125; /&gt; */&#125;</span><br><span class=\"line\">+            &#123; exampleA &#125;</span><br><span class=\"line\">+            &#123; exampleB &#125;</span><br><span class=\"line\">            &lt;br /&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123; () =&gt; setA(&#x27;修改后的 ExampleA&#x27;) &#125;&gt;修改传给 ExampleA 的属性&lt;/button&gt;</span><br><span class=\"line\">            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class=\"line\">            &lt;button onClick=&#123; () =&gt; setB(&#x27;修改后的 ExampleB&#x27;) &#125;&gt;修改传给 ExampleB 的属性&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们点击不同的按钮，控制台都只会打印一条输出，改变 a 或者 b，A 和 B 组件都只有一个会重新渲染。</p>\n<h1 id=\"6、useCallback-优化函数式组件性能\"><a href=\"#6、useCallback-优化函数式组件性能\" class=\"headerlink\" title=\"6、useCallback 优化函数式组件性能\"></a>6、useCallback 优化函数式组件性能</h1><p>语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const memoizedCallback = useCallback(() =&gt; &#123; doSomething(a, b); &#125;, [a, b]);</span><br></pre></td></tr></table></figure>\n\n<p>返回值 memoizedCallback 是一个 memoized 回调。传递内联回调和一系列依赖项。useCallback 将返回一个回忆的 memoized 版本，该版本仅在其中一个依赖项发生更改时才会更改。当将回调传递给依赖于引用相等性的优化子组件以防止不必要的渲染（例如 shouldComponentUpdate）时，这非常有用。</p>\n<p>这个 Hook 的 API 不能够一两句解释的清楚，建议看一下这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/56975681\">useHooks 第一期：聊聊 hooks 中的 useCallback</a>。里面介绍的比较详细。</p>\n<h1 id=\"7、useRef-获取-dom\"><a href=\"#7、useRef-获取-dom\" class=\"headerlink\" title=\"7、useRef 获取 dom\"></a>7、useRef 获取 dom</h1><p>语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>\n\n<p>类组件、React 元素用 <code>React.createRef</code>，如：<code>remindRef: any = React.createRef();</code>通过 <code>this.remindRef.current</code>获取</p>\n<p>函数组件使用 useRef，如<code>let globalToolRef: any = useRef(null);</code>通过<code>globalToolRef.current</code>获取</p>\n<p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传递的参数（initialValue）。返回的对象将存留在整个组件的生命周期中。</p>\n<ul>\n<li>从本质上讲，useRef 就像一个“盒子”，可以在其.current 财产中保持一个可变的价值。</li>\n<li>useRef() Hooks 不仅适用于 DOM 引用。 “ref” 对象是一个通用容器，其 current 属性是可变的，可以保存任何值（可以是元素、对象、基本类型、甚至函数），类似于类上的实例属性。</li>\n</ul>\n<blockquote>\n<p>注意：useRef() 比 ref 属性更有用。与在类中使用 instance(实例) 字段的方式类似，它可以 方便地保留任何可变值。</p>\n</blockquote>\n<blockquote>\n<p>注意，内容更改时 useRef 不会通知您。变异.current 属性不会导致重新渲染。如果要在 React 将引用附加或分离到 DOM 节点时运行某些代码，则可能需要使用回调引用。</p>\n</blockquote>\n<p>使用</p>\n<p>下面这个例子中展示了可以在 useRef() 生成的 ref 的 current 中存入元素、字符串</p>\n<p>Example.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useRef, useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default () =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 使用 useRef 创建 inputEl</span><br><span class=\"line\">    const inputEl = useRef(null);</span><br><span class=\"line\"></span><br><span class=\"line\">    const [text, updateText] = useState(&#x27;&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 使用 useRef 创建 textRef</span><br><span class=\"line\">    const textRef = useRef();</span><br><span class=\"line\"></span><br><span class=\"line\">    useEffect(() =&gt; &#123;</span><br><span class=\"line\">        // 将 text 值存入 textRef.current 中</span><br><span class=\"line\">        textRef.current = text;</span><br><span class=\"line\">        console.log(&#x27;textRef.current：&#x27;, textRef.current);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const onButtonClick = () =&gt; &#123;</span><br><span class=\"line\">        // `current` points to the mounted text input element</span><br><span class=\"line\">        inputEl.current.value = &quot;Hello, useRef&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            &#123;/* 保存 input 的 ref 到 inputEl */&#125;</span><br><span class=\"line\">            &lt;input ref=&#123; inputEl &#125; type=&quot;text&quot; /&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123; onButtonClick &#125;&gt;在 input 上展示文字&lt;/button&gt;</span><br><span class=\"line\">            &lt;br /&gt;</span><br><span class=\"line\">            &lt;br /&gt;</span><br><span class=\"line\">            &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">        &lt;/&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>点击 在 input 上展示文字 按钮，就可以看到第一个 input 上出现 Hello, useRef；在第二个 input 中输入内容，可以看到控制台打印出对应的内容。</p>\n<h1 id=\"8、useLayoutEffect\"><a href=\"#8、useLayoutEffect\" class=\"headerlink\" title=\"8、useLayoutEffect\"></a>8、useLayoutEffect</h1><p>语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">useLayoutEffect(() =&gt; &#123; doSomething &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>与 useEffect Hooks 类似，都是执行副作用操作。但是它是在所有 DOM 更新完成后触发。可以用来执行一些与布局相关的副作用，比如获取 DOM 元素宽高，窗口滚动距离等等。</p>\n<blockquote>\n<p>进行副作用操作时尽量优先选择 useEffect，以免阻止视觉更新。与 DOM 无关的副作用操作请使用 useEffect。</p>\n</blockquote>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>用法与 useEffect 类似。</p>\n<p>Example.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; useRef, useState, useLayoutEffect &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default () =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const divRef = useRef(null);</span><br><span class=\"line\"></span><br><span class=\"line\">    const [height, setHeight] = useState(100);</span><br><span class=\"line\"></span><br><span class=\"line\">    useLayoutEffect(() =&gt; &#123;</span><br><span class=\"line\">        // DOM 更新完成后打印出 div 的高度</span><br><span class=\"line\">        console.log(&#x27;useLayoutEffect: &#x27;, divRef.current.clientHeight);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &lt;&gt;</span><br><span class=\"line\">        &lt;div ref=&#123; divRef &#125; style=&#123;&#123; background: &#x27;red&#x27;, height: height &#125;&#125;&gt;Hello&lt;/div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123; () =&gt; setHeight(height + 50) &#125;&gt;改变 div 高度&lt;/button&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特定场景下的页面闪烁问题。</li>\n<li>useEffect 可以满足百分之 99 的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。</li>\n<li>useEffect 在全部渲染完毕后才会执行</li>\n<li>useLayoutEffect 会在 浏览器 layout 之后，painting 之前执行</li>\n<li>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect</li>\n<li>可以使用它来读取 DOM 布局并同步触发重渲染</li>\n<li>在浏览器执行绘制之前 useLayoutEffect 内部的更新计划将被同步刷新</li>\n<li>尽可能使用标准的 useEffect 以避免阻塞视图更新</li>\n</ul>\n<h1 id=\"forwardRef\"><a href=\"#forwardRef\" class=\"headerlink\" title=\"forwardRef\"></a>forwardRef</h1><p><strong>因为函数组件没有实例，所以函数组件无法像类组件一样可以接收 ref 属性</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Parent() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">         // &lt;Child ref=&#123;xxx&#125; /&gt; 这样是不行的</span><br><span class=\"line\">            &lt;Child /&gt;</span><br><span class=\"line\">            &lt;button&gt;+&lt;/button&gt;</span><br><span class=\"line\">        &lt;/&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>forwardRef 可以在父组件中操作子组件的 ref 对象</li>\n<li>forwardRef 可以将父组件中的 ref 对象转发到子组件中的 dom 元素上</li>\n<li>子组件接受 props 和 ref 作为参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Child(props,ref)&#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; ref=&#123;ref&#125;/&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child = React.forwardRef(Child);</span><br><span class=\"line\">function Parent()&#123;</span><br><span class=\"line\">  let [number,setNumber] = useState(0);</span><br><span class=\"line\">  // 在使用类组件的时候，创建 ref 返回一个对象，该对象的 current 属性值为空</span><br><span class=\"line\">  // 只有当它被赋给某个元素的 ref 属性时，才会有值</span><br><span class=\"line\">  // 所以父组件（类组件）创建一个 ref 对象，然后传递给子组件（类组件），子组件内部有元素使用了</span><br><span class=\"line\">  // 那么父组件就可以操作子组件中的某个元素</span><br><span class=\"line\">  // 但是函数组件无法接收 ref 属性 &lt;Child ref=&#123;xxx&#125; /&gt; 这样是不行的</span><br><span class=\"line\">  // 所以就需要用到 forwardRef 进行转发</span><br><span class=\"line\">  const inputRef = useRef();//&#123;current:&#x27;&#x27;&#125;</span><br><span class=\"line\">  function getFocus()&#123;</span><br><span class=\"line\">    inputRef.current.value = &#x27;focus&#x27;;</span><br><span class=\"line\">    inputRef.current.focus();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">      &lt;&gt;</span><br><span class=\"line\">        &lt;Child ref=&#123;inputRef&#125;/&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;()=&gt;setNumber(&#123;number:number+1&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;/button&gt;</span><br><span class=\"line\">      &lt;/&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"10、useImperativeHandle\"><a href=\"#10、useImperativeHandle\" class=\"headerlink\" title=\"10、useImperativeHandle\"></a>10、useImperativeHandle</h1><ul>\n<li>useImperativeHandle 可以让你在使用 ref 时，自定义暴露给父组件的实例值，不能让父组件想干嘛就干嘛</li>\n<li><strong>在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用</strong></li>\n<li><strong>父组件可以使用操作子组件中的多个 ref</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React,&#123;useState,useEffect,createRef,useRef,forwardRef,useImperativeHandle&#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child(props,parentRef)&#123;</span><br><span class=\"line\">    // 子组件内部自己创建 ref</span><br><span class=\"line\">    let focusRef = useRef();</span><br><span class=\"line\">    let inputRef = useRef();</span><br><span class=\"line\">    useImperativeHandle(parentRef,()=&gt;&#123;</span><br><span class=\"line\">      // 这个函数会返回一个对象</span><br><span class=\"line\">      // 该对象会作为父组件 current 属性的值</span><br><span class=\"line\">      // 通过这种方式，父组件可以使用操作子组件中的多个 ref</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            focusRef,</span><br><span class=\"line\">            inputRef,</span><br><span class=\"line\">            name:&#x27;计数器&#x27;,</span><br><span class=\"line\">            focus()&#123;</span><br><span class=\"line\">                focusRef.current.focus();</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            changeText(text)&#123;</span><br><span class=\"line\">                inputRef.current.value = text;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;&gt;</span><br><span class=\"line\">            &lt;input ref=&#123;focusRef&#125;/&gt;</span><br><span class=\"line\">            &lt;input ref=&#123;inputRef&#125;/&gt;</span><br><span class=\"line\">        &lt;/&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const ForwardChild = forwardRef(Child);</span><br><span class=\"line\">function Parent()&#123;</span><br><span class=\"line\">  const parentRef = useRef();//&#123;current:&#x27;&#x27;&#125;</span><br><span class=\"line\">  function getFocus()&#123;</span><br><span class=\"line\">    parentRef.current.focus();</span><br><span class=\"line\">    // 因为子组件中没有定义这个属性，实现了保护，所以这里的代码无效</span><br><span class=\"line\">    parentRef.current.addNumber(666);</span><br><span class=\"line\">    parentRef.current.changeText(&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;);</span><br><span class=\"line\">    console.log(parentRef.current.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">      &lt;&gt;</span><br><span class=\"line\">        &lt;ForwardChild ref=&#123;parentRef&#125;/&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;/button&gt;</span><br><span class=\"line\">      &lt;/&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>官网介绍 forwardRef 与 useImperativeHandle 结合使用</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200803182456425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjMzMzU0OA==,size_16,color_FFFFFF,t_70\" alt=\"image\"></p>\n<h1 id=\"11、useMemo-和-useCallback-的使用\"><a href=\"#11、useMemo-和-useCallback-的使用\" class=\"headerlink\" title=\"11、useMemo 和 useCallback 的使用\"></a>11、useMemo 和 useCallback 的使用</h1><h2 id=\"useMemo\"><a href=\"#useMemo\" class=\"headerlink\" title=\"useMemo\"></a>useMemo</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p>\n</blockquote>\n<p>也就是说 useMemo 可以让函数在某个依赖项改变的时候才运行，这可以避免很多不必要的开销。举个例子：</p>\n<p><strong>不使用 useMemo</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Example() &#123;</span><br><span class=\"line\">    const [count, setCount] = useState(1);</span><br><span class=\"line\">    const [val, setValue] = useState(&#x27;&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function getNum() &#123;</span><br><span class=\"line\">        return Array.from(&#123;length: count * 100&#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a+b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &lt;div&gt;</span><br><span class=\"line\">        &lt;h4&gt;总和：&#123;getNum()&#125;&lt;/h4&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class=\"line\">            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个组件，维护了两个 state，可以看到 getNum 的计算仅仅跟 count 有关，但是现在无论是 count 还是 val 变化，都会导致 getNum 重新计算，所以这里我们希望 val 修改的时候，不需要再次计算，这种情况下我们可以使用 useMemo。</p>\n<p><strong>使用 useMemo</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Example() &#123;</span><br><span class=\"line\">    const [count, setCount] = useState(1);</span><br><span class=\"line\">    const [val, setValue] = useState(&#x27;&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const getNum = useMemo(() =&gt; &#123;</span><br><span class=\"line\">        return Array.from(&#123;length: count * 100&#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a+b)</span><br><span class=\"line\">    &#125;, [count])</span><br><span class=\"line\"></span><br><span class=\"line\">    return &lt;div&gt;</span><br><span class=\"line\">        &lt;h4&gt;总和：&#123;getNum()&#125;&lt;/h4&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class=\"line\">            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 useMemo 后，并将 count 作为依赖值传递进去，此时仅当 count 变化时才会重新执行 getNum。</p>\n<h2 id=\"useCallback\"><a href=\"#useCallback\" class=\"headerlink\" title=\"useCallback\"></a>useCallback</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const memoizedCallback = useCallback(</span><br><span class=\"line\">  () =&gt; &#123;</span><br><span class=\"line\">    doSomething(a, b);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  [a, b],</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。</p>\n</blockquote>\n<p>看起来似乎和 useMemo 差不多，我们来看看这两者有什么异同：</p>\n<p>useMemo 和 useCallback 接收的参数都是一样，都是在其依赖项发生变化后才执行，都是返回缓存的值，区别在于 useMemo 返回的是函数运行的结果，useCallback 返回的是函数。</p>\n<blockquote>\n<p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)</p>\n</blockquote>\n<p><strong>使用场景</strong></p>\n<p>正如上面所说的，当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。也就是说父组件传递一个函数给子组件的时候，由于父组件的更新会导致该函数重新生成从而传递给子组件的函数引用发生了变化，这就会导致子组件也会更新，而很多时候子组件的更新是没必要的，所以我们可以通过 useCallback 来缓存该函数，然后传递给子组件。举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Parent() &#123;</span><br><span class=\"line\">    const [count, setCount] = useState(1);</span><br><span class=\"line\">    const [val, setValue] = useState(&#x27;&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const getNum = useCallback(() =&gt; &#123;</span><br><span class=\"line\">        return Array.from(&#123;length: count * 100&#125;, (v, i) =&gt; i).reduce((a, b) =&gt; a+b)</span><br><span class=\"line\">    &#125;, [count])</span><br><span class=\"line\"></span><br><span class=\"line\">    return &lt;div&gt;</span><br><span class=\"line\">        &lt;Child getNum=&#123;getNum&#125; /&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt;</span><br><span class=\"line\">            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const Child = React.memo(function (&#123; getNum &#125;: any) &#123;</span><br><span class=\"line\">    return &lt;h4&gt;总和：&#123;getNum()&#125;&lt;/h4&gt;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>使用 useCallback 之后，仅当 count 发生变化时 Child 组件才会重新渲染，而 val 变化时，Child 组件是不会重新渲染的。</p>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"React 开发之Umi乌米框架使用","url":"/2022/12/16/React-%E5%BC%80%E5%8F%91%E4%B9%8BUmi%E4%B9%8C%E7%B1%B3%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/","content":"<p>以往搭建 React 应用时往往使用官方推荐的 # create-react-app 不过使用官方的脚手架往往不能很好的适应我们现有的项目，比如我们要集合 webpack 打包？我们要引入 Redux 状态管理器？Umi （乌米）框架应运而生。</p>\n<p>让我们来看看官方的自我介绍：</p>\n<blockquote>\n<p>umi 以路由为基础的，支持类 next.js 的约定式路由，以及各种进阶的路由功能，并以此进行功能扩展，比如支持路由级的按需加载。然后配以完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求，目前内外部加起来已有 50+ 的插件。</p>\n</blockquote>\n<p>再让我们看看 Umi 的特色：</p>\n<ul>\n<li>📦 开箱即用，内置 react、react-router 等</li>\n<li>🏈 类 next.js 且功能完备的路由约定，同时支持配置的路由方式</li>\n<li>🎉 完善的插件体系，覆盖从源码到构建产物的每个生命周期</li>\n<li>🚀 高性能，通过插件支持 PWA、以路由为单元的 code splitting 等</li>\n<li>💈 支持静态页面导出，适配各种环境，比如中台业务、无线业务、egg、支付宝钱包、云凤蝶等</li>\n<li>🚄 开发启动快，支持一键开启 dll 等</li>\n<li>🐠 一键兼容到 IE9，基于 umi-plugin-polyfills</li>\n<li>🍁 完善的 TypeScript 支持，包括 d.ts 定义和 umi test</li>\n<li>🌴 与 dva 数据流的深入融合，支持 duck directory、model 的自动加载、code splitting 等等</li>\n</ul>\n<h2 id=\"一、搭建流程\"><a href=\"#一、搭建流程\" class=\"headerlink\" title=\"一、搭建流程\"></a>一、搭建流程</h2><p>现在我们自己手动搭建一套完整可用的 Umi 框架吧</p>\n<h3 id=\"第一步：环境检测及安装\"><a href=\"#第一步：环境检测及安装\" class=\"headerlink\" title=\"第一步：环境检测及安装\"></a>第一步：环境检测及安装</h3><p>首先需要 node, 并确保 node 版本是 8.10 或以上。（mac 下推荐使用 nvm 来管理 node 版本）<br>而包管理器，这里推荐使用 yarn 管理 npm 依赖</p>\n<p>1.安装 yarn<br>可根据官网介绍选择安装方式 <a href=\"https://yarnpkg.com/zh-Hans/docs/install#windows-stable\">https://yarnpkg.com/zh-Hans/docs/install#windows-stable</a></p>\n<p>2.全局安装 umi，并确保版本是 2.0.0 或以上。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ yarn global add umi</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第二步：通过脚手架创建项目\"><a href=\"#第二步：通过脚手架创建项目\" class=\"headerlink\" title=\"第二步：通过脚手架创建项目\"></a>第二步：通过脚手架创建项目</h3><p>umi 通过 create-umi 提供脚手架能力</p>\n<ol>\n<li>在需要生成项目的文件夹下，打开 CMD or 终端 命令行输入 yarn create umi</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ yarn create umi</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>选择需要生成的项目类型</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">? Select the boilerplate type (Use arrow keys)</span><br><span class=\"line\">  ant-design-pro  - Create project with an layout-only ant-design-pro boilerplate, use together with umi block.</span><br><span class=\"line\">❯ app             - Create project with a simple boilerplate, support typescript.</span><br><span class=\"line\">  block           - Create a umi block.</span><br><span class=\"line\">  library         - Create a library with umi.</span><br><span class=\"line\">  plugin          - Create a umi plugin.</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>app，通用项目脚手架，支持选择是否启用 TypeScript，以及 umi-plugin-react 包含的功能</li>\n<li>ant-design-pro，仅包含 ant-design-pro 布局的脚手架，具体页面可通过 umi block 添加</li>\n<li>block，区块脚手架</li>\n<li>plugin，插件脚手架</li>\n<li>library，依赖（组件）库脚手架，基于 umi-plugin-library<br>在此我们 上下箭头切换到 app 并回车确定选择。</li>\n</ul>\n<ol start=\"3\">\n<li>其他选项</li>\n</ol>\n<p>此时会出现提示是否需要支持 Typescript, 可根据实际项目开发情况选择是否使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">? Do you want to use typescript? (y/N)</span><br></pre></td></tr></table></figure>\n\n<p>选择 Typescript 支持后再选择你需要的功能（多选），功能介绍详见 <a href=\"https://umijs.org/zh/plugin/umi-plugin-react.html\">plugin&#x2F;umi-plugin-react</a>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">? What functionality do you want to enable? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class=\"line\">❯◯ antd</span><br><span class=\"line\"> ◯ dva</span><br><span class=\"line\"> ◯ code splitting</span><br><span class=\"line\"> ◯ dll</span><br></pre></td></tr></table></figure>\n\n<p>同样按上下箭头移动，并按 空格 键选中需要的功能。<br>antd: UI 框架，启用后实现 antd, antd-mobile 和 antd-pro 的按需编译，无需要手动配置。<br>dva: 基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架<br>code splitting: 是否代码分包<br>dll: 通过 webpack 的 dll 插件预打包一份 dll 文件来达到二次启动提速的目的<br>注意 此处多选项未选择，后期也可以在配置文件中配置。</p>\n<p>确定后，会根据你的选择自动创建好目录和文件。</p>\n<h3 id=\"第三步：运行及编译\"><a href=\"#第三步：运行及编译\" class=\"headerlink\" title=\"第三步：运行及编译\"></a>第三步：运行及编译</h3><p>安装依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ yarn</span><br></pre></td></tr></table></figure>\n\n<p>启动项目</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ yarn start</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以愉快的开发和调试了。</p>\n<p>当我们开发好要编译项目发布测试 or 生产时，执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ yarn build</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、目录结构说明\"><a href=\"#二、目录结构说明\" class=\"headerlink\" title=\"二、目录结构说明\"></a>二、目录结构说明</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dist/ // 默认的 build 输出目录</span><br><span class=\"line\">├── mock/ // mock 文件所在目录，基于 express</span><br><span class=\"line\">├── config/</span><br><span class=\"line\">├── config.js // umi 配置，同 .umirc.js，二选一， 建议配置.umirc.js</span><br><span class=\"line\">└── src/ // 源码目录，可选</span><br><span class=\"line\">├── layouts/index.js // 全局布局</span><br><span class=\"line\">├── pages/ // 页面目录，里面的文件即路由</span><br><span class=\"line\">├── .umi/ // dev 临时目录，需添加到 .gitignore</span><br><span class=\"line\">├── .umi-production/ // build 临时目录，会自动删除</span><br><span class=\"line\">├── document.ejs // HTML 模板</span><br><span class=\"line\">├── 404.js // 404 页面</span><br><span class=\"line\">├── page1.js // 页面 1，任意命名，导出 react 组件</span><br><span class=\"line\">├── page1.test.js // 用例文件，umi test 会匹配所有 .test.js 和 .e2e.js 结尾的文件</span><br><span class=\"line\">└── page2.js // 页面 2，任意命名</span><br><span class=\"line\">├── global.css // 约定的全局样式文件，自动引入，也可以用 global.less</span><br><span class=\"line\">├── global.js // 可以在这里加入 polyfill</span><br><span class=\"line\">├── app.js // 运行时配置文件</span><br><span class=\"line\">├── .umirc.js // umi 配置，同 config/config.js，二选一</span><br><span class=\"line\">├── .env // 环境变量</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、开发提示\"><a href=\"#三、开发提示\" class=\"headerlink\" title=\"三、开发提示\"></a>三、开发提示</h2><p>.umirc.js 配置，<br>该文件中可以配置项目基本情况，如上面安装步骤中出现是否选用 antd, dva 等，在此文件中都可以更改为 true, 另外还可以配置 webpack 打包配置，具体的配置项详见.umirc.js 配置。</p>\n<p>设置.umirc.local.js 文件<br>由于.umirc 里的配置众多而且为了优化项目必然会分包代码抽离等，而在本地运行时无需这些，便可配置.umirc.local.js 文件，注意此文件中的选项配置和.umirc.js 配置一样，不要提交到 git，所以通常需要配置到 .gitignore。本地运行时会和 .umirc.js 合并后再返回。</p>\n<p>由于 umi 会根据 pages 目录自动生成路由配置，所以无需要手动配置路由，会根据 src &#x2F; pages 下 文件名自动生成路由，但是你也可以配置.umirc.js 中的 routes 属性，此配置项存在时则不会对 src&#x2F;pages 目录做约定式的解析。</p>\n<p>常用路由操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; PureComponent &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import Link from &#x27;umi/link&#x27;;</span><br><span class=\"line\">import router from &#x27;umi/router&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Examples extends PureComponent &#123;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;&gt;</span><br><span class=\"line\">                &#123;/* 普通使用 */&#125;</span><br><span class=\"line\">                &lt;Link to=&quot;/list&quot;&gt;跳转&lt;/Link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#123;/* 带参数 */&#125;</span><br><span class=\"line\">                &lt;Link to=&quot;/list?a=b&quot;&gt;跳转&lt;/Link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#123;/* 包含子组件 */&#125;</span><br><span class=\"line\">                &lt;Link to=&quot;/list?a=b&quot;&gt;&lt;button&gt;跳转&lt;/button&gt;&lt;/Link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#123;/* 点击跳转 */&#125;</span><br><span class=\"line\">                &lt;button onClick=&#123;() =&gt; router.push(&#x27;/list&#x27;)&#125;&gt;跳转&lt;/button&gt;</span><br><span class=\"line\">            &lt;/&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default Examples;</span><br></pre></td></tr></table></figure>\n\n<p>更多查看<a href=\"https://umijs.org/zh/api/#%E8%B7%AF%E7%94%B1\">路由配置</a></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>umi 框架为我们开发项目提升了效率，而其本身也在不断的升级完善中，在 2.8.0+版本，umi 可配置 ssr 服务器端渲染，相信 umi 还将越来越完善。<br>更多查看官方文档 <a href=\"https://umijs.org/\">https://umijs.org/</a></p>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"React 的 PureComponent Vs Component","url":"/2022/10/24/React-%E7%9A%84-PureComponent-Vs-Component/","content":"<h2 id=\"一-它们几乎完全相同，但是-PureComponent-通过-prop-和-state-的浅比较来实现-shouldComponentUpdate，某些情况下可以用-PureComponent-提升性能\"><a href=\"#一-它们几乎完全相同，但是-PureComponent-通过-prop-和-state-的浅比较来实现-shouldComponentUpdate，某些情况下可以用-PureComponent-提升性能\" class=\"headerlink\" title=\"一.它们几乎完全相同，但是 PureComponent 通过 prop 和 state 的浅比较来实现 shouldComponentUpdate，某些情况下可以用 PureComponent 提升性能\"></a>一.它们几乎完全相同，但是 PureComponent 通过 prop 和 state 的浅比较来实现 shouldComponentUpdate，某些情况下可以用 PureComponent 提升性能</h2><p>1.所谓浅比较(shallowEqual)，即 react 源码中的一个函数，然后根据下面的方法进行是不是 PureComponent 的判断，帮我们做了本来应该我们在 shouldComponentUpdate 中做的事情</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (this._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class=\"line\">  shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而本来我们做的事情如下，这里判断了 state 有没有发生变化（prop 同理），从而决定要不要重新渲染，这里的函数在一个继承了 Component 的组件中，而这里 this.state.person 是一个对象，你会发现，在这个对象的引用没有发生变化的时候是不会重新 render 的（即下面提到的第三点），所以我们可以用 shouldComponentUpdate 进行优化，这个方法如果返回 false，表示不需要重新进行渲染，返回 true 则重新渲染，默认返回 true</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    return (nextState.person !== this.state.person);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.上面提到的某些情况下可以使用 PureComponent 来提升性能，那具体是哪些情况可以，哪些情况不可以呢，实践出真知</p>\n<p>3.如下显示的是一个 IndexPage 组件，设置了一个 state 是 isShow，通过一个按钮点击可以改变它的值，结果是：初始化的时候输出的是 constructor，render，而第一次点击按钮，会输出一次 render，即重新渲染了一次，界面也会从显示 false 变成显示 true，但是当这个组件是继承自 PureComponent 的时候，再点击的时，不会再输出 render，即不会再重新渲染了，而当这个组件是继承自 Component 时，还是会输出 render，还是会重新渲染，这时候就是 PureComponent 内部做了优化的体现</p>\n<p>4.同理也适用于 string，number 等基本数据类型，因为基本数据类型，值改变了就算改变了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; PureComponent &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class IndexPage extends PureComponent&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      isShow: false</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    console.log(&#x27;constructor&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  changeState = () =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      isShow: true</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(&#x27;render&#x27;);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;this.changeState&#125;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;this.state.isShow.toString()&#125;&lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.当这个 this.state.arr 是一个数组时，且这个组件是继承自 PureComponent 时，初始化依旧是输出 constructor 和 render，但是当点击按钮时，界面上没有变化，也没有输出 render，证明没有渲染，但是我们可以从下面的注释中看到，每点击一次按钮，我们想要修改的 arr 的值已经改变，而这个值将去修改 this.state.arr,但是因为在 PureComponent 中浅比较这个数组的引用没有变化所以没有渲染，this.state.arr 也没有更新，因为在 this.setState()以后，值是在 render 的时候更新的，这里涉及到 this.setState()的知识</p>\n<p>6.但是当这个组件是继承自 Component 的时候，初始化依旧是输出 constructor 和 render，但是当点击按钮时，界面上出现了变化，即我们打印处理的 arr 的值输出，而且每点击一次按钮都会输出一次 render，证明已经重新渲染，this.state.arr 的值已经更新，所以我们能在界面上看到这个变化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; PureComponent &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class IndexPage extends PureComponent&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      arr:[&#x27;1&#x27;]</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    console.log(&#x27;constructor&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  changeState = () =&gt; &#123;</span><br><span class=\"line\">    let &#123; arr &#125; = this.state;</span><br><span class=\"line\">    arr.push(&#x27;2&#x27;);</span><br><span class=\"line\">    console.log(arr);</span><br><span class=\"line\">    // [&quot;1&quot;, &quot;2&quot;]</span><br><span class=\"line\">    // [&quot;1&quot;, &quot;2&quot;, &quot;2&quot;]</span><br><span class=\"line\">    // [&quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;]</span><br><span class=\"line\">    // ....</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      arr</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(&#x27;render&#x27;);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;this.changeState&#125;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &#123;this.state.arr.map((item) =&gt; &#123;</span><br><span class=\"line\">            return item;</span><br><span class=\"line\">          &#125;)&#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>7.下面的例子用扩展运算符产生新数组，使 this.state.arr 的引用发生了变化，所以初始化的时候输出 constructor 和 render 后，每次点击按钮都会输出 render，界面也会变化，不管该组件是继承自 Component 还是 PureComponent 的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; PureComponent &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class IndexPage extends PureComponent&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      arr:[&#x27;1&#x27;]</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    console.log(&#x27;constructor&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  changeState = () =&gt; &#123;</span><br><span class=\"line\">    let &#123; arr &#125; = this.state;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      arr: [...arr, &#x27;2&#x27;]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(&#x27;render&#x27;);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;this.changeState&#125;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &#123;this.state.arr.map((item) =&gt; &#123;</span><br><span class=\"line\">            return item;</span><br><span class=\"line\">          &#125;)&#125;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>8.上面的情况同样适用于对象的情况</p>\n<h2 id=\"二-PureComponent-不仅会影响本身，而且会影响子组件，所以-PureComponent-最佳情况是展示组件\"><a href=\"#二-PureComponent-不仅会影响本身，而且会影响子组件，所以-PureComponent-最佳情况是展示组件\" class=\"headerlink\" title=\"二.PureComponent 不仅会影响本身，而且会影响子组件，所以 PureComponent 最佳情况是展示组件\"></a>二.PureComponent 不仅会影响本身，而且会影响子组件，所以 PureComponent 最佳情况是展示组件</h2><p>1.我们让 IndexPage 组件里面包含一个子组件 Example 来展示 PureComponent 是如何影响子组件的</p>\n<p>2.父组件继承 PureComponent，子组件继承 Component 时：下面的结果初始化时输出为 constructor，IndexPage render，example render，但是当我们点击按钮时，界面没有变化，因为这个 this.state.person 对象的引用没有改变，只是改变了它里面的属性值所以尽管子组件是继承 Component 的也没有办法渲染，因为父组件是 PureComponent，父组件根本没有渲染，所以子组件也不会渲染</p>\n<p>3.父组件继承 PureComponent，子组件继承 PureComponent 时：因为渲染在父组件的时候就没有进行，相当于被拦截了，所以子组件是 PureComponent 还是 Component 根本不会影响结果，界面依旧没有变化</p>\n<p>4.父组件继承 Component，子组件继承 PureComponent 时：结果和我们预期的一样，即初始化是会输出 constructor，IndexPage render，example render，但是点击的时候只会出现 IndexPage render，因为父组件是 Component，所以父组件会渲染，但是<br>当父组件把值传给子组件的时候，因为子组件是 PureComponent，所以它会对 prop 进行浅比较，发现这个 person 对象的引用没有发生变化，所以不会重新渲染，而界面显示是由子组件显示的，所以界面也不会变化</p>\n<p>5.父组件继承 Component，子组件继承 Component 时：初始化是会输出 constructor，IndexPage render，example render，当我们第一次点击按钮以后，界面发生变化，后面就不再改变，因为我们一直把它设置为 sxt2，但是每点击一次都会输出 IndexPage render，example render，因为每次不管父组件还是子组件都会渲染</p>\n<p>6.所以正如下面第四条说的，如果 state 和 prop 一直变化的话，还是建议使用 Component，并且 PureComponent 最好作为展示组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//父组件</span><br><span class=\"line\">import React, &#123; PureComponent, Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import Example from &quot;../components/Example&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class IndexPage extends PureComponent&#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      person: &#123;</span><br><span class=\"line\">        name: &#x27;sxt&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    console.log(&#x27;constructor&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  changeState = () =&gt; &#123;</span><br><span class=\"line\">    let &#123; person &#125; = this.state;</span><br><span class=\"line\">    person.name = &#x27;sxt2&#x27;;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      person</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(&#x27;IndexPage render&#x27;);</span><br><span class=\"line\">    const &#123; person &#125; = this.state;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;this.changeState&#125;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">        &lt;Example person=&#123;person&#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//子组件</span><br><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Example extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(&#x27;example render&#x27;);</span><br><span class=\"line\">    const &#123; person &#125; = this.props;</span><br><span class=\"line\">    return(</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;person.name&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三-若是数组和对象等引用类型，则要引用不同，才会渲染\"><a href=\"#三-若是数组和对象等引用类型，则要引用不同，才会渲染\" class=\"headerlink\" title=\"三.若是数组和对象等引用类型，则要引用不同，才会渲染\"></a>三.若是数组和对象等引用类型，则要引用不同，才会渲染</h2><h2 id=\"四-如果-prop-和-state-每次都会变，那么-PureComponent-的效率还不如-Component，因为你知道的，进行浅比较也是需要时间\"><a href=\"#四-如果-prop-和-state-每次都会变，那么-PureComponent-的效率还不如-Component，因为你知道的，进行浅比较也是需要时间\" class=\"headerlink\" title=\"四.如果 prop 和 state 每次都会变，那么 PureComponent 的效率还不如 Component，因为你知道的，进行浅比较也是需要时间\"></a>四.如果 prop 和 state 每次都会变，那么 PureComponent 的效率还不如 Component，因为你知道的，进行浅比较也是需要时间</h2><h2 id=\"五-若有-shouldComponentUpdate，则执行它，若没有这个方法会判断是不是-PureComponent，若是，进行浅比较\"><a href=\"#五-若有-shouldComponentUpdate，则执行它，若没有这个方法会判断是不是-PureComponent，若是，进行浅比较\" class=\"headerlink\" title=\"五.若有 shouldComponentUpdate，则执行它，若没有这个方法会判断是不是 PureComponent，若是，进行浅比较\"></a>五.若有 shouldComponentUpdate，则执行它，若没有这个方法会判断是不是 PureComponent，若是，进行浅比较</h2><p>1.继承自 Component 的组件，若是 shouldComponentUpdate 返回 false，就不会渲染了，继承自 PureComponent 的组件不用我们手动去判断 prop 和 state，所以在 PureComponent 中使用 shouldComponentUpdate 会有如下警告:</p>\n<p><code>IndexPage has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.</code></p>\n<p>也是比较好理解的，就是不要在 PureComponent 中使用 shouldComponentUpdate，因为根本没有必要</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"React16的新特性","url":"/2022/12/16/React16%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/","content":"<h1 id=\"一、新的组件生命周期钩子\"><a href=\"#一、新的组件生命周期钩子\" class=\"headerlink\" title=\"一、新的组件生命周期钩子\"></a>一、新的组件生命周期钩子</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/12185313-85b3010f0b8b7d16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp\" alt=\"image\"></p>\n<p>React 的生命周期钩子允许开发者在组件实例化、完成渲染、属性、更新、销毁等不同阶段操作组件。这给我们的开发带来更多的灵活性；</p>\n<p>但是，如果开发者对各个生命周期的理解错误，很容易造成对它的滥用，就会造成性能上的浪费等问题。</p>\n<p>比如：componentWillMount 对组件进行 setState、dom 操作、添加事件监听、获取数据等。这些都是不安全的操作。</p>\n<p>react16 对组件的生命周期做了优化，”移除”容易被大家误解的钩子，添加更加容易理解、安全的钩子。</p>\n<p>“删除”了以下钩子（17 版本中将真的删除）：</p>\n<p><code>componentWillMount()</code></p>\n<p><code>componentWillReceiveProps(nextProps, nextState)</code></p>\n<p><code>componentWillUpdate()</code></p>\n<p>新增了以下钩子：</p>\n<p><code>static getDerivedStateFromProps(nextProps, prevState)</code></p>\n<p><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></p>\n<p><code>componentDidCatch(error, info)</code></p>\n<h2 id=\"a-如何理解-static-getDerivedStateFromProps-nextProps-prevState-？\"><a href=\"#a-如何理解-static-getDerivedStateFromProps-nextProps-prevState-？\" class=\"headerlink\" title=\"a. 如何理解 static getDerivedStateFromProps(nextProps, prevState)？\"></a>a. 如何理解 static getDerivedStateFromProps(nextProps, prevState)？</h2><blockquote>\n<p>首先，需要对静态方法做一个理解。static 静态方法，在 es5 中怎么实现呢？<br>function Person() {}<br>Person.getCount &#x3D; function () {}<br>以上就是 static 静态方法的原理。由于“this”只能获取属性是根据原型链，而静态方法不在原型链上，所以，在组件实例内无法通过 this 调用 static 方法，static 方法也无法根据”this”调用实例的其他方法。<br>就防止在 getDerivedStateFromProps 对组件实例的错误操作。<br>再次，getDerivedStateFromProps 用来做什么用呢？<br>当组件实例化、接收到新的 props 时，会调用该方法。方法返回一个对象，这个对象会被更新到组件的 state 上。如果返回空，那么不对 state 做更新。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 以下代码实现，更新name属性到state上；</span><br><span class=\"line\">static getDerivedStateFromProps (nextProps, prevState) &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        name: nextProps.name</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 上面的代码在以前版本中</span><br><span class=\"line\">// 你可能会用以下这样做，虽然这样做看起来也没问题，用上面的方法更加安全，不会对this做误操作</span><br><span class=\"line\">componentWillReceiveProps (nextProps) &#123;</span><br><span class=\"line\">    if (this.state.name !== nextProps.name) &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            name: nextProps.name</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>这个生命周期函数是为了替代 componentWillReceiveProps 存在的，所以在你需要使用 componentWillReceiveProps 的时候，就可以考虑使用 getDerivedStateFromProps 来进行替代了。</p>\n<p>两者的参数是不相同的，而 getDerivedStateFromProps 是一个静态函数，也就是这个函数不能通过 this 访问到 class 的属性，也并不推荐直接访问属性。而是应该通过参数提供的 nextProps 以及 prevState 来进行判断，根据新传入的 props 来映射到 state。</p>\n<p>需要注意的是，如果 props 传入的内容不需要影响到你的 state，那么就需要返回一个 null，这个返回值是必须的，所以尽量将其写到函数的末尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">static getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class=\"line\">    const &#123;type&#125; = nextProps;</span><br><span class=\"line\">    // 当传入的type发生变化的时候，更新state</span><br><span class=\"line\">    if (type !== prevState.type) &#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            type,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 否则，对于state不进行任何操作</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"b-如何理解-getSnapshotBeforeUpdate-prevProps-prevState-？\"><a href=\"#b-如何理解-getSnapshotBeforeUpdate-prevProps-prevState-？\" class=\"headerlink\" title=\"b. 如何理解 getSnapshotBeforeUpdate(prevProps, prevState)？\"></a>b. 如何理解 getSnapshotBeforeUpdate(prevProps, prevState)？</h2><blockquote>\n<p>首先，从字面来理解“snapshot”是快照的意思。在 dom 更新之前调用。返回的值将被传给 componentDidUpdate(prevProps, prevState, snaphot)。<br>这个会比较少用到，但对于处理比如数据更新后的滚动条的差异滚动，对用户体验，很有帮助。</p>\n</blockquote>\n<h2 id=\"c-如何理解-componentDidCatch-error-info-？\"><a href=\"#c-如何理解-componentDidCatch-error-info-？\" class=\"headerlink\" title=\"c. 如何理解 componentDidCatch(error, info)？\"></a>c. 如何理解 componentDidCatch(error, info)？</h2><blockquote>\n<p>以往，当组件发生错误（可以用 throw new Error 模拟）时，会导致整个 react 程序死掉，这对于程序的稳定性来说非常不好。<br>componentDidCatch 可以捕获子组件中任何一个错误，捕获到错误后可以对错误进行处理。<br>如果发生错误的组件的父组件没有设置 componentDidCatch 错误捕获，将继续递归父组件的父组件中的 componentDidCatch，找到则停止。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 简单的错误捕获</span><br><span class=\"line\">componentDidCatch (error, info) &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">        error: true</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render () &#123;</span><br><span class=\"line\">    if (this.state.error) &#123;</span><br><span class=\"line\">        return &lt;div&gt;子组件发生异常了&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 其他代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、优化了哪些语法\"><a href=\"#二、优化了哪些语法\" class=\"headerlink\" title=\"二、优化了哪些语法\"></a>二、优化了哪些语法</h1><h2 id=\"1-ref-优化\"><a href=\"#1-ref-优化\" class=\"headerlink\" title=\"1. ref 优化\"></a>1. ref 优化</h2><p>ref 有很多作用，通过 ref 父组件可以调用子组件内的方法，配合<code>ReactDOM.findDOMNode(ref)</code> 可以获取到组件对应的 dom。ref 与 key 一样无法通过 this.props.ref 获取；</p>\n<p>以前版本的 react，给子组件添加 ref&#x3D;“inputName”，就可以通过 this.refs[‘inputName’]获取子组件实例。然后可以进行一些操作。</p>\n<p>React16 中有两种创建 Ref 的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">constructor () &#123;</span><br><span class=\"line\">    this.inputNameRef = React.createRef();</span><br><span class=\"line\">    this.switchRef = React.createRef();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render () &#123;</span><br><span class=\"line\">    // 通过this.inputNameRef.current 可以获取到input实例</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">             &lt;input ref=&#123;this.inputNameRef&#125; /&gt;</span><br><span class=\"line\">             &lt;Switch ref=&#123;this.switchRef&#125; /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">render () &#123;</span><br><span class=\"line\">    // 通过回调ref的方式实现</span><br><span class=\"line\">    // 通过this.inputNameRef 可以获取到input实例</span><br><span class=\"line\">    // this.switchRef可以获取Switch的实例</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">             &lt;input ref=&#123;(ref) =&gt; this.inputNameRef = ref&#125; /&gt;</span><br><span class=\"line\">             &lt;Switch ref=&#123;(ref) =&gt; this.switchRef = ref&#125; /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，既然 ref 和 key 可以一样不能用 this.props 获取，有没有办法传给子组件呢？这样就可以实现在组件中调用子子组件（比如子组件中的 input）了。</p>\n<p>答案是肯定的。</p>\n<p>也有两种方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">render () &#123;</span><br><span class=\"line\">    // 假设this.switchRef已经在constructor里创建了，那么可以通过其他属性传递。</span><br><span class=\"line\">    // 在子组件中可以通过this.props.forRef。</span><br><span class=\"line\">    // 注：forRef 为随便名只要不是react内置的名称就行</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;Switch forRef=&#123;this.switchRef&#125; /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 通过React.forwardRef 传递</span><br><span class=\"line\">export default React.forwardRef((props, ref) =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;OtherChild /&gt;</span><br><span class=\"line\">            &lt;Switch ref=&#123;ref&#125; /&gt;</span><br><span class=\"line\">            &lt;OtherChild2 /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-将组件实例化到其他-dom-下，可以优化吗？\"><a href=\"#2-将组件实例化到其他-dom-下，可以优化吗？\" class=\"headerlink\" title=\"2. 将组件实例化到其他 dom 下，可以优化吗？\"></a>2. 将组件实例化到其他 dom 下，可以优化吗？</h2><p>React 渲染时，默认是将节点渲染到父组件中，这样能满足我们大部分的需求，but，有这样的组件，比如 Dialog，在组件渲染时，需要能定义组件弹出的 dom 位置，如 Dialog 中的 appendToBody 为 true 时，渲染到 body 节点下。</p>\n<p>以前我们的做法是，通过 ref 和 ReactDOM.findDomNode 获取 dom 在 dialog open 时通过 document.body.appendChild(dom)，将 append 到 body 下，在 componentWillUnmount 时，document.body.removeChild(dom)，移除没用的 dom。</p>\n<p>这样来做就有点麻烦，需要 ref、ReactDOM 等。</p>\n<p>React16 提供了一种优雅的方式 createPortal，Portals 提供了一种很好的将子节点渲染到父组件以外的 DOM 节点的方式。</p>\n<p>createPortal，渲染子节点到目标节点，并返回元素。</p>\n<p>我们知道 ReactDOM.render 也可以将子节点渲染到目标节点，区别是 ReactDOM.render 并没有元素，因此不作为 render 方法的 return</p>\n<p>我直接贴 react 的 Demo。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const modalRoot = document.body;</span><br><span class=\"line\"></span><br><span class=\"line\">class Modal extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.el = document.createElement(&#x27;div&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        modalRoot.appendChild(this.el);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">        modalRoot.removeChild(this.el);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return ReactDOM.createPortal(</span><br><span class=\"line\">            this.props.children,</span><br><span class=\"line\">            this.el,</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-需要传递的多层的-props，可以优化吗？\"><a href=\"#3-需要传递的多层的-props，可以优化吗？\" class=\"headerlink\" title=\"3. 需要传递的多层的 props，可以优化吗？\"></a>3. 需要传递的多层的 props，可以优化吗？</h2><p>在实际开发中，我们经常会碰到，一个值需要被传递到多层的子组件中，我们不得不通过 props 一层一层的传递。</p>\n<p>react16 同样提供了优雅的方式。</p>\n<p>React.createContext</p>\n<h1 id=\"三、性能方面的优化\"><a href=\"#三、性能方面的优化\" class=\"headerlink\" title=\"三、性能方面的优化\"></a>三、性能方面的优化</h1><h2 id=\"1-React-Fragment\"><a href=\"#1-React-Fragment\" class=\"headerlink\" title=\"1. React.Fragment\"></a>1. React.Fragment</h2><p>React 渲染时，要求 JSX 元素是 tree 结构，因为 JSX 原理还是调用 <code>React.createElement(Component, attrs, [...children])</code>，这样好理解。但这样在组件开发过程中，就有所限制，比如：Table Tr 组件，需要渲染同时多个 Tr，在以前我们就需要包一层<code>&lt;div&gt;</code>，造成了浪费。</p>\n<p>react16 提供了<code>Fragment</code>，可以让我们渲染一个子元素列表，并且不在 DOM 中增加额外节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">render () &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;&gt;   // 也可以用 &lt;React.Fragment&gt;</span><br><span class=\"line\">            &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;</span><br><span class=\"line\">            &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;</span><br><span class=\"line\">        &lt;/&gt;   // 也可以用 &lt;/React.Fragment&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-React-memo\"><a href=\"#2-React-memo\" class=\"headerlink\" title=\"2. React.memo\"></a>2. React.memo</h2><p>用在函数组件的性能优化上，会对函数组件实现和 PureComponent 一样的功能，对 props 和 prevProps 做一次 shallowEqual 浅比较。</p>\n<p>用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">React.memo((props) =&gt; &#123;</span><br><span class=\"line\">   // codes</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-React-lazy-amp-React-Suspense\"><a href=\"#3-React-lazy-amp-React-Suspense\" class=\"headerlink\" title=\"3.React.lazy &amp; React.Suspense\"></a>3.React.lazy &amp; React.Suspense</h2><p>实现 React 的 Code Spliting 对 React 代码进行拆包，有效的减少一次性加载太多代码的问题。</p>\n<p>用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const IconDemo = lazy(() =&gt; import(&#x27;./icon&#x27;));</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Suspense fallback=&#123;&lt;div className=&quot;loading&quot;&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/&quot; component=&#123;Home&#125; exact /&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/icon&quot; component=&#123;IconDemo&#125; /&gt;</span><br><span class=\"line\">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、hooks\"><a href=\"#四、hooks\" class=\"headerlink\" title=\"四、hooks\"></a>四、hooks</h1><p><img src=\"https://pic1.zhimg.com/80/v2-1a9c7f5ce089376d9371238930a0173c_720w.jpg\" alt=\"image\"></p>\n<p>我们知道，React 创建组件有 3 中方式【extends React.Component &#x2F; PureComponent】、【React.createClass】，纯函数(无副作用，只接受参数，不对参数做任何处理)。</p>\n<p>extends React.Component、React.createClass 创建的组件，拥有完成 react 声明周期、状态，可以开发较为复杂的组件。</p>\n<p>而，纯函数组件，只能做渲染，绑定的属性都是通过 props 决定的。没有声明周期、状态的概念。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function UserInfo (props) &#123;</span><br><span class=\"line\">   // 这里可以写一些操作</span><br><span class=\"line\">   return (</span><br><span class=\"line\">       &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;</span><br><span class=\"line\">   )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>React v16.7.0-alpha 对函数组件做了以下扩展。</p>\n<h2 id=\"a-针对没有-state-做的扩展\"><a href=\"#a-针对没有-state-做的扩展\" class=\"headerlink\" title=\"a. 针对没有 state 做的扩展\"></a>a. 针对没有 state 做的扩展</h2><p>useState，可以将 state 添加到函数组件中，允许函数组件操作 state。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123;useState&#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">function UserInfo(props) &#123;</span><br><span class=\"line\">    // useState 接收一个参数（当做初始的state)</span><br><span class=\"line\">    // 返回一个初始state值，和修改state的方法</span><br><span class=\"line\">    // 允许多次使用，因此传给useState的参数应该尽可能是简单的数字、字符串等。</span><br><span class=\"line\">    let [count, setCount] = useState(0);</span><br><span class=\"line\">    let [checked, setChecked] = useState(props.checked || false);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">            &lt;Switch onClick=&#123;() =&gt; setChecked(!checked)&#125;&gt;&#123; checked ?  &#x27;开&#x27; : &#x27;关&#x27; &#125;&lt;/Switch&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"b-针对没有生命周期钩子的扩展\"><a href=\"#b-针对没有生命周期钩子的扩展\" class=\"headerlink\" title=\"b. 针对没有生命周期钩子的扩展\"></a>b. 针对没有生命周期钩子的扩展</h2><p>useEffect，可以将 componentDidMount、componentDidUpdate、componentWillUnmount 钩子添加到函数组件中。</p>\n<p>注意：区分有返回值，和没有返回值的情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123;useState, useEffect&#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">function UserInfo(props) &#123;</span><br><span class=\"line\">    let [count, setCount] = useState(0);</span><br><span class=\"line\">    let [checked, setChecked] = useState(props.checked || false);</span><br><span class=\"line\"></span><br><span class=\"line\">    function handleStatusChange(checked) &#123;</span><br><span class=\"line\">        setChecked(checked);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回值的情况</span><br><span class=\"line\">    useEffect(() =&gt; &#123;</span><br><span class=\"line\">        // 组件Mount是添加监听，componentDidMount</span><br><span class=\"line\">        // subscribe原理是，callbacks.push(handleStatusChange)</span><br><span class=\"line\">        // 当值status值变化是，对遍历callbacks数组，调用内方法</span><br><span class=\"line\">        // callbacks.map((fn) =&gt; &#123; fn(status) &#125;);</span><br><span class=\"line\">        ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 组件销毁是移除监听(componentWillUnmount，时执行return的内方法)</span><br><span class=\"line\">        // unsubscribe的原理是</span><br><span class=\"line\">        // let index = callbacks.indexOf(fn);</span><br><span class=\"line\">        // callbacks.splice(index, 1);</span><br><span class=\"line\">        return function cleanup() &#123;</span><br><span class=\"line\">            ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    // 没有返回值的情况</span><br><span class=\"line\">    useEffect(() =&gt; &#123;</span><br><span class=\"line\">        // 组件Mount是调用，componentDidMount、componentDidUpdate1</span><br><span class=\"line\">        document.title = `Clicked $&#123;count&#125;`;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">            &lt;Switch onClick=&#123;() =&gt; setChecked(!checked)&#125;&gt;&#123; checked ?  &#x27;开&#x27; : &#x27;关&#x27; &#125;&lt;/Switch&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"c-one-more-thing\"><a href=\"#c-one-more-thing\" class=\"headerlink\" title=\"c. one more thing\"></a>c. one more thing</h2><p>出于不至于滥用的目的，react 指定了一些 hooks 的使用规则。如命名、代码位置等。当然还很友好的除了代码检测 eslint 插件（<a href=\"https://link.zhihu.com/?target=https://www.npmjs.com/package/eslint-plugin-react-hooks\">eslint-plugin-react-hooks</a>），可以检测开发者写的 hooks 是否合法。</p>\n<p>规则如下：</p>\n<ul>\n<li>在函数组件的顶层使用 hooks，不要在函数组件内的 for、if、匿名函数内使用 useState、useEffect，这将会报错。</li>\n<li>关于 hooks 组件的使用，你可以在 react 组件内使用，也可以在 custom Hooks 内使用。<br>什么是自定义 hook（custom Hooks）呢？就是对 hook 的一个封装，我们可以封装特定功能的 hook，比如：用户状态的 hook、在线人数的 hook，这样在其他地方也可以使用。建议以 useXxxxx 的规范命名。</li>\n</ul>\n<p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function useSetState (initial) &#123;</span><br><span class=\"line\">    const [state, set] = useState(initial);</span><br><span class=\"line\">    const setState = (patch) =&gt; &#123;</span><br><span class=\"line\">        if (patch instanceof Function) &#123;</span><br><span class=\"line\">            set((prevState) =&gt; &#123;</span><br><span class=\"line\">                return Object.assign(state, patch(prevState));</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            Object.assign(state, patch);</span><br><span class=\"line\">            set(state);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    return [state, setState];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用</span><br><span class=\"line\">const Demo = () =&gt; &#123;</span><br><span class=\"line\">    const [state, setState] = useSetState(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;div&gt;&#123; JSON.stringify(state, null, 2) &#125;&lt;/div&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; setState(&#123;foo: &#x27;bar&#x27;&#125;)&#125;&gt;foo&lt;/button&gt;</span><br><span class=\"line\">            &lt;button</span><br><span class=\"line\">                onClick=&#123;() =&gt; &#123;</span><br><span class=\"line\">                    setState((prevState) =&gt; (&#123;</span><br><span class=\"line\">                        count: (prevState.count || 0) + 1,</span><br><span class=\"line\">                    &#125;));</span><br><span class=\"line\">                &#125;&#125;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">                count</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"React状态管理Redux、Redux-Thunk、Redux-Sagas、React-Redux小结","url":"/2022/12/16/React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86Redux%E3%80%81Redux-Thunk%E3%80%81Redux-Sagas%E3%80%81React-Redux%E5%B0%8F%E7%BB%93/","content":"<h1 id=\"一、React-环境配置\"><a href=\"#一、React-环境配置\" class=\"headerlink\" title=\"一、React 环境配置\"></a>一、React 环境配置</h1><p><strong>安装脚手架工具</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install -g create-react-app</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建项目工程</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// demo是项目名称，不能有大写字母</span><br><span class=\"line\">$ create-react-app demo</span><br></pre></td></tr></table></figure>\n\n<p><strong>安装浏览器调试工具</strong></p>\n<ul>\n<li>在 FireFox 中安装 React Developer Tools 和 Redux DevTools</li>\n<li>React Developer Tools 能够在工具栏中很方便的看到页面的布局</li>\n<li>Redux DevTools 能够追踪页面 state、action 等的变化</li>\n</ul>\n<h1 id=\"二、Redux\"><a href=\"#二、Redux\" class=\"headerlink\" title=\"二、Redux\"></a>二、Redux</h1><h2 id=\"Redux-作用\"><a href=\"#Redux-作用\" class=\"headerlink\" title=\"Redux 作用\"></a>Redux 作用</h2><p>当项目越来越复杂时，组件越来越多的时候，组件之间数据的共享就成为了一个问题，那么 Redux 就是用来解决各个组件之间数据共享的问题的。</p>\n<h2 id=\"在项目中安装-Redux\"><a href=\"#在项目中安装-Redux\" class=\"headerlink\" title=\"在项目中安装 Redux\"></a>在项目中安装 Redux</h2><p>redux 的 GitHub 地址：<a href=\"https://github.com/reduxjs/redux\">https://github.com/reduxjs/redux</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 两种安装方法</span><br><span class=\"line\">$ npm install --save redux</span><br><span class=\"line\">$ yarn add redux</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"理解-Redux-工作流程\"><a href=\"#理解-Redux-工作流程\" class=\"headerlink\" title=\"理解 Redux 工作流程\"></a>理解 Redux 工作流程</h2><p><img src=\"https://img-blog.csdnimg.cn/20190725211305715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70\" alt=\"image\"></p>\n<ol>\n<li>Store 就是项目中的数据仓库，但是数据是交给 Reducer 管理的</li>\n<li>Store 向组件提供数据，组件订阅数据后，会根据状态的变化自动更新数据</li>\n<li>组件要修改 Store 中的数据，需要创建一个 action 利用 dispatch 函数通知 Store</li>\n<li>Store 把 action 和数据交给 Reducer，Reducer 根据 action 的类型来处理数据</li>\n<li>Reducer 把处理好的数据返回给 Store</li>\n</ol>\n<h2 id=\"从-Store-中读取数据：派发-action-改变-Store-中的数据\"><a href=\"#从-Store-中读取数据：派发-action-改变-Store-中的数据\" class=\"headerlink\" title=\"从 Store 中读取数据：派发 action 改变 Store 中的数据\"></a>从 Store 中读取数据：派发 action 改变 Store 中的数据</h2><p>action 是一个字符串，在 App 组件、reducer 文件中都使用了，容易引起难以调试的 Bug，也不利于后期维护。<br>所以使用一个 actionType 和 actionCreator 来管理 action 的类型和 action 的创建。<br>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// App组件</span><br><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import store from &#x27;./store&#x27;;</span><br><span class=\"line\">import &#123; changeInputValue &#125; from &#x27;./store/actionCreators&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = store.getState();</span><br><span class=\"line\">        this.handleChangeInput = this.handleChangeInput.bind(this);</span><br><span class=\"line\">        this.handleStoreChange = this.handleStoreChange.bind(this);</span><br><span class=\"line\">        store.subscribe(this.handleStoreChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;input</span><br><span class=\"line\">                    placeholder=&quot;请输入信息&quot;</span><br><span class=\"line\">                    style=&#123;&#123;width: &quot;200px&quot;, height: &#x27;40px&#x27;, border: &#x27;1px solid red&#x27;&#125;&#125;</span><br><span class=\"line\">                    value=&#123;this.state.inputValue&#125;</span><br><span class=\"line\">                    onChange=&#123;this.handleChangeInput&#125;</span><br><span class=\"line\">                /&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChangeInput (e) &#123;</span><br><span class=\"line\">        store.dispatch(changeInputValue(e.target.value));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleStoreChange () &#123;</span><br><span class=\"line\">        this.setState(store.getState());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default App;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// actionTypes.js 管理action类型</span><br><span class=\"line\">export const CHANGE_INPUT_VALUE = &#x27;change_input_value&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// actionCreators.js 管理action的创建</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; CHANGE_INPUT_VALUE &#125; from &#x27;./actionTypes&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const changeInputValue = (value) =&gt; (&#123;</span><br><span class=\"line\">    type: CHANGE_INPUT_VALUE,</span><br><span class=\"line\">    value: value</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// reducer.js</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; CHANGE_INPUT_VALUE &#125; from &#x27;./actionTypes&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const defaultState = &#123;</span><br><span class=\"line\">    inputValue: &#x27;zhangsan&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default (state = defaultState, action) =&gt; &#123;</span><br><span class=\"line\">    if (action.type === CHANGE_INPUT_VALUE) &#123;</span><br><span class=\"line\">        const newState = JSON.parse(JSON.stringify(state));</span><br><span class=\"line\">        newState.inputValue = action.value;</span><br><span class=\"line\">        return newState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// store/index.js</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; createStore &#125; from &#x27;redux&#x27;;</span><br><span class=\"line\">import reducer from &#x27;./reducer&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = createStore(</span><br><span class=\"line\">    reducer,</span><br><span class=\"line\">    window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">export default store;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、Redux-Thunk\"><a href=\"#三、Redux-Thunk\" class=\"headerlink\" title=\"三、Redux-Thunk\"></a>三、Redux-Thunk</h1><h2 id=\"Redux-Thunk-的作用\"><a href=\"#Redux-Thunk-的作用\" class=\"headerlink\" title=\"Redux-Thunk 的作用\"></a>Redux-Thunk 的作用</h2><p>Redux-Thunk<strong>是 Redux</strong>的中间件(<strong>并不是 React 的中间件</strong>)，用来将组件异步获取数据的操作封装到 action 中去，以此来减少组件中复杂的异步操作。<br>使用 Redux-Thunk 之后 action 可以返回一个函数(Redux 的 action 默认只能返回对象)。</p>\n<h2 id=\"安装以及配置\"><a href=\"#安装以及配置\" class=\"headerlink\" title=\"安装以及配置\"></a>安装以及配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ yarn add redux-thunk</span><br><span class=\"line\">$ npm install --save redux-thunk</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用-Redux-Thunk-之后的数据流程\"><a href=\"#使用-Redux-Thunk-之后的数据流程\" class=\"headerlink\" title=\"使用 Redux-Thunk 之后的数据流程\"></a>使用 Redux-Thunk 之后的数据流程</h2><p><img src=\"https://img-blog.csdnimg.cn/20190725212421249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70\" alt=\"image\"></p>\n<p>实际上变化就在 Dispatch 中，使用 Redux-Thunk 之后 action 不仅可以返回对象，还可以返回函数，然后将异步操作代码放在 action 中了。</p>\n<h2 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>这里采用从服务端获取数据展示一个 ul 列表</p>\n<p>使用 Redux-Thunk 之后的代码以及配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// App.js</span><br><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import store from &#x27;./store&#x27;;</span><br><span class=\"line\">import &#123; getListDataAction &#125; from &#x27;./store/actionCreators&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = store.getState();</span><br><span class=\"line\">        this.handleStoreChange = this.handleStoreChange.bind(this);</span><br><span class=\"line\">        store.subscribe(this.handleStoreChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;ul&gt;</span><br><span class=\"line\">                    &#123;this.state.list.map((item, index) =&gt; &#123;</span><br><span class=\"line\">                        return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class=\"line\">                    &#125;)&#125;</span><br><span class=\"line\">                &lt;/ul&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        // 着重变化的代码</span><br><span class=\"line\">        store.dispatch(getListDataAction())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleStoreChange () &#123;</span><br><span class=\"line\">        this.setState(store.getState());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default App;</span><br><span class=\"line\"></span><br><span class=\"line\">-----------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// actionCreators.js</span><br><span class=\"line\">import &#123; GET_LIST_DATA &#125; from &#x27;./actionTypes&#x27;;</span><br><span class=\"line\">import axios from &#x27;axios&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const getListData = (data) =&gt; (&#123;</span><br><span class=\"line\">    type: GET_LIST_DATA,</span><br><span class=\"line\">    value: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// action 返回一个函数，异步操作在这里进行</span><br><span class=\"line\">export const getListDataAction = () =&gt; &#123;</span><br><span class=\"line\">    return (dispatch) =&gt; &#123;</span><br><span class=\"line\">        axios.get(&#x27;/list.json&#x27;).then((res) =&gt; &#123;</span><br><span class=\"line\">            if (res.data) &#123;</span><br><span class=\"line\">                dispatch(getListData(res.data));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).catch((e) =&gt; &#123;</span><br><span class=\"line\">            console.log(e);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-----------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// store.js</span><br><span class=\"line\">import &#123; createStore, applyMiddleware, compose &#125; from &#x27;redux&#x27;;</span><br><span class=\"line\">import thunk from &#x27;redux-thunk&#x27;;</span><br><span class=\"line\">import reducer from &#x27;./reducer&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;</span><br><span class=\"line\"></span><br><span class=\"line\">const enhancer = composeEnhancers(</span><br><span class=\"line\">    applyMiddleware(thunk)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">const store = createStore(</span><br><span class=\"line\">    reducer,</span><br><span class=\"line\">    enhancer</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">export default store;</span><br><span class=\"line\"></span><br><span class=\"line\">-----------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// reducer.js无变化</span><br><span class=\"line\">import &#123; GET_LIST_DATA &#125; from &#x27;./actionTypes&#x27;;</span><br><span class=\"line\">const defaultState = &#123;</span><br><span class=\"line\">    list: []</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default (state = defaultState, action) =&gt; &#123;</span><br><span class=\"line\">    if (action.type === GET_LIST_DATA) &#123;</span><br><span class=\"line\">        const newState = JSON.parse(JSON.stringify(state));</span><br><span class=\"line\">        newState.list = action.value;</span><br><span class=\"line\">        console.log(action);</span><br><span class=\"line\">        return newState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190725213027838.png\" alt=\"image\"></p>\n<h1 id=\"四、Redux-saga\"><a href=\"#四、Redux-saga\" class=\"headerlink\" title=\"四、Redux-saga\"></a>四、Redux-saga</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>redux-saga 同样是用来拆分组件异步代码的中间件，它和 Redux-Thunk 的区别就是将异步代码的操作放到一个单独的文件中去管理。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install --save redux-saga</span><br><span class=\"line\">$ yarn add redux-saga</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码演示-1\"><a href=\"#代码演示-1\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>这里采用上面的例子，同样从服务器获取数据展示在 ul 列表中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// App.js</span><br><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import store from &#x27;./store&#x27;;</span><br><span class=\"line\">import &#123; getListDataSagas &#125; from &#x27;./store/actionCreators&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = store.getState();</span><br><span class=\"line\">        this.handleStoreChange = this.handleStoreChange.bind(this);</span><br><span class=\"line\">        store.subscribe(this.handleStoreChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;ul&gt;</span><br><span class=\"line\">                    &#123;this.state.list.map((item, index) =&gt; &#123;</span><br><span class=\"line\">                        return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class=\"line\">                    &#125;)&#125;</span><br><span class=\"line\">                &lt;/ul&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        store.dispatch(getListDataSagas());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleStoreChange () &#123;</span><br><span class=\"line\">        this.setState(store.getState());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default App;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// actionTypes.js</span><br><span class=\"line\">export const GET_LIST_DATA = &#x27;get_list_data&#x27;;</span><br><span class=\"line\">export const GET_LIST_DATA_SAGAS = &#x27;get_list_data_sagas&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// actionCreators.js</span><br><span class=\"line\">import &#123; GET_LIST_DATA, GET_LIST_DATA_SAGAS &#125; from &#x27;./actionTypes&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const getListData = (data) =&gt; (&#123;</span><br><span class=\"line\">    type: GET_LIST_DATA,</span><br><span class=\"line\">    value: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 这里创建了一个sagas中需要的action</span><br><span class=\"line\">export const getListDataSagas = () =&gt; (&#123;</span><br><span class=\"line\">    type: GET_LIST_DATA_SAGAS,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// reducer.js</span><br><span class=\"line\">import &#123; GET_LIST_DATA &#125; from &#x27;./actionTypes&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const defaultState = &#123;</span><br><span class=\"line\">    list: []</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default (state = defaultState, action) =&gt; &#123;</span><br><span class=\"line\">    if (action.type === GET_LIST_DATA) &#123;</span><br><span class=\"line\">        const newState = JSON.parse(JSON.stringify(state));</span><br><span class=\"line\">        newState.list = action.value;</span><br><span class=\"line\">        console.log(action);</span><br><span class=\"line\">        return newState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">// store.js</span><br><span class=\"line\">import &#123; createStore, applyMiddleware, compose &#125; from &#x27;redux&#x27;;</span><br><span class=\"line\">import reducer from &#x27;./reducer&#x27;;</span><br><span class=\"line\">import createSagaMiddleware from &#x27;redux-saga&#x27;;</span><br><span class=\"line\">// 新创建的sagas.js文件用来管理异步操作的代码</span><br><span class=\"line\">import sagas from &#x27;./sagas&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const sagaMiddleware = createSagaMiddleware();</span><br><span class=\"line\">const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;</span><br><span class=\"line\">const enhancer = composeEnhancers(</span><br><span class=\"line\">    applyMiddleware(sagaMiddleware)</span><br><span class=\"line\">);</span><br><span class=\"line\">const store = createStore(</span><br><span class=\"line\">    reducer,</span><br><span class=\"line\">    enhancer</span><br><span class=\"line\">);</span><br><span class=\"line\">sagaMiddleware.run(sagas);</span><br><span class=\"line\">export default store;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------</span><br><span class=\"line\">// sagas.js  单独管理异步操作的文件</span><br><span class=\"line\">import &#123; put, takeEvery &#125; from &#x27;redux-saga/effects&#x27;;</span><br><span class=\"line\">import &#123; GET_LIST_DATA_SAGAS &#125; from &#x27;./actionTypes&#x27;;</span><br><span class=\"line\">import axios from &#x27;axios&#x27;;</span><br><span class=\"line\">import &#123; getListData &#125; from  &#x27;./actionCreators&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">function* mySaga() &#123;</span><br><span class=\"line\">    // 这句代码意思是：当接收到一个名叫GET_LIST_DATA_SAGAS的action的时候</span><br><span class=\"line\">    //会去调用getDataFromServer方法</span><br><span class=\"line\">    yield takeEvery(GET_LIST_DATA_SAGAS, getDataFromServer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取数据的异步操作</span><br><span class=\"line\">function* getDataFromServer() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        const res = yield axios.get(&#x27;/list.json&#x27;);</span><br><span class=\"line\">        yield put(getListData(res.data));</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">        console.log(&#x27;请求错误&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default mySaga;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"五、React-Redux\"><a href=\"#五、React-Redux\" class=\"headerlink\" title=\"五、React-Redux\"></a>五、React-Redux</h1><h2 id=\"作用-1\"><a href=\"#作用-1\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>React-Redux 的作用是为了在项目中使用 Redux 更加方便。</p>\n<h2 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install --save react-redux</span><br><span class=\"line\">$ yarn add react-redux</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码演示-2\"><a href=\"#代码演示-2\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>代码演示的例子是改变 input 输入框中的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// index.js 项目的入口文件</span><br><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class=\"line\">import App from &#x27;./App&#x27;;</span><br><span class=\"line\">import &#123; Provider &#125; from  &#x27;react-redux&#x27;;</span><br><span class=\"line\">import store from  &#x27;./store&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const AppRoot = (</span><br><span class=\"line\">    // 重点把store提供给每一个组件</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">      &lt;App&gt;&lt;/App&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;</span><br><span class=\"line\">);</span><br><span class=\"line\">ReactDOM.render(AppRoot, document.getElementById(&#x27;root&#x27;));</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------</span><br><span class=\"line\">// actionTypes.js</span><br><span class=\"line\">export const INPUT_CHANGE = &#x27;input_change&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------</span><br><span class=\"line\">// actionCreators.js</span><br><span class=\"line\">import &#123; INPUT_CHANGE &#125; from &#x27;./actionTypes&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const inputChange = (data) =&gt; (&#123;</span><br><span class=\"line\">    type: INPUT_CHANGE,</span><br><span class=\"line\">    value: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------</span><br><span class=\"line\">// reducer.js</span><br><span class=\"line\">import &#123; INPUT_CHANGE &#125; from &#x27;./actionTypes&#x27;;</span><br><span class=\"line\">const defaultState = &#123;</span><br><span class=\"line\">    inputValue: &#x27;&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default (state = defaultState, action) =&gt; &#123;</span><br><span class=\"line\">    if (action.type === INPUT_CHANGE) &#123;</span><br><span class=\"line\">        const newState = JSON.parse(JSON.stringify(state));</span><br><span class=\"line\">        newState.inputValue = action.value;</span><br><span class=\"line\">        return newState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------</span><br><span class=\"line\">// App.js</span><br><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123; inputChange &#125; from &#x27;./store/actionCreators&#x27;;</span><br><span class=\"line\">import &#123; connect &#125; from &#x27;react-redux&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;input</span><br><span class=\"line\">                    placeholder=&quot;请输入信息&quot;</span><br><span class=\"line\">                    style=&#123;&#123;width: &quot;200px&quot;, height: &#x27;40px&#x27;, border: &#x27;1px solid red&#x27;&#125;&#125;</span><br><span class=\"line\">                    value=&#123;this.props.inputValue&#125;</span><br><span class=\"line\">                    onChange=&#123;this.props.handleChangeInput&#125;</span><br><span class=\"line\">                /&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 将store中存储的数据映射到当前组件的props中</span><br><span class=\"line\">const mapStateToProps = (state) =&gt; &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        inputValue: state.inputValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const mapDispatchToProps = (dispatch) =&gt; &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        handleChangeInput (e) &#123;</span><br><span class=\"line\">            dispatch(inputChange(e.target.value));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 利用connect将组件和store连接(连接规则mapStateToProps、mapDispatchToProps)</span><br><span class=\"line\">export default connect(mapStateToProps, mapDispatchToProps)(App);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"react-推崇的是组件化开发\"><a href=\"#react-推崇的是组件化开发\" class=\"headerlink\" title=\"react 推崇的是组件化开发\"></a>react 推崇的是组件化开发</h2><p>下面就是一个有两个组件的 demo 演示基本骨架的搭建。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190725213849116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70\" alt=\"image\"></p>\n<h1 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h1><ul>\n<li>Redux: 就是用来管理项目中状态或者数据的</li>\n<li>Redux-Thunk: Redux 的中间件，用来将异步操作的代码拆分到 action 中去的</li>\n<li>Redux-Sagas: Redux 的中间件，用来将异步操作的代码拆分到单独的文件中管理</li>\n<li>React-Redux: 更能方便的管理和使用 Redux</li>\n</ul>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"Rxjs常见操作符","url":"/2022/12/16/Rxjs%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E7%AC%A6/","content":"<h2 id=\"一-RxJS-初试\"><a href=\"#一-RxJS-初试\" class=\"headerlink\" title=\"一.RxJS 初试\"></a>一.RxJS 初试</h2><ul>\n<li>在 javascript 中的试炼</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const height = document.getElementById(&#x27;height&#x27;);</span><br><span class=\"line\">const height$ = Rx.Observable.fromEvent(height, &#x27;keyup&#x27;);//$是约定俗称的命名方式,因为通过Rx.Observable已经将其转换成了流形式,其中含义是:将keyup事件转换成了Observable观察者</span><br><span class=\"line\">//既然是观察者,则可以订阅</span><br><span class=\"line\">height$.subscribe(val =&gt; console.log(val));//当输入的时候会输出事件的对象,获得值则使用val.target.value</span><br><span class=\"line\">// 输入是1,console打印的就是1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>RxJs 的威力在于合并和转换流,实例如下</li>\n</ul>\n<p><strong>（1）html</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; id=&quot;length&quot;/&gt;</span><br><span class=\"line\">&lt;input type=&quot;text&quot; id=&quot;width&quot; /&gt;</span><br><span class=\"line\">&lt;div id=&quot;area&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const length = document.getElementById(&#x27;height&#x27;);</span><br><span class=\"line\">const width = document.getElementById(&#x27;width&#x27;);</span><br><span class=\"line\">const area = document.getElementById(&#x27;area&#x27;);</span><br><span class=\"line\">const length$ = Rx.Observable.fromEvent(length, &#x27;keyup&#x27;).pluck(&#x27;target&#x27;,&#x27;value&#x27;);</span><br><span class=\"line\">const width$ = Rx.Observable.fromEvent(width, &#x27;keyup&#x27;).pluck(&#x27;target&#x27;,&#x27;value&#x27;);</span><br><span class=\"line\">//combineLatest表示如果监听的两个值有一个改变则会重新计算一遍</span><br><span class=\"line\">const area$ = Rx.Observable.combineLatest(length$, width$, (l,w)=&gt;&#123;return l*w&#125;);//用于将两个流合并成一个数据流</span><br><span class=\"line\">area$.subscribe(val =&gt; area.innerHTML = val);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>事件流:理解 Rx 的关键是要把任何变化想象成事件流</li>\n</ul>\n<h2 id=\"二-RxJS-常见操作符\"><a href=\"#二-RxJS-常见操作符\" class=\"headerlink\" title=\"二.RxJS 常见操作符\"></a>二.RxJS 常见操作符</h2><h3 id=\"1-常见创建类操作符\"><a href=\"#1-常见创建类操作符\" class=\"headerlink\" title=\"1.常见创建类操作符\"></a>1.常见创建类操作符</h3><ul>\n<li>from:可以把数组、Promise、以及 Iterable 转化为 Observable</li>\n<li>fromEvent:可以把事件转化为 Observable</li>\n<li>of:接受一系列的数据，并把它们 emit 出去<ul>\n<li>如可以使用<code>object$ = Rx.Observable.of(&#123;id:1,value:20&#125;)</code>转化对象，使用的时候应该是 object.value 或 object.id 的方式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-常见转换操作符\"><a href=\"#2-常见转换操作符\" class=\"headerlink\" title=\"2.常见转换操作符\"></a>2.常见转换操作符</h3><ul>\n<li>map<ul>\n<li>是 mapTo、pluck 操作符的根本</li>\n<li>举例将上述 pluck 操作符取 target 的 value 值转换成使用 map 操作符</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const width$ = Rx.Observable.fromEvent(width, &#x27;keyup&#x27;).map(ev=&gt;ev.target.value);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 angular 中灵活使用 Observable 如下</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 定义一个发起网络请求获取Observable的方法</span><br><span class=\"line\">getQuote():Observable&lt;Quote&gt; &#123;</span><br><span class=\"line\">    const uri = &#x27;http://localhost:3000&#x27;;</span><br><span class=\"line\">    return this.http.get(uri)</span><br><span class=\"line\">    \t\t.map(res =&gt; res.json() as Quote);// 将请求返回的内容转换成json并转换成对应定义的Quote对象</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>mapTo</p>\n<ul>\n<li><p>比如点击按钮事件或其他事件，我们不需要关注其值内容，只需要知道发生了即可，可以使用 mapTo 定义成一个固定值</p>\n</li>\n<li><p>实例代码</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const width$ = Rx.Observable.fromEvent(width, &#x27;keyup&#x27;).mapTo(1);//此时执行keyup事件，width$的值即为1</span><br><span class=\"line\">//等同于如下</span><br><span class=\"line\">const width$ = Rx.Observable.fromEvent(width, &#x27;keyup&#x27;).map(_ =&gt; 1);//此时执行keyup事件，width$的值即为1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>pluck</li>\n</ul>\n<h3 id=\"3-Observable-的性质\"><a href=\"#3-Observable-的性质\" class=\"headerlink\" title=\"3.Observable 的性质\"></a>3.Observable 的性质</h3><ul>\n<li>Observable 有三种状态（即 subscribe 的三个参数）：next、error、complete<ul>\n<li>next 是正常执行时的内容，subscribe 的第一个参数</li>\n<li>error 是当执行时出错，或监听了 throw 类型 Observable 时的执行内容，subscribe 的第二个参数</li>\n<li>complete 是 Observable 执行结束时的内容，subscribe 的第三个参数</li>\n</ul>\n</li>\n<li>特殊的 Observable：永不结束、Never、Empty（结束但不发射）、Throw<ul>\n<li>Never 类型 Observable 表示不会发生也永远不会结束，会在执行过程中导致，也可直接通过 Rx.Observable.error(‘xxx’)的方式声明，结果不会执行 next、error、complete 中任何一个阶段</li>\n<li>Empty 类型 Observable 不会发射元素会直接结束，会在执行过程中导致，也可以通过 Rx.Observable.empty()的方式声明，结果不会执行 next、error，会执行 complete 阶段</li>\n<li>Throw 类型 Observable 直接进入 error 状态，会在执行过程中抛出异常导致，也可以直接通过 Rx.Observable.throw(‘xxx’)的方式声明，结果只会执行 error 阶段</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-常见工作操作符：do\"><a href=\"#4-常见工作操作符：do\" class=\"headerlink\" title=\"4.常见工作操作符：do\"></a>4.常见工作操作符：do</h2><ul>\n<li>do 操作符用于在流处理期间对数据进行操作，实例如下</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const interval$ = Rx.Observable.interval(100)</span><br><span class=\"line\">.do(v =&gt; &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;val is :&#x27;+v);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.take(3);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-常见变换类操作符：scan\"><a href=\"#5-常见变换类操作符：scan\" class=\"headerlink\" title=\"5.常见变换类操作符：scan\"></a>5.常见变换类操作符：scan</h3><ul>\n<li>scan(()&#x3D;&gt;{})接受一个函数，参数 1 是上次处理后的结果，参数 2 是新值内容。实例代码</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const interval$ = Rx.Observable.interval(100)</span><br><span class=\"line\">.filter(v =&gt; val%2 === 0) //表示是偶数才放行</span><br><span class=\"line\">.scan((x,y)=&gt;&#123;return x+y&#125;)//表示结果累加操作</span><br><span class=\"line\">.take(4);</span><br><span class=\"line\">//输出结果</span><br><span class=\"line\">// 0[0+0]</span><br><span class=\"line\">// 2[上次结果0+新值2]</span><br><span class=\"line\">// 6[上次结果2+新值4]</span><br><span class=\"line\">// 12[上次结果6+新值6]</span><br><span class=\"line\">//complete执行内容</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-常见数学类操作符：reduce\"><a href=\"#6-常见数学类操作符：reduce\" class=\"headerlink\" title=\"6.常见数学类操作符：reduce\"></a>6.常见数学类操作符：reduce</h3><ul>\n<li>reduce 是将流计算结果做统一的最后处理并发射，实例代码</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const interval$ = Rx.Observable.interval(100)</span><br><span class=\"line\">.filter(v =&gt; val%2 === 0) //表示是偶数才放行</span><br><span class=\"line\">.take(4)</span><br><span class=\"line\">.reduce((x,y)=&gt;&#123;return x+y&#125;);</span><br><span class=\"line\">//输出结果</span><br><span class=\"line\">// 12[只发射最终值]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-过滤类操作符：filter、take、first-x2F-last、skip…\"><a href=\"#7-过滤类操作符：filter、take、first-x2F-last、skip…\" class=\"headerlink\" title=\"7.过滤类操作符：filter、take、first&#x2F;last、skip…\"></a>7.过滤类操作符：filter、take、first&#x2F;last、skip…</h3><ul>\n<li>take(num)表示取流中前 num 个</li>\n<li>filter(()&#x3D;&gt;{})表示对流处理的放行判断，如果满足条件则放行，不满足条件则不放行</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const interval$ = Rx.Observable.interval(100)</span><br><span class=\"line\">.filter(v =&gt; val%2 === 0) //表示是偶数才放行</span><br><span class=\"line\">.take(3);//订阅后会输出0 2 4</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>first()表示取流第一个，相当于 take(1)</li>\n<li>last()表示取流最后一个</li>\n<li>skip(num)表示跳过前 num 个</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const interval$ = Rx.Observable.interval(100)</span><br><span class=\"line\">.filter(v =&gt; val%2 === 0) //表示是偶数才放行</span><br><span class=\"line\">.skip(2);//订阅后会输出4 6 8 ...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-常见创建类操作符：Interval、Timer\"><a href=\"#8-常见创建类操作符：Interval、Timer\" class=\"headerlink\" title=\"8.常见创建类操作符：Interval、Timer\"></a>8.常见创建类操作符：Interval、Timer</h3><ul>\n<li>Interval 实例代码</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const interval$ = Rx.Observable.interval(100).take(3);</span><br><span class=\"line\">interval$.subscribe(</span><br><span class=\"line\">    val =&gt; &#123;</span><br><span class=\"line\">        console.log(val) //next状态</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    err =&gt; &#123;</span><br><span class=\"line\">        console.log(err) // error状态</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ()=&gt; &#123;</span><br><span class=\"line\">        console.log(&#x27;I am complete&#x27;) // complete状态</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">//输出结果:interval()是做循环用的,每次发射出来的是索引，故生成的是0/1/2/3/4....，又由于take表示取前多少个，故take(3)表示取前3个</span><br><span class=\"line\">// 0</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// &quot;I am complete&quot; // complete状态执行的内容</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Timer 实例代码</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const timer$ = Rx.Observable.timer(100,200);//表示100毫秒之后启动，之后以200毫秒的频率一直发送</span><br><span class=\"line\">// 故timer比Interval多出起始延迟时间的设置</span><br><span class=\"line\">timer$.subscribe(v=&gt; console.log(v))</span><br><span class=\"line\">//输出结果</span><br><span class=\"line\">// 0 --运行后100毫秒之后输出</span><br><span class=\"line\">// 1 --输出0后200毫秒之后输出</span><br><span class=\"line\">// 2 --输出1后200毫秒之后输出</span><br><span class=\"line\">// 3 --...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-实例：自行给-rxjs-中-Observable-添加-debug-方法\"><a href=\"#9-实例：自行给-rxjs-中-Observable-添加-debug-方法\" class=\"headerlink\" title=\"9.实例：自行给 rxjs 中 Observable 添加 debug 方法\"></a>9.实例：自行给 rxjs 中 Observable 添加 debug 方法</h3><ul>\n<li>通过 Observable 的原型中定义 debug 方法返回 Observable 对象</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123;Observable&#125; from &#x27;rxjs/Observable&#x27;;</span><br><span class=\"line\">import &#123;environment&#125; from &#x27;../../environment/environment&#x27;</span><br><span class=\"line\">// typescript用于解决自行添加对象属性的报错问题</span><br><span class=\"line\">declare module &#x27;rxjs/Observable&#x27; &#123;</span><br><span class=\"line\">    interface Observable&lt;T&gt; &#123;</span><br><span class=\"line\">        debug: (...any) =&gt; Observable&lt;T&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 给Observable添加debug方法</span><br><span class=\"line\">Observable.prototype.debug = function(message:string) &#123;</span><br><span class=\"line\">    return this.do(</span><br><span class=\"line\">        (next)=&gt;&#123;</span><br><span class=\"line\">            if(!environment.production) &#123;</span><br><span class=\"line\">                console.log(message,next)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        (err) =&gt; &#123;</span><br><span class=\"line\">            if(!environment.production) &#123;</span><br><span class=\"line\">                console.error(&#x27;ERROR&gt;&gt;&#x27;,message,err);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ()=&gt; &#123;</span><br><span class=\"line\">            if(!environment.production) &#123;</span><br><span class=\"line\">                console.log(&#x27;Completed -&#x27;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//使用时直接在声明Observable期间添加即可以查看对应Observable对象内容,如</span><br><span class=\"line\">this.http.get(&#x27;url&#x27;)</span><br><span class=\"line\">\t.debug(&#x27;Test:&#x27;)</span><br><span class=\"line\">\t.map(res =&gt; res.json() as Quote);</span><br><span class=\"line\">//在subscribe监听后的会输出对应的log</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-过滤类操作符：debounce、debounceTime\"><a href=\"#10-过滤类操作符：debounce、debounceTime\" class=\"headerlink\" title=\"10.过滤类操作符：debounce、debounceTime\"></a>10.过滤类操作符：debounce、debounceTime</h3><ul>\n<li>debounce：比 debounceTime 灵活，debounceTime 只能设定固定的毫秒间隔，而 debounce 可以通过接受的 function 设定毫秒间隔</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const length$ = Rx.Observable.fromEvent(length,&#x27;keyup&#x27;).pluck(&#x27;target&#x27;,&#x27;value&#x27;).debounce(()=&gt;Rx.Observable.interval(300));//可以自行修改function返回内容从而决定滤掉的内容</span><br><span class=\"line\">//上述代码含义是：过滤掉300毫秒以内keyup事件监听内容</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>debouceTime(num)：时间滤波器，表示只关注大于等于 num 毫秒间隔的事件内容</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const length$ = Rx.Observable.fromEvent(length,&#x27;keyup&#x27;).pluck(&#x27;target&#x27;,&#x27;value&#x27;).debounceTime(300);</span><br><span class=\"line\">//上述代码含义是：过滤掉300毫秒以内keyup事件监听内容</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行图片</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20190602185826234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI5NDQ3,size_16,color_FFFFFF,t_70\" alt=\"image\"></p>\n<h3 id=\"11-过滤类操作符：distinct、distinctUtilChanged\"><a href=\"#11-过滤类操作符：distinct、distinctUtilChanged\" class=\"headerlink\" title=\"11.过滤类操作符：distinct、distinctUtilChanged\"></a>11.过滤类操作符：distinct、distinctUtilChanged</h3><ul>\n<li>distinct：整个序列中，过滤一样的，保留不一样的(要求序列中没有重复的元素)</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const length$ = Rx.Observable.fromEvent(length,&#x27;keyup&#x27;).pluck(&#x27;target&#x27;,&#x27;value&#x27;).distinct();//过滤掉整个流中重复的元素</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>distinctUtilChanged：只跟前一个元素比，过滤一样的，保留不一样的</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const length$ = Rx.Observable.fromEvent(length,&#x27;keyup&#x27;).pluck(&#x27;target&#x27;,&#x27;value&#x27;).distinctUtilChanged();//过滤掉流中前一个重复的元素</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行图片</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20190602185839813.png\" alt=\"image\"></p>\n<h3 id=\"12-合并类操作符：merge、concat、startWith\"><a href=\"#12-合并类操作符：merge、concat、startWith\" class=\"headerlink\" title=\"12.合并类操作符：merge、concat、startWith\"></a>12.合并类操作符：merge、concat、startWith</h3><ul>\n<li>merge：在整个序列中按照流运行状态进行合并</li>\n<li>concat：在整个序列中将流前后拼接（如拼接的第一个流是无尽流，则永远只会输出第一个流内容，因为第二个流永远不会发生，第一个流没有执行完）</li>\n<li>startWith：设定流发射的初始值</li>\n<li>执行图片<br><img src=\"https://img-blog.csdnimg.cn/20190602185848388.png\" alt=\"image\"></li>\n</ul>\n<h3 id=\"13-合并类操作符：combineLatest、withLatestFrom、zip\"><a href=\"#13-合并类操作符：combineLatest、withLatestFrom、zip\" class=\"headerlink\" title=\"13.合并类操作符：combineLatest、withLatestFrom、zip\"></a>13.合并类操作符：combineLatest、withLatestFrom、zip</h3><p><img src=\"https://img-blog.csdnimg.cn/20190602185857966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI5NDQ3,size_16,color_FFFFFF,t_70\" alt=\"image\"></p>\n<ul>\n<li>通过 combineLatest 可以对两个流进行对应的处理操作，实例请参照开头计算面积</li>\n<li>zip 有对齐的感觉，将两个流对应位置的元素进行处理操作，慢的流决定最终 zip 生成流的速度</li>\n<li>withLatestFrom 当基准流改变时才会进行流处理，使用方式是基准流.withLatestFrom(其他流)，如下</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const merged$ = length$.withLatestFrom(width$);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>区别：zip 有对齐的特性，withLatestFrom 是以源事件流为基准，combineLatest 是无论任何一个流发生改变时都会处理</li>\n</ul>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"SCSS常用语法总结","url":"/2022/12/16/SCSS%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","content":"<p>Scss 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。</p>\n<h2 id=\"1-使用变量\"><a href=\"#1-使用变量\" class=\"headerlink\" title=\"1. 使用变量\"></a>1. 使用变量</h2><p>因为 css 里不能使用变量，造成很大不便。所以 scss 里引入了变量。</p>\n<p>任何可以用作 css 属性值的赋值都可以用作 scss 的变量值，甚至是以空格分割的多个属性值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$width: 100px; // 定义$width变量</span><br><span class=\"line\">nav &#123;</span><br><span class=\"line\">  width: $width; // 引用$width变量</span><br><span class=\"line\">  color: $nav-color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-嵌套-CSS-规则\"><a href=\"#2-嵌套-CSS-规则\" class=\"headerlink\" title=\"2. 嵌套 CSS 规则\"></a>2. 嵌套 CSS 规则</h2><p>css 中重复写选择器是非常麻烦的。比如下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#content article h1 &#123; color: #333 &#125;</span><br><span class=\"line\">#content article p &#123; margin-bottom: 1.4em &#125;</span><br><span class=\"line\">#content aside &#123; background-color: #EEE &#125;</span><br></pre></td></tr></table></figure>\n\n<p>像这种情况，scss 可以只写一遍，且使样式可读性更高。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#content &#123;</span><br><span class=\"line\">  article &#123;</span><br><span class=\"line\">    h1 &#123; color: #333 &#125;</span><br><span class=\"line\">    p &#123; margin-bottom: 1.4em &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  aside &#123; background-color: #EEE &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-父选择器的标识符-amp\"><a href=\"#2-1-父选择器的标识符-amp\" class=\"headerlink\" title=\"2-1. 父选择器的标识符&amp;\"></a>2-1. 父选择器的标识符&amp;</h3><p>当你想为 article 元素内 a 标签写 :hover 这种伪类时，css 的写法是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">article a &#123;</span><br><span class=\"line\">  color: blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">article a:hover &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而 scss 可以通过&amp;符号实现上面功能，更方便也更容易理解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">article a &#123;</span><br><span class=\"line\">  color: blue;</span><br><span class=\"line\">  &amp;:hover &#123; color: red &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>常用父选择器用法：</strong></p>\n<p>&amp;:hover</p>\n<p>&amp;:active</p>\n<p>&amp;:disabled</p>\n<p>&amp;:focus</p>\n<p>&amp;::placeholder</p>\n<p>&amp;::after</p>\n<h3 id=\"2-2-群组选择器的嵌套\"><a href=\"#2-2-群组选择器的嵌套\" class=\"headerlink\" title=\"2-2. 群组选择器的嵌套\"></a>2-2. 群组选择器的嵌套</h3><p>你需要在一个特定的容器元素内对一个群组选择器进行修饰时。css 的写法是让你在群组选择器中的每一个选择器前都重复一遍容器元素的选择器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125;</span><br></pre></td></tr></table></figure>\n\n<p>而用 scss 写是这样的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.container &#123;</span><br><span class=\"line\">  h1, h2, h3 &#123;margin-bottom: .8em&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有利必有弊，你需要特别注意群组选择器的规则嵌套生成的 css。虽然 scss 让你的样式表看上去很小，但实际生成的 css 却可能非常大，这会降低网站的速度。</p>\n<h3 id=\"2-3-子组合选择器和同层组合选择器：-gt-、-和\"><a href=\"#2-3-子组合选择器和同层组合选择器：-gt-、-和\" class=\"headerlink\" title=\"2-3. 子组合选择器和同层组合选择器：&gt;、+和~\"></a>2-3. 子组合选择器和同层组合选择器：&gt;、+和~</h3><p>上边这三个组合选择器必须和其他选择器配合使用，以指定浏览器仅选择某种特定上下文中的元素。</p>\n<p>用子组合选择器 &gt; 选择一个元素的直接子元素。选择器会选择 article 下紧跟着的 section 子元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">article &gt; section &#123; border: 1px solid #ccc &#125;</span><br></pre></td></tr></table></figure>\n\n<p>用同层相邻组合选择器 + 选择 header 元素后紧跟的 p 元素</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">header + p &#123; font-size: 1.1em &#125;</span><br></pre></td></tr></table></figure>\n\n<p>你也可以用同层全体组合选择器~，选择所有跟在 article 后的同层 article 元素，不管它们之间隔了多少其他元素</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">article ~ article &#123; border-top: 1px dashed #ccc &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-注释-x2F-x2F-与-x2F-x2F\"><a href=\"#3-注释-x2F-x2F-与-x2F-x2F\" class=\"headerlink\" title=\"3. 注释 &#x2F;* *&#x2F; 与 &#x2F;&#x2F;\"></a>3. 注释 &#x2F;* *&#x2F; 与 &#x2F;&#x2F;</h2><p>Scss 支持标准的 CSS 多行注释 &#x2F;* *&#x2F;，以及单行注释 &#x2F;&#x2F;</p>\n<h2 id=\"4-混合器\"><a href=\"#4-混合器\" class=\"headerlink\" title=\"4. 混合器\"></a>4. 混合器</h2><p>scss 的混合器可以实现大段样式的重用。混合器使用@mixin 标识符定义，然后通过@include 来使用这个混合器。<br><strong>为便于书写，@mixin 可以用 &#x3D; 表示，而 @include 可以用 + 表示</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@mixin div-back&#123;</span><br><span class=\"line\">    background: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item &#123;</span><br><span class=\"line\">    @include div-back;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-给混合器传参\"><a href=\"#4-1-给混合器传参\" class=\"headerlink\" title=\"4-1. 给混合器传参\"></a>4-1. 给混合器传参</h3><p>混合器可以做为方法一样可以传参</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@mixin div-back($color) &#123;</span><br><span class=\"line\">    background: $color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item &#123;</span><br><span class=\"line\">    @include div-back(red);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当你用混合器传参时，有时候会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，scss 允许通过语法$name: value 的形式指定每个参数的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@mixin div-back($color,$size) &#123;</span><br><span class=\"line\">    background: $color;</span><br><span class=\"line\">    font-size: $size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item &#123;</span><br><span class=\"line\">    @include div-back(</span><br><span class=\"line\">        $color: green,</span><br><span class=\"line\">        $size: 30px</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了在@include 混合器时不必传入所有的参数，我们可以给参数指定一个默认值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@mixin div-back($color,$size: 20px) &#123;</span><br><span class=\"line\">    background: $color;</span><br><span class=\"line\">    font-size: $size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item &#123;</span><br><span class=\"line\">    @include div-back(</span><br><span class=\"line\">        $color: green</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-继承\"><a href=\"#5-继承\" class=\"headerlink\" title=\"5. 继承\"></a>5. 继承</h2><p>使用 scss 的时候，最后一个减少重复的主要特性就是选择器继承。选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend 语法实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.div &#123;</span><br><span class=\"line\">    font-size: 40px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item &#123;</span><br><span class=\"line\">    @extend .div;</span><br><span class=\"line\">    background: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-占位符选择器\"><a href=\"#6-占位符选择器\" class=\"headerlink\" title=\"6. 占位符选择器 %\"></a>6. 占位符选择器 %</h2><p>有时，需要定义一套样式并不是给某个元素用，而是只通过 @extend 指令使用。当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#context a%extreme &#123;</span><br><span class=\"line\">  color: blue;</span><br><span class=\"line\">  font-weight: bold;</span><br><span class=\"line\">  font-size: 2em;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.notice &#123;</span><br><span class=\"line\">  @extend %extreme;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#context a.notice &#123;</span><br><span class=\"line\">  color: blue;</span><br><span class=\"line\">  font-weight: bold;</span><br><span class=\"line\">  font-size: 2em;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原理可以理解为用@extend 的.notice 去替换占位符选择器%extreme 的位置。</p>\n<h2 id=\"7-ScssScript\"><a href=\"#7-ScssScript\" class=\"headerlink\" title=\"7. ScssScript\"></a>7. ScssScript</h2><p>ScssScript 支持 6 种主要的数据类型：</p>\n<ul>\n<li>数字：1, 2, 13, 10px</li>\n<li>字符串：有引号字符串与无引号字符串，”foo”, ‘bar’, baz</li>\n<li>颜色：blue, #04a3f9, rgba(255,0,0,0.5)</li>\n<li>布尔型：true, false</li>\n<li>空值：null</li>\n<li>数组 (list)：用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif</li>\n<li>maps：相当于 JavaScript 的 object，(key1: value1, key2: value2)</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@mixin firefox-message($selector) &#123;</span><br><span class=\"line\">  body.firefox #&#123;$selector&#125;:before &#123;</span><br><span class=\"line\">    content: &quot;Hi, Firefox users!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@include firefox-message(&quot;.header&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>编译为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">body.firefox .header:before &#123;</span><br><span class=\"line\">  content: &quot;Hi, Firefox users!&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有数据类型均支持相等运算 &#x3D;&#x3D; 或 !&#x3D;，此外，每种数据类型也有其各自支持的运算方式。</p>\n<h3 id=\"7-1-颜色值运算\"><a href=\"#7-1-颜色值运算\" class=\"headerlink\" title=\"7-1. 颜色值运算\"></a>7-1. 颜色值运算</h3><p>颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &#123;</span><br><span class=\"line\">  color: #010203 + #040506;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>计算 01 + 04 &#x3D; 05 02 + 05 &#x3D; 07 03 + 06 &#x3D; 09，然后编译为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &#123;</span><br><span class=\"line\">  color: #050709;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可用于连接字符串</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">    background: re + d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p:before &#123;</span><br><span class=\"line\">  content: &quot;I ate #&#123;5 + 10&#125; pies!&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-变量定义-default\"><a href=\"#7-2-变量定义-default\" class=\"headerlink\" title=\"7-2. 变量定义 !default\"></a>7-2. 变量定义 !default</h3><p>可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p>\n<h3 id=\"7-3-if、-for、-each、-while\"><a href=\"#7-3-if、-for、-each、-while\" class=\"headerlink\" title=\"7-3. @if、@for、@each、@while\"></a>7-3. @if、@for、@each、@while</h3><p>scss 也可以写 if else 等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$type: monster;</span><br><span class=\"line\">p &#123;</span><br><span class=\"line\">  @if $type == ocean &#123;</span><br><span class=\"line\">    color: blue;</span><br><span class=\"line\">  &#125; @else if $type == matador &#123;</span><br><span class=\"line\">    color: red;</span><br><span class=\"line\">  &#125; @else if $type == monster &#123;</span><br><span class=\"line\">    color: green;</span><br><span class=\"line\">  &#125; @else &#123;</span><br><span class=\"line\">    color: black;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &#123;</span><br><span class=\"line\">  color: green;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-函数指令\"><a href=\"#8-函数指令\" class=\"headerlink\" title=\"8. 函数指令\"></a>8. 函数指令</h2><p>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$grid-width: 40px;</span><br><span class=\"line\">$gutter-width: 10px;</span><br><span class=\"line\"></span><br><span class=\"line\">@function grid-width($n) &#123;</span><br><span class=\"line\">  @return $n * $grid-width + ($n - 1) * $gutter-width;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#sidebar &#123; width: grid-width(5); &#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#sidebar &#123;</span><br><span class=\"line\">  width: 240px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["常用指令合集"],"tags":["javascript"]},{"title":"Taro 使用指南","url":"/2022/12/16/Taro-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","content":"<p>Taro 就是可以用 React 语法写小程序的框架，拥有多端转换能力，一套代码可编译为微信小程序、百度小程序、支付宝小程序、H5、RN 等</p>\n<h2 id=\"1、入门\"><a href=\"#1、入门\" class=\"headerlink\" title=\"1、入门\"></a>1、入门</h2><h3 id=\"1-1、安装-CLI-及项目初始化\"><a href=\"#1-1、安装-CLI-及项目初始化\" class=\"headerlink\" title=\"1.1、安装 CLI 及项目初始化\"></a>1.1、安装 CLI 及项目初始化</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g @tarojs/cli</span><br><span class=\"line\">taro init 项目名</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6813214-f9a34c9f56809815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/607/format/webp\" alt=\"image\"></p>\n<p>可以选择使用 SCSS 、TS、Redux</p>\n<h3 id=\"1-2、编译至各种平台\"><a href=\"#1-2、编译至各种平台\" class=\"headerlink\" title=\"1.2、编译至各种平台\"></a>1.2、编译至各种平台</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 编译为小程序</span><br><span class=\"line\">npm run dev:weapp</span><br><span class=\"line\">npm run build:weapp</span><br><span class=\"line\">// 编译为 H5</span><br><span class=\"line\">npm run dev:h5</span><br><span class=\"line\">// 编译为 RN</span><br><span class=\"line\">npm run dev:rn</span><br></pre></td></tr></table></figure>\n\n<p>编译为小程序时，小程序代码位于 dist 目录下</p>\n<h3 id=\"1-3、微信小程序须知\"><a href=\"#1-3、微信小程序须知\" class=\"headerlink\" title=\"1.3、微信小程序须知\"></a>1.3、微信小程序须知</h3><ul>\n<li>小程序注册<br/><br><a href=\"https://links.jianshu.com/go?to=https://mp.weixin.qq.com/wxopen/waregister?action=step1\">注册地址</a>，注意一个邮箱只能注册一个小程序</li>\n<li>小程序后台<br/><br><a href=\"https://links.jianshu.com/go?to=https://mp.weixin.qq.com/wxopen/authprofile?action=index&token=1030929877&lang=zh_CN\">后台地址</a>，后台可查看当前小程序版本，添加开发者，查看小程序 AppID 和 AppSecret 等功能</li>\n<li>小程序开发者工具<br/><br><a href=\"https://links.jianshu.com/go?to=https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html\">下载地址</a></li>\n<li>小程序开发流程<br/><br>1、在开发者工具中新建项目，填入对应的 AppID<br/><br>2、在小程序后台配置服务器域名（开发-服务器域名）</li>\n<li>小程序发布流程<br/><br>1、在开发者工具中上传代码<br/><br>2、在管理后台-版本管理-开发版本中提交审核，注意提交审核前可先生成体验版，确认体验版没问题后再提交审核</li>\n</ul>\n<h2 id=\"2、注意点\"><a href=\"#2、注意点\" class=\"headerlink\" title=\"2、注意点\"></a>2、注意点</h2><p>由于 Taro 编译后的代码已经经过了转义和压缩，因此还需要注意微信开发者工具的项目设置</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6813214-5e31c3c6ab19a603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/710/format/webp\" alt=\"image\"></p>\n<ul>\n<li>只能在 render 里使用 jsx 语法</li>\n<li>不能在包含 JSX 元素的 map 循环中使用 if 表达式<br>尽量在 map 循环中使用条件表达式或逻辑表达式</li>\n<li>不能使用 Array.map 之外的方法操作 JSX 数组<br>先处理好需要遍历的数组，然后再用处理好的数组调用 map 方法。</li>\n<li>不能在 JSX 参数中使用匿名函数<br>使用 bind 或 类参数绑定函数。</li>\n<li>不能在 JSX 参数中使用对象展开符<br>开发者自行赋值：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;View &#123;...props&#125; /&gt;　 // wrong</span><br><span class=\"line\">&lt;View id=&#123;id&#125; title=&#123;title&#125; /&gt;  // ok</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不允许在 JSX 参数（props）中传入 JSX 元素</li>\n<li>不支持无状态组件（Stateless Component)</li>\n<li>函数名驼峰，且不能包含数字，不能以下划线开始或结尾以及长度不超过２０</li>\n<li>必须使用单引号，不支持双引号</li>\n<li>对于 process.env，建议直接书写 process.env.NODE_ENV，而不是解构</li>\n<li>组件传递函数属性名以 on 开头</li>\n<li>小程序端不要将在模板中用到的数据设置为 undefined</li>\n<li>小程序端不要在组件中打印 this.props.children</li>\n<li>组件属性传递注意<br/><br>不要以 id、class、style 作为自定义组件的属性与内部 state 的名称，因为这些属性名在微信小程序中会丢失。</li>\n<li>组件 state 与 props 里字段重名的问题<br/><br>不要在 state 与 props 上用同名的字段，因为这些被字段在微信小程序中都会挂在 data 上。</li>\n<li>小程序中页面生命周期 componentWillMount 不一致问题</li>\n<li>组件的 constructor 与 render 提前调用</li>\n</ul>\n<h2 id=\"3、Taro-实战\"><a href=\"#3、Taro-实战\" class=\"headerlink\" title=\"3、Taro 实战\"></a>3、Taro 实战</h2><h3 id=\"3-1、相关库介绍\"><a href=\"#3-1、相关库介绍\" class=\"headerlink\" title=\"3.1、相关库介绍\"></a>3.1、相关库介绍</h3><ul>\n<li>@tarojs&#x2F;taro<br/><br>taro 核心库，相当于 react</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Taro, &#123; Component &#125; from &#x27;@tarojs/taro&#x27;</span><br><span class=\"line\">class App extends Component &#123;&#125;</span><br><span class=\"line\">Taro.render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;))</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@tarojs&#x2F;redux<br>taro 状态管理辅助库，相当于 react-redux</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; Provider,connect  &#125; from &#x27;@tarojs/redux&#x27;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@tarojs&#x2F;components<br>taro 为屏蔽多端差异而制定的标准组件库，在 taro 中不能直接写常规的 HTML 标签，而必须用这个组件库里的标签，就像写 RN 一样：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; View, Button, Text &#125; from &quot;@tarojs/components&quot;;</span><br><span class=\"line\">&lt;View className=&#x27;index&#x27;&gt;</span><br><span class=\"line\">   &lt;Button className=&#x27;add_btn&#x27; onClick=&#123;this.props.add&#125;&gt;</span><br><span class=\"line\">       +</span><br><span class=\"line\">   &lt;/Button&gt;</span><br><span class=\"line\">   &lt;Text&gt; Hello, World &lt;/Text&gt;</span><br><span class=\"line\">&lt;/View&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@tarojs&#x2F;async-await<br>taro 支持 async await 写法库</li>\n<li>taro-ui<br>taro 为屏蔽多端差异而制定的业务组件库，比如 Tabs，Modal，Menu 之类的常用的业务组件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; AtTabs, AtTabsPane &#125; from &quot;taro-ui&quot;;</span><br><span class=\"line\"> &lt;AtTabs</span><br><span class=\"line\">    current=&#123;this.state.current&#125;</span><br><span class=\"line\">    tabList=&#123;tabList&#125;</span><br><span class=\"line\">    onClick=&#123;this.handleClick.bind(this)&#125;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">    &lt;AtTabsPane current=&#123;this.state.current&#125; index=&#123;0&#125;&gt;</span><br><span class=\"line\">      &lt;AllContainer /&gt;</span><br><span class=\"line\">    &lt;/AtTabsPane&gt;</span><br><span class=\"line\">    &lt;AtTabsPane current=&#123;this.state.current&#125; index=&#123;1&#125;&gt;</span><br><span class=\"line\">      &lt;View style=&#x27;padding: 100px 50px;background-color: #FAFBFC;text-align: center;&#x27;&gt;</span><br><span class=\"line\">        标签页二的内容</span><br><span class=\"line\">      &lt;/View&gt;</span><br><span class=\"line\">    &lt;/AtTabsPane&gt;</span><br><span class=\"line\">    &lt;AtTabsPane current=&#123;this.state.current&#125; index=&#123;2&#125;&gt;</span><br><span class=\"line\">      &lt;View style=&#x27;padding: 100px 50px;background-color: #FAFBFC;text-align: center;&#x27;&gt;</span><br><span class=\"line\">        标签页三的内容</span><br><span class=\"line\">      &lt;/View&gt;</span><br><span class=\"line\">    &lt;/AtTabsPane&gt;</span><br><span class=\"line\">  &lt;/AtTabs&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2、常用工具类封装\"><a href=\"#3-2、常用工具类封装\" class=\"headerlink\" title=\"3.2、常用工具类封装\"></a>3.2、常用工具类封装</h3><ul>\n<li>本地存储</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Taro from &quot;@tarojs/taro&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Store &#123;</span><br><span class=\"line\">  removeItem(key) &#123;</span><br><span class=\"line\">    return Taro.removeStorageSync(key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getItem(key) &#123;</span><br><span class=\"line\">    return Taro.getStorageSync(key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setItem(key, value) &#123;</span><br><span class=\"line\">    return Taro.setStorageSync(key, value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    return Taro.clearStorageSync();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default  new Store();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>请求封装</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Taro from &#x27;@tarojs/taro&#x27;</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  API_USER_LOGIN</span><br><span class=\"line\">&#125; from &#x27;@constants/api&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const CODE_SUCCESS = &#x27;200&#x27;</span><br><span class=\"line\">const CODE_AUTH_EXPIRED = &#x27;600&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">function getStorage(key) &#123;</span><br><span class=\"line\">  return Taro.getStorage(&#123;</span><br><span class=\"line\">    key</span><br><span class=\"line\">  &#125;).then(res =&gt; res.data).catch(() =&gt; &#x27;&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function updateStorage(data = &#123;&#125;) &#123;</span><br><span class=\"line\">  return Promise.all([</span><br><span class=\"line\">    Taro.setStorage(&#123;</span><br><span class=\"line\">      key: &#x27;token&#x27;,</span><br><span class=\"line\">      data: data[&#x27;3rdSession&#x27;] || &#x27;&#x27;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    Taro.setStorage(&#123;</span><br><span class=\"line\">      key: &#x27;uid&#x27;,</span><br><span class=\"line\">      data: data[&#x27;uid&#x27;] || &#x27;&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 简易封装网络请求</span><br><span class=\"line\"> * // NOTE 需要注意 RN 不支持 *StorageSync，此处用 async/await 解决</span><br><span class=\"line\"> * @param &#123;*&#125; options</span><br><span class=\"line\"> */</span><br><span class=\"line\">export default async function fetch(options) &#123;</span><br><span class=\"line\">  const &#123;</span><br><span class=\"line\">    url,</span><br><span class=\"line\">    payload,</span><br><span class=\"line\">    method = &#x27;GET&#x27;,</span><br><span class=\"line\">    showToast = true</span><br><span class=\"line\">  &#125; = options</span><br><span class=\"line\">  const token = await getStorage(&#x27;token&#x27;)</span><br><span class=\"line\">  const header = token ? &#123;</span><br><span class=\"line\">    &#x27;WX-PIN-SESSION&#x27;: token,</span><br><span class=\"line\">    &#x27;X-WX-3RD-Session&#x27;: token</span><br><span class=\"line\">  &#125; : &#123;&#125;</span><br><span class=\"line\">  if (method === &#x27;POST&#x27;) &#123;</span><br><span class=\"line\">    header[&#x27;content-type&#x27;] = &#x27;application/json&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return Taro.request(&#123;</span><br><span class=\"line\">    url,</span><br><span class=\"line\">    method,</span><br><span class=\"line\">    data: payload,</span><br><span class=\"line\">    header</span><br><span class=\"line\">  &#125;).then(async (res) =&gt; &#123;</span><br><span class=\"line\">    const &#123;</span><br><span class=\"line\">      code,</span><br><span class=\"line\">      data</span><br><span class=\"line\">    &#125; = res.data</span><br><span class=\"line\">    if (code !== CODE_SUCCESS) &#123;</span><br><span class=\"line\">      if (code === CODE_AUTH_EXPIRED) &#123;</span><br><span class=\"line\">        await updateStorage(&#123;&#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return Promise.reject(res.data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (url === API_USER_LOGIN) &#123;</span><br><span class=\"line\">      await updateStorage(data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return data</span><br><span class=\"line\">  &#125;).catch((err) =&gt; &#123;</span><br><span class=\"line\">    const defaultMsg = err.code === CODE_AUTH_EXPIRED ? &#x27;登录失效&#x27; : &#x27;请求异常&#x27;</span><br><span class=\"line\">    if (showToast) &#123;</span><br><span class=\"line\">      Taro.showToast(&#123;</span><br><span class=\"line\">        title: err &amp;&amp; err.errorMsg || defaultMsg,</span><br><span class=\"line\">        icon: &#x27;none&#x27;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Promise.reject(&#123;</span><br><span class=\"line\">      message: defaultMsg,</span><br><span class=\"line\">      ...err</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-常用-API-介绍\"><a href=\"#3-3-常用-API-介绍\" class=\"headerlink\" title=\"3.3 常用 API 介绍\"></a>3.3 常用 API 介绍</h3><ul>\n<li>授权</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button</span><br><span class=\"line\">   className=&#x27;btn-max-w&#x27;</span><br><span class=\"line\">   plain</span><br><span class=\"line\">   type=&#x27;primary&#x27;</span><br><span class=\"line\">   open-type=&#x27;getUserInfo&#x27;</span><br><span class=\"line\">   onGetUserInfo=&#123;this.handleUserInfo&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">    授权</span><br><span class=\"line\">&lt;/Button&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>获取位置</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Taro.getLocation(&#123;type:&#x27;gcj02&#x27;&#125;).then(data=&gt;console.log(data))</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>操作反馈</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Taro.showToast(&#123;</span><br><span class=\"line\">  title: &quot;成功&quot;,</span><br><span class=\"line\">  icon: &quot;success&quot;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Taro.setTabBarBadge(&#123; index: 1, text: &quot;1&quot; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Taro.showLoading(&#123;</span><br><span class=\"line\">  title: &quot;加载中...&quot;</span><br><span class=\"line\">&#125;).then(res =&gt;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    Taro.hideLoading();</span><br><span class=\"line\">  &#125;, 2000)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、其他问题记录\"><a href=\"#4、其他问题记录\" class=\"headerlink\" title=\"4、其他问题记录\"></a>4、其他问题记录</h2><ul>\n<li>设置页面全屏</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// app.scss</span><br><span class=\"line\">page &#123;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Css Modules 支持<br>配置 config&#x2F;index.js 下的 h5 和 weapp 中的 module.cssModules 即可</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// css modules 功能开关与相关配置</span><br><span class=\"line\">cssModules: &#123;</span><br><span class=\"line\">  enable: true, // 默认为 false，如需使用 css modules 功能，则设为 true</span><br><span class=\"line\">  config: &#123;</span><br><span class=\"line\">    namingPattern: &#x27;module&#x27;, // 转换模式，取值为 global/module，下文详细说明</span><br><span class=\"line\">    generateScopedName: &#x27;[name]__[local]___[hash:base64:5]&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置路径别名<br>配置 config&#x2F;index.js 下的 alias</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">alias: &#123;</span><br><span class=\"line\">    &#x27;components&#x27;: path.resolve(__dirname, &#x27;..&#x27;, &#x27;src/components&#x27;),</span><br><span class=\"line\">    &#x27;pages&#x27;: path.resolve(__dirname, &#x27;..&#x27;, &#x27;src/pages&#x27;),</span><br><span class=\"line\">    &#x27;store&#x27;: path.resolve(__dirname, &#x27;..&#x27;, &#x27;src/store&#x27;),</span><br><span class=\"line\">    &#x27;constants&#x27;: path.resolve(__dirname, &#x27;..&#x27;, &#x27;src/constants&#x27;),</span><br><span class=\"line\">    &#x27;api&#x27;: path.resolve(__dirname, &#x27;..&#x27;, &#x27;src/api&#x27;),</span><br><span class=\"line\">    &#x27;assets&#x27;: path.resolve(__dirname, &#x27;..&#x27;, &#x27;src/assets&#x27;),</span><br><span class=\"line\">    &#x27;utils&#x27;: path.resolve(__dirname, &#x27;..&#x27;, &#x27;src/utils&#x27;),</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>多端兼容性问题，引入 lodash 包，支付宝不支持</li>\n</ul>\n<p>引入 utils.js 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">global.Object = Object</span><br><span class=\"line\">global.Array = Array</span><br><span class=\"line\">global.Buffer = Buffer</span><br><span class=\"line\">global.DataView = DataView</span><br><span class=\"line\">global.Date = Date</span><br><span class=\"line\">global.Error = Error</span><br><span class=\"line\">global.Float32Array = Float32Array</span><br><span class=\"line\">global.Float64Array = Float64Array</span><br><span class=\"line\">global.Function = Function</span><br><span class=\"line\">global.Int8Array = Int8Array</span><br><span class=\"line\">global.Int16Array = Int16Array</span><br><span class=\"line\">global.Int32Array = Int32Array</span><br><span class=\"line\">global.Map = Map</span><br><span class=\"line\">global.Math = Math</span><br><span class=\"line\">global.Promise = Promise</span><br><span class=\"line\">global.RegExp = RegExp</span><br><span class=\"line\">global.Set = Set</span><br><span class=\"line\">global.String = String</span><br><span class=\"line\">global.Symbol = Symbol</span><br><span class=\"line\">global.TypeError = TypeError</span><br><span class=\"line\">global.Uint8Array = Uint8Array</span><br><span class=\"line\">global.Uint8ClampedArray = Uint8ClampedArray</span><br><span class=\"line\">global.Uint16Array = Uint16Array</span><br><span class=\"line\">global.Uint32Array = Uint32Array</span><br><span class=\"line\">global.WeakMap = WeakMap</span><br><span class=\"line\">global.clearTimeout = clearTimeout</span><br><span class=\"line\">global.isFinite = isFinite</span><br><span class=\"line\">global.parseInt = parseInt</span><br><span class=\"line\">global.setTimeout = setTimeout</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>打包微信，支付宝出问题</li>\n</ul>\n<p>npm 包版本不统一导致</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;@tarojs/components&quot;: &quot;3.0.18&quot;,</span><br><span class=\"line\">  &quot;@tarojs/react&quot;: &quot;3.0.18&quot;,</span><br><span class=\"line\">  &quot;@tarojs/runtime&quot;: &quot;3.0.18&quot;,</span><br><span class=\"line\">  &quot;@tarojs/taro&quot;: &quot;3.0.18&quot;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;@tarojs/cli&quot;: &quot;3.0.18&quot;,</span><br><span class=\"line\">  &quot;@tarojs/mini-runner&quot;: &quot;3.0.18&quot;,</span><br><span class=\"line\">  &quot;@tarojs/webpack-runner&quot;: &quot;3.0.18&quot;,</span><br><span class=\"line\">  &quot;babel-preset-taro&quot;: &quot;3.0.18&quot;,</span><br><span class=\"line\">  &quot;eslint-config-taro&quot;: &quot;3.0.18&quot;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局 scss 设置，</li>\n</ul>\n<p>config.js 中可以设置，但是必须要重新启动才可以</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sass: &#123;</span><br><span class=\"line\">    resource: path.resolve(__dirname, &#x27;..&#x27;, &#x27;src/assets/styles/global.scss&#x27;),</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置代理问题</li>\n</ul>\n<p>nginx 配合 fiddler 代理转发可以实现本地开发，app 端进行调试</p>\n<ul>\n<li>手机页面头部点击返回，不能触发页面生命周期</li>\n</ul>\n<p>可以通过 componentDidShow 或者 useDidShow 实现</p>\n<ul>\n<li>map 结构存储订单数据(存储二维数组)</li>\n</ul>\n<p>用法实现 order.get(status)</p>\n<ul>\n<li>不同业务线的状态扭转问题</li>\n</ul>\n<p>利用回调函数，函数式编程实现</p>\n<ul>\n<li>地图坐标系问题</li>\n</ul>\n<p>百度（bd09ll）、高德（gcj02）、腾讯（gcj02）</p>\n<ul>\n<li>轨迹渲染问题</li>\n</ul>\n<p>polyline, label, marker</p>\n<p>动态设置展示区域</p>\n<p>includePoints,并且通过 updateComponent 强制渲染，手机端和开发工具展示不一致问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">this.mapCtx.updateComponents(&#123;</span><br><span class=\"line\">      markers,</span><br><span class=\"line\">      includePoints,</span><br><span class=\"line\">      polyline,</span><br><span class=\"line\">      longitude: cLocation.lng,</span><br><span class=\"line\">      latitude: cLocation.lat,</span><br><span class=\"line\">      setting: &#123;</span><br><span class=\"line\">        showCompass: 0,</span><br><span class=\"line\">        showScale: 0,</span><br><span class=\"line\">        gestureEnable: 1,</span><br><span class=\"line\">        tiltGesturesEnabled: 0,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>处理多个不同任务的定时器，清除问题</li>\n</ul>\n<p>static 静态局部变量</p>\n<ul>\n<li>发布订阅者模式，处理登陆问题</li>\n</ul>\n<p>发布订阅的 service 类库封装</p>\n<ul>\n<li>定时器（汽车位置，订单状态，订单详情，支付状态），状态扭转类，支付类</li>\n</ul>\n<p>类封装</p>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"Tree-Shaking性能优化实践 - 原理篇","url":"/2022/10/24/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E5%8E%9F%E7%90%86%E7%AF%87/","content":"<h2 id=\"一-什么是-Tree-shaking\"><a href=\"#一-什么是-Tree-shaking\" class=\"headerlink\" title=\"一. 什么是 Tree-shaking\"></a>一. 什么是 Tree-shaking</h2><p><img src=\"https://pic4.zhimg.com/80/v2-8b075867835d03be30338855aaea126b_720w.jpg\" alt=\"image\"></p>\n<p>先来看一下 Tree-shaking 原始的本意</p>\n<p><img src=\"https://tse2-mm.cn.bing.net/th/id/OIP.FK1leNlztl80mibxa-uu8QHaEM?w=322&h=183&c=7&o=5&dpr=1.25&pid=1.7\" alt=\"image\"></p>\n<p>上图形象的解释了 Tree-shaking 的本意，本文所说的前端中的 tree-shaking 可以理解为通过工具”摇”我们的 JS 文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-d415073437f0ce3c2349717b4e13a9fb_720w.jpg\" alt=\"image\"></p>\n<p>Tree-shaking 较早由 Rich_Harris 的 rollup 实现，后来，webpack2 也增加了 tree-shaking 的功能。其实在更早，google closure compiler 也做过类似的事情。三个工具的效果和使用各不相同，使用方法可以通过官网文档去了解，三者的效果对比，后文会详细介绍。</p>\n<h2 id=\"二-tree-shaking-的原理\"><a href=\"#二-tree-shaking-的原理\" class=\"headerlink\" title=\"二. tree-shaking 的原理\"></a>二. tree-shaking 的原理</h2><p><img src=\"https://pic2.zhimg.com/80/v2-ff9d9ea4b5313771471c2796a6741d91_720w.jpg\" alt=\"image\"></p>\n<p>Tree-shaking 的本质是消除无用的 js 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 DCE（dead code elimination）。</p>\n<p>Tree-shaking 是 DCE 的一种新的实现，Javascript 同传统的编程语言不同的是，javascript 绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对 javascript 来说更有意义。</p>\n<p>Tree-shaking 和传统的 DCE 的方法又不太一样，传统的 DCE 消灭不可能执行的代码，而 Tree-shaking 更关注于消除没有用到的代码。下面详细介绍一下 DCE 和 Tree-shaking。</p>\n<h3 id=\"（1）先来看一下-DCE-消除大法\"><a href=\"#（1）先来看一下-DCE-消除大法\" class=\"headerlink\" title=\"（1）先来看一下 DCE 消除大法\"></a>（1）先来看一下 DCE 消除大法</h3><p><img src=\"https://pic3.zhimg.com/80/v2-18129c123fbaebba27ac786c856abfd2_720w.jpg\" alt=\"image\"></p>\n<p>Dead Code 一般具有以下几个特征</p>\n<ul>\n<li>代码不会被执行，不可到达</li>\n<li>代码执行的结果不会被用到</li>\n<li>代码只会影响死变量（只写不读）</li>\n</ul>\n<p>下面红框标示的代码就属于死码，满足以上特征</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-e7063073c59b49906e6aa9cefac1281f_720w.jpg\" alt=\"image\"></p>\n<p>传统编译型的语言中，都是由编译器将 Dead Code 从 AST（抽象语法树）中删除，那 javascript 中是由谁做 DCE 呢？</p>\n<p>首先肯定不是浏览器做 DCE，因为当我们的代码送到浏览器，那还谈什么消除无法执行的代码来优化呢，所以肯定是送到浏览器之前的步骤进行优化。</p>\n<p>其实也不是上面提到的三个工具，rollup，webpack，cc 做的，而是著名的代码压缩优化工具 uglify，uglify 完成了 javascript 的 DCE，下面通过一个实验来验证一下。</p>\n<blockquote>\n<p>以下所有的示例代码都能在 github 中找到</p>\n</blockquote>\n<p><a href=\"https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack\">https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack</a></p>\n<p><strong>分别用 rollup 和 webpack 将图 4 中的代码进行打包</strong></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-87a1817d027f5e000b80ada132e11b33_720w.jpg\" alt=\"image\"></p>\n<p>中间是 rollup 打包的结果，右边是 webpack 打包的结果</p>\n<p>可以发现，rollup 将无用的代码 foo 函数和 unused 函数消除了，但是仍然保留了不会执行到的代码，而 webpack 完整的保留了所有的无用代码和不会执行到的代码。</p>\n<p><strong>分别用 rollup + uglify 和 webpack + uglify 将图 4 中的代码进行打包</strong></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-cd8913573d1862aa0799b28ca84e048d_720w.jpg\" alt=\"image\"></p>\n<p>中间是配置文件，右侧是结果</p>\n<p>可以看到右侧最终打包结果中都去除了无法执行到的代码，结果符合我们的预期。</p>\n<h3 id=\"2-再来看一下-Tree-shaking-消除大法\"><a href=\"#2-再来看一下-Tree-shaking-消除大法\" class=\"headerlink\" title=\"(2) 再来看一下 Tree-shaking 消除大法\"></a>(2) 再来看一下 Tree-shaking 消除大法</h3><p>前面提到了 tree-shaking 更关注于无用模块的消除，消除那些引用了但并没有被使用的模块。</p>\n<p>先思考一个问题，为什么 tree-shaking 是最近几年流行起来了？而前端模块化概念已经有很多年历史了，其实 tree-shaking 的消除原理是依赖于 ES6 的模块特性。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-e56729aa4ee3efa34ebbfe8ec02d9583_720w.jpg\" alt=\"image\"></p>\n<p>ES6 module 特点：</p>\n<ul>\n<li>只能作为模块顶层的语句出现</li>\n<li>import 的模块名只能是字符串常量</li>\n<li>import binding 是 immutable 的<br>ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础。</li>\n</ul>\n<p>所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6 之前的模块化，比如我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。</p>\n<p>这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。</p>\n<p>我们还是通过例子来详细了解一下</p>\n<p>面向过程编程函数和面向对象编程是 javascript 最常用的编程模式和代码组织方式，从这两个方面来实验：</p>\n<ul>\n<li>函数消除实验</li>\n<li>类消除实验</li>\n</ul>\n<p><strong>先看下函数消除实验</strong></p>\n<p>utils 中 get 方法没有被使用到，我们期望的是 get 方法最终被消除。</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0ab75edb6d645a574fca0f7cfed6eaf2_720w.jpg\" alt=\"image\"></p>\n<p>注意，uglify 目前不会跨文件去做 DCE，所以上面这种情况，uglify 是不能优化的。</p>\n<p><strong>先看看 rollup 的打包结果</strong></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-c6212005445fa180a103ff7c8b26c234_720w.jpg\" alt=\"image\"></p>\n<p>完全符合预期，最终结果中没有 get 方法</p>\n<p><strong>再看看 webpack 的结果</strong></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-19c1884f6deaeab166036df5dc7af121_720w.jpg\" alt=\"image\"></p>\n<p>也符合预期，最终结果中没有 get 方法</p>\n<p>可以看到 rollup 打包的结果比 webpack 更优化</p>\n<blockquote>\n<p>函数消除实验中，rollup 和 webpack 都通过，符合预期</p>\n</blockquote>\n<p><strong>再来看下类消除实验</strong></p>\n<p>增加了对 menu.js 的引用，但其实代码中并没有用到 menu 的任何方法和变量，所以我们的期望是，最终代码中 menu.js 里的内容被消除</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-eb682abb2e27a72ce2ab031ad94cdc09_720w.jpg\" alt=\"image\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-7aab6ee6e04416d34a30208d3a8125ac_720w.jpg\" alt=\"image\"></p>\n<p>rollup 打包结果</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-559f5911b18e201ca7407277ecdd3911_720w.jpg\" alt=\"image\"></p>\n<p>包中竟然包含了 menu.js 的全部代码</p>\n<p><strong>webpack 打包结果</strong></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-444d7415f84a373778702747372d2370_720w.jpg\" alt=\"image\"></p>\n<p>包中竟然也包含了 menu.js 的全部代码</p>\n<blockquote>\n<p>类消除实验中，rollup，webpack 全军覆没，都没有达到预期</p>\n</blockquote>\n<p><img src=\"https://pic3.zhimg.com/80/v2-b796932873b2f5b217a1fdd00212c376_720w.jpg\" alt=\"image\"></p>\n<p>这跟我们想象的完全不一样啊？为什么呢？无用的类不能消除，这还能叫做 tree-shaking 吗？我当时一度怀疑自己的 demo 有问题，后来各种网上搜索，才明白 demo 没有错。</p>\n<p>下面摘取了 rollup 核心贡献者的的一些回答：</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-a04ef2070513c5a4d90966c8e80df0ca_720w.jpg\" alt=\"image\"></p>\n<ul>\n<li>rollup 只处理函数和顶层的 import&#x2F;export 变量，不能把没用到的类的方法消除掉</li>\n<li>javascript 动态语言的特性使得静态分析比较困难</li>\n<li>图 7 下部分的代码就是副作用的一个例子，如果静态分析的时候删除 run 或者 jump，程序运行时就可能报错，那就本末倒置了，我们的目的是优化，肯定不能影响执行</li>\n</ul>\n<p>再举个例子说明下为什么不能消除 menu.js，比如下面这个场景</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Menu() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Menu.prototype.show = function() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Array.prototype.unique = function() &#123;</span><br><span class=\"line\">    // 将 array 中的重复元素去除</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Menu;</span><br></pre></td></tr></table></figure>\n\n<p>如果删除 menu.js，那 Array 的扩展也会被删除，就会影响功能。那也许你会问，难道 rollup，webpack 不能区分是定义 Menu 的 proptotype 还是定义 Array 的 proptotype 吗？当然如果代码写成上面这种形式是可以区分的，如果我写成这样呢？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Menu() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Menu.prototype.show = function() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var a = &#x27;Arr&#x27; + &#x27;ay&#x27;</span><br><span class=\"line\">var b</span><br><span class=\"line\">if(a == &#x27;Array&#x27;) &#123;</span><br><span class=\"line\">    b = Array</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    b = Menu</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">b.prototype.unique = function() &#123;</span><br><span class=\"line\">    // 将 array 中的重复元素去除</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Menu;</span><br></pre></td></tr></table></figure>\n\n<p>这种代码，静态分析是分析不了的，就算能静态分析代码，想要正确完全的分析也比较困难。</p>\n<p>更多关于副作用的讨论，可以看这个</p>\n<p><a href=\"https://github.com/rollup/rollup/issues/349\">https://github.com/rollup/rollup/issues/349</a></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0417d8e35bd25ec6fb184b2c378d65e6_720w.jpg\" alt=\"image\"></p>\n<blockquote>\n<p>tree-shaking 对函数效果较好</p>\n</blockquote>\n<p>函数的副作用相对较少，顶层函数相对来说更容易分析，加上 babel 默认都是”use strict”严格模式，减少顶层函数的动态访问的方式，也更容易分析</p>\n<p>我们开始说的三个工具，rollup 和 webpack 表现不理想，那 closure compiler 又如何呢？</p>\n<p>将示例中的代码用 cc 打包后得到的结果如下：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-91bc794a87ea5c35f2981ebb55b9b44b_720w.jpg\" alt=\"image\"></p>\n<p>天啊，这不就是我们要的结果吗？完美消除所有无用代码的结果，输出的结果非常性感</p>\n<blockquote>\n<p>closure compiler， tree-shaking 的结果完美！</p>\n</blockquote>\n<p>可是不能高兴得太早，能得到这么完美结果是需要条件的，那就是 cc 的侵入式约束规范。必须在代码里添加这样的代码，看红线框标示的</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-6346776acfa7b0c50a331afd22d260ad_720w.jpg\" alt=\"image\"></p>\n<p>google 定义一整套注解规范 Annotating JavaScript for the Closure Compiler，想更多了解的，可以去看下官网。</p>\n<p>侵入式这个就让人很不爽，google Closure Compiler 是 java 写的，和我们基于 node 的各种构建库不可能兼容（不过目前好像已经有 nodejs 版 Closure Compiler），Closure Compiler 使用起来也比较麻烦，所以虽然效果很赞，但比较难以应用到项目中，迁移成本较大。</p>\n<p><strong>说了这么多，总结一下：</strong></p>\n<p>三大工具的 tree-shaking 对于无用代码，无用模块的消除，都是有限的，有条件的。closure compiler 是最好的，但与我们日常的基于 node 的开发流很难兼容。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-f74aabd0006d76162998f04ac09c87ac_720w.jpg\" alt=\"image\"></p>\n<p>tree-shaking 对 web 意义重大，是一个极致优化的理想世界，是前端进化的又一个终极理想。</p>\n<p>理想是美好的，但目前还处在发展阶段，还比较困难，有各个方面的，甚至有目前看来无法解</p>\n<p>决的问题，但还是应该相信新技术能带来更好的前端世界。</p>\n<p>但优化是一种态度，不因小而不为，不因艰而不攻。</p>\n<h2 id=\"三、Tree-Shaking-的工作原理\"><a href=\"#三、Tree-Shaking-的工作原理\" class=\"headerlink\" title=\"三、Tree-Shaking 的工作原理\"></a>三、Tree-Shaking 的工作原理</h2><p>Tree-shaking （树摇）最早是由 Rollup 实现，是一种采用删除不需要的额外代码的方式优化代码体积的技术，webpack2 借鉴了这个特性也增加了 tree-shaking 的功能。</p>\n<p>tree-shaking 只能在静态 modules 下工作，在 ES6 之前我们使用 CommonJS 规范引入模块，具体采用 require()的方式动态引入模块，这个特性可以通过判断条件解决按需加载的优化问题，具体如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let module;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if(condition) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    module =  require(&quot;HellowModule&quot;) ;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    module = requitre(&#x27;BeyModule&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是 CommonJS 规范无法确定在实际运行前需要或者不需要某些模块，所以 CommonJS 不适合 tree-shaking 机制。</p>\n<p>在 JavaScript 模块化方案中，只有 ES6 的模块方案：import()引入模块的方式采用静态导入，可以采用一次导入所有的依赖包再根据条件判断的方式，获取不需要的包，然后执行删除操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import hello from &quot;Hellow&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import bey from &quot;Bey&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import other from &quot;Other&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if(condition) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // hello</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // bey</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Tree-shaking 的实现原理</strong></p>\n<p><strong>利用 ES6 模块特性：</strong></p>\n<ul>\n<li>只能作为模块顶层的语句出现</li>\n<li>import 的模块名只能是字符串常量</li>\n<li>import binding 是 immutable 的，引入的模块不能再进行修改</li>\n</ul>\n<p><strong>代码删除：</strong></p>\n<ul>\n<li>uglify：判断程序流，判断变量是否被使用和引用，进而删除代码</li>\n</ul>\n<p>实现原理可以简单的概况：</p>\n<ol>\n<li>ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块</li>\n<li>静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</li>\n</ol>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"TypeScript的使用技巧","url":"/2022/12/16/TypeScript%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","content":"<h1 id=\"一、Enum-类型\"><a href=\"#一、Enum-类型\" class=\"headerlink\" title=\"一、Enum 类型\"></a>一、Enum 类型</h1><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</p>\n<h2 id=\"1-数字枚举\"><a href=\"#1-数字枚举\" class=\"headerlink\" title=\"1.数字枚举\"></a>1.数字枚举</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Direction &#123;</span><br><span class=\"line\">  NORTH,</span><br><span class=\"line\">  SOUTH,</span><br><span class=\"line\">  EAST,</span><br><span class=\"line\">  WEST,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let dir: Direction = Direction.NORTH;</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">var Direction;</span><br><span class=\"line\">(function (Direction) &#123;</span><br><span class=\"line\">  Direction[(Direction[&quot;NORTH&quot;] = 0)] = &quot;NORTH&quot;;</span><br><span class=\"line\">  Direction[(Direction[&quot;SOUTH&quot;] = 1)] = &quot;SOUTH&quot;;</span><br><span class=\"line\">  Direction[(Direction[&quot;EAST&quot;] = 2)] = &quot;EAST&quot;;</span><br><span class=\"line\">  Direction[(Direction[&quot;WEST&quot;] = 3)] = &quot;WEST&quot;;</span><br><span class=\"line\">&#125;)(Direction || (Direction = &#123;&#125;));</span><br><span class=\"line\">var dir = Direction.NORTH;</span><br></pre></td></tr></table></figure>\n\n<p>当然我们也可以设置 NORTH 的初始值，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Direction &#123;</span><br><span class=\"line\">  NORTH = 3,</span><br><span class=\"line\">  SOUTH,</span><br><span class=\"line\">  EAST,</span><br><span class=\"line\">  WEST,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-字符串枚举\"><a href=\"#2-字符串枚举\" class=\"headerlink\" title=\"2.字符串枚举\"></a>2.字符串枚举</h2><p>在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Direction &#123;</span><br><span class=\"line\">  NORTH = &quot;NORTH&quot;,</span><br><span class=\"line\">  SOUTH = &quot;SOUTH&quot;,</span><br><span class=\"line\">  EAST = &quot;EAST&quot;,</span><br><span class=\"line\">  WEST = &quot;WEST&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码对于的 ES5 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">var Direction;</span><br><span class=\"line\">(function (Direction) &#123;</span><br><span class=\"line\">    Direction[&quot;NORTH&quot;] = &quot;NORTH&quot;;</span><br><span class=\"line\">    Direction[&quot;SOUTH&quot;] = &quot;SOUTH&quot;;</span><br><span class=\"line\">    Direction[&quot;EAST&quot;] = &quot;EAST&quot;;</span><br><span class=\"line\">    Direction[&quot;WEST&quot;] = &quot;WEST&quot;;</span><br><span class=\"line\">&#125;)(Direction || (Direction = &#123;&#125;));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-异构枚举\"><a href=\"#3-异构枚举\" class=\"headerlink\" title=\"3.异构枚举\"></a>3.异构枚举</h2><p>异构枚举的成员值是数字和字符串的混合：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Enum &#123;</span><br><span class=\"line\">  A,</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  C = &quot;C&quot;,</span><br><span class=\"line\">  D = &quot;D&quot;,</span><br><span class=\"line\">  E = 8,</span><br><span class=\"line\">  F,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码对于的 ES5 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">var Enum;</span><br><span class=\"line\">(function (Enum) &#123;</span><br><span class=\"line\">    Enum[Enum[&quot;A&quot;] = 0] = &quot;A&quot;;</span><br><span class=\"line\">    Enum[Enum[&quot;B&quot;] = 1] = &quot;B&quot;;</span><br><span class=\"line\">    Enum[&quot;C&quot;] = &quot;C&quot;;</span><br><span class=\"line\">    Enum[&quot;D&quot;] = &quot;D&quot;;</span><br><span class=\"line\">    Enum[Enum[&quot;E&quot;] = 8] = &quot;E&quot;;</span><br><span class=\"line\">    Enum[Enum[&quot;F&quot;] = 9] = &quot;F&quot;;</span><br><span class=\"line\">&#125;)(Enum || (Enum = &#123;&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(Enum.A) //输出：0</span><br><span class=\"line\">console.log(Enum[0]) // 输出：A</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、特殊数据类型\"><a href=\"#二、特殊数据类型\" class=\"headerlink\" title=\"二、特殊数据类型\"></a>二、特殊数据类型</h1><h2 id=\"1-Unknown-类型\"><a href=\"#1-Unknown-类型\" class=\"headerlink\" title=\"1. Unknown 类型\"></a>1. Unknown 类型</h2><p>就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）。下面我们来看一下 unknown 类型的使用示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let value: unknown;</span><br><span class=\"line\"></span><br><span class=\"line\">value = true; // OK</span><br><span class=\"line\">value = 42; // OK</span><br><span class=\"line\">value = &quot;Hello World&quot;; // OK</span><br><span class=\"line\">value = []; // OK</span><br><span class=\"line\">value = &#123;&#125;; // OK</span><br><span class=\"line\">value = Math.random; // OK</span><br><span class=\"line\">value = null; // OK</span><br><span class=\"line\">value = undefined; // OK</span><br><span class=\"line\">value = new TypeError(); // OK</span><br><span class=\"line\">value = Symbol(&quot;type&quot;); // OK</span><br></pre></td></tr></table></figure>\n\n<p>对 <code>value</code> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <code>unknown</code> 的值赋值给其他类型的变量时会发生什么？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let value: unknown;</span><br><span class=\"line\"></span><br><span class=\"line\">let value1: unknown = value; // OK</span><br><span class=\"line\">let value2: any = value; // OK</span><br><span class=\"line\">let value3: boolean = value; // Error</span><br><span class=\"line\">let value4: number = value; // Error</span><br><span class=\"line\">let value5: string = value; // Error</span><br><span class=\"line\">let value6: object = value; // Error</span><br><span class=\"line\">let value7: any[] = value; // Error</span><br><span class=\"line\">let value8: Function = value; // Error</span><br></pre></td></tr></table></figure>\n\n<p><code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 <code>unknown</code> 类型的值。毕竟我们不知道变量 <code>value</code> 中存储了什么类型的值。</p>\n<p>现在让我们看看当我们尝试对类型为 unknown 的值执行操作时会发生什么。以下是我们在之前 any 章节看过的相同操作：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let value: unknown;</span><br><span class=\"line\"></span><br><span class=\"line\">value.foo.bar; // Error</span><br><span class=\"line\">value.trim(); // Error</span><br><span class=\"line\">value(); // Error</span><br><span class=\"line\">new value(); // Error</span><br><span class=\"line\">value[0][1]; // Error</span><br></pre></td></tr></table></figure>\n\n<p>将 <code>value</code> 变量类型设置为 <code>unknown</code> 后，这些操作都不再被认为是类型正确的。通过将 <code>any</code> 类型改变为 <code>unknown</code> 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。</p>\n<h2 id=\"2-Never-类型\"><a href=\"#2-Never-类型\" class=\"headerlink\" title=\"2. Never 类型\"></a>2. Never 类型</h2><p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如，<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 返回never的函数必须存在无法达到的终点</span><br><span class=\"line\">function error(message: string): never &#123;</span><br><span class=\"line\">  throw new Error(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function infiniteLoop(): never &#123;</span><br><span class=\"line\">  while (true) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Foo = string | number;</span><br><span class=\"line\"></span><br><span class=\"line\">function controlFlowAnalysisWithNever(foo: Foo) &#123;</span><br><span class=\"line\">  if (typeof foo === &quot;string&quot;) &#123;</span><br><span class=\"line\">    // 这里 foo 被收窄为 string 类型</span><br><span class=\"line\">  &#125; else if (typeof foo === &quot;number&quot;) &#123;</span><br><span class=\"line\">    // 这里 foo 被收窄为 number 类型</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // foo 在这里是 never</span><br><span class=\"line\">    const check: never = foo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Foo = string | number | boolean;</span><br></pre></td></tr></table></figure>\n\n<p>然而他忘记同时修改 <code>controlFlowAnalysisWithNever</code> 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 <code>boolean</code> 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保</p>\n<p><code>controlFlowAnalysisWithNever</code> 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</p>\n<h1 id=\"三、Typescript-的类型系统\"><a href=\"#三、Typescript-的类型系统\" class=\"headerlink\" title=\"三、Typescript 的类型系统\"></a>三、Typescript 的类型系统</h1><p>充分使用编辑器的 language service 功能（类型提示，类型检查，类型推倒，自动补全，类型定义跳转)</p>\n<p>把类型当做值的集合思考</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type A= &#x27;A&#x27; // 单值集合 &#123; &#x27;A&#x27; &#125;</span><br><span class=\"line\">type B= &#x27;B&#x27; // 单值集合 &#123; &#x27;B&#x27; &#125;</span><br><span class=\"line\">type AB = &#x27;A&#x27; | &#x27;B&#x27;  // 集合的并集 &#123; &#x27;A&#x27;, &#x27;B&#x27; &#125;</span><br><span class=\"line\">type twoInt =  2 | 4 | 5 ... // 无限元素集合 &#123; 1,2,3,4&#125;</span><br><span class=\"line\">type threeInt = 3 | 6 | 9 // 无限集合</span><br><span class=\"line\">type twoIntersectThreeInt = twoInt &amp; threeInt // 无限集合的交集</span><br><span class=\"line\">type twoUnionThreeInt = 2| 3 | 4 | 6 ... // 无限集合的并集</span><br><span class=\"line\">keyof (A&amp;B) = (keyof A) | (keyof B)</span><br><span class=\"line\">keyof (A|B) = (keyof A) &amp; (keyof B)</span><br></pre></td></tr></table></figure>\n\n<p>术语和集合术语对照表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Typescript术语\t                  集合术语</span><br><span class=\"line\">never\t                          空集</span><br><span class=\"line\">literal type\t                  单值集合</span><br><span class=\"line\">value 可赋值给 T\t              value ∈T</span><br><span class=\"line\">T1 assignable to T2\t              T1是T2的子集</span><br><span class=\"line\">T1 extends T2\t                  T1是T2的子集</span><br><span class=\"line\">T1\t                              T2</span><br><span class=\"line\">T1 &amp; T2\t                          T1 和T2的交集</span><br><span class=\"line\">unknown\t                          universal set</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、了解-type-和-interface-的区别\"><a href=\"#四、了解-type-和-interface-的区别\" class=\"headerlink\" title=\"四、了解 type 和 interface 的区别\"></a>四、了解 type 和 interface 的区别</h1><p>绝大部分情况下，type 和 interface 都能等价转换</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 普通对象</span><br><span class=\"line\">type TState = &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    capital: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface IState &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    capital: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// index signature</span><br><span class=\"line\">type TDict = &#123;[key:string]: string &#125;</span><br><span class=\"line\">interface IDict &#123;</span><br><span class=\"line\">    [key:string]: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type TFn = (x:number) =&gt; string;</span><br><span class=\"line\">interface IFn &#123;</span><br><span class=\"line\">    (x:number):string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// function with props</span><br><span class=\"line\">type TFnWithProps = &#123;</span><br><span class=\"line\">    (x:number):number;</span><br><span class=\"line\">    prop: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface IFnWithProps &#123;</span><br><span class=\"line\">    (x:number):number;</span><br><span class=\"line\">    prop: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//  constructor</span><br><span class=\"line\">type TConstructor = new(x:number) =&gt; &#123;x:number&#125;</span><br><span class=\"line\">interface IConstructor&#123;</span><br><span class=\"line\">    new(x:number): &#123;x:number&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// generic</span><br><span class=\"line\">type TPair&lt;T&gt;= &#123;</span><br><span class=\"line\">    first: T;</span><br><span class=\"line\">    second: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface IPair&lt;T&gt; &#123;</span><br><span class=\"line\">    first: T;</span><br><span class=\"line\">    second: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// extends</span><br><span class=\"line\">type TStateWithProps = TState &amp; &#123; population : number&#125;</span><br><span class=\"line\">interface IStateWithProp extends IState &#123;</span><br><span class=\"line\">    population: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// implements</span><br><span class=\"line\">class StateT implements TState &#123;</span><br><span class=\"line\">    name = &#x27;&#x27;;</span><br><span class=\"line\">    capital = &#x27;&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class StateI implements IState &#123;</span><br><span class=\"line\">    name=&#x27;&#x27;;</span><br><span class=\"line\">    capital = &#x27;&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>type 和 interface 亦有所区别</p>\n<ol>\n<li>interface 无法应用于 union type | intersection type | conditional type | tuple</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type AorB = &#x27;A&#x27; | &#x27;B&#x27;</span><br><span class=\"line\">type NamedVariable = (Input | Output) &amp; &#123; name: string&#125;</span><br><span class=\"line\">type Pair = [number,number]</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>interface 可以 argumented,而 type 不可以</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// inner</span><br><span class=\"line\">interface IState &#123;</span><br><span class=\"line\">    name :string;</span><br><span class=\"line\">    capital: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// outer</span><br><span class=\"line\">interface IState &#123;</span><br><span class=\"line\">    population: number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const wyoming: IState = &#123;</span><br><span class=\"line\">    name: &#x27;Wyoming&#x27;,</span><br><span class=\"line\">    capital: &#x27;Cheyenne&#x27;,</span><br><span class=\"line\">    population: 500_000</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"五、keyof-操作符\"><a href=\"#五、keyof-操作符\" class=\"headerlink\" title=\"五、keyof 操作符\"></a>五、keyof 操作符</h1><h2 id=\"keyof-简介\"><a href=\"#keyof-简介\" class=\"headerlink\" title=\"keyof 简介\"></a>keyof 简介</h2><p>TypeScript 允许我们遍历某种类型的属性，并通过 keyof 操作符提取其属性的名称。keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</p>\n<p>下面我们来看个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">  name: string;</span><br><span class=\"line\">  age: number;</span><br><span class=\"line\">  location: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span><br><span class=\"line\">type K2 = keyof Person[];  // number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...</span><br><span class=\"line\">type K3 = keyof &#123; [x: string]: Person &#125;;  // string | number</span><br></pre></td></tr></table></figure>\n\n<p>除了接口外，keyof 也可以用于操作类，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">  name: string = &quot;Semlinker&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let sname: keyof Person;</span><br><span class=\"line\">sname = &quot;name&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>若把 <code>sname = &quot;name&quot;</code> 改为 <code>sname = &quot;age&quot;</code> 的话，TypeScript 编译器会提示以下错误信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Type &#x27;&quot;age&quot;&#x27; is not assignable to type &#x27;&quot;name&quot;&#x27;.</span><br></pre></td></tr></table></figure>\n\n<p>keyof 操作符除了支持接口和类之外，它也支持基本数据类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let K1: keyof boolean; // let K1: &quot;valueOf&quot;</span><br><span class=\"line\">let K2: keyof number; // let K2: &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; | ...</span><br><span class=\"line\">let K3: keyof symbol; // let K3: &quot;valueOf&quot;</span><br></pre></td></tr></table></figure>\n\n<p>此外 keyof 也称为输入索引类型查询，与之相对应的是索引访问类型，也称为查找类型。在语法上，它们看起来像属性或元素访问，但最终会被转换为类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type P1 = Person[&quot;name&quot;];  // string</span><br><span class=\"line\">type P2 = Person[&quot;name&quot; | &quot;age&quot;];  // string | number</span><br><span class=\"line\">type P3 = string[&quot;charAt&quot;];  // (pos: number) =&gt; string</span><br><span class=\"line\">type P4 = string[][&quot;push&quot;];  // (...items: string[]) =&gt; number</span><br><span class=\"line\">type P5 = string[][0];  // string</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"keyof-的作用\"><a href=\"#keyof-的作用\" class=\"headerlink\" title=\"keyof 的作用\"></a>keyof 的作用</h2><p>JavaScript 是一种高度动态的语言。有时在静态类型系统中捕获某些操作的语义可能会很棘手。以一个简单的 prop 函数为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function prop(obj, key) &#123;</span><br><span class=\"line\">  return obj[key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该函数接收 obj 和 key 两个参数，并返回对应属性的值。对象上的不同属性，可以具有完全不同的类型，我们甚至不知道 obj 对象长什么样。</p>\n<p>那么在 TypeScript 中如何定义上面的 prop 函数呢？我们来尝试一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function prop(obj: object, key: string) &#123;</span><br><span class=\"line\">  return obj[key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面代码中，为了避免调用 prop 函数时传入错误的参数类型，我们为 obj 和 key 参数设置了类型，分别为 {} 和 string 类型。然而，事情并没有那么简单。针对上述的代码，TypeScript 编译器会输出以下错误信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Element implicitly has an &#x27;any&#x27; type because expression of type &#x27;string&#x27; can&#x27;t be used to index type &#x27;&#123;&#125;&#x27;.</span><br></pre></td></tr></table></figure>\n\n<p>元素隐式地拥有 any 类型，因为 string 类型不能被用于索引 {} 类型。要解决这个问题，你可以使用以下非常暴力的方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function prop(obj: object, key: string) &#123;</span><br><span class=\"line\">  return (obj as any)[key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很明显该方案并不是一个好的方案，我们来回顾一下 prop 函数的作用，该函数用于获取某个对象中指定属性的属性值。因此我们期望用户输入的属性是对象上已存在的属性，那么如何限制属性名的范围呢？这时我们可以利用本文的主角 keyof 操作符：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) &#123;</span><br><span class=\"line\">  return obj[key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中，我们使用了 TypeScript 的泛型和泛型约束。首先定义了 T 类型并使用 extends 关键字约束该类型必须是 object 类型的子类型，然后使用 keyof 操作符获取 T 类型的所有键，其返回类型是联合类型，最后利用 extends 关键字约束 K 类型必须为 keyof T 联合类型的子类型。 是骡子是马拉出来遛遛就知道了，我们来实际测试一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Todo = &#123;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  text: string;</span><br><span class=\"line\">  done: boolean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const todo: Todo = &#123;</span><br><span class=\"line\">  id: 1,</span><br><span class=\"line\">  text: &quot;Learn TypeScript keyof&quot;,</span><br><span class=\"line\">  done: false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) &#123;</span><br><span class=\"line\">  return obj[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const id = prop(todo, &quot;id&quot;); // const id: number</span><br><span class=\"line\">const text = prop(todo, &quot;text&quot;); // const text: string</span><br><span class=\"line\">const done = prop(todo, &quot;done&quot;); // const done: boolean</span><br></pre></td></tr></table></figure>\n\n<p>很明显使用泛型，重新定义后的 prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) 函数，已经可以正确地推导出指定键对应的类型。那么当访问 todo 对象上不存在的属性时，会出现什么情况？比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const date = prop(todo, &quot;date&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>对于上述代码，TypeScript 编译器会提示以下错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Argument of type &#x27;&quot;date&quot;&#x27; is not assignable to parameter of type &#x27;&quot;id&quot; | &quot;text&quot; | &quot;done&quot;&#x27;.</span><br></pre></td></tr></table></figure>\n\n<p>这就阻止我们尝试读取不存在的属性。</p>\n<h2 id=\"keyof-与对象的数值属性\"><a href=\"#keyof-与对象的数值属性\" class=\"headerlink\" title=\"keyof 与对象的数值属性\"></a>keyof 与对象的数值属性</h2><p>在使用对象的数值属性时，我们也可以使用 keyof 关键字。请记住，如果我们定义一个带有数值属性的对象，那么我们既需要定义该属性，又需要使用数组语法访问该属性， 如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class ClassWithNumericProperty &#123;</span><br><span class=\"line\">  [1]: string = &quot;Semlinker&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let classWithNumeric = new ClassWithNumericProperty();</span><br><span class=\"line\">console.log(`$&#123;classWithNumeric[1]&#125; `);</span><br></pre></td></tr></table></figure>\n\n<p>下面我们来举个示例，介绍一下在含有数值属性的对象中，如何使用 keyof 操作符来安全地访问对象的属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Currency &#123;</span><br><span class=\"line\">  CNY = 6,</span><br><span class=\"line\">  EUR = 8,</span><br><span class=\"line\">  USD = 10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const CurrencyName = &#123;</span><br><span class=\"line\">  [Currency.CNY]: &quot;人民币&quot;,</span><br><span class=\"line\">  [Currency.EUR]: &quot;欧元&quot;,</span><br><span class=\"line\">  [Currency.USD]: &quot;美元&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(`CurrencyName[Currency.CNY] = $&#123;CurrencyName[Currency.CNY]&#125;`);</span><br><span class=\"line\">console.log(`CurrencyName[36] = $&#123;CurrencyName[6]&#125;`);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中，首先定义了一个 Currency 枚举用于表示三种货币类型，接着定义一个 CurrencyName 对象，该对象使用数值属性作为键，对应的值是该货币类型的名称。该代码成功运行后，控制台会输出以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CurrencyName[Currency.CNY] = 人民币</span><br><span class=\"line\">CurrencyName[36] = 人民币</span><br></pre></td></tr></table></figure>\n\n<p>为了方便用户能根据货币类型来获取对应的货币名称，我们来定义一个 getCurrencyName 函数，具体实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getCurrencyName&lt;T, K extends keyof T&gt;(key: K, map: T): T[K] &#123;</span><br><span class=\"line\">  return map[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(`name = $&#123;getCurrencyName(Currency.CNY, CurrencyName)&#125;`);</span><br></pre></td></tr></table></figure>\n\n<p>同样，getCurrencyName 函数和前面介绍的 prop 函数一样，使用了泛型和泛型约束，从而来保证属性的安全访问。最后，我们来简单介绍一下 keyof 与 typeof 操作符如何配合使用。</p>\n<h2 id=\"keyof-与-typeof-操作符\"><a href=\"#keyof-与-typeof-操作符\" class=\"headerlink\" title=\"keyof 与 typeof 操作符\"></a>keyof 与 typeof 操作符</h2><p>typeof 操作符用于获取变量的类型。因此这个操作符的后面接的始终是一个变量，且需要运用到类型定义当中。为了方便大家理解，我们来举一个具体的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Person = &#123;</span><br><span class=\"line\">  name: string;</span><br><span class=\"line\">  age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let man: Person = &#123;</span><br><span class=\"line\">  name: &quot;Semlinker&quot;,</span><br><span class=\"line\">  age: 30</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type Human = typeof man;</span><br></pre></td></tr></table></figure>\n\n<p>了解完 typeof 和 keyof 操作符的作用，我们来举个例子，介绍一下它们如何结合在一起使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const COLORS = &#123;</span><br><span class=\"line\">  red: &#x27;red&#x27;,</span><br><span class=\"line\">  blue: &#x27;blue&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 首先通过typeof操作符获取color变量的类型，然后通过keyof操作符获取该类型的所有键，</span><br><span class=\"line\">// 即字符串字面量联合类型 &#x27;red&#x27; | &#x27;blue&#x27;</span><br><span class=\"line\">type Colors = keyof typeof COLORS</span><br><span class=\"line\">let color: Colors;</span><br><span class=\"line\">color = &#x27;red&#x27; // Ok</span><br><span class=\"line\">color = &#x27;blue&#x27; // Ok</span><br><span class=\"line\"></span><br><span class=\"line\">// Type &#x27;&quot;yellow&quot;&#x27; is not assignable to type &#x27;&quot;red&quot; | &quot;blue&quot;&#x27;.</span><br><span class=\"line\">color = &#x27;yellow&#x27; // Error</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"六、TypeScript-泛型\"><a href=\"#六、TypeScript-泛型\" class=\"headerlink\" title=\"六、TypeScript 泛型\"></a>六、TypeScript 泛型</h1><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>\n<p>在像 <code>C#</code> 和 <code>Java</code> 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>\n<p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p>\n<p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p>\n<h2 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface GenericIdentityFn&lt;T&gt; &#123;</span><br><span class=\"line\">  (arg: T): T;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class GenericNumber&lt;T&gt; &#123;</span><br><span class=\"line\">  zeroValue: T;</span><br><span class=\"line\">  add: (x: T, y: T) =&gt; T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myGenericNumber = new GenericNumber&lt;number&gt;();</span><br><span class=\"line\">myGenericNumber.zeroValue = 0;</span><br><span class=\"line\">myGenericNumber.add = function (x, y) &#123;</span><br><span class=\"line\">  return x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"泛型变量\"><a href=\"#泛型变量\" class=\"headerlink\" title=\"泛型变量\"></a>泛型变量</h2><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p>\n<ul>\n<li>T（Type）：表示一个 TypeScript 类型</li>\n<li>K（Key）：表示对象中的键类型</li>\n<li>V（Value）：表示对象中的值类型</li>\n<li>E（Element）：表示元素类型</li>\n</ul>\n<h2 id=\"泛型工具类型\"><a href=\"#泛型工具类型\" class=\"headerlink\" title=\"泛型工具类型\"></a>泛型工具类型</h2><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p>\n<p><strong>1.typeof</strong><br>在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">  name: string;</span><br><span class=\"line\">  age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const sem: Person = &#123; name: &#x27;semlinker&#x27;, age: 30 &#125;;</span><br><span class=\"line\">type Sem= typeof sem; // -&gt; Person</span><br><span class=\"line\"></span><br><span class=\"line\">function toArray(x: number): Array&lt;number&gt; &#123;</span><br><span class=\"line\">  return [x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type Func = typeof toArray; // -&gt; (x: number) =&gt; number[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.keyof</strong><br>keyof 操作符可以用来获取一个对象中的所有 key 值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot;</span><br><span class=\"line\">type K2 = keyof Person[]; // &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot;</span><br><span class=\"line\">type K3 = keyof &#123; [x: string]: Person &#125;;  // string | number</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.in</strong><br>in 用来遍历枚举类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Keys = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">type Obj =  &#123;</span><br><span class=\"line\">  [p in Keys]: any</span><br><span class=\"line\">&#125; // -&gt; &#123; a: any, b: any, c: any &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.infer</strong><br>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type ReturnType&lt;T&gt; = T extends (</span><br><span class=\"line\">  ...args: any[]</span><br><span class=\"line\">) =&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p>\n<p><strong>5.extends</strong><br>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface ILengthwise &#123;</span><br><span class=\"line\">  length: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function loggingIdentity&lt;T extends ILengthwise&gt;(arg: T): T &#123;</span><br><span class=\"line\">  console.log(arg.length);</span><br><span class=\"line\">  return arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">loggingIdentity(3);  // Error, number doesn&#x27;t have a .length property</span><br></pre></td></tr></table></figure>\n\n<p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">loggingIdentity(&#123;length: 10, value: 3&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>6.Partial</strong></p>\n<p>Partial<T> 的作用就是将某个类型里的属性全部变为可选项 ?。</p>\n<p><strong>定义：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * node_modules/typescript/lib/lib.es5.d.ts</span><br><span class=\"line\"> * Make all properties in T optional</span><br><span class=\"line\"> */</span><br><span class=\"line\">type Partial&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P in keyof T]?: T[P];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中，首先通过 keyof T 拿到 T 的所有属性名，然后使用 in 进行遍历，将值赋给 P，最后通过 T[P] 取得相应的属性值。中间的 ? 号，用于将所有属性变为可选。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Todo &#123;</span><br><span class=\"line\">  title: string;</span><br><span class=\"line\">  description: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) &#123;</span><br><span class=\"line\">  return &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const todo1 = &#123;</span><br><span class=\"line\">  title: &quot;organize desk&quot;,</span><br><span class=\"line\">  description: &quot;clear clutter&quot;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const todo2 = updateTodo(todo1, &#123;</span><br><span class=\"line\">  description: &quot;throw out trash&quot;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在上面的 updateTodo 方法中，我们利用 Partial<T> 工具类型，定义 fieldsToUpdate 的类型为 Partial<Todo>，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   title?: string | undefined;</span><br><span class=\"line\">   description?: string | undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"七、充分利用泛型和类型运算避免冗余类型标记\"><a href=\"#七、充分利用泛型和类型运算避免冗余类型标记\" class=\"headerlink\" title=\"七、充分利用泛型和类型运算避免冗余类型标记\"></a>七、充分利用泛型和类型运算避免冗余类型标记</h1><p>使用泛型提取公共的 util type，简化类型编写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface ButtonProps &#123;</span><br><span class=\"line\">    type: string;</span><br><span class=\"line\">    size: &#x27;large&#x27; | &#x27;middle&#x27;| &#x27;small&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface ButtonPropsWithChildren&#123;</span><br><span class=\"line\">    type: string;</span><br><span class=\"line\">    size: &#x27;large&#x27; | &#x27;middle&#x27;| &#x27;small&#x27;,</span><br><span class=\"line\">    children: React.ReactNode</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 PropsWithChildren 简化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; PropsWithChildren &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">type ButtonPropsWithChildren = PropsWithChildren&lt;ButtonProps&gt;</span><br></pre></td></tr></table></figure>\n\n<p>使用 index type | mapped type | keyof 等进行类型传递</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface State &#123;</span><br><span class=\"line\">    userId: string;</span><br><span class=\"line\">    pageTitle: string;</span><br><span class=\"line\">    recentFiles: string[]</span><br><span class=\"line\">    pageContents: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface TopNavState &#123;</span><br><span class=\"line\">    userId: string;</span><br><span class=\"line\">    pageTitle: string;</span><br><span class=\"line\">    recentFiles: string[]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码可通过 lookup type 简化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface TopNavState = &#123;</span><br><span class=\"line\">    userId: State[&#x27;userId&#x27;];</span><br><span class=\"line\">    pageTitle: State[&#x27;pageTitle&#x27;]</span><br><span class=\"line\">    recentFiles: State[&#x27;recentFiles&#x27;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 mapped type 可进一步简化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type TopNavState = &#123;</span><br><span class=\"line\">    [k in &#x27;userId&#x27; | &#x27;pageTitle&#x27; | &#x27;recentFiles&#x27;] : State[k]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再使用工具类进一步简化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type TopNavState = Pick&lt;State, &#x27;userId&#x27;, &#x27;pageTitle&#x27;, &#x27;rencentFiles&#x27;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以利用 typeof 来进行类型传递</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getUserInfo(userId:string)&#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    userId,</span><br><span class=\"line\">    name,</span><br><span class=\"line\">    age,</span><br><span class=\"line\">    height,</span><br><span class=\"line\">    weight,</span><br><span class=\"line\">    favoriteColor</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type UserInfo = ReturnType&lt;typeof getUserInfo&gt;</span><br></pre></td></tr></table></figure>\n\n<p>编写 utility type 时，多多使用 generic constraint 保证实例化时的类型安全</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Name &#123;</span><br><span class=\"line\">    first: string;</span><br><span class=\"line\">    last: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type Pick1&lt;T, K&gt;&#123;</span><br><span class=\"line\">    [k in K]: T[k]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type FirstLast = Pick1&lt;Name, &#x27;first&#x27;| &#x27;last&#x27;&gt;</span><br><span class=\"line\">type FirstMiddle = Pick1&lt;Name, &#x27;first&#x27;, &#x27;middle&#x27;&gt; // 应该报错但没报错</span><br><span class=\"line\">type Pick2&lt;T, K extends keyof T&gt; = &#123; // 添加泛型约束</span><br><span class=\"line\">    [k in K]: T[K]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type FirstMiddle = Pick2&lt;Name, &#x27;first&#x27;, &#x27;middle&#x27;&gt; // 正确的报错了</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"八、用-TypeScript-编写-React-的最佳实践\"><a href=\"#八、用-TypeScript-编写-React-的最佳实践\" class=\"headerlink\" title=\"八、用 TypeScript 编写 React 的最佳实践\"></a>八、用 TypeScript 编写 React 的最佳实践</h1><h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>React 的核心概念之一是组件。在这里，我们将引用 React v16.8 以后的标准组件，这意味着使用 Hook 而不是类的组件。</p>\n<p>通常，一个基本的组件有很多需要关注的地方。让我们看一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数声明式写法</span><br><span class=\"line\">function Heading(): React.ReactNode &#123;</span><br><span class=\"line\">  return &lt;h1&gt;My Website Heading&lt;/h1&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数扩展式写法</span><br><span class=\"line\">const OtherHeading: React.FC = () =&gt; &lt;h1&gt;My Website Heading&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注意这里的关键区别。在第一个例子中，我们使用函数声明式写法，我们注明了这个函数返回值是 <code>React.ReactNode</code> 类型。相反，第二个例子使用了一个函数表达式。因为第二个实例返回一个函数，而不是一个值或表达式，所以我们我们注明了这个函数返回值是 <code>React.FC</code> 类型。</p>\n<p>记住这两种方式可能会让人混淆。这主要取决于设计选择。无论您选择在项目中使用哪个，都要始终如一地使用它。</p>\n<h2 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h2><p>我们将介绍的下一个核心概念是 Props。你可以使用 interface 或 type 来定义 Props 。让我们看另一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Props &#123;</span><br><span class=\"line\">  name: string;</span><br><span class=\"line\">  color: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type OtherProps = &#123;</span><br><span class=\"line\">  name: string;</span><br><span class=\"line\">  color: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Notice here we&#x27;re using the function declaration with the interface Props</span><br><span class=\"line\">function Heading(&#123; name, color &#125;: Props): React.ReactNode &#123;</span><br><span class=\"line\">  return &lt;h1&gt;My Website Heading&lt;/h1&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Notice here we&#x27;re using the function expression with the type OtherProps</span><br><span class=\"line\">const OtherHeading: React.FC&lt;OtherProps&gt; = (&#123; name, color &#125;) =&gt;</span><br><span class=\"line\">  &lt;h1&gt;My Website Heading&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n\n<p>关于 interface 或 type ，我们建议遵循 react-typescript-cheatsheet 社区提出的准则：</p>\n<ul>\n<li>在编写库或第三方环境类型定义时，始终将 interface 用于公共 API 的定义。</li>\n<li>考虑为你的 React 组件的 State 和 Props 使用 type ，因为它更受约束。”</li>\n</ul>\n<p>让我们再看一个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">type Props = &#123;</span><br><span class=\"line\">   /** color to use for the background */</span><br><span class=\"line\">  color?: string;</span><br><span class=\"line\">   /** standard children prop: accepts any valid React Node */</span><br><span class=\"line\">  children: React.ReactNode;</span><br><span class=\"line\">   /** callback function passed to the onClick handler*/</span><br><span class=\"line\">  onClick: ()  =&gt; void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const Button: React.FC&lt;Props&gt; = (&#123; children, color = &#x27;tomato&#x27;, onClick &#125;) =&gt; &#123;</span><br><span class=\"line\">   return &lt;button style=&#123;&#123; backgroundColor: color &#125;&#125; onClick=&#123;onClick&#125;&gt;&#123;children&#125;&lt;/button&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在此 <code>&lt;Button /&gt;</code> 组件中，我们为 Props 使用 type。每个 Props 上方都有简短的说明，以为其他开发人员提供更多背景信息。? 表示 Props 是可选的。<code>children props</code> 是一个 <code>React.ReactNode</code> 表示它还是一个 React 组件。</p>\n<p>通常，在 React 和 TypeScript 项目中编写 Props 时，请记住以下几点：</p>\n<ul>\n<li>始终使用 TSDoc 标记为你的 Props 添加描述性注释 <code>/** comment */</code>。</li>\n<li>无论你为组件 Props 使用 type 还是 interface ，都应始终使用它们。</li>\n<li>如果 props 是可选的，请适当处理或使用默认值。</li>\n</ul>\n<h2 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h2><p>幸运的是，当使用 Hook 时， TypeScript 类型推断工作得很好。这意味着你没有什么好担心的。举个例子:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// `value` is inferred as a string</span><br><span class=\"line\">// `setValue` is inferred as (newValue: string) =&gt; void</span><br><span class=\"line\">const [value, setValue] = useState(&#x27;&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript 推断出 useState 钩子给出的值。这是一个 React 和 TypeScript 协同工作的成果。</p>\n<p>在极少数情况下，你需要使用一个空值初始化 Hook ，可以使用泛型并传递联合以正确键入 Hook 。查看此实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type User = &#123;</span><br><span class=\"line\">  email: string;</span><br><span class=\"line\">  id: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// the generic is the &lt; &gt;</span><br><span class=\"line\">// the union is the User | null</span><br><span class=\"line\">// together, TypeScript knows, &quot;Ah, user can be User or null&quot;.</span><br><span class=\"line\">const [user, setUser] = useState&lt;User | null&gt;(null);</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个使用 useReducer 的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type AppState = &#123;&#125;;</span><br><span class=\"line\">type Action =</span><br><span class=\"line\">  | &#123; type: &quot;SET_ONE&quot;; payload: string &#125;</span><br><span class=\"line\">  | &#123; type: &quot;SET_TWO&quot;; payload: number &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export function reducer(state: AppState, action: Action): AppState &#123;</span><br><span class=\"line\">  switch (action.type) &#123;</span><br><span class=\"line\">    case &quot;SET_ONE&quot;:</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        one: action.payload // `payload` is string</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    case &quot;SET_TWO&quot;:</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        two: action.payload // `payload` is number</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      return state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，Hooks 并没有为 React 和 TypeScript 项目增加太多复杂性。</p>\n<h2 id=\"常见用例\"><a href=\"#常见用例\" class=\"headerlink\" title=\"常见用例\"></a>常见用例</h2><h3 id=\"处理表单事件\"><a href=\"#处理表单事件\" class=\"headerlink\" title=\"处理表单事件\"></a>处理表单事件</h3><p>最常见的情况之一是 onChange 在表单的输入字段上正确键入使用的。这是一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const MyInput = () =&gt; &#123;</span><br><span class=\"line\">  const [value, setValue] = React.useState(&#x27;&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">  // 事件类型是“ChangeEvent”</span><br><span class=\"line\">  // 我们将 “HTMLInputElement” 传递给 input</span><br><span class=\"line\">  function onChange(e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#123;</span><br><span class=\"line\">    setValue(e.target.value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;input value=&#123;value&#125; onChange=&#123;onChange&#125; id=&quot;input-example&quot;/&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"扩展组件的-Props\"><a href=\"#扩展组件的-Props\" class=\"headerlink\" title=\"扩展组件的 Props\"></a>扩展组件的 Props</h3><p>有时，你希望获取为一个组件声明的 Props，并对它们进行扩展，以便在另一个组件上使用它们。但是你可能想要修改一两个属性。还记得我们如何看待两种类型组件 Props、type 或 interface 的方法吗?取决于你使用的组件决定了你如何扩展组件 Props 。让我们先看看如何使用 type:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">type ButtonProps = &#123;</span><br><span class=\"line\">    /** the background color of the button */</span><br><span class=\"line\">    color: string;</span><br><span class=\"line\">    /** the text to show inside the button */</span><br><span class=\"line\">    text: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type ContainerProps = ButtonProps &amp; &#123;</span><br><span class=\"line\">    /** the height of the container (value used with &#x27;px&#x27;) */</span><br><span class=\"line\">    height: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const Container: React.FC&lt;ContainerProps&gt; = (&#123; color, height, width, text &#125;) =&gt; &#123;</span><br><span class=\"line\">  return &lt;div style=&#123;&#123; backgroundColor: color, height: `$&#123;height&#125;px` &#125;&#125;&gt;&#123;text&#125;&lt;/div&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你使用 interface 来声明 props，那么我们可以使用关键字 extends 从本质上“扩展”该接口，但要进行一些修改：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">interface ButtonProps &#123;</span><br><span class=\"line\">    /** the background color of the button */</span><br><span class=\"line\">    color: string;</span><br><span class=\"line\">    /** the text to show inside the button */</span><br><span class=\"line\">    text: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface ContainerProps extends ButtonProps &#123;</span><br><span class=\"line\">    /** the height of the container (value used with &#x27;px&#x27;) */</span><br><span class=\"line\">    height: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const Container: React.FC&lt;ContainerProps&gt; = (&#123; color, height, width, text &#125;) =&gt; &#123;</span><br><span class=\"line\">  return &lt;div style=&#123;&#123; backgroundColor: color, height: `$&#123;height&#125;px` &#125;&#125;&gt;&#123;text&#125;&lt;/div&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两种方法都可以解决问题。由您决定使用哪个。就个人而言，扩展 interface 更具可读性，但最终取决于你和你的团队。</p>\n<h1 id=\"九、编译上下文\"><a href=\"#九、编译上下文\" class=\"headerlink\" title=\"九、编译上下文\"></a>九、编译上下文</h1><h2 id=\"tsconfig-json-的作用\"><a href=\"#tsconfig-json-的作用\" class=\"headerlink\" title=\"tsconfig.json 的作用\"></a>tsconfig.json 的作用</h2><ul>\n<li>用于标识 TypeScript 项目的根路径；</li>\n<li>用于配置 TypeScript 编译器；</li>\n<li>用于指定编译的文件。</li>\n</ul>\n<h2 id=\"tsconfig-json-重要字段\"><a href=\"#tsconfig-json-重要字段\" class=\"headerlink\" title=\"tsconfig.json 重要字段\"></a>tsconfig.json 重要字段</h2><ul>\n<li>files - 设置要编译的文件的名称；</li>\n<li>include - 设置需要进行编译的文件，支持路径模式匹配；</li>\n<li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li>\n<li>compilerOptions - 设置与编译流程相关的选项。</li>\n</ul>\n<h2 id=\"compilerOptions-选项\"><a href=\"#compilerOptions-选项\" class=\"headerlink\" title=\"compilerOptions 选项\"></a>compilerOptions 选项</h2><p>compilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。</p>\n<p>compilerOptions 每个选项的详细说明如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 基本选项 */</span><br><span class=\"line\">    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br><span class=\"line\">    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br><span class=\"line\">    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件</span><br><span class=\"line\">    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件</span><br><span class=\"line\">    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误</span><br><span class=\"line\">    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br><span class=\"line\">    &quot;declaration&quot;: true,                   // 生成相应的 &#x27;.d.ts&#x27; 文件</span><br><span class=\"line\">    &quot;sourceMap&quot;: true,                     // 生成相应的 &#x27;.map&#x27; 文件</span><br><span class=\"line\">    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件</span><br><span class=\"line\">    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录</span><br><span class=\"line\">    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.</span><br><span class=\"line\">    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释</span><br><span class=\"line\">    &quot;noEmit&quot;: true,                        // 不生成输出文件</span><br><span class=\"line\">    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数</span><br><span class=\"line\">    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 严格的类型检查选项 */</span><br><span class=\"line\">    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项</span><br><span class=\"line\">    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错</span><br><span class=\"line\">    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查</span><br><span class=\"line\">    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误</span><br><span class=\"line\">    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 额外的检查 */</span><br><span class=\"line\">    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误</span><br><span class=\"line\">    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误</span><br><span class=\"line\">    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误</span><br><span class=\"line\">    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 模块解析选项 */</span><br><span class=\"line\">    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br><span class=\"line\">    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录</span><br><span class=\"line\">    &quot;paths&quot;: &#123;&#125;,                           // 模块名到基于 baseUrl 的路径映射的列表</span><br><span class=\"line\">    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br><span class=\"line\">    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表</span><br><span class=\"line\">    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表</span><br><span class=\"line\">    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Source Map Options */</span><br><span class=\"line\">    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br><span class=\"line\">    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置</span><br><span class=\"line\">    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br><span class=\"line\">    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 其他选项 */</span><br><span class=\"line\">    &quot;experimentalDecorators&quot;: true,        // 启用装饰器</span><br><span class=\"line\">    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tsconfig.json 配置文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">    &quot;target&quot;: &quot;es5&quot;, // 指定 ECMAScript 版本</span><br><span class=\"line\">    &quot;lib&quot;: [</span><br><span class=\"line\">      &quot;dom&quot;,</span><br><span class=\"line\">      &quot;dom.iterable&quot;,</span><br><span class=\"line\">      &quot;esnext&quot;</span><br><span class=\"line\">    ], // 要包含在编译中的依赖库文件列表</span><br><span class=\"line\">    &quot;allowJs&quot;: true, // 允许编译 JavaScript 文件</span><br><span class=\"line\">    &quot;skipLibCheck&quot;: true, // 跳过所有声明文件的类型检查</span><br><span class=\"line\">    &quot;esModuleInterop&quot;: true, // 禁用命名空间引用 (import * as fs from &quot;fs&quot;) 启用 CJS/AMD/UMD 风格引用 (import fs from &quot;fs&quot;)</span><br><span class=\"line\">    &quot;allowSyntheticDefaultImports&quot;: true, // 允许从没有默认导出的模块进行默认导入</span><br><span class=\"line\">    &quot;strict&quot;: true, // 启用所有严格类型检查选项</span><br><span class=\"line\">    &quot;forceConsistentCasingInFileNames&quot;: true, // 不允许对同一个文件使用不一致格式的引用</span><br><span class=\"line\">    &quot;module&quot;: &quot;esnext&quot;, // 指定模块代码生成</span><br><span class=\"line\">    &quot;moduleResolution&quot;: &quot;node&quot;, // 使用 Node.js 风格解析模块</span><br><span class=\"line\">    &quot;resolveJsonModule&quot;: true, // 允许使用 .json 扩展名导入的模块</span><br><span class=\"line\">    &quot;noEmit&quot;: true, // 不输出(意思是不编译代码，只执行类型检查)</span><br><span class=\"line\">    &quot;jsx&quot;: &quot;react&quot;, // 在.tsx文件中支持JSX</span><br><span class=\"line\">    &quot;sourceMap&quot;: true, // 生成相应的.map文件</span><br><span class=\"line\">    &quot;declaration&quot;: true, // 生成相应的.d.ts文件</span><br><span class=\"line\">    &quot;noUnusedLocals&quot;: true, // 报告未使用的本地变量的错误</span><br><span class=\"line\">    &quot;noUnusedParameters&quot;: true, // 报告未使用参数的错误</span><br><span class=\"line\">    &quot;experimentalDecorators&quot;: true, // 启用对ES装饰器的实验性支持</span><br><span class=\"line\">    &quot;incremental&quot;: true, // 通过从以前的编译中读取/写入信息到磁盘上的文件来启用增量编译</span><br><span class=\"line\">    &quot;noFallthroughCasesInSwitch&quot;: true </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;include&quot;: [</span><br><span class=\"line\">    &quot;src/**/*&quot; // *** TypeScript文件应该进行类型检查 ***</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;build&quot;] // *** 不进行类型检查的文件 ***</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十、参考资料\"><a href=\"#十、参考资料\" class=\"headerlink\" title=\"十、参考资料\"></a>十、参考资料</h2><ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/1641493?from=article.detail.1595718\">了不起的 TypeScript 入门教程</a></li>\n<li><a href=\"https://blog.staleclosure.com/effective-typescript/\">Effective Typescript</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_40906515/article/details/106798727\">用 TypeScript 编写 React 的最佳实践</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1595718\">TypeScript keyof 操作符</a></li>\n</ul>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"VUE iview 搭建项目 - 使用总结","url":"/2022/12/16/VUE-iview-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","content":"<h2 id=\"iView-放大招了-一口气发布-3-款新产品\"><a href=\"#iView-放大招了-一口气发布-3-款新产品\" class=\"headerlink\" title=\"iView 放大招了!一口气发布 3 款新产品\"></a>iView 放大招了!一口气发布 3 款新产品</h2><p>本次发布的主要内容有：</p>\n<ul>\n<li>iView Pro</li>\n<li>iView Pro Admin</li>\n<li>iView 4.0 的预告</li>\n<li>iView weapp + mpvue</li>\n</ul>\n<p><a href=\"https://v.qq.com/x/page/t0905b3h0qj.html?start=4574\">iView 2019 发布会视频观看</a></p>\n<p>使用方法：</p>\n<p>先安装或引入</p>\n<h2 id=\"CDN-引入\"><a href=\"#CDN-引入\" class=\"headerlink\" title=\"CDN 引入\"></a>CDN 引入</h2><p>通过 <a href=\"https://unpkg.com/iview/\">unpkg.com&#x2F;iview</a> 可以看到 iView 最新版本的资源，也可以切换版本选择需要的资源，在页面上引入 js 和 css 文件即可开始使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- import Vue.js --&gt;</span><br><span class=\"line\">&lt;script src=&quot;//vuejs.org/js/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;!-- import stylesheet --&gt;</span><br><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;//unpkg.com/iview/dist/styles/iview.css&quot;&gt;</span><br><span class=\"line\">&lt;!-- import iView --&gt;</span><br><span class=\"line\">&lt;script src=&quot;//unpkg.com/iview/dist/iview.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"NPM-安装\"><a href=\"#NPM-安装\" class=\"headerlink\" title=\"NPM 安装\"></a>NPM 安装</h2><p>推荐使用 npm 来安装，享受生态圈和工具带来的便利，更好地和 webpack 配合使用，推荐使用 ES2015。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install iview --save</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用-vue-CLI3\"><a href=\"#使用-vue-CLI3\" class=\"headerlink\" title=\"使用 vue CLI3\"></a>使用 vue CLI3</h2><h3 id=\"引入-iView-方法一：\"><a href=\"#引入-iView-方法一：\" class=\"headerlink\" title=\"引入 iView 方法一：\"></a>引入 iView 方法一：</h3><p>一般在 webpack 入口页面 main.js 中如下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;;</span><br><span class=\"line\">import VueRouter from &#x27;vue-router&#x27;;</span><br><span class=\"line\">import App from &#x27;components/app.vue&#x27;;</span><br><span class=\"line\">import Routers from &#x27;./router.js&#x27;;</span><br><span class=\"line\">import iView from &#x27;iview&#x27;;</span><br><span class=\"line\">import &#x27;iview/dist/styles/iview.css&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(VueRouter);</span><br><span class=\"line\">Vue.use(iView);</span><br></pre></td></tr></table></figure>\n\n<p>引入成功，在你需要的地方直接使用组件。</p>\n<h3 id=\"引入-iView-方法二：\"><a href=\"#引入-iView-方法二：\" class=\"headerlink\" title=\"引入 iView 方法二：\"></a>引入 iView 方法二：</h3><h4 id=\"按需引用\"><a href=\"#按需引用\" class=\"headerlink\" title=\"按需引用\"></a>按需引用</h4><p>借助插件<a href=\"https://github.com/ant-design/babel-plugin-import\"> babel-plugin-import</a>可以实现按需加载组件，减少文件体积。首先安装，并在文件 .babelrc 中配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-import --save-dev</span><br><span class=\"line\"></span><br><span class=\"line\">// .babelrc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;plugins&quot;: [[&quot;import&quot;, &#123;</span><br><span class=\"line\">    &quot;libraryName&quot;: &quot;iview&quot;,</span><br><span class=\"line\">    &quot;libraryDirectory&quot;: &quot;src/components&quot;</span><br><span class=\"line\">  &#125;]]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后这样按需引入组件，就可以减小体积了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; Button, Table &#125; from &#x27;iview&#x27;;</span><br><span class=\"line\">Vue.component(&#x27;Button&#x27;, Button);</span><br><span class=\"line\">Vue.component(&#x27;Table&#x27;, Table);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特别提醒\"><a href=\"#特别提醒\" class=\"headerlink\" title=\"特别提醒\"></a>特别提醒</h2><ul>\n<li>按需引用仍然需要导入样式，即在 main.js 或根组件执行 import ‘iview&#x2F;dist&#x2F;styles&#x2F;iview.css’;</li>\n</ul>\n<p>引入成功之后</p>\n<p><a href=\"https://www.iviewui.com/docs/guide/install\">https://www.iviewui.com/docs/guide/install</a></p>\n<p>打开官方文档就可以随意使用了。</p>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"Vue3最新的15个常用Api","url":"/2022/12/16/Vue3%E6%9C%80%E6%96%B0%E7%9A%8415%E4%B8%AA%E5%B8%B8%E7%94%A8Api/","content":"<p>Vue2 每次都把整个 Vue 导入，例如 Vue2 的 main.js 文件中的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App.vue&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.productionTip = false</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  render: h =&gt; h(App)</span><br><span class=\"line\">&#125;).$mount(&#x27;#app&#x27;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>但很明显我们的项目中不可能用到 Vue 所有的 API，因此很多模块其实是没有用的</p>\n<p>那么在 Vue3 中，对外暴露了很多的 API 供开发者使用，我们可以根据自己的需求，将所需要的 API 从 Vue 中导入。例如 main.js 中的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; createApp &#125; from &#x27;vue&#x27;;</span><br><span class=\"line\">import App from &#x27;./App.vue&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">createApp(App).mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>利用了 import 和 export 的导入导出语法，实现了按需打包模块的功能，项目打包后的文件体积明显小了很多</p>\n<p>这也是我们本文需要对 Vue3 API 进行详细了解的原因</p>\n<h2 id=\"（1）setup\"><a href=\"#（1）setup\" class=\"headerlink\" title=\"（1）setup\"></a>（1）setup</h2><p>setup 函数也是 Composition API 的入口函数，我们的变量、方法都是在该函数里定义的，来看一下使用方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  \t&lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  \t&lt;button @click=&quot;add&quot;&gt;增加&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 1. 从 vue 中引入 ref 函数</span><br><span class=\"line\">import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;App&#x27;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">  \t// 2. 用 ref 函数包装一个响应式变量 number</span><br><span class=\"line\">    let number = ref(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 3. 设定一个方法</span><br><span class=\"line\">    function add() &#123;</span><br><span class=\"line\">    \t// number是被ref函数包装过了的，其值保存在.value中</span><br><span class=\"line\">\t\tnumber.value ++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 4. 将 number 和 add 返回出去，供template中使用</span><br><span class=\"line\">    return &#123;number, add&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中用到了 ref 函数，下面会详细讲解，在这里你只需要理解它的作用是包装一个响应式的数据即可，并且你可以将 ref 函数包装过的变量看作是 Vue2 data 中的变量</p>\n<p>这样就简单实现了一个点击按钮数字加 1 的功能</p>\n<hr>\n<p>在 Vue2 中，我们访问 data 或 props 中的变量，都是通过类似 this.number 这样的形式去获取的，但要特别注意的是，在 setup 中，this 指向的是 undefined，也就是说不能再向 Vue2 一样通过 this 去获取变量了</p>\n<p>那么到底该如何获取到 props 中的数据呢？</p>\n<p>其实 setup 函数还有两个参数，分别是 props 、context，前者存储着定义当前组件允许外界传递过来的参数名称以及对应的值；后者是一个上下文对象，能从中访问到 attr 、emit 、slots</p>\n<p>其中 emit 就是我们熟悉的 Vue2 中与父组件通信的方法，可以直接拿来调用</p>\n<h2 id=\"（2）生命周期\"><a href=\"#（2）生命周期\" class=\"headerlink\" title=\"（2）生命周期\"></a>（2）生命周期</h2><p>Vue2 中有 beforeCreate 、created 、beforeMount 、mounted 、beforeUpdate 等生命周期函数</p>\n<p>而在 Vue3 中，这些生命周期部分有所变化，并且调用的方式也有所改变，下面放上一张变化图来简单了解一下</p>\n<table>\n<thead>\n<tr>\n<th>Vue2</th>\n<th>Vue3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>beforeCreate</td>\n<td>setup</td>\n</tr>\n<tr>\n<td>created</td>\n<td>setup</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>onBeforeMount</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>onMounted</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>onBeforeUpdate</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>onUpdated</td>\n</tr>\n<tr>\n<td>beforeDestory</td>\n<td>onBeforeUnmount</td>\n</tr>\n<tr>\n<td>destoryed</td>\n<td>onUnmounted</td>\n</tr>\n</tbody></table>\n<p>Vue3 的这些生命周期调用也很简单，同样是先从 vue 中导入，再进行直接调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 1. 从 vue 中引入 多个生命周期函数</span><br><span class=\"line\">import &#123;onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, unMounted&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;App&#x27;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">\tonBeforeMount(() =&gt; &#123;</span><br><span class=\"line\">\t\t// 在挂载前执行某些代码</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tonMounted(() =&gt; &#123;</span><br><span class=\"line\">\t\t// 在挂载后执行某些代码</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tonBeforeUpdate(() =&gt; &#123;</span><br><span class=\"line\">\t\t// 在更新前前执行某些代码</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tonUpdated(() =&gt; &#123;</span><br><span class=\"line\">\t\t// 在更新后执行某些代码</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tonBeforeUnmount(() =&gt; &#123;</span><br><span class=\"line\">\t\t// 在组件销毁前执行某些代码</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tonUnmounted(() =&gt; &#123;</span><br><span class=\"line\">\t\t// 在组件销毁后执行某些代码</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"（3）reactive\"><a href=\"#（3）reactive\" class=\"headerlink\" title=\"（3）reactive\"></a>（3）reactive</h2><p>reactive 方法是用来创建一个响应式的数据对象，该 API 也很好地解决了 Vue2 通过 defineProperty 实现数据响应式的缺陷</p>\n<p>用法很简单，只需将数据作为参数传入即可，代码如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  \t&lt;!-- 4. 访问响应式数据对象中的 count  --&gt;</span><br><span class=\"line\">  \t&#123;&#123; state.count &#125;&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 1. 从 vue 中导入 reactive</span><br><span class=\"line\">import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;App&#x27;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">  \t// 2. 创建响应式的数据对象</span><br><span class=\"line\">\tconst state = reactive(&#123;count: 3&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 3. 将响应式数据对象state return 出去，供template使用</span><br><span class=\"line\">    return &#123;state&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"（4）ref\"><a href=\"#（4）ref\" class=\"headerlink\" title=\"（4）ref\"></a>（4）ref</h2><p>在介绍 setup 函数时，我们使用了 ref 函数包装了一个响应式的数据对象，这里表面上看上去跟 reactive 好像功能一模一样啊，确实差不多，因为 ref 就是通过 reactive 包装了一个对象 ，然后是将值传给该对象中的 value 属性，这也就解释了为什么每次访问时我们都需要加上 .value</p>\n<p>我们可以简单地把 ref(obj) 理解为这个样子 reactive({value: obj})</p>\n<p>这里我们写一段代码来具体看一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;ref, reactive&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;App&#x27;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">  \tconst obj = &#123;count: 3&#125;</span><br><span class=\"line\">  \tconst state1 = ref(obj)</span><br><span class=\"line\">  \tconst state2 = reactive(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">\tconsole.log(state1)</span><br><span class=\"line\">\tconsole.log(state2)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>来看一下打印结果<br><img src=\"https://img-blog.csdnimg.cn/20201118122406844.png?x-oss-process=image\" alt=\"image\"></p>\n<blockquote>\n<p>注意： 这里指的 .value 是在 setup 函数中访问 ref 包装后的对象时才需要加的，在 template 模板中访问时是不需要的，因为在编译时，会自动识别其是否为 ref 包装过的</p>\n</blockquote>\n<p>那么我们到底该如何选择 ref 和 reactive 呢？</p>\n<p><strong>建议：</strong></p>\n<ol>\n<li>基本类型值（String 、Number 、Boolean 等）或单值对象（类似像 {count: 3} 这样只有一个属性值的对象）使用 ref</li>\n<li>引用类型值（Object 、Array）使用 reactive</li>\n</ol>\n<h2 id=\"（5）toRef\"><a href=\"#（5）toRef\" class=\"headerlink\" title=\"（5）toRef\"></a>（5）toRef</h2><p>toRef 是将某个对象中的某个值转化为响应式数据，其接收两个参数，第一个参数为 obj 对象；第二个参数为对象中的属性名</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 1. 导入 toRef</span><br><span class=\"line\">import &#123;toRef&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;count: 3&#125;</span><br><span class=\"line\">        // 2. 将 obj 对象中属性count的值转化为响应式数据</span><br><span class=\"line\">        const state = toRef(obj, &#x27;count&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 3. 将toRef包装过的数据对象返回供template使用</span><br><span class=\"line\">        return &#123;state&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但其实表面上看上去 toRef 这个 API 好像非常的没用，因为这个功能也可以用 ref 实现，代码如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 1. 导入 ref</span><br><span class=\"line\">import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;count: 3&#125;</span><br><span class=\"line\">        // 2. 将 obj 对象中属性count的值转化为响应式数据</span><br><span class=\"line\">        const state = ref(obj.count)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 3. 将ref包装过的数据对象返回供template使用</span><br><span class=\"line\">        return &#123;state&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>乍一看好像还真是，其实这两者是有区别的，我们可以通过一个案例来比较一下，代码如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123; state1 &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;add1&quot;&gt;增加&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state2 &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;add2&quot;&gt;增加&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;ref, toRef&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;count: 3&#125;</span><br><span class=\"line\">        const state1 = ref(obj.count)</span><br><span class=\"line\">        const state2 = toRef(obj, &#x27;count&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">        function add1() &#123;</span><br><span class=\"line\">            state1.value ++</span><br><span class=\"line\">            console.log(&#x27;原始值：&#x27;, obj);</span><br><span class=\"line\">            console.log(&#x27;响应式数据对象：&#x27;, state1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfunction add2() &#123;</span><br><span class=\"line\">            state2.value ++</span><br><span class=\"line\">            console.log(&#x27;原始值：&#x27;, obj);</span><br><span class=\"line\">            console.log(&#x27;响应式数据对象：&#x27;, state2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return &#123;state1, state2, add1, add2&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们分别用 ref 和 toRef 将 obj 中的 count 转化为响应式，并声明了两个方法分别使 count 值增加，每次增加后打印一下原始值 obj 和被包装过的响应式数据对象，同时还要看看视图的变化</p>\n<p><strong>ref：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201118131536584.gif#pic_center\" alt=\"image\"></p>\n<p>可以看到，在对响应式数据的值进行 +1 操作后，视图改变了，原始值未改变，响应式数据对象的值也改变了，这说明 ref 是对原数据的一个拷贝，不会影响到原始值，同时响应式数据对象值改变后会同步更新视图</p>\n<p><strong>toRef：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201118131948827.gif#pic_center\" alt=\"image\"></p>\n<p>可以看到，在对响应式数据的值进行 +1 操作后，视图未发生改变，原始值改变了，响应式数据对象的值也改变了，这说明 toRef 是对原数据的一个引用，会影响到原始值，但是响应式数据对象值改变后会不会更新视图</p>\n<p>总结：</p>\n<ul>\n<li>ref 是对传入数据的拷贝；toRef 是对传入数据的引用</li>\n<li>ref 的值改变会更新视图；toRef 的值改变不会更新视图</li>\n</ul>\n<h2 id=\"（6）toRefs\"><a href=\"#（6）toRefs\" class=\"headerlink\" title=\"（6）toRefs\"></a>（6）toRefs</h2><p>了解完 toRef 后，就很好理解 toRefs 了，其作用就是将传入的对象里所有的属性的值都转化为响应式数据对象，该函数支持一个参数，即 obj 对象</p>\n<p>我们来看一下它的基本使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 1. 导入 toRefs</span><br><span class=\"line\">import &#123;toRefs&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;</span><br><span class=\"line\">\t\t\tname: &#x27;前端印象&#x27;,</span><br><span class=\"line\">\t\t\tage: 22,</span><br><span class=\"line\">\t\t\tgender: 0</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        // 2. 将 obj 对象中属性count的值转化为响应式数据</span><br><span class=\"line\">        const state = toRefs(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 3. 打印查看一下</span><br><span class=\"line\">\t\tconsole.log(state)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印结果如下：<br><img src=\"https://img-blog.csdnimg.cn/20201118132812793.png#pic_center\" alt=\"image\"></p>\n<p>返回的是一个对象，对象里包含了每一个包装过后的响应式数据对象</p>\n<h2 id=\"（7）shallowReactive\"><a href=\"#（7）shallowReactive\" class=\"headerlink\" title=\"（7）shallowReactive\"></a>（7）shallowReactive</h2><p>听这个 API 的名称就知道，这是一个渐层的 reactive，难道意思就是原本的 reactive 是深层的呗，没错，这是一个用于性能优化的 API</p>\n<p>其实将 obj 作为参数传递给 reactive 生成响应式数据对象时，若 obj 的层级不止一层，那么会将每一层都用 Proxy 包装一次，我们来验证一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;</span><br><span class=\"line\">\t\t\ta: 1,</span><br><span class=\"line\">\t\t\tfirst: &#123;</span><br><span class=\"line\">\t\t\t\tb: 2,</span><br><span class=\"line\">\t\t\t\tsecond: &#123;</span><br><span class=\"line\">\t\t\t\t\tc: 3</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        const state = reactive(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconsole.log(state)</span><br><span class=\"line\">\t\tconsole.log(state.first)</span><br><span class=\"line\">\t\tconsole.log(state.first.second)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>来看一下打印结果：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201118134158778.png#pic_center\" alt=\"image\"></p>\n<p>设想一下如果一个对象层级比较深，那么每一层都用 Proxy 包装后，对于性能是非常不友好的</p>\n<p>接下来我们再来看看 shallowReactive</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;shallowReactive&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;</span><br><span class=\"line\">\t\t\ta: 1,</span><br><span class=\"line\">\t\t\tfirst: &#123;</span><br><span class=\"line\">\t\t\t\tb: 2,</span><br><span class=\"line\">\t\t\t\tsecond: &#123;</span><br><span class=\"line\">\t\t\t\t\tc: 3</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        const state = shallowReactive(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconsole.log(state)</span><br><span class=\"line\">\t\tconsole.log(state.first)</span><br><span class=\"line\">\t\tconsole.log(state.first.second)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>来看一下打印结果：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201118134358346.png#pic_center\" alt=\"image\"></p>\n<p>结果非常的明了了，只有第一层被 Proxy 处理了，也就是说只有修改第一层的值时，才会响应式更新，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.a &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.first.b &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.first.second.c &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;button @click=&quot;change1&quot;&gt;改变1&lt;/button&gt;</span><br><span class=\"line\">\t&lt;button @click=&quot;change2&quot;&gt;改变2&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;shallowReactive&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;</span><br><span class=\"line\">\t\t\ta: 1,</span><br><span class=\"line\">\t\t\tfirst: &#123;</span><br><span class=\"line\">\t\t\t\tb: 2,</span><br><span class=\"line\">\t\t\t\tsecond: &#123;</span><br><span class=\"line\">\t\t\t\t\tc: 3</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        const state = shallowReactive(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfunction change1() &#123;</span><br><span class=\"line\">\t\t\tstate.a = 7</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfunction change2() &#123;</span><br><span class=\"line\">\t\t\tstate.first.b = 8</span><br><span class=\"line\">\t\t\tstate.first.second.c = 9</span><br><span class=\"line\">\t\t\tconsole.log(state);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn &#123;state&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>来看一下具体过程：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2020111814184662.gif#pic_center\" alt=\"image\"></p>\n<p>首先我们点击了第二个按钮，改变了第二层的 b 和第三层的 c，虽然值发生了改变，但是视图却没有进行更新；</p>\n<p>当我们点击了第一个按钮，改变了第一层的 a 时，整个视图进行了更新；</p>\n<p>由此可说明，shallowReactive 监听了第一层属性的值，一旦发生改变，则更新视图</p>\n<h2 id=\"（8）shallowRef\"><a href=\"#（8）shallowRef\" class=\"headerlink\" title=\"（8）shallowRef\"></a>（8）shallowRef</h2><p>这是一个浅层的 ref，与 shallowReactive 一样是拿来做性能优化的</p>\n<p>shallowReactive 是监听对象第一层的数据变化用于驱动视图更新，那么 shallowRef 则是监听 .value 的值的变化来更新视图的</p>\n<p>我们来看一下具体代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.a &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.first.b &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.first.second.c &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;button @click=&quot;change1&quot;&gt;改变1&lt;/button&gt;</span><br><span class=\"line\">\t&lt;button @click=&quot;change2&quot;&gt;改变2&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;shallowRef&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;</span><br><span class=\"line\">\t\t\ta: 1,</span><br><span class=\"line\">\t\t\tfirst: &#123;</span><br><span class=\"line\">\t\t\t\tb: 2,</span><br><span class=\"line\">\t\t\t\tsecond: &#123;</span><br><span class=\"line\">\t\t\t\t\tc: 3</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconst state = shallowRef(obj)</span><br><span class=\"line\">\t\tconsole.log(state);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfunction change1() &#123;</span><br><span class=\"line\">\t\t\t// 直接将state.value重新赋值</span><br><span class=\"line\">\t\t\tstate.value = &#123;</span><br><span class=\"line\">\t\t\t\ta: 7,</span><br><span class=\"line\">\t\t\t\tfirst: &#123;</span><br><span class=\"line\">\t\t\t\t\tb: 8,</span><br><span class=\"line\">\t\t\t\t\tsecond: &#123;</span><br><span class=\"line\">\t\t\t\t\t\tc: 9</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfunction change2() &#123;</span><br><span class=\"line\">\t\t\tstate.value.first.b = 8</span><br><span class=\"line\">            state.value.first.second.c = 9</span><br><span class=\"line\">            console.log(state);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn &#123;state, change1, change2&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>首先看一下被 shallowRef 包装过后是怎样的结构</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201119112420368.png?x-oss-process=image\" alt=\"image\"></p>\n<p>然后再来看看改变其值会有什么变化</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201119112840682.gif#pic_center\" alt=\"image\"></p>\n<p>我们先点击了第二个按钮，发现数据确实被改变了，但是视图并没随之更新；</p>\n<p>于是点击了第一个按钮，即将整个 .value 重新赋值了，视图就立马更新了</p>\n<p>这么一看，未免也太过麻烦了，改个数据还要重新赋值，不要担心，此时我们可以用到另一个 API，叫做 triggerRef ，调用它就可以立马更新视图，其接收一个参数 state ，即需要更新的 ref 对象</p>\n<p>我们来使用一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.a &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.first.b &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.first.second.c &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;button @click=&quot;change&quot;&gt;改变&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;shallowRef, triggerRef&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;</span><br><span class=\"line\">\t\t\ta: 1,</span><br><span class=\"line\">\t\t\tfirst: &#123;</span><br><span class=\"line\">\t\t\t\tb: 2,</span><br><span class=\"line\">\t\t\t\tsecond: &#123;</span><br><span class=\"line\">\t\t\t\t\tc: 3</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconst state = shallowRef(obj)</span><br><span class=\"line\">\t\tconsole.log(state);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfunction change() &#123;</span><br><span class=\"line\">\t\t\tstate.value.first.b = 8</span><br><span class=\"line\">            state.value.first.second.c = 9</span><br><span class=\"line\">            // 修改值后立即驱动视图更新</span><br><span class=\"line\">            triggerRef(state)</span><br><span class=\"line\">            console.log(state);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn &#123;state, change&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看一下具体过程<br><img src=\"https://img-blog.csdnimg.cn/20201119113821279.gif#pic_center\" alt=\"image\"></p>\n<p>可以看到，我们没有给 .value 重新赋值，只是在修改值后，调用了 triggerRef 就实现了视图的更新</p>\n<h2 id=\"（9）toRaw\"><a href=\"#（9）toRaw\" class=\"headerlink\" title=\"（9）toRaw\"></a>（9）toRaw</h2><p>toRaw 方法是用于获取 ref 或 reactive 对象的原始数据的</p>\n<p>先来看一段代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.name &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.age &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;button @click=&quot;change&quot;&gt;改变&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;</span><br><span class=\"line\">\t\t\tname: &#x27;前端印象&#x27;,</span><br><span class=\"line\">\t\t\tage: 22</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconst state = reactive(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfunction change() &#123;</span><br><span class=\"line\">\t\t\tstate.age = 90</span><br><span class=\"line\">\t\t\tconsole.log(obj); // 打印原始数据obj</span><br><span class=\"line\">\t\t\tconsole.log(state);  // 打印 reactive对象</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn &#123;state, change&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>来看看具体过程</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201119120334341.gif#pic_center\" alt=\"image\"></p>\n<p>我们改变了 reactive 对象中的数据，于是看到原始数据 obj 和被 reactive 包装过的对象的值都发生了变化，由此我们可以看出，这两者是一个引用关系</p>\n<p>那么此时我们就想了，那如果直接改变原始数据 obj 的值，会怎么样呢？答案是： reactive 的值也会跟着改变，但是视图不会更新</p>\n<p>由此可见，当我们想修改数据，但不想让视图更新时，可以选择直接修改原始数据上的值，因此需要先获取到原始数据，我们可以使用 Vue3 提供的 toRaw 方法</p>\n<p>toRaw 接收一个参数，即 ref 对象或 reactive 对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;reactive, toRaw&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;</span><br><span class=\"line\">\t\t\tname: &#x27;前端印象&#x27;,</span><br><span class=\"line\">\t\t\tage: 22</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconst state = reactive(obj)</span><br><span class=\"line\">\t\tconst raw = toRaw(state)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconsole.log(obj === raw)   // true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码就证明了 toRaw 方法从 reactive 对象中获取到的是原始数据，因此我们就可以很方便的通过修改原始数据的值而不更新视图来做一些性能优化了</p>\n<blockquote>\n<p>注意： 补充一句，当 toRaw 方法接收的参数是 ref 对象时，需要加上 .value 才能获取到原始数据对象</p>\n</blockquote>\n<h2 id=\"（10）markRaw\"><a href=\"#（10）markRaw\" class=\"headerlink\" title=\"（10）markRaw\"></a>（10）markRaw</h2><p>markRaw 方法可以将原始数据标记为非响应式的，即使用 ref 或 reactive 将其包装，仍无法实现数据响应式，其接收一个参数，即原始数据，并返回被标记后的数据</p>\n<p>我们来看一下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.name &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; state.age &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;button @click=&quot;change&quot;&gt;改变&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;reactive, markRaw&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj = &#123;</span><br><span class=\"line\">\t\t\tname: &#x27;前端印象&#x27;,</span><br><span class=\"line\">\t\t\tage: 22</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 通过markRaw标记原始数据obj, 使其数据更新不再被追踪</span><br><span class=\"line\">\t\tconst raw = markRaw(obj)</span><br><span class=\"line\">\t\t// 试图用reactive包装raw, 使其变成响应式数据</span><br><span class=\"line\">\t\tconst state = reactive(raw)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfunction change() &#123;</span><br><span class=\"line\">\t\t\tstate.age = 90</span><br><span class=\"line\">\t\t\tconsole.log(state);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn &#123;state, change&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看一下在被 markRaw 方法处理过后的数据是否还能被 reactive 包装成响应式数据</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201119130344291.gif#pic_center\" alt=\"image\"></p>\n<p>从图中可以看到，即使我们修改了值也不会更新视图了，即没有实现数据响应式</p>\n<h2 id=\"（11）provide-amp-amp-inject\"><a href=\"#（11）provide-amp-amp-inject\" class=\"headerlink\" title=\"（11）provide &amp;&amp; inject\"></a>（11）provide &amp;&amp; inject</h2><p>与 Vue2 中的 provide 和 inject 作用相同，只不过在 Vue3 中需要手动从 vue 中导入</p>\n<p>这里简单说明一下这两个方法的作用：</p>\n<ul>\n<li>provide ：向子组件以及子孙组件传递数据。接收两个参数，第一个参数是 key，即数据的名称；第二个参数为 value，即数据的值</li>\n<li>inject ：接收父组件或祖先组件传递过来的数据。接收一个参数 key，即父组件或祖先组件传递的数据名称</li>\n</ul>\n<p>假设这有三个组件，分别是 A.vue 、B.vue 、C.vue，其中 B.vue 是 A.vue 的子组件，C.vue 是 B.vue 的子组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// A.vue</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;provide&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">        const obj= &#123;</span><br><span class=\"line\">\t\t\tname: &#x27;前端印象&#x27;,</span><br><span class=\"line\">\t\t\tage: 22</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 向子组件以及子孙组件传递名为info的数据</span><br><span class=\"line\">\t\tprovide(&#x27;info&#x27;, obj)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// B.vue</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;inject&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">\t\t// 接收A.vue传递过来的数据</span><br><span class=\"line\">\t\tinject(&#x27;info&#x27;)  // &#123;name: &#x27;前端印象&#x27;, age: 22&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// C.vue</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;inject&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">\t\t// 接收A.vue传递过来的数据</span><br><span class=\"line\">\t\tinject(&#x27;info&#x27;)  // &#123;name: &#x27;前端印象&#x27;, age: 22&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（12）watch-amp-amp-watchEffect\"><a href=\"#（12）watch-amp-amp-watchEffect\" class=\"headerlink\" title=\"（12）watch &amp;&amp; watchEffect\"></a>（12）watch &amp;&amp; watchEffect</h3><p>watch 和 watchEffect 都是用来监视某项数据变化从而执行指定的操作的，但用法上还是有所区别</p>\n<p>watch：watch( source, cb, [options] )</p>\n<p>参数说明：</p>\n<ul>\n<li>source：可以是表达式或函数，用于指定监听的依赖对象</li>\n<li>cb：依赖对象变化后执行的回调函数</li>\n<li>options：可选参数，可以配置的属性有 immediate（立即触发回调函数）、deep（深度监听）<br>当监听 ref 类型时：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;ref, watch&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">\t\tconst state = ref(0)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\twatch(state, (newValue, oldValue) =&gt; &#123;</span><br><span class=\"line\">\t\t\tconsole.log(`原值为$&#123;oldValue&#125;`)</span><br><span class=\"line\">\t\t\tconsole.log(`新值为$&#123;newValue&#125;`)</span><br><span class=\"line\">\t\t\t/* 1秒后打印结果：</span><br><span class=\"line\">\t\t\t\t\t\t\t原值为0</span><br><span class=\"line\">\t\t\t\t\t\t\t新值为1</span><br><span class=\"line\">\t\t\t*/</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 1秒后将state值+1</span><br><span class=\"line\">\t\tsetTimeout(() =&gt; &#123;</span><br><span class=\"line\">\t\t\tstate.value ++</span><br><span class=\"line\">\t\t&#125;, 1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当监听 reactive 类型时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;reactive, watch&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">\t\tconst state = reactive(&#123;count: 0&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\twatch(() =&gt; state.count, (newValue, oldValue) =&gt; &#123;</span><br><span class=\"line\">\t\t\tconsole.log(`原值为$&#123;oldValue&#125;`)</span><br><span class=\"line\">\t\t\tconsole.log(`新值为$&#123;newValue&#125;`)</span><br><span class=\"line\">\t\t\t/* 1秒后打印结果：</span><br><span class=\"line\">\t\t\t\t\t\t\t原值为0</span><br><span class=\"line\">\t\t\t\t\t\t\t新值为1</span><br><span class=\"line\">\t\t\t*/</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 1秒后将state.count的值+1</span><br><span class=\"line\">\t\tsetTimeout(() =&gt; &#123;</span><br><span class=\"line\">\t\t\tstate.count ++</span><br><span class=\"line\">\t\t&#125;, 1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当同时监听多个值时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;reactive, watch&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">\t\tconst state = reactive(&#123; count: 0, name: &#x27;zs&#x27; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t   watch(</span><br><span class=\"line\">\t      [() =&gt; state.count, () =&gt; state.name],</span><br><span class=\"line\">\t      ([newCount, newName], [oldvCount, oldvName]) =&gt; &#123;</span><br><span class=\"line\">\t        console.log(oldvCount) // 旧的 count 值</span><br><span class=\"line\">\t        console.log(newCount) // 新的 count 值</span><br><span class=\"line\">\t        console.log(oldName) // 旧的 name 值</span><br><span class=\"line\">\t        console.log(newvName) // 新的 name 值</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t    )</span><br><span class=\"line\"></span><br><span class=\"line\">\t    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">\t      state.count ++</span><br><span class=\"line\">\t      state.name = &#x27;ls&#x27;</span><br><span class=\"line\">\t    &#125;, 1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>因为 watch 方法的第一个参数我们已经指定了监听的对象，因此当组件初始化时，不会执行第二个参数中的回调函数，若我们想让其初始化时就先执行一遍，可以在第三个参数对象中设置 immediate: true</p>\n<p>watch 方法默认是浅层的监听我们指定的数据，例如如果监听的数据有多层嵌套，深层的数据变化不会触发监听的回调，若我们想要其对深层数据也进行监听，可以在第三个参数对象中设置 deep: true</p>\n<blockquote>\n<p>补充： watch 方法会返回一个 stop 方法，若想要停止监听，便可直接执行该 stop 函数</p>\n</blockquote>\n<p>接下来再来聊聊 watchEffect，它与 watch 的区别主要有以下几点：</p>\n<ol>\n<li>不需要手动传入依赖</li>\n<li>每次初始化时会执行一次回调函数来自动获取依赖</li>\n<li>无法获取到原值，只能得到变化后的值<br>来看一下该方法如何使用：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;reactive, watchEffect&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">\t\tconst state = reactive(&#123; count: 0, name: &#x27;zs&#x27; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t   \twatchEffect(() =&gt; &#123;</span><br><span class=\"line\">\t\t\tconsole.log(state.count)</span><br><span class=\"line\">\t\t\tconsole.log(state.name)</span><br><span class=\"line\">\t\t\t/*  初始化时打印：</span><br><span class=\"line\">\t\t\t\t\t\t\t0</span><br><span class=\"line\">\t\t\t\t\t\t\tzs</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t1秒后打印：</span><br><span class=\"line\">\t\t\t\t\t\t\t1</span><br><span class=\"line\">\t\t\t\t\t\t\tls</span><br><span class=\"line\">\t\t\t*/</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">\t      state.count ++</span><br><span class=\"line\">\t      state.name = &#x27;ls&#x27;</span><br><span class=\"line\">\t    &#125;, 1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>从上述代码中可以看出，我们并没有像 watch 方法一样先给其传入一个依赖，而是直接指定了一个回调函数</p>\n<p>当组件初始化时，将该回调函数执行一次，自动获取到需要检测的数据是 state.count 和 state.name</p>\n<p>根据以上特征，我们可以自行选择使用哪一个监听器</p>\n<h2 id=\"（13）getCurrentInstance\"><a href=\"#（13）getCurrentInstance\" class=\"headerlink\" title=\"（13）getCurrentInstance\"></a>（13）getCurrentInstance</h2><p>我们都知道在 Vue2 的任何一个组件中想要获取当前组件的实例可以通过 this 来得到，而在 Vue3 中我们大量的代码都在 setup 函数中运行，并且在该函数中 this 指向的是 undefined，那么该如何获取到当前组件的实例呢？</p>\n<p>这时可以用到另一个方法，即 getCurrentInstance</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123;ref, getCurrentInstance&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">    \tconst num = ref(3)</span><br><span class=\"line\">\t\tconst instance = getCurrentInstance()</span><br><span class=\"line\">\t\tconsole.log(instance)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn &#123;num&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看一下其打印结果</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201119141859447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfUFBQ,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>因为 instance 包含的内容太多，所以没截完整，但是主要的内容都在图上了，我们重点来看一下 ctx 和 proxy，因为这两个才是我们想要的 this 的内容</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201119142920681.png?x-oss-process=image\" alt=\"image\"></p>\n<p>可以看到 ctx 和 proxy 的内容十分类似，只是后者相对于前者外部包装了一层 proxy，由此可说明 proxy 是响应式的</p>\n<h2 id=\"（14）useStore\"><a href=\"#（14）useStore\" class=\"headerlink\" title=\"（14）useStore\"></a>（14）useStore</h2><p>在 Vue2 中使用 Vuex，我们都是通过 this.$store 来获取到 Vuex 实例，但上一部分说了原本 Vue2 中的 this 的获取方式不一样了，并且我们在 Vue3 的 getCurrentInstance().ctx 中也没有发现 $store 这个属性，那么如何获取到 Vuex 实例呢？这就要通过 vuex 中的一个方法了，即 useStore</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// store 文件夹下的 index.js</span><br><span class=\"line\">import Vuex from &#x27;vuex&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = Vuex.createStore(&#123;</span><br><span class=\"line\">\tstate: &#123;</span><br><span class=\"line\">\t\tname: &#x27;前端印象&#x27;,</span><br><span class=\"line\">\t\tage: 22</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tmutations: &#123;</span><br><span class=\"line\">\t\t……</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t……</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// example.vue</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 从 vuex 中导入 useStore 方法</span><br><span class=\"line\">import &#123;useStore&#125; from &#x27;vuex&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">    \t// 获取 vuex 实例</span><br><span class=\"line\">    \tconst store = useStore()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconsole.log(store)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看一下打印结果</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201119145014243.png?x-oss-process=image#pic_center\" alt=\"image\"></p>\n<p>然后接下来就可以像之前一样正常使用 vuex 了</p>\n<h2 id=\"（15）获取标签元素\"><a href=\"#（15）获取标签元素\" class=\"headerlink\" title=\"（15）获取标签元素\"></a>（15）获取标签元素</h2><p>最后再补充一个 ref 另外的作用，那就是可以获取到标签元素或组件</p>\n<p>在 Vue2 中，我们获取元素都是通过给元素一个 ref 属性，然后通过 this.$refs.xx 来访问的，但这在 Vue3 中已经不再适用了</p>\n<p>接下来看看 Vue3 中是如何获取元素的吧</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;div ref=&quot;el&quot;&gt;div元素&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    // 创建一个DOM引用，名称必须与元素的ref属性名相同</span><br><span class=\"line\">    const el = ref(null)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 在挂载后才能通过 el 获取到目标元素</span><br><span class=\"line\">    onMounted(() =&gt; &#123;</span><br><span class=\"line\">      el.value.innerHTML = &#x27;内容被修改&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把创建的引用 return 出去</span><br><span class=\"line\">    return &#123;el&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>获取元素的操作一共分为以下几个步骤：</p>\n<ul>\n<li>先给目标元素的 ref 属性设置一个值，假设为 el</li>\n<li>然后在 setup 函数中调用 ref 函数，值为 null，并赋值给变量 el，这里要注意，该变量名必须与我们给元素设置的 ref 属性名相同</li>\n<li>把对元素的引用变量 el 返回（return）出去</li>\n</ul>\n<blockquote>\n<p>补充：设置的元素引用变量只有在组件挂载后才能访问到，因此在挂载前对元素进行操作都是无效的</p>\n</blockquote>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"Vue学习知识点总结","url":"/2022/12/16/Vue%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","content":"<p>Vue 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<h2 id=\"一、Vue-基础使用\"><a href=\"#一、Vue-基础使用\" class=\"headerlink\" title=\"一、Vue 基础使用\"></a>一、Vue 基础使用</h2><h3 id=\"vue-的使用\"><a href=\"#vue-的使用\" class=\"headerlink\" title=\"vue 的使用\"></a>vue 的使用</h3><blockquote>\n<p>下载 Vue：npm i vue</p>\n</blockquote>\n<ol>\n<li>首先下载 vue，引入 vue.js</li>\n<li>js 中创建一个 Vue 对象实例</li>\n<li>通过 el 指定 vue 管理页面的边界</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 引入vue.js文件 --&gt;</span><br><span class=\"line\">&lt;script src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input v-model=&quot;message&quot; type=&quot;text&quot;&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 下载Vue：npm i vue --&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">        *   el是element的简写，用来指定vue管理页面的边界，</span><br><span class=\"line\">        *   也就是说只有包裹在 #app内部的元素，才会收到Vue的管理！！！</span><br><span class=\"line\">        */</span><br><span class=\"line\">        el: &#x27;#app&#x27;,</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">        *   页面中用的到数据都放到data对象中</span><br><span class=\"line\">        */</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            message: &#x27;邓紫棋喜欢你&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 写Vue可能会遇到的错误：</span><br><span class=\"line\">        // 1 注意：Vue 是以大写字母开头的，它是一个构造函数！！！</span><br><span class=\"line\">        // 2 注意：在 Vue 中，HTML属性值无法使用 `&#123;&#123;&#125;&#125;`！！！</span><br><span class=\"line\">        // 3 开发期间一定要使用未压缩版的Vue（开发版）</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">    *   vm是Vue的对象实例，可以通过vm.$data.属性名获取data中的属性值，可以省略$data</span><br><span class=\"line\">    */</span><br><span class=\"line\">    console.log(vm.message)</span><br><span class=\"line\">    console.log(vm.$data.message)</span><br><span class=\"line\">    console.log(vm.message === vm.$data.message)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Mustache-表达式使用\"><a href=\"#Mustache-表达式使用\" class=\"headerlink\" title=\"Mustache 表达式使用\"></a>Mustache 表达式使用</h3><blockquote>\n<p>双花括号<code>&#123;&#123;&#125;&#125;</code> 就是 mustache 语法，用于展示 data 中的内容,mustache 中可以出现任意的 JS 表达式；</p>\n</blockquote>\n<ul>\n<li>表达式<code>&#123;&#123;&#125;&#125;</code>只能从数据对象 data 中获取数据；</li>\n<li>mustache 中不能出现语句，比如：if () {} &#x2F; for(var i &#x3D;0 …) {} &#x2F; var num &#x3D; 1;</li>\n<li>Mustache 语法不能作用在 HTML 元素的属性上；</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;&#123; 1 + 2 &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;&#123; [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;] &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;&#123; [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;].join(&#x27;-&#x27;) &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;&#123; msg + &#x27; -- 拼接内容&#x27; &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;&#123; age &gt; 18 ? &#x27;成年了&#x27; : &#x27;未成年&#x27; &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;&#123; Math.random() &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el:&#x27;#app&#x27;,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            msg:&#x27;邓紫棋金鱼嘴&#x27;,</span><br><span class=\"line\">            age:19</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指令-v-使用\"><a href=\"#指令-v-使用\" class=\"headerlink\" title=\"指令 v-使用\"></a>指令 v-使用</h3><blockquote>\n<p>指令 (Directives) 是带有 v- 前缀的特殊属性，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p>\n</blockquote>\n<h4 id=\"1-v-text\"><a href=\"#1-v-text\" class=\"headerlink\" title=\"1.v-text\"></a>1.v-text</h4><blockquote>\n<p>用来设置当前元素的文本内容，相当于 DOM 对象的 innerText 或 textContent</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div v-text=&#x27;msg&#x27;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-v-html\"><a href=\"#2-v-html\" class=\"headerlink\" title=\"2.v-html\"></a>2.v-html</h4><blockquote>\n<p>更新 DOM 对象的 innerHTML</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div v-html=&#x27;htmlMsg&#x27;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-v-bind\"><a href=\"#3-v-bind\" class=\"headerlink\" title=\"3.v-bind\"></a>3.v-bind</h4><blockquote>\n<p>通过 v-bind 为 HTML 元素绑定属性，使用 data 中提供的数据;<br>因为 v-bind:title 这种使用方式很繁琐，所以，vue 提供了一个简化语法 :title</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img v-bind:title=&#x27;msg&#x27; v-bind:src=&#x27;imgPath&#x27; v-bind:name=&#x27;name&#x27;&gt;</span><br><span class=\"line\">&lt;img :title=&#x27;msg&#x27; :src=&#x27;imgPath&#x27; :name=&#x27;name&#x27;&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-v-on\"><a href=\"#4-v-on\" class=\"headerlink\" title=\"4.v-on\"></a>4.v-on</h4><blockquote>\n<p>绑定事件,<strong>支持 js 所有的事件类型</strong>， v-on 绑定的事件方法都要写在 Vue 实例中的 methods 对象中;<br>v-on:省略写 @</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button v-on:click=&#x27;getData&#x27;&gt;点我&lt;/button&gt;&lt;input v-on:onfocus=&#x27;getFocus&#x27;&gt;</span><br><span class=\"line\">&lt;button @click=&#x27;getData&#x27;&gt;点我&lt;/button&gt;&lt;input @onfocus=&#x27;getFocus&#x27;&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-v-model\"><a href=\"#5-v-model\" class=\"headerlink\" title=\"5.v-model\"></a>5.v-model</h4><blockquote>\n<p>在表单元素上创建双向数据绑定;<br>只能用在表单元素中，注意：不同的表单元素，v-model 的表现可能会有所不同。<br>比如：v-model 操作文本框的 value 属性，而复选框 v-model 就是操作其选中状态;</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 绑定的是文本框输入的内容 --&gt;</span><br><span class=\"line\">&lt;input type=&quot;text&quot; v-model=&#x27;msg&#x27;&gt;</span><br><span class=\"line\">&lt;!-- 绑定的是复选框是否选中 --&gt;</span><br><span class=\"line\">&lt;input type=&quot;checkbox&quot; v-model=&#x27;isCheck&#x27;&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-v-for\"><a href=\"#6-v-for\" class=\"headerlink\" title=\"6.v-for\"></a>6.v-for</h4><blockquote>\n<p>基于源数据多次渲染元素或模板块,不仅可以渲染集合 List 也可以遍历对象 Obj；</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- v-for 遍历list集合--&gt;</span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &lt;!--1.item是每一项对象</span><br><span class=\"line\">        使用 v-for 的时候提供 key 属性，以获得性能提升。</span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">    &lt;li v-for=&#x27;item in list&#x27; :key=&#x27;item.key&#x27;&gt;</span><br><span class=\"line\">        姓名：&#123;&#123;item.name&#125;&#125; -- 年龄：&#123;&#123;item.age&#125;&#125;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--2.item 为当前项，index 为索引 --&gt;</span><br><span class=\"line\">    &lt;li v-for=&#x27;(item,index) in list&#x27;&gt;</span><br><span class=\"line\">        姓名：&#123;&#123;item.name&#125;&#125; -- 年龄：&#123;&#123;item.age&#125;&#125; -- 下标：&#123;&#123;index&#125;&#125;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- v-for Obj对象 value,key,index顺序不能变 --&gt;</span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &lt;li v-for=&#x27;(value,key,index) in csObj&#x27;&gt;</span><br><span class=\"line\">        key=&#123;&#123;key&#125;&#125; -- value=&#123;&#123;value&#125;&#125; -- index=&#123;&#123;index&#125;&#125;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-v-bind-class-和-v-bind-style\"><a href=\"#7-v-bind-class-和-v-bind-style\" class=\"headerlink\" title=\"7.v-bind:class 和 v-bind:style\"></a>7.v-bind:class 和 v-bind:style</h4><blockquote>\n<p>表达式的类型：字符串、数组、对象（重点）</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 可以是对象，key是类名 value是布尔值，如果是true就添加这个类，否则就不添加--&gt;</span><br><span class=\"line\">&lt;h2 :class=&#x27;&#123;pink:true,green:true&#125;&#x27;&gt;中国惊奇先生&lt;/h2&gt;</span><br><span class=\"line\">&lt;!-- 可以是数组，--&gt;</span><br><span class=\"line\">&lt;h2 :class=&#x27;[&#x27;pink&#x27;,&#x27;fz&#x27;,&#x27;green&#x27;]&#x27;&gt;斗罗大陆&lt;/h2&gt;</span><br><span class=\"line\">&lt;h2 :style=&quot;&#123; color: activeColor, &#x27;font-size&#x27;: fontSize + &#x27;px&#x27; &#125;&quot;&gt;不良人&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"8-v-if\"><a href=\"#8-v-if\" class=\"headerlink\" title=\"8.v-if\"></a>8.v-if</h4><blockquote>\n<p>根据表达式布尔值的真假条件是否加载这段代码， true:DOM 中会加载这段代码，false:DOM 中不会加载这段代码；</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;h3 v-if=&#x27;isIF&#x27;&gt;我是v-if,是否会加载我&lt;/h3&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"9-v-show\"><a href=\"#9-v-show\" class=\"headerlink\" title=\"9.v-show\"></a>9.v-show</h4><blockquote>\n<p>根据表达式之真假值，切换元素的 display CSS 属性，无论 true 还是 false DOM 中都会加载这段代码；</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;h3 v-show=&#x27;isShow&#x27;&gt;我是v-show，是否会显示出来</span><br><span class=\"line\">&lt;/h3&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"10-v-pre\"><a href=\"#10-v-pre\" class=\"headerlink\" title=\"10.v-pre\"></a>10.v-pre</h4><blockquote>\n<p>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--测试：页面中的msg不会显示data中的内容，因为跳过了表达式编译--&gt;</span><br><span class=\"line\"> &lt;div v-pre&gt;v-pre跳过编译过程 &#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-v-once\"><a href=\"#11-v-once\" class=\"headerlink\" title=\"11.v-once\"></a>11.v-once</h4><blockquote>\n<p>只渲染元素和组件一次。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--测试：在控制台通过vm对象修改msg,页面显示中的msg内容不会有变化--&gt;</span><br><span class=\"line\">    &lt;div v-once&gt;v-once跳过编译过程 &#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-v-cloak\"><a href=\"#12-v-cloak\" class=\"headerlink\" title=\"12.v-cloak\"></a>12.v-cloak</h4><blockquote>\n<p>页面中使用 <code>&#123;&#123;&#125;&#125;</code> 的时候，经历了由 <code>&#123;&#123;&#125;&#125;</code> -&gt; 具体内容，这么一个过程，所以页面会造成“闪烁”<br>解决：通过添加 v-cloak 指令，配合 [v-cloak] { display: none; } 避免了页面闪烁</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div v-cloak&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态添加数据到-data、异步更新-DOM\"><a href=\"#动态添加数据到-data、异步更新-DOM\" class=\"headerlink\" title=\"动态添加数据到 data、异步更新 DOM\"></a>动态添加数据到 data、异步更新 DOM</h3><h4 id=\"1-动态添加数据到-data\"><a href=\"#1-动态添加数据到-data\" class=\"headerlink\" title=\"1.动态添加数据到 data\"></a>1.动态添加数据到 data</h4><blockquote>\n<p>只有 data 中的数据才是响应式的，动态添加进来的数据默认为非响应式<br>可以通过以下方式实现动态添加数据的响应式:</p>\n</blockquote>\n<ul>\n<li>1 Vue.set(object, key, value) - 适用于添加单个属性</li>\n<li>2 Object.assign() - 适用于添加多个属性</li>\n</ul>\n<h4 id=\"2-异步更新-DOM\"><a href=\"#2-异步更新-DOM\" class=\"headerlink\" title=\"2.异步更新 DOM\"></a>2.异步更新 DOM</h4><blockquote>\n<p>当绑定的数据发生变动时，Vue 异步执行 DOM 更新，监视所有数据改变，一次性更新 DOM；<br>解决方法：</p>\n</blockquote>\n<ul>\n<li>Vue.nextTick</li>\n<li>this.$nextTick</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 点击按钮之前data中还没有age属性 --&gt;</span><br><span class=\"line\">    &lt;button @click=&#x27;addAge&#x27;&gt;给data添加age&lt;/button&gt;</span><br><span class=\"line\">    &lt;div&gt;名字：&#123;&#123;stu.name&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">    &lt;!--</span><br><span class=\"line\">        这里使用的表达式中的属性必须是响应式的</span><br><span class=\"line\">        只有data中的数据才是响应式的，动态添加进来的数据默认为非响应式</span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">    &lt;div&gt;年龄：&#123;&#123;stu.age&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">    &lt;div&gt;性别：&#123;&#123;stu.sex&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: &#x27;#app&#x27;,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            msg: &#x27;hello vue&#x27;,</span><br><span class=\"line\">            stu: &#123;</span><br><span class=\"line\">                name: &#x27;jack&#x27;,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            addAge: function () &#123;</span><br><span class=\"line\">                //可以通过以下方式实现动态添加数据的响应式</span><br><span class=\"line\">                //1.添加单个属性</span><br><span class=\"line\">                // 第一个参数：表示要给哪个对象添加响应式属性 $data可以省略</span><br><span class=\"line\">                // 第二个参数：表示要添加的属性名称</span><br><span class=\"line\">                // 第三个参数：表示属性的值</span><br><span class=\"line\">                Vue.set(this.stu, &quot;age&quot;, 18)</span><br><span class=\"line\">                //2.添加多个属性</span><br><span class=\"line\">                //第一个参数：是一个空对象</span><br><span class=\"line\">                //第二个参数：添加到哪个对象</span><br><span class=\"line\">                //第三个参数：添加属性的对象</span><br><span class=\"line\">                this.stu = Object.assign(&#123;&#125;,this.stu,&#123;&quot;name&quot;:&quot;邓紫棋&quot;,&quot;age&quot;:18,&quot;sex&quot;:&quot;man&quot;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">                //此时打印的内容为 名字：jack</span><br><span class=\"line\">                //</span><br><span class=\"line\">                //为什么呢？ Vue 异步执行 DOM 更新，监视所有数据改变，一次性更新DOM</span><br><span class=\"line\">                console.log(this.$el.children[1].innerText)</span><br><span class=\"line\"></span><br><span class=\"line\">                //解决方法 Vue.nextTick 和 this.$nextTick 是相同的</span><br><span class=\"line\">                //在DOM更新后，回调执行某个操作（DOM操作）</span><br><span class=\"line\">                this.$nextTick(function()&#123;</span><br><span class=\"line\">                    console.log(this.$el.children[1].innerText)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"filter-过滤器\"><a href=\"#filter-过滤器\" class=\"headerlink\" title=\"filter 过滤器\"></a>filter 过滤器</h3><ul>\n<li>作用：文本数据格式化 , 也就是: 将数据按照我们指定的一种格式输出</li>\n<li>过滤器可以用在两个地方：<code>&#123;&#123;&#125;&#125;</code>表达式 和 v-bind 指令中</li>\n<li>两种过滤器：1 全局过滤器 2 局部过滤器</li>\n</ul>\n<h4 id=\"1-全局过滤器\"><a href=\"#1-全局过滤器\" class=\"headerlink\" title=\"1.全局过滤器\"></a>1.全局过滤器</h4><ul>\n<li>说明：通过全局方式创建的过滤器，在任何一个 vue 实例中都可以使用</li>\n<li>注意：使用全局过滤器的时候，需要先创建全局过滤器，再创建 Vue 实例</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&#123;&#123; dateStr | date &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&#123;&#123; dateStr | date(&#x27;YYYY-MM-DD hh:mm:ss&#x27;) &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  Vue.filter(&#x27;date&#x27;, function(value, format) &#123;</span><br><span class=\"line\">    // value 要过滤的字符串内容，比如：dateStr</span><br><span class=\"line\">    // format 过滤器的参数，比如：&#x27;YYYY-MM-DD hh:mm:ss&#x27;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-局部过滤器\"><a href=\"#2-局部过滤器\" class=\"headerlink\" title=\"2.局部过滤器\"></a>2.局部过滤器</h4><ul>\n<li>说明：局部过滤器是在某一个 vue 实例的内容创建的，只在当前实例中起作用</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&#123;&#123;msg | fi(&quot;九&quot;)&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">          el:&#x27;#app&#x27;,</span><br><span class=\"line\">          data:&#123;</span><br><span class=\"line\">              msg:&#x27;八百个标兵奔北坡，八百个标兵奔北坡&#x27;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          //2. 局部过滤器 只有在当前Vue实例中才起作用</span><br><span class=\"line\">          // 通过 filters 配置项, 来创建过滤器</span><br><span class=\"line\">          filters:&#123;</span><br><span class=\"line\">              // content是内容，format是过滤的规则可以多个参数</span><br><span class=\"line\">              fi:function(content,format)&#123;</span><br><span class=\"line\">                  return content.replace(/八/g,format);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"watch-监听配置项\"><a href=\"#watch-监听配置项\" class=\"headerlink\" title=\"watch 监听配置项\"></a>watch 监听配置项</h3><ul>\n<li>概述：watch 是一个对象，键是需要观察的表达式，值是对应回调函数</li>\n<li>作用：当表达式的值发生变化后，会调用对应的回调函数完成响应的监视操作</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&#x27;userName&#x27;&gt;</span><br><span class=\"line\">    &lt;p v-show=&#x27;isError&#x27;&gt;请输入4-8位字符&lt;/p&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&#x27;stu.age&#x27;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: &#x27;#app&#x27;,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            userName: &#x27;&#x27;,</span><br><span class=\"line\">            isError: false,</span><br><span class=\"line\">            stu: &#123;</span><br><span class=\"line\">                age: 10,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 通过 watch 配置项，来监视数据变化</span><br><span class=\"line\">        // 只能监视 data 中的数据，要监视的数据，作为watch的属性</span><br><span class=\"line\">        watch: &#123;</span><br><span class=\"line\">            // 监视userName值的变化，方法名要用要监视的值的名字</span><br><span class=\"line\">            userName:function(curVal, oldVal)&#123;</span><br><span class=\"line\">                console.log(&#x27;当前值为：&#x27;, curVal, &#x27;上一次值为：&#x27;, oldVal);</span><br><span class=\"line\">                if(curVal.length&gt;=4 &amp;&amp; curVal.length&lt;=8)&#123;</span><br><span class=\"line\">                    this.isError = false;</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    this.isError = true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            // 监听对象，加上deep:true</span><br><span class=\"line\">            // 注意：如果监视对象的变化，那么，curVal 和 oldVal 是相同的，指向同一个对象</span><br><span class=\"line\">            stu:&#123;</span><br><span class=\"line\">                handler:function(curVal, oldVal)&#123;</span><br><span class=\"line\">                    console.log(&#x27;当前值为：&#x27;, curVal, &#x27;上一次值为：&#x27;, oldVal);</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                deep: true</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            // 一般都是监听对象中的属性</span><br><span class=\"line\">            // 只需要监视某个属性的变化，而不是整个对象中所有的属性的变化</span><br><span class=\"line\">            &#x27;stu.age&#x27;:function(curVal, oldVal)&#123;</span><br><span class=\"line\">                console.log(&#x27;当前值为：&#x27;, curVal, &#x27;上一次值为：&#x27;, oldVal);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"computed-计算属性配置项\"><a href=\"#computed-计算属性配置项\" class=\"headerlink\" title=\"computed 计算属性配置项\"></a>computed 计算属性配置项</h3><ul>\n<li>说明：计算属性是基于它们的依赖进行缓存的，只有在它的依赖发生改变时才会重新求值</li>\n<li>注意：Mustache 语法（<code>&#123;&#123;&#125;&#125;</code>）中不要放入太多的逻辑，否则会让模板过重、难以理解和维护</li>\n<li>注意：computed 中的属性不能与 data 中的属性同名，否则会报错</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&#x27;num1&#x27;&gt;+</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&#x27;num2&#x27;&gt;=</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&#x27;result&#x27;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: &#x27;#app&#x27;,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            num1: 0,</span><br><span class=\"line\">            num2: 0,</span><br><span class=\"line\">            // result: 0 计算属性名不能和data中的属性相同</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 计算属性，通过 computed 配置项来指定</span><br><span class=\"line\">        // 注意：计算属性不能与data中的属性相同！！！否则会报错</span><br><span class=\"line\">        // 特点：计算属性依赖的属性（比如：num1 和 num2）发生改变，那么计算属性就会被重新计算</span><br><span class=\"line\">        // 优势：内部使用缓存机制，如果页面中多个地方都用到了计算属性，那么计算属性只会被重新计算一次！！！</span><br><span class=\"line\">        computed: &#123;</span><br><span class=\"line\">            result:function()&#123;</span><br><span class=\"line\">                return (this.num1-0)+(this.num2-0);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h3><ul>\n<li>.stop 阻止向上冒泡 不会调用父的事件</li>\n<li>.prevent 阻止默认行为，调用 event.preventDefault()</li>\n<li>.capture 捕获冒泡</li>\n<li>.self 只当事件在该元素本身触发时，才会触发事件</li>\n<li>.once 事件只触发一次</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- .stop 阻止向上冒泡 不会调用父的事件 --&gt;</span><br><span class=\"line\">&lt;div @click=&#x27;cathFather&#x27;&gt;我是父事件修饰符</span><br><span class=\"line\">    &lt;!-- .stop  阻止冒泡，调用 event.stopPropagation() --&gt;</span><br><span class=\"line\">    &lt;div @click.stop=&#x27;catchSon&#x27;&gt;我是子事件修饰符&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- .prevent 阻止默认行为，调用 event.preventDefault() --&gt;</span><br><span class=\"line\">&lt;a href=&quot;http://www.baidu&quot; @click.prevent=&#x27;onPrevent&#x27;&gt;我是prevent事件&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- .capture捕获冒泡，</span><br><span class=\"line\">    即有冒泡发生时，有该修饰符的dom元素会先执行，如果有多个，从外到内依次执行，然后再按自然顺序执行触发的事件。</span><br><span class=\"line\">--&gt;</span><br><span class=\"line\">&lt;!-- 如果不给爷爷添加capture 点击儿子触发的顺序是 儿子、爸爸、爷爷 --&gt;</span><br><span class=\"line\">&lt;!-- 给爷爷添加了capture事件后 点击儿子触发的顺序是 爷爷、儿子、爸爸 --&gt;</span><br><span class=\"line\">&lt;div @click.capture=&#x27;grandpa&#x27;&gt;我是爷爷</span><br><span class=\"line\">    &lt;div @click=&#x27;father&#x27;&gt;我是爸爸</span><br><span class=\"line\">        &lt;div @click=&#x27;son&#x27;&gt;</span><br><span class=\"line\">                我是儿子</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- .self 只当事件在该元素本身触发时，才会触发事件 --&gt;</span><br><span class=\"line\">&lt;div @click.self=&#x27;onSelfFather&#x27;&gt;self事件爸爸</span><br><span class=\"line\">    &lt;div @click=&#x27;onSelfSon&#x27;&gt;self事件儿子&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- .once  事件只触发一次 --&gt;</span><br><span class=\"line\">&lt;div @click.once=&#x27;onOnce&#x27;&gt;再点我一次试试&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"键值修饰符\"><a href=\"#键值修饰符\" class=\"headerlink\" title=\"键值修饰符\"></a>键值修饰符</h4><ul>\n<li>说明：在监听键盘事件时，Vue 允许为 v-on 在监听键盘事件时添加关键修饰符</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 键值修饰符 包括键盘、鼠标 --&gt;</span><br><span class=\"line\">    &lt;!-- 13是Enter键的code值 --&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&#x27;msg&#x27; @keyup.13=&#x27;submit&#x27;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&#x27;msg2&#x27; @keyup.enter=&#x27;submit2&#x27;&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;!-- 使用自定义键值修饰符 --&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&#x27;msg&#x27; @keyup.f2=&#x27;submit&#x27;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 自定义键值修饰符 有时候写code值是数字的时候并没有语义，所有我们给它定义一下</span><br><span class=\"line\">    Vue.config.keyCodes.f2 = 113;</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el:&#x27;#app&#x27;,</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            msg:&#x27;&#x27;,</span><br><span class=\"line\">            msg2:&#x27;&#x27;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods:&#123;</span><br><span class=\"line\">            submit:function()&#123;</span><br><span class=\"line\">                console.log(&#x27;提交数据=&#x27;+this.msg)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            submit2:function()&#123;</span><br><span class=\"line\">                console.log(&#x27;提交数据=&#x27;+this.msg2)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"vue-声明周期钩子函数\"><a href=\"#vue-声明周期钩子函数\" class=\"headerlink\" title=\"vue 声明周期钩子函数\"></a>vue 声明周期钩子函数</h3><h4 id=\"1-beforeCreate\"><a href=\"#1-beforeCreate\" class=\"headerlink\" title=\"1. beforeCreate()\"></a>1. beforeCreate()</h4><ul>\n<li>说明：在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用</li>\n<li>注意：此时，无法获取 data 中的数据、methods 中的方法</li>\n<li>使用场景：可以在这个钩子函数中开启页面加载的 loading 效果</li>\n</ul>\n<h4 id=\"2-created\"><a href=\"#2-created\" class=\"headerlink\" title=\"2. created()\"></a>2. created()</h4><ul>\n<li>注意：这是一个常用的生命周期，可以调用 methods 中的方法、改变 data 中的数据</li>\n<li>使用场景：发送请求获取数据</li>\n</ul>\n<h4 id=\"3-beforeMounted\"><a href=\"#3-beforeMounted\" class=\"headerlink\" title=\"3. beforeMounted()\"></a>3. beforeMounted()</h4><ul>\n<li>说明：组件将要挂载到页面中，也就是说：组件的内容还没有被挂载到页面中</li>\n<li>注意：此时，获取不到页面中 DOM 元素</li>\n</ul>\n<h4 id=\"4-mounted\"><a href=\"#4-mounted\" class=\"headerlink\" title=\"4. mounted()\"></a>4. mounted()</h4><ul>\n<li>说明：组件已经被挂载到页面中，此时，可以进行 DOM 操作了</li>\n</ul>\n<h4 id=\"5-beforeUpdate\"><a href=\"#5-beforeUpdate\" class=\"headerlink\" title=\"5. beforeUpdate()\"></a>5. beforeUpdate()</h4><ul>\n<li>说明：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>\n</ul>\n<h4 id=\"6-updated\"><a href=\"#6-updated\" class=\"headerlink\" title=\"6. updated()\"></a>6. updated()</h4><ul>\n<li>说明：组件 DOM 已经更新完成，所以你现在可以执行依赖于 DOM 的操作。</li>\n</ul>\n<h4 id=\"7-beforeDestroy\"><a href=\"#7-beforeDestroy\" class=\"headerlink\" title=\"7. beforeDestroy()\"></a>7. beforeDestroy()</h4><ul>\n<li>说明：实例销毁之前调用。在这一步，实例仍然完全可用。</li>\n<li>使用：实例销毁之前，执行清理任务，比如：清除定时器等</li>\n</ul>\n<h4 id=\"8-destroyed\"><a href=\"#8-destroyed\" class=\"headerlink\" title=\"8. destroyed()\"></a>8. destroyed()</h4><ul>\n<li>说明：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>\n</ul>\n<h3 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h3><blockquote>\n<p>Vue 这种 MVVM 模式的框架不推荐开发人员直接手动操作 DOM 有些情况, 还是需要操作 DOM 的, 如果需要操作 DOM, 就通过 Vue 中的自定义指令来操作!!!</p>\n</blockquote>\n<p>通过 Vue.directive()方法自定义指令：</p>\n<ul>\n<li>第一个参数: 表示自定义指令的名称；</li>\n<li>第二个参数 1.表示自定义指令运行的时候, 需要执行的逻辑操作；</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.directive(&#x27;ff1&#x27;, function (el) &#123;</span><br><span class=\"line\">    console.log(el)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二个参数 2.还可以是一个对象，对象中是指令的钩子函数;</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> Vue.directive(&#x27;ff2&#x27;, &#123;</span><br><span class=\"line\">    // bind 和 inserted 这两个钩子函数， 都是进入页面就立即执行的</span><br><span class=\"line\">    // 区别：inserted 能获取到指令所在元素的父元素，bind 获取不到父元素</span><br><span class=\"line\">    bind(el) &#123;</span><br><span class=\"line\">        console.log(&#x27;bind&#x27;, el.parentNode)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    inserted(el) &#123;</span><br><span class=\"line\">        console.log(&#x27;inserted&#x27;, el.parentNode)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)&#125;</span><br></pre></td></tr></table></figure>\n\n<p>指令函数的入参:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 标识放到自定义指令的后面 .表示名 --&gt;</span><br><span class=\"line\">&lt;!-- 注意：如果 v-color=&quot;red&quot; 那么，red指的值：data中的red属性 --&gt;</span><br><span class=\"line\">&lt;div v-color.back=&quot; &#x27;blue&#x27; &quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;div v-color.col=&quot; &#x27;red&#x27; &quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">Vue.directive(&#x27;color&#x27;, function (el, binding) &#123;</span><br><span class=\"line\">    if (binding.modifiers.col) &#123;</span><br><span class=\"line\">        el.style.color = binding.value</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        el.style.backgroundColor = binding.value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"小案例\"><a href=\"#小案例\" class=\"headerlink\" title=\"小案例\"></a>小案例</h4><blockquote>\n<p>案例请到<a href=\"https://github.com/pengjunshan/WebPJS\">https://github.com/pengjunshan/WebPJS</a>中查看<br><img src=\"https://upload-images.jianshu.io/upload_images/3735156-799df1d167356992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp\" alt=\"image\"></p>\n</blockquote>\n<h2 id=\"二、Vue-组件\"><a href=\"#二、Vue-组件\" class=\"headerlink\" title=\"二、Vue 组件\"></a>二、Vue 组件</h2><blockquote>\n<p>组件是可复用的 Vue 实例,组件分为全局组件和局部组件。因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等,el 是根实例特有的属性，组件中没有。</p>\n</blockquote>\n<h3 id=\"全局组件\"><a href=\"#全局组件\" class=\"headerlink\" title=\"全局组件\"></a>全局组件</h3><blockquote>\n<p>全局组件在所有的 vue 实例中都可以使用,注意：先注册组件，再初始化根实例。</p>\n</blockquote>\n<h4 id=\"Vue-component-‘name’，-配置项\"><a href=\"#Vue-component-‘name’，-配置项\" class=\"headerlink\" title=\"Vue.component(‘name’，{配置项})\"></a>Vue.component(‘name’，{配置项})</h4><ul>\n<li>第一个参数是组件名</li>\n<li>第二个参数是组件的配置项，与 Vue 根实例配置项差不多</li>\n<li>组件中的 data 必须是个函数数据用 return 返回，Vue 根实例中的 data 是个对象</li>\n<li>组件中 template 模板有两种方式，“字符串” “html 模板”</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;hello&gt;&lt;/hello&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;template id=&quot;temp&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;我是组件：&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">            &lt;button @click=&#x27;fn&#x27;&gt; 点击消灭新冠 &lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">        * 第一个参数是组件名</span><br><span class=\"line\">        * 第二个参数是配置项，与Vue实例的配置几乎一样</span><br><span class=\"line\">        */</span><br><span class=\"line\">        Vue.component(&#x27;hello&#x27;, &#123;</span><br><span class=\"line\">            //template是组件的模板 也就是要展示的内容</span><br><span class=\"line\">            //组件中template模板有两种方式，“字符串” “html模板”</span><br><span class=\"line\">            //方式一：字符串</span><br><span class=\"line\">            // template: `</span><br><span class=\"line\">            //     &lt;div&gt;</span><br><span class=\"line\">            //         &lt;p&gt;我是组件：&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">            //         &lt;button @click=&#x27;fn&#x27;&gt; 点击消灭新冠 &lt;/button&gt;</span><br><span class=\"line\">            //     &lt;/div&gt;</span><br><span class=\"line\">            // `,</span><br><span class=\"line\">            //方式二：html模板</span><br><span class=\"line\">            template: &#x27;#temp&#x27;,</span><br><span class=\"line\"></span><br><span class=\"line\">            //组件中的data必须是个函数数据用return返回，Vue根实例中的data是个对象</span><br><span class=\"line\">            data() &#123;</span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    msg: &#x27;武汉加油 中国加油&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                fn() &#123;</span><br><span class=\"line\">                    this.msg = &#x27;新冠被消灭了，中国威武&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            data: &#123;&#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"局部组件\"><a href=\"#局部组件\" class=\"headerlink\" title=\"局部组件\"></a>局部组件</h3><blockquote>\n<p>局部组件，是在某一个具体的 vue 实例中定义的，只能在这个 vue 实例中使用；在 Vue 实例中使用 components 对象创建组件，可以创建多个组件；</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;!-- hello组件 --&gt;</span><br><span class=\"line\">        &lt;hello&gt;&lt;/hello&gt;</span><br><span class=\"line\">        &lt;!-- love组件 --&gt;</span><br><span class=\"line\">        &lt;love&gt;&lt;/love&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;template id=&quot;temp&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;我是组件222：&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">            &lt;button @click=&#x27;fn&#x27;&gt; 点击消灭新冠 &lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        //1.局部组件，是在某一个具体的vue实例中定义的，只能在这个vue实例中使用</span><br><span class=\"line\">        //2.在Vue实例中使用components对象创建组件，可以创建多个组件</span><br><span class=\"line\">        //3.组件中template模板有两种方式，“字符串” “html模板”</span><br><span class=\"line\"></span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            components: &#123;</span><br><span class=\"line\">                //hello 组件名</span><br><span class=\"line\">                &#x27;hello&#x27;: &#123;</span><br><span class=\"line\">                    //方式一 字符串</span><br><span class=\"line\">                    template: `</span><br><span class=\"line\">                        &lt;div&gt;</span><br><span class=\"line\">                            &lt;p&gt;我是组件111：&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">                            &lt;button @click=&#x27;fn&#x27;&gt; 点击消灭新冠 &lt;/button&gt;</span><br><span class=\"line\">                        &lt;/div&gt;</span><br><span class=\"line\">                    `,</span><br><span class=\"line\">                    data() &#123;</span><br><span class=\"line\">                        return &#123;</span><br><span class=\"line\">                            msg: &#x27;武汉加油 中国加油&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    methods: &#123;</span><br><span class=\"line\">                        fn() &#123;</span><br><span class=\"line\">                            this.msg = &#x27;新冠被消灭了，中国威武&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#x27;love&#x27;: &#123;</span><br><span class=\"line\">                    //方式二 引用html中的代码模板</span><br><span class=\"line\">                    template: &#x27;#temp&#x27;,</span><br><span class=\"line\">                    data() &#123;</span><br><span class=\"line\">                        return &#123;</span><br><span class=\"line\">                            msg: &#x27;我们爱中国 爱武汉&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    methods: &#123;</span><br><span class=\"line\">                        fn() &#123;</span><br><span class=\"line\">                            this.msg = &#x27;我们爱中华民族&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"父组件传递子组件数据\"><a href=\"#父组件传递子组件数据\" class=\"headerlink\" title=\"父组件传递子组件数据\"></a>父组件传递子组件数据</h3><ul>\n<li>方式：通过 props 属性来传递数据</li>\n<li>注意：属性的值必须在组件中通过 props 属性显示指定，否则，不会生效</li>\n<li>说明：传递过来的 props 属性的用法与 data 属性的用法相同</li>\n<li>如果传递的数据是 data 中的属性时，必须使用 v-bind 绑定属性才可以传递过去</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;hello mm=&#x27;中华民族万岁&#x27;&gt;&lt;/hello&gt;</span><br><span class=\"line\">        &lt;!-- 如果传递的数据是data中的属性时，必须使用v-bind绑定属性才可以传递过去 --&gt;</span><br><span class=\"line\">        &lt;!-- &lt;hello zz=&#x27;msg&#x27;&gt;&lt;/hello&gt; --&gt;</span><br><span class=\"line\">        &lt;hello v-bind:zz=&#x27;msg&#x27;&gt;&lt;/hello&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 父组件 传递数据给 子组件：（父组件：Vue的实例对象，子组件：hello组件）</span><br><span class=\"line\">        // 原理：通过 props 属性来传递</span><br><span class=\"line\">        // 注意：使用父组件传递的属性方式和使用data中的属性方式一样</span><br><span class=\"line\">        Vue.component(&#x27;hello&#x27;, &#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;p&gt;我是组件：&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">                    &lt;p v-if=&#x27;mm&#x27;&gt;我接收到父组件的内容：&#123;&#123;mm&#125;&#125;&lt;/P&gt;</span><br><span class=\"line\">                    &lt;p v-if=&#x27;zz&#x27;&gt;我接收到父组件的内容：&#123;&#123;zz&#125;&#125;&lt;/P&gt;</span><br><span class=\"line\">                    &lt;button @click=&#x27;fn&#x27;&gt; 点击消灭新冠 &lt;/button&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            `,</span><br><span class=\"line\">            //指定props中的值，来接收父组件传递过来的值</span><br><span class=\"line\">            props:[&#x27;mm&#x27;,&#x27;zz&#x27;],</span><br><span class=\"line\">            data() &#123;</span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    msg: &#x27;武汉加油 中国加油&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                fn() &#123;</span><br><span class=\"line\">                    this.msg=this.msg+&#x27;-----&#x27;+(this.mm===undefined? this.zz:this.mm);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                msg:&#x27;浙江杭州&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"子组件传递父组件数据\"><a href=\"#子组件传递父组件数据\" class=\"headerlink\" title=\"子组件传递父组件数据\"></a>子组件传递父组件数据</h3><ul>\n<li>方式：父组件给子组件传递一个函数，由子组件调用这个函数</li>\n<li>说明：借助 vue 中的自定义事件（v-on:cunstomFn&#x3D;”fn”）</li>\n<li>$emit()：触发事件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">        &lt;hello @pfn=&#x27;parentFn&#x27;&gt;&lt;/hello&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;template id=&quot;temp&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;我是组件：&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">            &lt;button @click=&#x27;sonFn&#x27;&gt; 点击消灭新冠 &lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        //组件传递 子》父</span><br><span class=\"line\">        //1.由父组件定义一个方法，通过@pfn传给子组件</span><br><span class=\"line\">        //2.子组件通过$emit方法把数据传递给父组件定义的方法</span><br><span class=\"line\"></span><br><span class=\"line\">        Vue.component(&#x27;hello&#x27;, &#123;</span><br><span class=\"line\">            template: &#x27;#temp&#x27;,</span><br><span class=\"line\">            data() &#123;</span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    msg: &#x27;武汉加油 中国加油&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                sonFn() &#123;</span><br><span class=\"line\">                    //通过$emit方法传递数据给父组件的方法，参数可以为多个</span><br><span class=\"line\">                    this.$emit(&#x27;pfn&#x27;, &#x27;新冠被消灭了，中国威武&#x27;, &#x27;测试&#x27;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                msg: &#x27;标题&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                parentFn(data, data2) &#123;</span><br><span class=\"line\">                    this.msg = data;</span><br><span class=\"line\">                    console.log(data2)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"非父子组件传递数据\"><a href=\"#非父子组件传递数据\" class=\"headerlink\" title=\"非父子组件传递数据\"></a>非父子组件传递数据</h3><ul>\n<li>可以使用一个空的 Vue 实例作为事件总线 bus</li>\n<li>A 组件传递 B 组件数据 1.B 先通过 bus.$on绑定事件，2.A通过bus.$emit 方法调用 B 绑定的事件方法</li>\n<li>$on和$emit 都是 bus 调用的</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;aaa&gt;&lt;/aaa&gt;</span><br><span class=\"line\">        &lt;bbb&gt;&lt;/bbb&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        //可以使用一个空的 Vue 实例作为事件总线</span><br><span class=\"line\">        var bus = new Vue()</span><br><span class=\"line\">        //A组件传递B组件数据 1.B先通过bus.$on绑定事件，2.A通过bus.$emit方法调用B绑定的事件方法</span><br><span class=\"line\">        //$on和$emit都是bus调用的</span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            data: &#123;&#125;,</span><br><span class=\"line\">            components: &#123;</span><br><span class=\"line\">                aaa: &#123;</span><br><span class=\"line\">                    template: `</span><br><span class=\"line\">                        &lt;div&gt;</span><br><span class=\"line\">                            &lt;h3&gt;我是组件AA&lt;/h3&gt;</span><br><span class=\"line\">                            &lt;button @click=&#x27;fn&#x27;&gt; 点我传给B数据 &lt;/button&gt;</span><br><span class=\"line\">                        &lt;/div&gt;</span><br><span class=\"line\">                    `,</span><br><span class=\"line\">                    data() &#123;</span><br><span class=\"line\">                        return &#123;</span><br><span class=\"line\">                            msg: &#x27;A组件&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    methods: &#123;</span><br><span class=\"line\">                        fn() &#123;</span><br><span class=\"line\">                            bus.$emit(&#x27;bfn&#x27;, &#x27;组件A说：你好组件B&#x27;)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                bbb: &#123;</span><br><span class=\"line\">                    template: `</span><br><span class=\"line\">                        &lt;div&gt;</span><br><span class=\"line\">                            &lt;h3&gt;我是组件BB&lt;/h3&gt;</span><br><span class=\"line\">                            &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">                        &lt;/div&gt;</span><br><span class=\"line\">                    `,</span><br><span class=\"line\">                    data() &#123;</span><br><span class=\"line\">                        return &#123;</span><br><span class=\"line\">                            msg: &#x27;我在等待数据...&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    created() &#123;</span><br><span class=\"line\">                        //绑定事件 接收数据，当进入页面时走到这个钩子函数后就自动绑定事件了</span><br><span class=\"line\">                        bus.$on(&#x27;bfn&#x27;, data =&gt; &#123;</span><br><span class=\"line\">                            this.msg = data</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件中插槽使用\"><a href=\"#组件中插槽使用\" class=\"headerlink\" title=\"组件中插槽使用\"></a>组件中插槽使用</h3><blockquote>\n<p>有时在使用组件的时候希望往组件中加入其它内容，在组件中通过插槽<slot></slot>来接收内容。插槽内可以包含任何模板代码，包括 HTML，甚至其它的组件；</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;hello&gt;</span><br><span class=\"line\">      &lt;p&gt;赶走新冠&lt;/p&gt;</span><br><span class=\"line\">    &lt;/hello&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;template id=&quot;temp&quot;&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    //当组件渲染的时候，&lt;slot&gt;&lt;/slot&gt; 将会被替换为&quot;赶走新冠&quot;。插槽内可以包含任何模板代码</span><br><span class=\"line\">    //可以有多个插槽</span><br><span class=\"line\">    Vue.component(&#x27;hello&#x27;,&#123;</span><br><span class=\"line\">      template:&#x27;#temp&#x27;,</span><br><span class=\"line\">      data()&#123;</span><br><span class=\"line\">        return&#123;</span><br><span class=\"line\">          msg:&#x27;武汉加油 中国加油&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">      el: &#x27;#app&#x27;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        msg:&#x27;赶走新冠&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"vue-中-ref-使用\"><a href=\"#vue-中-ref-使用\" class=\"headerlink\" title=\"vue 中 ref 使用\"></a>vue 中 ref 使用</h3><blockquote>\n<p>使用 ref 注册后 可以使用 this.$refs 获取当前 DOM 对象，必须在 mounted()钩子函数之后才可以获取 DOM 对象；元素和组件都可以使用 ref 注册；</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 使用ref注册后  可以使用this.$refs.pp获取当前DOM对象 --&gt;</span><br><span class=\"line\">        &lt;p ref=&#x27;pp&#x27;&gt;哈喽，大家好&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- 组件也可以 --&gt;</span><br><span class=\"line\">        &lt;hello ref=&quot;ho&quot;&gt;&lt;/hello&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            components: &#123;</span><br><span class=\"line\">                hello: &#123;</span><br><span class=\"line\">                    template: `&lt;h1&gt;大家好&lt;/h1&gt;`,</span><br><span class=\"line\">                    data() &#123;</span><br><span class=\"line\">                        return &#123;</span><br><span class=\"line\">                            msg: &#x27;hello message&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    methods: &#123;</span><br><span class=\"line\">                        fn() &#123;</span><br><span class=\"line\">                            console.log(&quot;触发了事件11111&quot;)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            mounted() &#123;</span><br><span class=\"line\">                console.log(this.$refs.pp)</span><br><span class=\"line\">                this.$refs.pp.style.color = &#x27;red&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">                console.log(this.$refs.ho.msg)</span><br><span class=\"line\">                this.$refs.ho.fn()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、vue-router-路由\"><a href=\"#三、vue-router-路由\" class=\"headerlink\" title=\"三、vue-router 路由\"></a>三、vue-router 路由</h2><h3 id=\"路由基本使用\"><a href=\"#路由基本使用\" class=\"headerlink\" title=\"路由基本使用\"></a>路由基本使用</h3><ul>\n<li>1.在当前文件夹下执行 npm init、npm init -y 初始化 package.json</li>\n<li>2.然后执行 npm i -s vue、npm i -s vue-router 安装 vue 和 vue-router</li>\n<li>3.在 node_modules 下找到 vue 和 vue-router 中的 js 并引入到项目中</li>\n<li>4.创建组件</li>\n<li>5.创建路由对象，并配置路由</li>\n<li>6.在 Vue 实例中关联 router</li>\n<li>7.路由入口</li>\n<li>8.路由出口</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 6.路由入口 --&gt;</span><br><span class=\"line\">        &lt;router-link to=&#x27;/home&#x27;&gt;首页&lt;/router-link&gt;</span><br><span class=\"line\">        &lt;router-link to=&#x27;/me&#x27;&gt;我的&lt;/router-link&gt;</span><br><span class=\"line\">        &lt;!-- 7.路由出口 --&gt;</span><br><span class=\"line\">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./node_modules/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        //首先先安装vue和vue-router</span><br><span class=\"line\">        //1.在当前文件夹下执行npm init、npm init -y初始化package.json</span><br><span class=\"line\">        //2.然后执行npm i -s vue、npm i -s vue-router安装vue和vue-router</span><br><span class=\"line\">        //3.在node_modules下找到vue和vue-router中的js并引入到项目中</span><br><span class=\"line\">        //4.先创建两个组件</span><br><span class=\"line\">        const Home = Vue.component(&#x27;home&#x27;, &#123;</span><br><span class=\"line\">            template: `&lt;h1&gt;我是Home组件&lt;/h1&gt;`</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        const Me = Vue.component(&#x27;me&#x27;, &#123;</span><br><span class=\"line\">            template: `&lt;h1&gt;我是Me组件&lt;/h1&gt;`</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        //5.创建路由对象</span><br><span class=\"line\">        const router = new VueRouter(&#123;</span><br><span class=\"line\">            routes: [</span><br><span class=\"line\">                &#123; path: &#x27;/home&#x27;, component: Home &#125;,</span><br><span class=\"line\">                &#123; path: &#x27;/me&#x27;, component: Me &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            data: &#123;&#125;,</span><br><span class=\"line\">            //将vue和router</span><br><span class=\"line\">            router: router</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重定向、高亮\"><a href=\"#重定向、高亮\" class=\"headerlink\" title=\"重定向、高亮\"></a>重定向、高亮</h3><blockquote>\n<p>当第一次打开页面时，想要默认打开一个路由，就可以使用路由中的重定向；按钮的高亮样式不是我们喜欢的，可以使用 linkActiveClass 来自定义高亮元素的类名，然后再设置 css 样式就可以了；</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> //5.创建路由对象</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        //如果当前路径是&#x27;/&#x27;就redirect重定向 默认home组件</span><br><span class=\"line\">        &#123; path: &#x27;/&#x27;, redirect: &#x27;/home&#x27; &#125;,</span><br><span class=\"line\">        &#123; path: &#x27;/home&#x27;, component: Home &#125;,</span><br><span class=\"line\">        &#123; path: &#x27;/me&#x27;, component: Me &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    // 修改默认高亮的a标签的类名</span><br><span class=\"line\">    // 如果是配合第三方组件库来实现菜单高亮，此时，只需要将类名设置为 第三方组件的类名即可</span><br><span class=\"line\">    linkActiveClass: &#x27;now&#x27;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> &lt;style&gt;</span><br><span class=\"line\">    /* .router-link-exact-active, */</span><br><span class=\"line\">    /* .router-link-active &#123; */</span><br><span class=\"line\">    .now &#123;</span><br><span class=\"line\">        color: hotpink;</span><br><span class=\"line\">        font-size: 30px;</span><br><span class=\"line\">        text-decoration: none;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"路由传参方式\"><a href=\"#路由传参方式\" class=\"headerlink\" title=\"路由传参方式\"></a>路由传参方式</h3><blockquote>\n<p>有时候多个路由都打开同一个组件，可以通过给组件传不同的参数展示不同的内容就可以了；通过路由打开不同组件传参也是一样的；<br><strong>导航分为两种</strong></p>\n</blockquote>\n<ul>\n<li>1.声明式导航(router-link)</li>\n<li>2.编程式导航($router.push)</li>\n</ul>\n<h3 id=\"声明式导航-router-link\"><a href=\"#声明式导航-router-link\" class=\"headerlink\" title=\"声明式导航(router-link)\"></a>声明式导航(router-link)</h3><ul>\n<li>to 字符串：只能传递字符串</li>\n<li>:to 对象：可以传递对象,可以通过 name、path 方式</li>\n</ul>\n<h3 id=\"编程式导航-router-push\"><a href=\"#编程式导航-router-push\" class=\"headerlink\" title=\"编程式导航($router.push)\"></a>编程式导航($router.push)</h3><ul>\n<li><strong>this.router.push(name,params)</strong>;通过 name 跳转的状态栏里看不到参数类似 post;组件通过 route.params 获取参数;</li>\n<li><strong>this.router.push(path,query)</strong>;通过 path 跳转的状态栏里可以看到参数类似 get;组件通过 route.query 获取参数;</li>\n</ul>\n<h3 id=\"监听路由变化\"><a href=\"#监听路由变化\" class=\"headerlink\" title=\"监听路由变化\"></a>监听路由变化</h3><blockquote>\n<p>在组件中通过 watch 对象中监听路由的变化$route(to, from) {}，在这里可进行监听数据变化 进行网络请求等等；</p>\n</blockquote>\n<h4 id=\"详细使用方式请看下面代码\"><a href=\"#详细使用方式请看下面代码\" class=\"headerlink\" title=\"详细使用方式请看下面代码\"></a>详细使用方式请看下面代码</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 通过to字符串 --&gt;</span><br><span class=\"line\">        &lt;router-link to=&quot;/home/1001&quot;&gt;1001号赛车&lt;/router-link&gt;</span><br><span class=\"line\">        &lt;router-link to=&quot;/home/1002&quot;&gt;1002号赛车&lt;/router-link&gt;</span><br><span class=\"line\">        &lt;!-- 通过$router.push&#123;&#125; --&gt;</span><br><span class=\"line\">        &lt;a @click=&#x27;fn&#x27;&gt;1003号赛车&lt;/a&gt;</span><br><span class=\"line\">        &lt;a @click=&#x27;fn1&#x27;&gt;1004号赛车&lt;/a&gt;</span><br><span class=\"line\">        &lt;!-- 通过:to对象 --&gt;</span><br><span class=\"line\">        &lt;router-link :to=&quot;&#123; name:&#x27;Home&#x27;,params:&#123;id:1005,title:&#x27;pjs&#x27;&#125;&#125;&quot;&gt;1005&lt;/router-link&gt;</span><br><span class=\"line\">        &lt;router-link :to=&quot;&#123; path:&#x27;/home&#x27;,query:&#123;id:1006,title:&#x27;pjs&#x27;&#125;&#125;&quot;&gt;1006&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        //导航分为两种：1.声明式导航(router-link)  2.编程式导航($router.push)</span><br><span class=\"line\">        //1.通过to字符串</span><br><span class=\"line\">        //2.$router.push&#123;&#125;</span><br><span class=\"line\">        //3.通过:to对象</span><br><span class=\"line\"></span><br><span class=\"line\">        //通过name跳转的状态栏里看不到参数类似post，通过path跳转的状态栏里可以看到参数类似get</span><br><span class=\"line\">        //通过$route.params或$route.query来获取参数</span><br><span class=\"line\">        const Home = Vue.component(&#x27;home&#x27;, &#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;h1 v-if=&#x27;$route.params.id&#x27;&gt;欢迎来到主页面&#123;&#123; $route.params.id&#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">                    &lt;h1 v-if=&#x27;$route.query.id&#x27;&gt;欢迎来到主页面&#123;&#123; $route.query.id&#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            `,</span><br><span class=\"line\">            //监听路由变化，获取参数进行操作</span><br><span class=\"line\">            watch: &#123;</span><br><span class=\"line\">                 //只要路由发生的变化就会执行这个方法，to 跳转的目的地， from 从哪里来</span><br><span class=\"line\">                $route(to, from) &#123;</span><br><span class=\"line\">                    //在这里可进行监听数据变化 进行网络请求</span><br><span class=\"line\">                    console.log(to)</span><br><span class=\"line\">                    console.log(from)</span><br><span class=\"line\">                    console.log(to.params.id)</span><br><span class=\"line\">                    console.log(to.query.id)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        const router = new VueRouter(&#123;</span><br><span class=\"line\">            routes: [</span><br><span class=\"line\">                &#123; path: &#x27;/home/:id&#x27;, component: Home &#125;,</span><br><span class=\"line\">                &#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: Home &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            router,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                fn() &#123;</span><br><span class=\"line\">                    this.$router.push(&#123;</span><br><span class=\"line\">                        name: &#x27;Home&#x27;,//找到routes里匹配到name为Home</span><br><span class=\"line\">                        params: &#123;</span><br><span class=\"line\">                            id: 1003,</span><br><span class=\"line\">                            title: &#x27;pjs&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                fn1() &#123;</span><br><span class=\"line\">                    this.$router.push(&#123;</span><br><span class=\"line\">                        path: &#x27;/home&#x27;,</span><br><span class=\"line\">                        query: &#123;</span><br><span class=\"line\">                            id: 1004,</span><br><span class=\"line\">                            title: &#x27;pjs&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"路由嵌套-子路由\"><a href=\"#路由嵌套-子路由\" class=\"headerlink\" title=\"路由嵌套-子路由\"></a>路由嵌套-子路由</h3><ul>\n<li>路由是可以嵌套的，即：路由中又包含子路由</li>\n<li>规则：父组件中包含 router-view，在路由规则中使用 children 配置</li>\n<li>使用 children 里配置子路由，子路由的 path 里不需要加&#x2F;符号了</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;router-link to=&#x27;/home&#x27;&gt;首页&lt;/router-link&gt;</span><br><span class=\"line\">        &lt;router-link to=&#x27;/user&#x27;&gt;我的&lt;/router-link&gt;</span><br><span class=\"line\">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        //路由是可以嵌套的，即：路由中又包含子路由</span><br><span class=\"line\">        //规则：父组件中包含 router-view，在路由规则中使用 children 配置</span><br><span class=\"line\">        const Home = Vue.component(&#x27;home&#x27;, &#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;router-link to=&#x27;/home/cartA&#x27;&gt;买车&lt;/router-link&gt;</span><br><span class=\"line\">                    &lt;router-link to=&#x27;/home/cartB&#x27;&gt;卖车&lt;/router-link&gt;</span><br><span class=\"line\">                    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        const CartA = &#123;</span><br><span class=\"line\">            template: `&lt;h3&gt;买什么样的车？&lt;/h3&gt;`</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const CartB = &#123;</span><br><span class=\"line\">            template: `&lt;h3&gt;卖什么样的车？&lt;/h3&gt;`</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const User = Vue.component(&#x27;user&#x27;, &#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    这里是个人信息</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        const router = new VueRouter(&#123;</span><br><span class=\"line\">            routes: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    path: &#x27;/home&#x27;, component: Home,</span><br><span class=\"line\">                    //使用children里配置子路由，子路由的path里不需要加/符号了</span><br><span class=\"line\">                    children: [</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            path: &#x27;cartA&#x27;,</span><br><span class=\"line\">                            component: CartA</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            path:&#x27;cartB&#x27;,</span><br><span class=\"line\">                            component:CartB</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123; path: &#x27;/user&#x27;, component: User &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            router</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、vuex\"><a href=\"#四、vuex\" class=\"headerlink\" title=\"四、vuex\"></a>四、vuex</h2><blockquote>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。意思就是所有组件共同操作一份数据，都可以对它进行增删改查。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">State</td>\n<td align=\"center\">共享数据都存在这里</td>\n</tr>\n<tr>\n<td align=\"center\">Mutation</td>\n<td align=\"center\">更改 State 中数据的唯一方法，同步操作</td>\n</tr>\n<tr>\n<td align=\"center\">Action</td>\n<td align=\"center\">异步操作 Mutation 来更改 State 中的数据</td>\n</tr>\n<tr>\n<td align=\"center\">Getter</td>\n<td align=\"center\">基于 state 的派生状态，可理解为组件中的计算属性</td>\n</tr>\n</tbody></table>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><ul>\n<li>1.安装 vuex npm i -s vuex</li>\n<li>2.创建 store 对象</li>\n<li>3.把 vue 和 store 进行关联</li>\n<li>4.使用$store.state 中的数据</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 4.使用$store.state中的数据 --&gt;</span><br><span class=\"line\">        &lt;h1&gt;&#123;&#123;this.$store.state.name&#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        //1.安装vuex npm i -s vuex</span><br><span class=\"line\">        //2.创建store对象</span><br><span class=\"line\">        let store = new Vuex.Store(&#123;</span><br><span class=\"line\">            /**</span><br><span class=\"line\">            *   state中可以存储任何类型的值</span><br><span class=\"line\">            */</span><br><span class=\"line\">            state: &#123;</span><br><span class=\"line\">                name: &#x27;邓紫棋&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        let vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            data: &#123;&#125;,</span><br><span class=\"line\">            //3.把vue和store进行关联</span><br><span class=\"line\">            store,</span><br><span class=\"line\">            mounted() &#123;</span><br><span class=\"line\">                //可以获取store对象</span><br><span class=\"line\">                console.log(this.$store)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3735156-7bac355c4d38d857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/517/format/webp\" alt=\"image\"></p>\n<h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h3><blockquote>\n<p>mutation 是更改 store 中状态的唯一方法,vuex 中规定只能通过提交 mutation 的方式去更改 store 中的状态,store.commit()方法更改数据。</p>\n</blockquote>\n<ul>\n<li>无参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//调用方 只传一个方法名</span><br><span class=\"line\">this.$store.commit(&#x27;changeName&#x27;)</span><br><span class=\"line\">//接收方 默认第一个参数是state，无参接收</span><br><span class=\"line\"> changeName(state) &#123;</span><br><span class=\"line\">    state.name = &#x27;张韶涵&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>载荷提交，只能提交一个参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//调用方，第一个参数：方法名，第二个参数：参数</span><br><span class=\"line\">this.$store.commit(&#x27;changeName&#x27;,this.msg)</span><br><span class=\"line\">//接收方</span><br><span class=\"line\"> changeName(state, name) &#123;</span><br><span class=\"line\">    state.name = name ? name : &#x27;张韶涵&#x27;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>载荷对象提交</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//调用方，传递一个对象</span><br><span class=\"line\">this.$store.commit(&#x27;changeName&#x27;,&#123;</span><br><span class=\"line\">   name:this.msg</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//接收方</span><br><span class=\"line\">changeName(state, payload) &#123;</span><br><span class=\"line\">    state.name = payload.name ;</span><br><span class=\"line\">    state.sex = payload.sex//给state新增一个属性</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>纯对象风格提交 type 值是方法名</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//提交一个纯对象当做参数，type值为方法名</span><br><span class=\"line\">this.$store.commit(&#123;</span><br><span class=\"line\">    type: &#x27;changeName&#x27;,</span><br><span class=\"line\">    name: this.msg,</span><br><span class=\"line\">    sex: &#x27;男&#x27;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//接收方</span><br><span class=\"line\">changeName(state, payload) &#123;</span><br><span class=\"line\">    state.name = payload.name ;</span><br><span class=\"line\">    state.sex = payload.sex//给state新增一个属性</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>案例</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 组件AAA和组件BBB共同操作$store.state中的数据 --&gt;</span><br><span class=\"line\">        &lt;!-- 比我们之前学的组件之间通讯更加方便 --&gt;</span><br><span class=\"line\">        &lt;AAA&gt;&lt;/AAA&gt;</span><br><span class=\"line\">        &lt;BBB&gt;&lt;/BBB&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">        *  mutation是更改store中状态的唯一方法</span><br><span class=\"line\">        *  vuex中规定只能通过提交mutation的方式去更改store中的状态</span><br><span class=\"line\">        *  store.commit()更改数据</span><br><span class=\"line\">        */</span><br><span class=\"line\">        let store = new Vuex.Store(&#123;</span><br><span class=\"line\">            state: &#123;</span><br><span class=\"line\">                name: &#x27;邓紫棋&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">            /**</span><br><span class=\"line\">            *   mutations对象中自定义方法来操作state中的数据</span><br><span class=\"line\">            *   并且每个方法会接受 state 作为第一个参数</span><br><span class=\"line\">            *   注意：Store对象中写mutations；Mutation 必须是同步函数</span><br><span class=\"line\">            */</span><br><span class=\"line\">            mutations: &#123;</span><br><span class=\"line\">                //不接收参数</span><br><span class=\"line\">                changeName(state) &#123;</span><br><span class=\"line\">                    state.name = &#x27;张韶涵&#x27;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                //只接收一个参数</span><br><span class=\"line\">                changeName(state, name) &#123;</span><br><span class=\"line\">                    state.name = name ? name : &#x27;张韶涵&#x27;;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                //接收参数对象</span><br><span class=\"line\">                changeName(state, payload) &#123;</span><br><span class=\"line\">                    state.name = payload.name ? payload.name : &#x27;张韶涵&#x27;;</span><br><span class=\"line\">                    state.sex = payload.sex//给state新增一个属性</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        //创建两个组件</span><br><span class=\"line\">        const AAA = Vue.component(&#x27;aaa&#x27;, &#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;!-- 4.使用$store.state中的数据 --&gt;</span><br><span class=\"line\">                    &lt;h1&gt;&#123;&#123;this.$store.state.name&#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">                    &lt;h2&gt;&#123;&#123;this.$store.state.sex&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        const BBB = Vue.component(&#x27;bbb&#x27;, &#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; v-model=&#x27;msg&#x27;&gt;</span><br><span class=\"line\">                    &lt;input type=&quot;button&quot; value=&quot;确定&quot; @click=&#x27;change&#x27;&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            `,</span><br><span class=\"line\">            data() &#123;</span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    msg: &#x27;&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                change() &#123;</span><br><span class=\"line\">                    //1.无参数</span><br><span class=\"line\">                    // this.$store.commit(&#x27;changeName&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">                    //2.载荷提交，只能提交一个参数</span><br><span class=\"line\">                    // this.$store.commit(&#x27;changeName&#x27;,this.msg)</span><br><span class=\"line\"></span><br><span class=\"line\">                    //3.载荷对象提交</span><br><span class=\"line\">                    // this.$store.commit(&#x27;changeName&#x27;,&#123;</span><br><span class=\"line\">                    //     name:this.msg</span><br><span class=\"line\">                    // &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">                    //4.纯对象风格提交 type值是方法名</span><br><span class=\"line\">                    this.$store.commit(&#123;</span><br><span class=\"line\">                        type: &#x27;changeName&#x27;,</span><br><span class=\"line\">                        name: this.msg,</span><br><span class=\"line\">                        sex: &#x27;男&#x27;</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        let vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            //把vue和store进行关联</span><br><span class=\"line\">            store</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3735156-46e377f77e8f06bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/706/format/webp\" alt=\"image\"></p>\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><blockquote>\n<p>mutation 中规则上是不允许异步操作的,于是 vuex 为我们提供了 action。actions 对象中自定义方法来操作 mutations,并且每个方法会接受 context 作为第一个参数,context 对象与 store 对象具有相同的方法和属性;action 与 mutation 除了使用了异步操作和调用 mutation，其它使用并无差别 ;</p>\n</blockquote>\n<ul>\n<li>异步更新数据</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//action事件的触发同样可以使用载荷和对象两种方式,其它方式就不写了和mutations方式一样</span><br><span class=\"line\">this.$store.dispatch(&#123;</span><br><span class=\"line\">    type:&#x27;changeNameAsync&#x27;,//Store.actions中的方法名</span><br><span class=\"line\">    name: this.msg,</span><br><span class=\"line\">    sex: &#x27;男&#x27;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    //接收数据 延迟一秒提交数据</span><br><span class=\"line\">    changeNameAsync(context, payload) &#123;</span><br><span class=\"line\">    //异步操作</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        context.commit(&#x27;changeName&#x27;,payload)</span><br><span class=\"line\">    &#125;, 1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">    //接收参数对象</span><br><span class=\"line\">    changeName(state, payload) &#123;</span><br><span class=\"line\">    state.name = payload.name ;</span><br><span class=\"line\">    state.sex = payload.sex//给state新增一个属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>案例</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;AAA&gt;&lt;/AAA&gt;</span><br><span class=\"line\">        &lt;BBB&gt;&lt;/BBB&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">        *  action--异步更改状态</span><br><span class=\"line\">        *  mutation中规则上是不允许异步操作的,于是vuex为我们提供了action。</span><br><span class=\"line\">        *  store.dispatch() 方法触发</span><br><span class=\"line\">        */</span><br><span class=\"line\">        let store = new Vuex.Store(&#123;</span><br><span class=\"line\">            state: &#123;</span><br><span class=\"line\">                name: &#x27;邓紫棋&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">            /**</span><br><span class=\"line\">            *   mutations只能同步执行</span><br><span class=\"line\">            */</span><br><span class=\"line\">            mutations: &#123;</span><br><span class=\"line\">                //接收参数对象</span><br><span class=\"line\">                changeName(state, payload) &#123;</span><br><span class=\"line\">                    state.name = payload.name ? payload.name : &#x27;张韶涵&#x27;;</span><br><span class=\"line\">                    state.sex = payload.sex//给state新增一个属性</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            /**</span><br><span class=\"line\">            *   actions对象中自定义方法来操作mutations,并且每个方法会接受 context 作为第一个参数;</span><br><span class=\"line\">            *   context对象与store对象具有相同的方法和属性</span><br><span class=\"line\">            *   action 与 mutation 除了使用了异步操作和调用mutation，其它使用并无差别</span><br><span class=\"line\">            */</span><br><span class=\"line\">            actions: &#123;</span><br><span class=\"line\">                //接收数据</span><br><span class=\"line\">                changeNameAsync(context, payload) &#123;</span><br><span class=\"line\">                    //异步操作</span><br><span class=\"line\">                    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                        context.commit(&#123;</span><br><span class=\"line\">                            type: &#x27;changeName&#x27;,</span><br><span class=\"line\">                            name: payload.name,</span><br><span class=\"line\">                            sex: &#x27;男&#x27;</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                    &#125;, 1000)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        //创建两个组件</span><br><span class=\"line\">        const AAA = Vue.component(&#x27;aaa&#x27;, &#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;!-- 4.使用$store.state中的数据 --&gt;</span><br><span class=\"line\">                    &lt;h1&gt;&#123;&#123;this.$store.state.name&#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">                    &lt;h2&gt;&#123;&#123;this.$store.state.sex&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        const BBB = Vue.component(&#x27;bbb&#x27;, &#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; v-model=&#x27;msg&#x27;&gt;</span><br><span class=\"line\">                    &lt;input type=&quot;button&quot; value=&quot;确定&quot; @click=&#x27;change&#x27;&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            `,</span><br><span class=\"line\">            data() &#123;</span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    msg: &#x27;&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                change() &#123;</span><br><span class=\"line\">                    //action事件的触发同样可以使用载荷和对象两种方式,其它方式就不写了和mutations方式一样</span><br><span class=\"line\">                    this.$store.dispatch(&#123;</span><br><span class=\"line\">                        type:&#x27;changeNameAsync&#x27;,//Store.actions中的方法名</span><br><span class=\"line\">                        name: this.msg</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        let vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            store</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3735156-1bb9c077d8bc7f10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/709/format/webp\" alt=\"image\"></p>\n<h3 id=\"getter\"><a href=\"#getter\" class=\"headerlink\" title=\"getter\"></a>getter</h3><blockquote>\n<p>getters 类似 Vue 实例中的计算属性，当绑定的属性发生变化后才会重新计算;每个方法都默认接收 state 参数。</p>\n</blockquote>\n<ul>\n<li>getters 使用</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//在getters下创建一个getName方法，默认接收state，此方法和计算属性用法一样，当state中的name发生改变时会重新计算这个方法return结果</span><br><span class=\"line\">getters:&#123;</span><br><span class=\"line\">    getName(state)&#123;</span><br><span class=\"line\">        let myName=&#x27;&#x27;;</span><br><span class=\"line\">        if(state.name === &#x27;彭俊山&#x27;)&#123;</span><br><span class=\"line\">            myName = &#x27;你是最帅的！&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return state.name + myName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//在A组件中使用getters下的getName属性，当B组件修改了state中的name后A组件中h2数据也会变化</span><br><span class=\"line\">&lt;h2&gt;&#123;&#123;this.$store.getters.getName&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>案例</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;AAA&gt;&lt;/AAA&gt;</span><br><span class=\"line\">        &lt;BBB&gt;&lt;/BBB&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        let store = new Vuex.Store(&#123;</span><br><span class=\"line\">            state: &#123;</span><br><span class=\"line\">                name: &#x27;邓紫棋&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            mutations: &#123;</span><br><span class=\"line\">                //接收参数对象</span><br><span class=\"line\">                changeName(state, payload) &#123;</span><br><span class=\"line\">                    state.name = payload.name ? payload.name : &#x27;张韶涵&#x27;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            /**</span><br><span class=\"line\">            *   getters类似Vue实例中的计算属性，当绑定的属性发生变化后才会重新计算</span><br><span class=\"line\">            *   每个方法都默认接收state参数</span><br><span class=\"line\">            */</span><br><span class=\"line\">            getters:&#123;</span><br><span class=\"line\">                getName(state)&#123;</span><br><span class=\"line\">                    let myName=&#x27;&#x27;;</span><br><span class=\"line\">                    if(state.name === &#x27;彭俊山&#x27;)&#123;</span><br><span class=\"line\">                        myName = &#x27;你是最帅的！&#x27;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    return state.name + myName;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        //创建两个组件</span><br><span class=\"line\">        const AAA = Vue.component(&#x27;aaa&#x27;, &#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;!-- 使用$store.state中的数据 --&gt;</span><br><span class=\"line\">                    &lt;h1&gt;&#123;&#123;this.$store.state.name&#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">                    &lt;!-- 使用$store.getters中的属性 --&gt;</span><br><span class=\"line\">                    &lt;h2&gt;&#123;&#123;this.$store.getters.getName&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        const BBB = Vue.component(&#x27;bbb&#x27;, &#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; v-model=&#x27;msg&#x27;&gt;</span><br><span class=\"line\">                    &lt;input type=&quot;button&quot; value=&quot;确定&quot; @click=&#x27;change&#x27;&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            `,</span><br><span class=\"line\">            data() &#123;</span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    msg: &#x27;&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                change() &#123;</span><br><span class=\"line\">                    //纯对象风格提交 type值是方法名</span><br><span class=\"line\">                    this.$store.commit(&#123;</span><br><span class=\"line\">                        type: &#x27;changeName&#x27;,</span><br><span class=\"line\">                        name: this.msg</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        let vm = new Vue(&#123;</span><br><span class=\"line\">            el: &#x27;#app&#x27;,</span><br><span class=\"line\">            store</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3735156-ae75344b34e3a726.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/709/format/webp\" alt=\"image\"></p>\n<h3 id=\"vuex-刷新页面-store-数据丢失\"><a href=\"#vuex-刷新页面-store-数据丢失\" class=\"headerlink\" title=\"vuex 刷新页面 store 数据丢失\"></a>vuex 刷新页面 store 数据丢失</h3><blockquote>\n<p>当刷新页面后，store 中的数据都会丢失；将 store 的数据存储在 storage 里，由于 vue 多为单页面应用，且每次重新打开页面需要保持数据为空 所以这里我们不选用 localStorage，用 sessionStorage 会话机制;</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">created() &#123;</span><br><span class=\"line\">    //在页面加载时读取sessionStorage里的状态信息</span><br><span class=\"line\">    if (sessionStorage.getItem(&quot;store&quot;)) &#123;</span><br><span class=\"line\">        this.$store.replaceState(Object.assign(&#123;&#125;, this.$store.state, JSON.parse(sessionStorage.getItem(&quot;store&quot;))))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //在页面刷新时将vuex里的信息保存到sessionStorage里</span><br><span class=\"line\">    window.addEventListener(&quot;beforeunload&quot;, () =&gt; &#123;</span><br><span class=\"line\">        sessionStorage.setItem(&quot;store&quot;, JSON.stringify(this.$store.state))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"XSS 和 CSRF 详解及区别解析","url":"/2022/10/24/XSS-%E5%92%8C-CSRF-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%8C%BA%E5%88%AB%E8%A7%A3%E6%9E%90/","content":"<h2 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h2><p>cross site script，跨站脚本攻击（关键字：脚本）。为了与 css 冲突取名为 xss！<br>XSS 攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在 url 中输入、在评论框中输入），向你的页面注入脚本（可能是 js、hmtl 代码块等）。<br>恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p>\n<p><strong>最后导致的结果可能是</strong>：</p>\n<ul>\n<li>盗用 Cookie</li>\n<li>破坏页面的正常结构，插入广告等恶意内容</li>\n<li>D-doss 攻击</li>\n</ul>\n<h3 id=\"XSS-的攻击方式\"><a href=\"#XSS-的攻击方式\" class=\"headerlink\" title=\"XSS 的攻击方式\"></a>XSS 的攻击方式</h3><p>1、反射型（临时，非持久型）<br>发出请求时，XSS 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，所以叫反射型 XSS。<br>客户端提交，服务器解析后响应，到客户端再执行</p>\n<p>2、存储型（持久型）<br>存储型 XSS 和反射型 XSS 的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等）。<br>比如先通过对一个攻击 url 进行编码(来绕过 xss filter)，然后提交该 web server(存储在 web server 中), 然后用户在浏览页面时，如果点击该 url，就会触发一个 XSS 攻击。当然用户点击该 url 时，也可能会触发一个 CSRF(Cross site request forgery)攻击。</p>\n<p>以上两种服务端参与</p>\n<p>3、DOM based XSS<br>基于 DOM 的 XSS，也就是 web server 不参与，仅仅涉及到浏览器的 XSS。比如根据用户的输入来动态构造一个 DOM 节点，如果没有对用户的输入进行过滤，那么也就导致 XSS 攻击的产生。过滤可以考虑采用 esapi4js。</p>\n<p><strong>预防</strong>：<br>简而言之：转义+过滤（<strong>输入过滤，输出转义</strong>）</p>\n<p>1、在 cookie 中设置了 HttpOnly 属性，那么通过 js 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击</p>\n<p><strong>过滤</strong>：</p>\n<p>移除用户输入的和事件相关的属性。如 onerror 可以自动触发攻击，还有 onclick 等。（总而言是，过滤掉一些不安全的内容）</p>\n<p>移除用户输入的 Style 节点、Script 节点、Iframe 节点。（尤其是 Script 节点，它可是支持跨域的呀，一定要移除）。</p>\n<h2 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h2><p>用户登录 A 网站产生 cookie，此时再访问 B（危险），B 要求访问 A，并发起一个请求</p>\n<p>此时，B（危险）就利用用户的权限在 A 进行了操作。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1627906-03e225c2ab2d1d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp\" alt=\"image\"></p>\n<p>如何预防：<br>1、Token 验证：（用的最多）</p>\n<p>（1）服务器发送给客户端一个 token；</p>\n<p>（2）客户端提交的表单中带着这个 token。</p>\n<p>（3）如果这个 token 不合法，那么服务器拒绝这个请求。</p>\n<p>2、隐藏令牌：<br>把 token 隐藏在 http 的 head 头中。</p>\n<p>响应头</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1627906-d8c2ef9a7b0c95c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1130/format/webp\" alt=\"image\"></p>\n<p>请求头</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1627906-59051e4a8516f9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/998/format/webp\" alt=\"image\"></p>\n<p>ps：方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p>\n<h2 id=\"CSRF-和-XSS-的区别\"><a href=\"#CSRF-和-XSS-的区别\" class=\"headerlink\" title=\"CSRF 和 XSS 的区别\"></a>CSRF 和 XSS 的区别</h2><p>面试官还可能喜欢问二者的区别。</p>\n<p>区别一：</p>\n<p>CSRF：需要用户先登录网站 A，获取 cookie。<br>XSS：不需要登录。<br>区别二：（原理的区别）</p>\n<p>CSRF：是利用网站 A 本身的漏洞，去请求网站 A 的 api。<br>XSS：是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"angular和vue还有jquery的区别","url":"/2022/12/16/angular%E5%92%8Cvue%E8%BF%98%E6%9C%89jquery%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<h2 id=\"angularjs-简单介绍和特点\"><a href=\"#angularjs-简单介绍和特点\" class=\"headerlink\" title=\"angularjs 简单介绍和特点\"></a>angularjs 简单介绍和特点</h2><p>首先 angular 是一个 mvc 框架, 使用 mvc 解耦, 采用 model, controller 以及 view 的方式去组织代码, 会将一个 html 页面分成若干个模块, 每个模块都有自己的 scope, service, directive, 各个模块之间也可以进行通信, 但是整体结构上是比较清晰的, 就是说其代码组织是模块化的, angular 的 view 可能仅仅是一个框架, , 对 view 的 dom 操作或者事件监听都是在 directive 中实现的, 而且一般情况下很少直接去写 dom 操作代码, 只要你监听 model, model 发生变化后 view 也会发生变化, 就是双向绑定机制, angularjs 适用于单页面开发</p>\n<p>在 angularJS 中，一个模板就是一个 HTML 文件。但是 HTML 的内容扩展了，包含了很多帮助你映射 model 到 view 的内容。</p>\n<p>HTML 模板将会被浏览器解析到 DOM 中。DOM 然后成为 AngularJS 编译器的输入。AngularJS 将会遍历 DOM 模板来生成一些指导，即，directive（指令）。所有的指令都负责针对 view 来设置数据绑定。</p>\n<p>angularJS 并不把模板当做 String 来操作。输入 angularJS 的是 DOM 而非 string。数据绑定是 DOM 变化，不是字符串的连接或者 innerHTML 变化。使用 DOM 作为输入，而不是字符串，是 AngularJS 区别于其它的框架的最大原因。使用 DOM 允许你扩展指令词汇并且可以创建你自己的指令，甚至开发可重用的组件。angular 占用的内存较小, 可以兼容主流的浏览器, 他拥有内置的依赖注入的子系统, 可以帮助开发人员更容易开发, 理解和测试和应用, DI 允许你请求你的依赖，而不是自己找寻它们。比如，我们需要一个东西，DI 负责找创建并且提供给我们。那么 AngularJS 可以做到。指令可以用来创建自定义的标签。它们可以用来装饰元素或者操作 DOM 属性。</p>\n<h2 id=\"vuejs-简单介绍特点\"><a href=\"#vuejs-简单介绍特点\" class=\"headerlink\" title=\"vuejs 简单介绍特点\"></a>vuejs 简单介绍特点</h2><p>官网: <a href=\"http://cn.vuejs.org/\">http://cn.vuejs.org/</a></p>\n<p>vue 是一个渐进式的框架, 是一个轻量级的框架, 也不算是一个框架, 他核心只关注图层, 是一个构建数据驱动的 web 界面,易于上手, 还便于第三方库或与既有项目整合,也能够为复杂的单页应用程序提供驱动</p>\n<h3 id=\"1-vue-的核心\"><a href=\"#1-vue-的核心\" class=\"headerlink\" title=\"1. vue 的核心\"></a>1. vue 的核心</h3><p>是一个允许采用简洁的模板语法来声明式的将数据渲染进 dom</p>\n<p>先创建一个后缀名为.html 的文件</p>\n<p>代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">html:  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">js里面的　var app = new Vue(&#123;</span><br><span class=\"line\">　　　　　　el: &#x27;#app&#x27;,</span><br><span class=\"line\">　　　　　　data: &#123;</span><br><span class=\"line\">　　　　　　　msg: &#x27;Hello Vue!&#x27;</span><br><span class=\"line\">　　　　　　&#125;</span><br><span class=\"line\">　　　&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在浏览器窗口上出现的内容:　 Hello Vue<br>数据和 DOM 已经绑定在一起, 验证是否是响应式的, 修改控制台里面 app.msg,你就会看到上面渲染是列子也更新出来了文本插值, 还可以用绑定 DOM 元素属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app-2&quot;&gt;</span><br><span class=\"line\">    &lt;span v-bind:title=&quot;message&quot;&gt;</span><br><span class=\"line\">　　　查看此处动态绑定提示信息！</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">js代码:</span><br><span class=\"line\">var app2 = new Vue(&#123;</span><br><span class=\"line\">　　el: &#x27;#app-2&#x27;,</span><br><span class=\"line\">　　data: &#123;</span><br><span class=\"line\">　　　　　message: &#x27;页面加载于 &#x27; + new Date()</span><br><span class=\"line\">　　　&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-vue-指令\"><a href=\"#2-vue-指令\" class=\"headerlink\" title=\"2. vue 指令\"></a>2. vue 指令</h3><p>指令带有前缀 v-, 以表示他们是 Vue 提供的特殊属性, 他们会在渲染的 DOM 上应用特殊的响应式行为</p>\n<p>v-bind : str &#x3D; “msg” 将这个元素的节点的 str 属性和 vue 实例对象的 msg 属性保持一致</p>\n<p>v-if &#x3D; 布尔值 条件渲染指令, 根据其后表达式的布尔值进行判断是否渲染该元素, v-if 只会渲染他身后表达式为 true 的元素</p>\n<p>v-show &#x3D; 布尔值 和 v-if 类似,只是会渲染他身后表达式为 false 的元素, 而且会给这样的元素添加 css 的代码, style &#x3D; “display:none”</p>\n<p>v-else 必须在 v-if&#x2F;v-show 指令后, 不然就不会起作用, 如果 v-if&#x2F;v-show 的指令表达式为 true, 则 else 就不显示, 如果 v-if&#x2F;v-show 指令的表达式为 false, 则 else 元素会显示在页面上</p>\n<p>v-for 类似于 js 的遍历, 用法为 v-for&#x3D;”(item,index) in imgs” :key&#x3D;”index”, items 是数组, item 为数组中的数组元素, index 是索引号, key 是为了更高效的查找到指定元素</p>\n<p>v-on 用于监听指定元素的 DOM 事件 v-on:click&#x3D;”greet”</p>\n<h3 id=\"3-vue-的双向数据绑定\"><a href=\"#3-vue-的双向数据绑定\" class=\"headerlink\" title=\"3. vue 的双向数据绑定\"></a>3. vue 的双向数据绑定</h3><p>vueJS 是使用 ES5 提供的 Object.defineProperty()方法, 监控对数据的操作, 从而可以自动触发数据, 并且, 由于是在不同的数据上触发同步, 可以精确的将变更发送给绑定的视图, 而不是对所有的数据都执行一次检测</p>\n<p>vue 和 angular 中, 都是通过在 html 中添加指令的方式, 将视图元素与数据的绑定关系进行声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;form id= &quot;app&quot;&gt;</span><br><span class=\"line\">　　&lt;input type=&quot;test&quot; v-model=&quot;name&quot;&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>以上的 html 代码表示该 input 元素与 name 数据进行绑定, 在 js 代码总可以这样进行初始化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">　　el: &quot;#app&quot;,</span><br><span class=\"line\">　　data:&#123;</span><br><span class=\"line\">　　　name: &quot;请输入你的名字&quot;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>代码执行正确后, 页面上 input 元素对应的位置会显示上面的代码给出的初始值 “请输入你的名字”, 由于双向绑定数据已经建立, 因此, 在 vm.name&#x3D;”小米”, 则 input 也会更新为小明, 在页面 input 上输入小明, 则 vm.name 获取的值为小明</p>\n<h3 id=\"4-vue-的插件化\"><a href=\"#4-vue-的插件化\" class=\"headerlink\" title=\"4. vue 的插件化\"></a>4. vue 的插件化</h3><p>插件通常会为 vue 添加全局功能, 插件的范围没有限制</p>\n<p>添加全局的方法或者属性 vue-element 这个我并不是很懂</p>\n<p>添加全局资源 指令&#x2F;过滤器&#x2F; 过渡</p>\n<p>添加 vue 实例的办法, 将他们添加到 vue-prototype 上实现</p>\n<p>引入一个库, 来提供自己的 api, 同时提供上面的一个或者多个功能, 如 vue-router</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import vueRouter from &#x27;&#x27;vue-router&#x27;;  //使用webpack的单文件组件打包的方式 会调用vue.component来注册全局组件或者vue.components注册局部组件</span><br></pre></td></tr></table></figure>\n\n<p>如果是后者，每个单文件组件中都不需要引入 vue,<br>因为单文件组件经 webpack 打包后，生成的模块只是一个组件选项对象，被其他组件或 Vue 实例注册时使用语法糖，只需要 字面量对象的 组件选项对象就可以了。</p>\n<p>使用插件:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vue.use(vueRouter); //通过全局方法Vue.use()使用插件, 会阻止注册相同插件多次, 只会注册一次该插件</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"angular-和-jquery-的区别\"><a href=\"#angular-和-jquery-的区别\" class=\"headerlink\" title=\"angular 和 jquery 的区别\"></a>angular 和 jquery 的区别</h2><p>angular 中是尽量避免操作 DOM, angular 是基于数据驱动, 适合做数据操作比较繁琐的项目,angular 适用于单页面开发,是一个比较完善的 mvvm 框架, 包含模板和双向数据绑定, 路由, 模块化, 服务, 过滤器, 依赖注入等所有功能,但是 angular 验证功能比较薄弱, 需要写很多模板标签, 而且 ngview 只能有一个, 不能嵌套多个视图,angular 的兼容性比较好, jquery 是基于操作 DOM, 适用于操作 DOM 比较多的项目, jquery 是一个库, 比较大,兼容大部分浏览器, 有丰富的插件, 可拓展性强, jquery 不能向后兼容, 使用插件时,可能会有冲突,</p>\n<h2 id=\"angular-和-vue-的差别\"><a href=\"#angular-和-vue-的差别\" class=\"headerlink\" title=\"angular 和 vue 的差别\"></a>angular 和 vue 的差别</h2><p>一 angular 是 mvvm 框架, 而 vue 是一个渐进式的框架, 相当于 view 层, 都有双向数据绑定, 但是 angular 中的双向数据绑定是基于脏检查机制, vue 的双向数据绑定是基于 ES5 的 getter 和 setter 来实现, 而 angular 是有自己实现一套模板编译规则,vue 比 angular 更轻量, 性能上更高效, 比 angular 更容易上手, 学习成本低, vue 需要一个 el 对象进行实例化, 而 angular 是整个 html 页面下的,单页面应用, 而 vue 可以有多个 vue 实例</p>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"antV G6新手入门 使用笔记","url":"/2022/12/16/antV-G6%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","content":"<blockquote>\n<p>普通的图表，echarts 足够用，但是比如关系图等，echarts 定制化配置还是太麻烦。综合考量，还是 G6 方便 G6 是一个图可视化引擎。它提供了图</p>\n</blockquote>\n<p>普通的图表，echarts 足够用，但是比如关系图等，echarts 定制化配置还是太麻烦。综合考量，还是 G6 方便</p>\n<p><strong>G6 是一个图可视化引擎。它提供了图的绘制、布局、分析、交互、动画等图可视化的基础能力。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save @antv/g6</span><br><span class=\"line\"></span><br><span class=\"line\">import G6 from &#x27;@antv/g6&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"G6-使用\"><a href=\"#G6-使用\" class=\"headerlink\" title=\"G6 使用\"></a>G6 使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;mountNode&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">const graph = new G6.Graph(&#123;</span><br><span class=\"line\">  container: &#x27;mountNode&#x27;, // String | HTMLElement，必须，在 Step 1 中创建的容器 id 或容器本身</span><br><span class=\"line\">  width: 800, // Number，必须，图的宽度</span><br><span class=\"line\">  height: 500, // Number，必须，图的高度</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">graph.data(&#123;nodes:[&#123;id: &#x27;node1&#x27;&#125;], edges:[&#123;source: &#x27;node1&#x27;,target: &#x27;node2&#x27;,&#125;]&#125;);</span><br><span class=\"line\">graph.render(); // 渲染图</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>nodes 数组中包含节点对</strong>象，唯一的 id 是每个节点对象中必要的属性，x、 y 用于定位；</li>\n<li><strong>edges 数组中包含边对象</strong>，source 和 target 是每条边的必要属性，分别代表了该边的起始点 id 与 目标点 id。</li>\n<li>点和边的更多属性参见：<a href=\"https://g6.antv.vision/zh/docs/manual/middle/elements/nodes/defaultNode\">内置的节点</a>，<a href=\"https://g6.antv.vision/zh/docs/manual/middle/elements/edges/defaultEdge\">内置的边</a> 教程。</li>\n</ul>\n<h3 id=\"整体配置\"><a href=\"#整体配置\" class=\"headerlink\" title=\"整体配置\"></a>整体配置</h3><table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>类型</th>\n<th>选项 &#x2F; 示例</th>\n<th>默认</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>fitView</td>\n<td>Boolean</td>\n<td>true &#x2F; false</td>\n<td>false</td>\n<td>是否将图适配到画布大小，可以防止超出画布或留白太多。</td>\n</tr>\n<tr>\n<td>fitViewPadding</td>\n<td>Number &#x2F; Array</td>\n<td>20 &#x2F; [ 20, 40, 50, 20 ]</td>\n<td>0</td>\n<td>画布上的四周留白宽度。</td>\n</tr>\n<tr>\n<td>animate</td>\n<td>Boolean</td>\n<td>true &#x2F; false</td>\n<td>false</td>\n<td>是否启用图的动画。</td>\n</tr>\n<tr>\n<td>modes</td>\n<td>Object</td>\n<td>{ default: [ ‘drag-node’]}</td>\n<td>null</td>\n<td>图上行为模式的集合（如：拖拽、缩放）。由于比较复杂，按需参见：G6 中的 Mode 教程。</td>\n</tr>\n<tr>\n<td>defaultNode</td>\n<td>Object</td>\n<td>{ type: ‘circle’, style: {}}</td>\n<td>null</td>\n<td>节点默认的属性，包括节点的一般属性和样式属性（style）。</td>\n</tr>\n<tr>\n<td>defaultEdge</td>\n<td>Object</td>\n<td>{type: ‘polyline’, color: ‘#000}</td>\n<td>null</td>\n<td>边默认的属性，包括边的一般属性和样式属性（style）。</td>\n</tr>\n<tr>\n<td>nodeStateStyles</td>\n<td>Object</td>\n<td>{hover: {……},select: {…… }}</td>\n<td>null</td>\n<td>节点在除默认状态外，其他状态下的样式属性（style）。例如鼠标放置（hover）、选中（select）等状态。</td>\n</tr>\n<tr>\n<td>edgeStateStyles</td>\n<td>Object</td>\n<td>{hover: {……} ,select: {…… }}</td>\n<td>null</td>\n<td>边在除默认状态外，其他状态下的样式属性（style）。例如鼠标放置（hover）、选中（select）等状态。</td>\n</tr>\n</tbody></table>\n<p>这个是初始化图表配置项</p>\n<h2 id=\"图布局-Layout\"><a href=\"#图布局-Layout\" class=\"headerlink\" title=\"图布局 Layout\"></a>图布局 Layout</h2><p>当数据中没有节点位置信息，或者数据中的位置信息不满足需求时，需要借助一些布局算法对图进行布局。</p>\n<p>相比 echarts，支持布局多很多，G6 提供了 9 种一般图的布局和 4 种树图的布局：</p>\n<h3 id=\"一般图：\"><a href=\"#一般图：\" class=\"headerlink\" title=\"一般图：\"></a>一般图：</h3><ul>\n<li>Random Layout：随机布局；</li>\n<li>Force Layout：经典力导向布局：</li>\n</ul>\n<blockquote>\n<p>力导向布局：一个布局网络中，粒子与粒子之间具有引力和斥力，从初始的随机无序的布局不断演变，逐渐趋于平衡稳定的布局方式称之为力导向布局。适用于描述事物间关系，比如人物关系、计算机网络关系等。</p>\n</blockquote>\n<ul>\n<li>Circular Layout：环形布局；</li>\n<li>Radial Layout：辐射状布局；</li>\n<li>MDS Layout：高维数据降维算法布局；</li>\n<li>Fruchterman Layout：Fruchterman 布局，一种力导布局；</li>\n<li>Dagre Layout：层次布局；</li>\n<li>Concentric Layout：同心圆布局，将重要（默认以度数为度量）的节点放置在布局中心；</li>\n<li>Grid Layout：格子布局，将节点有序（默认是数据顺序）排列在格子上。</li>\n</ul>\n<h3 id=\"树图布局：\"><a href=\"#树图布局：\" class=\"headerlink\" title=\"树图布局：\"></a>树图布局：</h3><ul>\n<li>Dendrogram Layout：树状布局（叶子节点布局对齐到同一层）；</li>\n<li>CompactBox Layout：紧凑树布局；</li>\n<li>Mindmap Layout：脑图布局；</li>\n<li>Intended Layout：缩进布局。</li>\n</ul>\n<p><strong>设置节点和背景</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const graph = new G6.Graph(&#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  defaultNode: &#123;</span><br><span class=\"line\">    position: &#x27;left&#x27;,</span><br><span class=\"line\">    style: &#123;</span><br><span class=\"line\">      background: &#123;</span><br><span class=\"line\">        fill: &#x27;#ffffff&#x27;,</span><br><span class=\"line\">        stroke: &#x27;green&#x27;,</span><br><span class=\"line\">        padding: [3, 2, 3, 2],</span><br><span class=\"line\">        radius: 2,</span><br><span class=\"line\">        lineWidth: 3,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  defaultEdge: &#123;</span><br><span class=\"line\">    autoRotate: true,</span><br><span class=\"line\">    style: &#123;</span><br><span class=\"line\">      background: &#123;</span><br><span class=\"line\">        fill: &#x27;#ffffff&#x27;,</span><br><span class=\"line\">        stroke: &#x27;#000000&#x27;,</span><br><span class=\"line\">        padding: [2, 2, 2, 2],</span><br><span class=\"line\">        radius: 2,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","categories":["webGL总结"],"tags":["webGL"]},{"title":"antd 常用知识点和小技巧总结","url":"/2022/12/16/antd-%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%92%8C%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/","content":"<h2 id=\"1-form-表单中-FormItem-的布局\"><a href=\"#1-form-表单中-FormItem-的布局\" class=\"headerlink\" title=\"1 form 表单中 FormItem 的布局\"></a>1 form 表单中 FormItem 的布局</h2><p>使用 getFieldDecorator 包裹的输入框或者 Select，必须是在最外层，也就是只有一层，否则，检验会一直不通过，所以，需要重新布局应该在 getFieldDecorator 的外层添加父节点，而不应该在里面。</p>\n<p><strong>例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;FormItem</span><br><span class=\"line\">  &#123;...formItemLayout&#125;</span><br><span class=\"line\">  label=&quot;所属应用&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;getFieldDecorator(&#x27;apiwgAppName&#x27;, &#123;</span><br><span class=\"line\">      rules: [&#123; required: false, message: &#x27;请选择&#x27; &#125;],</span><br><span class=\"line\">    initialValue: apiwgAppName || &quot;&quot;</span><br><span class=\"line\">    &#125;)(</span><br><span class=\"line\">      &lt;Input disabled=&#123;this.store.data.apiId ? true : false&#125;</span><br><span class=\"line\">        className=&quot;control-special&quot; readOnly style=&#123;&#123; width: &quot;70%&quot; &#125;&#125;</span><br><span class=\"line\">        onClick=&#123;this.showModal.bind(this, &quot;apiwgApp&quot;)&#125; /&gt;</span><br><span class=\"line\">    )&#125;</span><br><span class=\"line\">    &lt;Button className=&quot;btn-modal&quot; type=&quot;primary&quot; onClick=&#123;this.showModal.bind(this, &quot;apiwgApp&quot;)&#125;</span><br><span class=\"line\">      disabled=&#123;this.store.data.apiId ? true : false&#125;</span><br><span class=\"line\">    &gt;选择所属应用</span><br><span class=\"line\">    &lt;/Button&gt;</span><br><span class=\"line\">    &lt;a</span><br><span class=\"line\">      style=&#123;&#123; marginLeft: &#x27;8px&#x27; &#125;&#125;</span><br><span class=\"line\">      onClick=&#123;this.openNewAppDlg.bind(this)&#125;</span><br><span class=\"line\">      className=&#123;`api-add $&#123;</span><br><span class=\"line\">        this.store.data.apiId ? &#x27;disabled&#x27; : &#x27;&#x27;</span><br><span class=\"line\">        &#125;`&#125;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">      +新增应用</span><br><span class=\"line\">    &lt;/a&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/FormItem&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-form-表单，FormItem-的-rules-中新增-validator，实时请求校验\"><a href=\"#2-form-表单，FormItem-的-rules-中新增-validator，实时请求校验\" class=\"headerlink\" title=\"2 form 表单，FormItem 的 rules 中新增 validator，实时请求校验\"></a>2 form 表单，FormItem 的 rules 中新增 validator，实时请求校验</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;FormItem</span><br><span class=\"line\">  labelCol=&#123;&#123; span: 8 &#125;&#125;</span><br><span class=\"line\">  wrapperCol=&#123;&#123; span: 15 &#125;&#125;</span><br><span class=\"line\">  label=&quot;菜单名称&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">  &#123;form.getFieldDecorator(&#x27;menuName&#x27;, &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123; required: true, message: &#x27;菜单名称不能为空&#x27; &#125;,</span><br><span class=\"line\">      &#123; type: &#x27;string&#x27;, max: 30, message: &#x27;菜单名称过长&#x27; &#125;,</span><br><span class=\"line\">      &#123; validator: this.handleCheckName &#125;,</span><br><span class=\"line\">      &#123; whitespace: true, message: &#x27;请输入非空白内容&#x27; &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    initialValue: this.props.menuSysData.menuName,</span><br><span class=\"line\">  &#125;)(</span><br><span class=\"line\">    &lt;Input</span><br><span class=\"line\">      // placeholder=&quot;请输入菜单名称&quot;</span><br><span class=\"line\">      disabled=&#123;disableFlag&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  )&#125;</span><br><span class=\"line\">&lt;/FormItem&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 实时校验</span><br><span class=\"line\">  handleCheckName = (rule, value, callback) =&gt; &#123;</span><br><span class=\"line\">    const &#123; checkName, actionType &#125; = this.state;</span><br><span class=\"line\">    if (!this.trim(value) || (checkName &amp;&amp; actionType === &#x27;M&#x27; &amp;&amp; this.trim(value) === checkName)) &#123;</span><br><span class=\"line\">      callback();</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let params = &#123;</span><br><span class=\"line\">      menuName: value,</span><br><span class=\"line\">      state: &quot;00A&quot;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    MenuSysService.checkMenuName(params).then(result =&gt; &#123;</span><br><span class=\"line\">      if (!result || !result.resultObject) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      let code = result.resultObject.code;</span><br><span class=\"line\">      if (code &amp;&amp; code &gt; 0) &#123;</span><br><span class=\"line\">        callback(&#x27;系统名称已存在！&#x27;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      callback();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-利用-validator-和正则，验证中文\"><a href=\"#3-利用-validator-和正则，验证中文\" class=\"headerlink\" title=\"3 利用 validator 和正则，验证中文\"></a>3 利用 validator 和正则，验证中文</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;FormItem</span><br><span class=\"line\">        hasFeedback=&#123;!disableFlag&#125;</span><br><span class=\"line\">        labelCol=&#123;&#123; span: 6 &#125;&#125;</span><br><span class=\"line\">        wrapperCol=&#123;&#123; span: 15 &#125;&#125;</span><br><span class=\"line\">        label=&quot;账号&quot; &gt;</span><br><span class=\"line\">        &#123;form.getFieldDecorator(&#x27;userCode&#x27;, &#123;</span><br><span class=\"line\">          initialValue: &#x27;&#x27;,</span><br><span class=\"line\">          rules: [</span><br><span class=\"line\">            &#123; required: !disableFlag, validator: this.usercodeValidator &#125;,</span><br><span class=\"line\">            &#123; type: &#x27;string&#x27;, max: 30, message: &#x27;账号过长&#x27; &#125;,</span><br><span class=\"line\">            &#123; whitespace: true, message: &#x27;内容不能为空&#x27; &#125;</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;)(</span><br><span class=\"line\">          &lt;Input placeholder=&quot;请输入账号&quot; disabled=&#123;account&#125; maxLength=&quot;30&quot; autoComplete=&quot;false&quot; /&gt;)&#125;</span><br><span class=\"line\">&lt;/FormItem&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">usercodeValidator = (rule, value, callback) =&gt; &#123;</span><br><span class=\"line\">    const &#123; userData &#125; = this.props;</span><br><span class=\"line\">    if (!value) &#123;</span><br><span class=\"line\">      callback(&#x27;内容不能为空&#x27;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // ！！！中文验证</span><br><span class=\"line\">    const reg = /[\\u4E00-\\u9FA5]&#123;1,4&#125;/;   /*定义验证表达式*/</span><br><span class=\"line\">    if (reg.test(value)) &#123; /*进行验证*/</span><br><span class=\"line\">      callback(&#x27;账号不能为中文&#x27;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    if (userData.userCode === value) &#123;</span><br><span class=\"line\">      callback();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">      let params = &#123;</span><br><span class=\"line\">        userCode: value + &quot;&quot;,  // 查一下有没有这个编码</span><br><span class=\"line\">        useState: &#x27;10301&#x27;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      SysUserMgService.checkUserCode(params).then(result =&gt; &#123;</span><br><span class=\"line\">        if (!result || result.code !== &#x27;0&#x27;) &#123;</span><br><span class=\"line\">          callback(result.message);</span><br><span class=\"line\">          return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (result.resultObject &amp;&amp; result.resultObject.num !== 0) &#123;</span><br><span class=\"line\">          callback(&#x27;该账号已存在&#x27;);</span><br><span class=\"line\">          return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        callback();</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-form-validateFields-直接获取表单的值\"><a href=\"#4-form-validateFields-直接获取表单的值\" class=\"headerlink\" title=\"4 form.validateFields 直接获取表单的值\"></a>4 form.validateFields 直接获取表单的值</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">this.props.form.validateFields((err, fieldsValue) =&gt; &#123;</span><br><span class=\"line\">     if (err) return;</span><br><span class=\"line\">     this.handleSubmit(fieldsValue);</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-form-表单提交-htmlType，改为-onClick\"><a href=\"#5-form-表单提交-htmlType，改为-onClick\" class=\"headerlink\" title=\"5 form 表单提交 htmlType，改为 onClick\"></a>5 form 表单提交 htmlType，改为 onClick</h2><p>说明：因为之前遇到过使用 htmlType 提交表单会有问题，但是改为 onClick 后，就没问题了，所以，也记录一下。<br>htmlType 是官网使用的方式，具体问题本人当时忘记截个图了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Form layout=&quot;inline&quot; onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class=\"line\">        &lt;FormItem</span><br><span class=\"line\">          validateStatus=&#123;userNameError ? &#x27;error&#x27; : &#x27;&#x27;&#125;</span><br><span class=\"line\">          help=&#123;userNameError || &#x27;&#x27;&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &#123;getFieldDecorator(&#x27;userName&#x27;, &#123;</span><br><span class=\"line\">            rules: [&#123; required: true, message: &#x27;Please input your username!&#x27; &#125;],</span><br><span class=\"line\">          &#125;)(</span><br><span class=\"line\">            &lt;Input prefix=&#123;&lt;Icon type=&quot;user&quot; style=&#123;&#123; color: &#x27;rgba(0,0,0,.25)&#x27; &#125;&#125; /&gt;&#125; placeholder=&quot;Username&quot; /&gt;</span><br><span class=\"line\">          )&#125;</span><br><span class=\"line\">        &lt;/FormItem&gt;</span><br><span class=\"line\">        &lt;FormItem</span><br><span class=\"line\">          validateStatus=&#123;passwordError ? &#x27;error&#x27; : &#x27;&#x27;&#125;</span><br><span class=\"line\">          help=&#123;passwordError || &#x27;&#x27;&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &#123;getFieldDecorator(&#x27;password&#x27;, &#123;</span><br><span class=\"line\">            rules: [&#123; required: true, message: &#x27;Please input your Password!&#x27; &#125;],</span><br><span class=\"line\">          &#125;)(</span><br><span class=\"line\">            &lt;Input prefix=&#123;&lt;Icon type=&quot;lock&quot; style=&#123;&#123; color: &#x27;rgba(0,0,0,.25)&#x27; &#125;&#125; /&gt;&#125; type=&quot;password&quot; placeholder=&quot;Password&quot; /&gt;</span><br><span class=\"line\">          )&#125;</span><br><span class=\"line\">        &lt;/FormItem&gt;</span><br><span class=\"line\">        &lt;FormItem&gt;</span><br><span class=\"line\">          &lt;Button</span><br><span class=\"line\">            type=&quot;primary&quot;</span><br><span class=\"line\">            htmlType=&quot;submit&quot;</span><br><span class=\"line\">            disabled=&#123;hasErrors(getFieldsError())&#125;</span><br><span class=\"line\">          &gt;</span><br><span class=\"line\">            Log in</span><br><span class=\"line\">          &lt;/Button&gt;</span><br><span class=\"line\">        &lt;/FormItem&gt;</span><br><span class=\"line\">      &lt;/Form&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 改变后：</span><br><span class=\"line\">&lt;Form layout=&quot;inline&quot; &gt;</span><br><span class=\"line\">        &lt;FormItem</span><br><span class=\"line\">          validateStatus=&#123;userNameError ? &#x27;error&#x27; : &#x27;&#x27;&#125;</span><br><span class=\"line\">          help=&#123;userNameError || &#x27;&#x27;&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &#123;getFieldDecorator(&#x27;userName&#x27;, &#123;</span><br><span class=\"line\">            rules: [&#123; required: true, message: &#x27;Please input your username!&#x27; &#125;],</span><br><span class=\"line\">          &#125;)(</span><br><span class=\"line\">            &lt;Input prefix=&#123;&lt;Icon type=&quot;user&quot; style=&#123;&#123; color: &#x27;rgba(0,0,0,.25)&#x27; &#125;&#125; /&gt;&#125; placeholder=&quot;Username&quot; /&gt;</span><br><span class=\"line\">          )&#125;</span><br><span class=\"line\">        &lt;/FormItem&gt;</span><br><span class=\"line\">        &lt;FormItem</span><br><span class=\"line\">          validateStatus=&#123;passwordError ? &#x27;error&#x27; : &#x27;&#x27;&#125;</span><br><span class=\"line\">          help=&#123;passwordError || &#x27;&#x27;&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &#123;getFieldDecorator(&#x27;password&#x27;, &#123;</span><br><span class=\"line\">            rules: [&#123; required: true, message: &#x27;Please input your Password!&#x27; &#125;],</span><br><span class=\"line\">          &#125;)(</span><br><span class=\"line\">            &lt;Input prefix=&#123;&lt;Icon type=&quot;lock&quot; style=&#123;&#123; color: &#x27;rgba(0,0,0,.25)&#x27; &#125;&#125; /&gt;&#125; type=&quot;password&quot; placeholder=&quot;Password&quot; /&gt;</span><br><span class=\"line\">          )&#125;</span><br><span class=\"line\">        &lt;/FormItem&gt;</span><br><span class=\"line\">        &lt;FormItem&gt;</span><br><span class=\"line\">          &lt;Button</span><br><span class=\"line\">            type=&quot;primary&quot;</span><br><span class=\"line\">            disabled=&#123;hasErrors(getFieldsError())&#125;</span><br><span class=\"line\">            onClick=&#123;() =&gt; this.handleSubmit()&#125;</span><br><span class=\"line\">          &gt;</span><br><span class=\"line\">            Log in</span><br><span class=\"line\">          &lt;/Button&gt;</span><br><span class=\"line\">        &lt;/FormItem&gt;</span><br><span class=\"line\">      &lt;/Form&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-Input-组件，利用-maxLength-属性，限制最大输入内容长度\"><a href=\"#6-Input-组件，利用-maxLength-属性，限制最大输入内容长度\" class=\"headerlink\" title=\"6 Input 组件，利用 maxLength 属性，限制最大输入内容长度\"></a>6 Input 组件，利用 maxLength 属性，限制最大输入内容长度</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Input</span><br><span class=\"line\">  placeholder=&quot;请输入账号&quot;</span><br><span class=\"line\">  disabled=&#123;account&#125;</span><br><span class=\"line\">  maxLength=&quot;30&quot;</span><br><span class=\"line\">  autoComplete=&quot;off&quot;</span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-InputNumber-只能输入数字：\"><a href=\"#7-InputNumber-只能输入数字：\" class=\"headerlink\" title=\"7 InputNumber 只能输入数字：\"></a>7 InputNumber 只能输入数字：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;InputNumber</span><br><span class=\"line\">     formatter=&#123;value =&gt; value&#125;</span><br><span class=\"line\">     parser=&#123;value =&gt; parseInt(value) || &#x27;&#x27;&#125;</span><br><span class=\"line\">     style=&#123;&#123; width: &#x27;100%&#x27; &#125;&#125;</span><br><span class=\"line\">     step=&#123;1&#125;</span><br><span class=\"line\">     onChange=&#123;(val) =&gt; this.onChangeIpt(1, val)&#125;</span><br><span class=\"line\"> /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-menu-实现回缩效果注意点\"><a href=\"#8-menu-实现回缩效果注意点\" class=\"headerlink\" title=\"8 menu 实现回缩效果注意点\"></a>8 menu 实现回缩效果注意点</h2><p>说明：menu 必须放在 Sider 中，才能实现缩回去的，这个有特定的布局。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Sider</span><br><span class=\"line\">  style=&#123;&#123; background: &#x27;#1D2023&#x27;, height: &#x27;100%&#x27; &#125;&#125;</span><br><span class=\"line\">  trigger=&#123;null&#125;</span><br><span class=\"line\">  collapsible</span><br><span class=\"line\">  collapsed=&#123;this.state.collapsed&#125;</span><br><span class=\"line\">  width=&#123;140&#125;</span><br><span class=\"line\">  collapsedWidth=&#123;40&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">    &lt;BaseMenu</span><br><span class=\"line\">       toggle=&#123;this.toggle&#125;</span><br><span class=\"line\">       collapsed=&#123;this.state.collapsed&#125;</span><br><span class=\"line\">       history=&#123;history&#125;</span><br><span class=\"line\">       location=&#123;location&#125;</span><br><span class=\"line\">     /&gt;</span><br><span class=\"line\">&lt;/Sider&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-左侧菜单调整宽度设置\"><a href=\"#9-左侧菜单调整宽度设置\" class=\"headerlink\" title=\"9 左侧菜单调整宽度设置\"></a>9 左侧菜单调整宽度设置</h2><p>说明：通过在 Sider 组件，设置 width，调整菜单的宽度，通过设置 collapsedWidth，调整缩进的宽度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Sider</span><br><span class=\"line\">  style=&#123;&#123; background: &#x27;#1D2023&#x27;, height: &#x27;100%&#x27; &#125;&#125;</span><br><span class=\"line\">  trigger=&#123;null&#125;</span><br><span class=\"line\">  collapsible</span><br><span class=\"line\">  collapsed=&#123;this.state.collapsed&#125;</span><br><span class=\"line\">  width=&#123;140&#125;</span><br><span class=\"line\">  collapsedWidth=&#123;40&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">    &lt;BaseMenu</span><br><span class=\"line\">       toggle=&#123;this.toggle&#125;</span><br><span class=\"line\">       collapsed=&#123;this.state.collapsed&#125;</span><br><span class=\"line\">       history=&#123;history&#125;</span><br><span class=\"line\">       location=&#123;location&#125;</span><br><span class=\"line\">     /&gt;</span><br><span class=\"line\">&lt;/Sider&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-表格-Columns-字段-id-页面不展示情况\"><a href=\"#10-表格-Columns-字段-id-页面不展示情况\" class=\"headerlink\" title=\"10 表格 Columns 字段 id 页面不展示情况\"></a>10 表格 Columns 字段 id 页面不展示情况</h2><p>说明：一般而言，表格 Columns 字段 id 是在界面不展示的，但是，对于有些逻辑的处理，又是需要的，可以使用相应样式隐藏的处理方式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">常规展示的情况：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  title: &#x27;序号&#x27;,</span><br><span class=\"line\">  dataIndex: &#x27;algoId&#x27;,</span><br><span class=\"line\">  key: &#x27;algoId&#x27;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">不展示id字段：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  title: &#x27;&#x27;,</span><br><span class=\"line\">  dataIndex: &#x27;algoId&#x27;,</span><br><span class=\"line\">  key: &#x27;algoId&#x27;,</span><br><span class=\"line\">  width: 0,</span><br><span class=\"line\">  render: item =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;span style=&#123;&#123; display: &#x27;none&#x27; &#125;&#125; title=&#123;item&#125;&gt;</span><br><span class=\"line\">        &#123;item&#125;</span><br><span class=\"line\">      &lt;/span&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-自定义-Modal\"><a href=\"#11-自定义-Modal\" class=\"headerlink\" title=\"11 自定义 Modal\"></a>11 自定义 Modal</h2><p>查看元素可知，Modal 是在界面构建完成之后，由 js 控制，动态的添加，所以想事先获取 ant-modal-body 中 DOM 元素的节点是不可能的，但是一般情况也不会去获取它。<br>自定义 Modal，解决上述的问题。</p>\n<p><strong>关键代码</strong>：</p>\n<p>说明：</p>\n<p>1：因为我们使用的是 antd，所以，下面的样式是不需要引入的。这个跟 antd 的 Modal 样式重复。</p>\n<p>2：Modal 的隐藏和显示，是通过控制 class 为 ant-modal-mask 和 ant-modal-wrap 两个 div 的显示和隐藏。</p>\n<ul>\n<li>通过给 ant-modal-mask 的 div，添加另外一个 className：ant-modal-mask-hidden，来控制其隐藏，也可以通过 display 来控制。</li>\n<li>通过给 ant-modal-wrap 设置行内样式 display: none，来控制其隐藏。不过，也可以使用 className，随便都可以。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">界面布局：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div className=&quot;ant-modal-mask&quot; &gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div tabIndex=&quot;-1&quot; className=&quot;ant-modal-wrap &quot; role=&quot;dialog&quot; aria-labelledby=&quot;rcDialogTitle0&quot; style=&#123;&#123;&#125;&#125;&gt;</span><br><span class=\"line\">  &lt;div role=&quot;document&quot; className=&quot;ant-modal&quot; style=&#123;&#123; width: &#x27;920px&#x27; &#125;&#125;&gt;</span><br><span class=\"line\">    &lt;div className=&quot;ant-modal-content&quot;&gt;</span><br><span class=\"line\">      &lt;div className=&quot;ant-modal-header&quot;&gt;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;div className=&quot;ant-modal-body&quot; style=&#123;&#123; background: &#x27;rgb(16, 16, 17)&#x27; &#125;&#125;&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;div tabIndex=&quot;0&quot; style=&#123;&#123; width: &#x27;0px&#x27;, height: &#x27;0px&#x27;, overflow: &#x27;hidden&#x27; &#125;&#125;&gt;</span><br><span class=\"line\">    sentinel</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样式：</span><br><span class=\"line\">.ant-modal-mask &#123; // 遮罩层</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  background-color: rgba(0, 0, 0, 0.65);</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  z-index: 1000;</span><br><span class=\"line\">  filter: alpha(opacity=50);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.ant-modal-wrap &#123;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  overflow: auto;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  z-index: 1000;</span><br><span class=\"line\">  -webkit-overflow-scrolling: touch;</span><br><span class=\"line\">  outline: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.ant-modal &#123;</span><br><span class=\"line\">  font-family: &quot;Chinese Quote&quot;, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;</span><br><span class=\"line\">  font-size: 14px;</span><br><span class=\"line\">  font-variant: tabular-nums;</span><br><span class=\"line\">  line-height: 1.5;</span><br><span class=\"line\">  color: rgba(0, 0, 0, 0.65);</span><br><span class=\"line\">  -webkit-box-sizing: border-box;</span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">  margin: 0;</span><br><span class=\"line\">  padding: 0;</span><br><span class=\"line\">  list-style: none;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  width: 920px;</span><br><span class=\"line\">  margin: 0 auto;</span><br><span class=\"line\">  top: 100px;</span><br><span class=\"line\">  padding-bottom: 24px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-Select-组件清除选框内容\"><a href=\"#12-Select-组件清除选框内容\" class=\"headerlink\" title=\"12 Select 组件清除选框内容\"></a>12 Select 组件清除选框内容</h2><p>通过给 Select 组件新增 allowClear 属性。注意：allowClear 也会触发 onChange 方法，所以，也要单独处理一下，因为 value 和 element 为 undefined。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Select &#123;...this.props&#125; placeholder=&quot;请选择&quot; allowClear=&#123;true&#125; &gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&lt;/Select&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-antd、mobx-注入的顺序\"><a href=\"#13-antd、mobx-注入的顺序\" class=\"headerlink\" title=\"13 antd、mobx @注入的顺序\"></a>13 antd、mobx @注入的顺序</h2><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NjMwMjY1LTNlNmVjMDRjNDg1YTA1MWMucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTAyNS9mb3JtYXQvd2VicA?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>顺序</p>\n<h2 id=\"14-解决-table-组件，-key-警告\"><a href=\"#14-解决-table-组件，-key-警告\" class=\"headerlink\" title=\"14 解决 table 组件， key 警告\"></a>14 解决 table 组件， key 警告</h2><p>一般都是使用 rowkey 方法一解决（后台数据要保证没有重复）；</p>\n<h3 id=\"14-1-方法一：一般都是使用-rowkey-解决（后台数据要保证没有重复）；\"><a href=\"#14-1-方法一：一般都是使用-rowkey-解决（后台数据要保证没有重复）；\" class=\"headerlink\" title=\"14.1 方法一：一般都是使用 rowkey 解决（后台数据要保证没有重复）；\"></a>14.1 方法一：一般都是使用 rowkey 解决（后台数据要保证没有重复）；</h3><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NjMwMjY1LTUyYzkwZGFlODk1ZmQ1NzYucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTczL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>使用 rowKey</p>\n<h3 id=\"14-2-方法二：dataSource-数据新增-key\"><a href=\"#14-2-方法二：dataSource-数据新增-key\" class=\"headerlink\" title=\"14.2 方法二：dataSource 数据新增 key\"></a>14.2 方法二：dataSource 数据新增 key</h3><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NjMwMjY1LWVlNmQ2YjBlMDU1NTIyNTgucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTg4L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>dataSource 数据新增 key</p>\n<h2 id=\"15-Form-create-方式\"><a href=\"#15-Form-create-方式\" class=\"headerlink\" title=\"15 Form.create 方式\"></a>15 Form.create 方式</h2><h3 id=\"15-1-方式一：-注解\"><a href=\"#15-1-方式一：-注解\" class=\"headerlink\" title=\"15.1 方式一：@注解\"></a>15.1 方式一：@注解</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Form.create(&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-2-方式二：高阶写法\"><a href=\"#15-2-方式二：高阶写法\" class=\"headerlink\" title=\"15.2 方式二：高阶写法\"></a>15.2 方式二：高阶写法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default (Form.create(&#123;&#125;)(APP));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"16-Form-initialValue-值编辑后，表单的值不改变问题\"><a href=\"#16-Form-initialValue-值编辑后，表单的值不改变问题\" class=\"headerlink\" title=\"16 Form initialValue 值编辑后，表单的值不改变问题\"></a>16 Form initialValue 值编辑后，表单的值不改变问题</h2><h3 id=\"16-1-方法一\"><a href=\"#16-1-方法一\" class=\"headerlink\" title=\"16.1 方法一\"></a>16.1 方法一</h3><p>其实，只要编辑成功后，回调调用 form.resetFields()，就可以了，如果<br>是使用 modal 框弹出的表单，就可以直接使用 destroyOnClose &#x3D; {true} 属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123; Input, Modal, Form &#125; from &#x27;antd&#x27;;</span><br><span class=\"line\">import styles from &#x27;./UserModal.less&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const FormItem = Form.Item;</span><br><span class=\"line\"></span><br><span class=\"line\">const UserModal = (&#123; currentItem, dispatch, form, visible &#125;) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  function handleOk() &#123;</span><br><span class=\"line\">    form.validateFields((err, fieldsValue) =&gt; &#123;</span><br><span class=\"line\">      if (err) return;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: &#x27;demo/update&#x27;,</span><br><span class=\"line\">        payload: &#123;</span><br><span class=\"line\">          currentItem: fieldsValue</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  function handleCancel() &#123;</span><br><span class=\"line\">    dispatch(&#123;</span><br><span class=\"line\">      type: &#x27;demo/hideModal&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const formItemLayout = &#123;</span><br><span class=\"line\">    labelCol: &#123;</span><br><span class=\"line\">      xs: &#123; span: 24 &#125;,</span><br><span class=\"line\">      sm: &#123; span: 4 &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    wrapperCol: &#123;</span><br><span class=\"line\">      xs: &#123; span: 24 &#125;,</span><br><span class=\"line\">      sm: &#123; span: 20 &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  const &#123; getFieldDecorator &#125; = form;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div className=&#123;styles.root&#125;&gt;</span><br><span class=\"line\">      &lt;Modal</span><br><span class=\"line\">        title=&quot;编辑&quot;</span><br><span class=\"line\">        visible=&#123;visible&#125;</span><br><span class=\"line\">        onOk=&#123;() =&gt; handleOk()&#125;</span><br><span class=\"line\">        onCancel=&#123;() =&gt; handleCancel()&#125;</span><br><span class=\"line\">        destroyOnClose=&#123;true&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;Form&gt;</span><br><span class=\"line\">          &lt;FormItem</span><br><span class=\"line\">            &#123;...formItemLayout&#125;</span><br><span class=\"line\">            label=&quot;用户名&quot;</span><br><span class=\"line\">          &gt;</span><br><span class=\"line\">            &#123;getFieldDecorator(&#x27;name&#x27;, &#123;</span><br><span class=\"line\">              initialValue: currentItem.name,</span><br><span class=\"line\">              rules: [&#123;</span><br><span class=\"line\">                required: true, message: &#x27;Please input your name!&#x27;,</span><br><span class=\"line\">              &#125;],</span><br><span class=\"line\">            &#125;)(</span><br><span class=\"line\">              &lt;Input placeholder=&quot;请输入用户名&quot; /&gt;</span><br><span class=\"line\">            )&#125;</span><br><span class=\"line\">          &lt;/FormItem&gt;</span><br><span class=\"line\">          &lt;FormItem</span><br><span class=\"line\">            &#123;...formItemLayout&#125;</span><br><span class=\"line\">            label=&quot;年龄&quot;</span><br><span class=\"line\">          &gt;</span><br><span class=\"line\">            &#123;getFieldDecorator(&#x27;age&#x27;, &#123;</span><br><span class=\"line\">              initialValue: currentItem.age,</span><br><span class=\"line\">              rules: [&#123;</span><br><span class=\"line\">                required: true, message: &#x27;Please input your age!&#x27;,</span><br><span class=\"line\">              &#125;],</span><br><span class=\"line\">            &#125;)(</span><br><span class=\"line\">              &lt;Input placeholder=&quot;请输入年龄&quot; /&gt;</span><br><span class=\"line\">            )&#125;</span><br><span class=\"line\">          &lt;/FormItem&gt;</span><br><span class=\"line\">          &lt;FormItem</span><br><span class=\"line\">            &#123;...formItemLayout&#125;</span><br><span class=\"line\">            label=&quot;地址&quot;</span><br><span class=\"line\">          &gt;</span><br><span class=\"line\">            &#123;getFieldDecorator(&#x27;address&#x27;, &#123;</span><br><span class=\"line\">              initialValue: currentItem.address,</span><br><span class=\"line\">              rules: [&#123;</span><br><span class=\"line\">                required: true, message: &#x27;Please input your address!&#x27;,</span><br><span class=\"line\">              &#125;],</span><br><span class=\"line\">            &#125;)(</span><br><span class=\"line\">              &lt;Input placeholder=&quot;请输入地址&quot; /&gt;</span><br><span class=\"line\">            )&#125;</span><br><span class=\"line\">          &lt;/FormItem&gt;</span><br><span class=\"line\">        &lt;/Form&gt;</span><br><span class=\"line\">      &lt;/Modal&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default (Form.create(&#123;&#125;)(UserModal));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">主要代码：destroyOnClose=&#123;true&#125;</span><br><span class=\"line\">&lt;Modal</span><br><span class=\"line\">        title=&quot;编辑&quot;</span><br><span class=\"line\">        visible=&#123;visible&#125;</span><br><span class=\"line\">        onOk=&#123;() =&gt; handleOk()&#125;</span><br><span class=\"line\">        onCancel=&#123;() =&gt; handleCancel()&#125;</span><br><span class=\"line\">        destroyOnClose=&#123;true&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/Modal&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-2-方法二\"><a href=\"#16-2-方法二\" class=\"headerlink\" title=\"16.2 方法二\"></a>16.2 方法二</h3><p>如果是 class 类，可以使用钩子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentDidUpdate = (prevProps, prevState) =&gt; &#123;</span><br><span class=\"line\">  if (!prevProps.visible) &#123;</span><br><span class=\"line\">    prevProps.form.resetFields();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>代码参考：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123; Input, Modal, Form &#125; from &#x27;antd&#x27;;</span><br><span class=\"line\">import styles from &#x27;./UserModal.less&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const FormItem = Form.Item;</span><br><span class=\"line\"></span><br><span class=\"line\">@Form.create(&#123;&#125;)</span><br><span class=\"line\">class UserModal extends React.PureComponent &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidUpdate = (prevProps, prevState) =&gt; &#123;</span><br><span class=\"line\">    if (!prevProps.visible) &#123;</span><br><span class=\"line\">      prevProps.form.resetFields();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleOk = () =&gt; &#123;</span><br><span class=\"line\">    const &#123; dispatch, form &#125; = this.props;</span><br><span class=\"line\">    form.validateFields((err, fieldsValue) =&gt; &#123;</span><br><span class=\"line\">      if (err) return;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: &#x27;demo/update&#x27;,</span><br><span class=\"line\">        payload: &#123;</span><br><span class=\"line\">          currentItem: fieldsValue</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleCancel = () =&gt; &#123;</span><br><span class=\"line\">    const &#123; dispatch &#125; = this.props;</span><br><span class=\"line\">    dispatch(&#123;</span><br><span class=\"line\">      type: &#x27;demo/hideModal&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123; currentItem, form, visible &#125; = this.props;</span><br><span class=\"line\">    const formItemLayout = &#123;</span><br><span class=\"line\">      labelCol: &#123;</span><br><span class=\"line\">        xs: &#123; span: 24 &#125;,</span><br><span class=\"line\">        sm: &#123; span: 4 &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      wrapperCol: &#123;</span><br><span class=\"line\">        xs: &#123; span: 24 &#125;,</span><br><span class=\"line\">        sm: &#123; span: 20 &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    const &#123; getFieldDecorator &#125; = form;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div className=&#123;styles.root&#125;&gt;</span><br><span class=\"line\">        &lt;Modal</span><br><span class=\"line\">          title=&quot;编辑&quot;</span><br><span class=\"line\">          visible=&#123;visible&#125;</span><br><span class=\"line\">          onOk=&#123;() =&gt; this.handleOk()&#125;</span><br><span class=\"line\">          onCancel=&#123;() =&gt; this.handleCancel()&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &lt;Form&gt;</span><br><span class=\"line\">            &lt;FormItem</span><br><span class=\"line\">              &#123;...formItemLayout&#125;</span><br><span class=\"line\">              label=&quot;用户名&quot;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">              &#123;getFieldDecorator(&#x27;name&#x27;, &#123;</span><br><span class=\"line\">                initialValue: currentItem.name,</span><br><span class=\"line\">                rules: [&#123;</span><br><span class=\"line\">                  required: true, message: &#x27;Please input your name!&#x27;,</span><br><span class=\"line\">                &#125;],</span><br><span class=\"line\">              &#125;)(</span><br><span class=\"line\">                &lt;Input placeholder=&quot;请输入用户名&quot; /&gt;</span><br><span class=\"line\">              )&#125;</span><br><span class=\"line\">            &lt;/FormItem&gt;</span><br><span class=\"line\">            &lt;FormItem</span><br><span class=\"line\">              &#123;...formItemLayout&#125;</span><br><span class=\"line\">              label=&quot;年龄&quot;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">              &#123;getFieldDecorator(&#x27;age&#x27;, &#123;</span><br><span class=\"line\">                initialValue: currentItem.age,</span><br><span class=\"line\">                rules: [&#123;</span><br><span class=\"line\">                  required: true, message: &#x27;Please input your age!&#x27;,</span><br><span class=\"line\">                &#125;],</span><br><span class=\"line\">              &#125;)(</span><br><span class=\"line\">                &lt;Input placeholder=&quot;请输入年龄&quot; /&gt;</span><br><span class=\"line\">              )&#125;</span><br><span class=\"line\">            &lt;/FormItem&gt;</span><br><span class=\"line\">            &lt;FormItem</span><br><span class=\"line\">              &#123;...formItemLayout&#125;</span><br><span class=\"line\">              label=&quot;地址&quot;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">              &#123;getFieldDecorator(&#x27;address&#x27;, &#123;</span><br><span class=\"line\">                initialValue: currentItem.address,</span><br><span class=\"line\">                rules: [&#123;</span><br><span class=\"line\">                  required: true, message: &#x27;Please input your address!&#x27;,</span><br><span class=\"line\">                &#125;],</span><br><span class=\"line\">              &#125;)(</span><br><span class=\"line\">                &lt;Input placeholder=&quot;请输入地址&quot; /&gt;</span><br><span class=\"line\">              )&#125;</span><br><span class=\"line\">            &lt;/FormItem&gt;</span><br><span class=\"line\">          &lt;/Form&gt;</span><br><span class=\"line\">        &lt;/Modal&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default UserModal;</span><br><span class=\"line\">// export default (Form.create(&#123;&#125;)(UserModal));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"17-Modal-是否显示-footer-底部按钮\"><a href=\"#17-Modal-是否显示-footer-底部按钮\" class=\"headerlink\" title=\"17 Modal 是否显示 footer 底部按钮\"></a>17 Modal 是否显示 footer 底部按钮</h2><p>一般应用场景，详情不需要底部按钮，新增和修改需要。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NjMwMjY1LWMwNjAwNDJmZWQ3OWE3MmMucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>api</p>\n<p><strong>解决：</strong></p>\n<p>通过父组件传递一个空的字符串或者 {footer: null} 给 Modal 组件进行属性解构。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NjMwMjY1LWE5OTcyZWQxNjhkY2MwYTQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNzU3L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>父组件需要传入的值</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NjMwMjY1LTc4YmY4NDZlOGZjNTFjOWIucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>子组件 Modal</p>\n<h2 id=\"18-有-connect-和-Form-表单\"><a href=\"#18-有-connect-和-Form-表单\" class=\"headerlink\" title=\"18 有 connect 和 Form 表单\"></a>18 有 connect 和 Form 表单</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function mapStateToProps(&#123; onlineCamera &#125;) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    favorites: onlineCamera.favorites,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default connect(mapStateToProps)(Form.create()(TreeModal));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"19-Tree-树组件增加右键菜单\"><a href=\"#19-Tree-树组件增加右键菜单\" class=\"headerlink\" title=\"19 Tree 树组件增加右键菜单\"></a>19 Tree 树组件增加右键菜单</h2><p>参考：<br><a href=\"https://github.com/ant-design/ant-design/issues/5151\">https://github.com/ant-design/ant-design/issues/5151</a></p>\n<p>关键代码：</p>\n<blockquote>\n<Tree onRightClick={this.treeNodeonRightClick} >\n</blockquote>\n<p>&#x2F;&#x2F; 实现这个方法 treeNodeonRightClick</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">treeNodeonRightClick(e) &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            rightClickNodeTreeItem: &#123;</span><br><span class=\"line\">                pageX: e.event.pageX,</span><br><span class=\"line\">                pageY: e.event.pageY,</span><br><span class=\"line\">                id: e.node.props[&#x27;data-key&#x27;],</span><br><span class=\"line\">                categoryName: e.node.props[&#x27;data-title&#x27;]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>&#x2F;&#x2F; id 和 categoryName 是生成时绑上去的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;TreeNode</span><br><span class=\"line\">                        key=&#123;item.id&#125;</span><br><span class=\"line\">                        title=&#123;title&#125;</span><br><span class=\"line\">                        data-key=&#123;item.id&#125;</span><br><span class=\"line\">                        data-title=&#123;item.categoryName&#125;</span><br><span class=\"line\">                    /&gt;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>&#x2F;&#x2F; 最后绑个菜单就可以实现了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getNodeTreeRightClickMenu() &#123;</span><br><span class=\"line\">        const &#123;pageX, pageY&#125; = &#123;...this.state.rightClickNodeTreeItem&#125;;</span><br><span class=\"line\">        const tmpStyle = &#123;</span><br><span class=\"line\">            position: &#x27;absolute&#x27;,</span><br><span class=\"line\">            left: `$&#123;pageX - 220&#125;px`,</span><br><span class=\"line\">            top: `$&#123;pageY - 70&#125;px`</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        const menu = (</span><br><span class=\"line\">            &lt;Menu</span><br><span class=\"line\">                onClick=&#123;this.handleMenuClick&#125;</span><br><span class=\"line\">                style=&#123;tmpStyle&#125;</span><br><span class=\"line\">                className=&#123;style.categs_tree_rightmenu&#125;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">                &lt;Menu.Item key=&#x27;1&#x27;&gt;&lt;Icon type=&#x27;plus-circle&#x27;/&gt;&#123;&#x27;加同级&#x27;&#125;&lt;/Menu.Item&gt;</span><br><span class=\"line\">                &lt;Menu.Item key=&#x27;2&#x27;&gt;&lt;Icon type=&#x27;plus-circle-o&#x27;/&gt;&#123;&#x27;加下级&#x27;&#125;&lt;/Menu.Item&gt;</span><br><span class=\"line\">                &lt;Menu.Item key=&#x27;4&#x27;&gt;&lt;Icon type=&#x27;edit&#x27;/&gt;&#123;&#x27;修改&#x27;&#125;&lt;/Menu.Item&gt;</span><br><span class=\"line\">                &lt;Menu.Item key=&#x27;3&#x27;&gt;&lt;Icon type=&#x27;minus-circle-o&#x27;/&gt;&#123;&#x27;删除目录&#x27;&#125;&lt;/Menu.Item&gt;</span><br><span class=\"line\">            &lt;/Menu&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">        return (this.state.rightClickNodeTreeItem == null) ? &#x27;&#x27; : menu;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>getNodeTreeRightClickMenu 方法放在 render 中：</p>\n<p>getNodeTreeRightClickMenu 方法是放在生成主界面的方法里（ render ），因为每一次 state 的变化后，render 方法都会执行，所以变一下任意的 this.state 里面的状态，就会执行 render 方法 ，这样 getNodeTreeRightClickMenu 方法放在 render 方法里来生成界面的一部分。就可以了</p>\n<p><strong>项目中实现关键代码：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * @Author: lin.zehong</span><br><span class=\"line\"> * @Date: 2018-12-02 22:13:59</span><br><span class=\"line\"> * @Last Modified by: lin.zehong</span><br><span class=\"line\"> * @Last Modified time: 2018-12-19 16:36:27</span><br><span class=\"line\"> * @Desc: 收藏夹--树</span><br><span class=\"line\"> */</span><br><span class=\"line\">import React from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123; connect &#125; from &#x27;dva&#x27;;</span><br><span class=\"line\">import &#123; Tree, Menu &#125; from &#x27;antd&#x27;;</span><br><span class=\"line\">import Zcon from &#x27;zteui-icon&#x27;;</span><br><span class=\"line\">import styles from &#x27;./TreeCollect.less&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; TreeNode &#125; = Tree;</span><br><span class=\"line\"></span><br><span class=\"line\">class TreeCollect extends React.Component &#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    expandedKeys: [&#x27;-1&#x27;],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 树节点右键事件</span><br><span class=\"line\">  treeNodeonRightClick = (&#123; event, node &#125;) =&gt; &#123;</span><br><span class=\"line\">    event.persist();</span><br><span class=\"line\">    const &#123; offsetLeft, _isCollapsed &#125; = this.props;</span><br><span class=\"line\">    const menuWidth = _isCollapsed ? 80 : 200;</span><br><span class=\"line\">    const &#123; favorites, favoritesDetail &#125; = node.props;</span><br><span class=\"line\">    this.changefavorites(favorites);</span><br><span class=\"line\">    const hasChild = !!(favorites &amp;&amp; favorites.scjId); // 收藏夹</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      rightClickNodeTreeItem: &#123;</span><br><span class=\"line\">        pageX: event.pageX - offsetLeft - 16 - menuWidth,</span><br><span class=\"line\">        pageY: event.target.offsetTop + 28,</span><br><span class=\"line\">        key: node.props.eventKey,</span><br><span class=\"line\">        id: node.props.eventKey,</span><br><span class=\"line\">        title: node.props.title,</span><br><span class=\"line\">        favorites,</span><br><span class=\"line\">        favoritesDetail,</span><br><span class=\"line\">        hasChild,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 右键节点页面展示</span><br><span class=\"line\">  getNodeTreeRightClickMenu = () =&gt; &#123;</span><br><span class=\"line\">    const &#123; rightClickNodeTreeItem &#125; = this.state;</span><br><span class=\"line\">    const &#123; pageX, pageY, hasChild, key &#125; = &#123; ...rightClickNodeTreeItem &#125;;</span><br><span class=\"line\">    const tmpStyle = &#123;</span><br><span class=\"line\">      position: &#x27;absolute&#x27;,</span><br><span class=\"line\">      left: `$&#123;pageX&#125;px`,</span><br><span class=\"line\">      top: `$&#123;pageY&#125;px`,</span><br><span class=\"line\">      boxShadow: &#x27;2px 2px 10px #333333&#x27;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    const menuHasNode = (</span><br><span class=\"line\">      &lt;Menu</span><br><span class=\"line\">        onClick=&#123;this.handleMenuClick&#125;</span><br><span class=\"line\">        style=&#123;tmpStyle&#125;</span><br><span class=\"line\">        className=&#123;styles.categs_tree_rightmenu&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;Menu.Item key=&#x27;1&#x27;&gt;自动巡查&lt;/Menu.Item&gt;</span><br><span class=\"line\">        &lt;Menu.Item key=&#x27;2&#x27;&gt;重命名&lt;/Menu.Item&gt;</span><br><span class=\"line\">        &lt;Menu.Item key=&#x27;3&#x27;&gt;添加同级目录&lt;/Menu.Item&gt;</span><br><span class=\"line\">        &lt;Menu.Item key=&#x27;4&#x27;&gt;添加子目录&lt;/Menu.Item&gt;</span><br><span class=\"line\">        &lt;Menu.Item key=&#x27;5&#x27;&gt;删除&lt;/Menu.Item&gt;</span><br><span class=\"line\">      &lt;/Menu&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    const menuRoot = (</span><br><span class=\"line\">      &lt;Menu</span><br><span class=\"line\">        onClick=&#123;this.handleMenuClick&#125;</span><br><span class=\"line\">        style=&#123;tmpStyle&#125;</span><br><span class=\"line\">        className=&#123;styles.categs_tree_rightmenu&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;Menu.Item key=&#x27;1&#x27;&gt;自动巡查&lt;/Menu.Item&gt;</span><br><span class=\"line\">        &lt;Menu.Item key=&#x27;2&#x27;&gt;重命名&lt;/Menu.Item&gt;</span><br><span class=\"line\">        &lt;Menu.Item key=&#x27;4&#x27;&gt;添加子目录&lt;/Menu.Item&gt;</span><br><span class=\"line\">      &lt;/Menu&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    const menuNoNode = (</span><br><span class=\"line\">      &lt;Menu</span><br><span class=\"line\">        onClick=&#123;this.handleMenuClick&#125;</span><br><span class=\"line\">        style=&#123;tmpStyle&#125;</span><br><span class=\"line\">        className=&#123;styles.categs_tree_rightmenu&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;Menu.Item key=&#x27;6&#x27;&gt;取消收藏&lt;/Menu.Item&gt;</span><br><span class=\"line\">      &lt;/Menu&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    const menu = hasChild ? (key === &quot;-1&quot; ? menuRoot : menuHasNode) : menuNoNode;</span><br><span class=\"line\"></span><br><span class=\"line\">    return (rightClickNodeTreeItem == null) ? &#x27;&#x27; : menu;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 隐藏右键菜单</span><br><span class=\"line\">  hideTreeRight = () =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123; rightClickNodeTreeItem: null &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123; expandedKeys, selectedKeys &#125; = this.state;</span><br><span class=\"line\">    const &#123; isExpand, gData &#125; = this.props;</span><br><span class=\"line\">    const loop = data =&gt; data.map((item) =&gt; &#123;</span><br><span class=\"line\">      if (item.children &amp;&amp; item.favorites) &#123;</span><br><span class=\"line\">        return &lt;TreeNode key=&#123;item.key&#125; icon=&#123;&lt;Zcon type=&quot;thing&quot; /&gt;&#125; title=&#123;item.title&#125; favorites=&#123;item.favorites&#125;&gt;&#123;loop(item.children)&#125;&lt;/TreeNode&gt;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return &lt;TreeNode key=&#123;item.favoritesDetail.sxtxxId&#125; title=&#123;item.title&#125; favoritesDetail=&#123;item.favoritesDetail&#125; /&gt;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div className=&#123;`$&#123;styles.root&#125; $&#123;isExpand ? &#x27;&#x27; : styles.hideTree&#125;`&#125; onClick=&#123;() =&gt; this.hideTreeRight()&#125;&gt;</span><br><span class=\"line\">        &lt;Tree</span><br><span class=\"line\">          showIcon</span><br><span class=\"line\">          className=&quot;draggable-tree&quot;</span><br><span class=\"line\">          defaultExpandedKeys=&#123;expandedKeys&#125;</span><br><span class=\"line\">          selectedKeys=&#123;selectedKeys&#125;</span><br><span class=\"line\">          onRightClick=&#123;this.treeNodeonRightClick&#125;</span><br><span class=\"line\">          onSelect=&#123;this.onSelect&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &#123;loop(gData)&#125;</span><br><span class=\"line\">        &lt;/Tree&gt;</span><br><span class=\"line\">        &#123;this.getNodeTreeRightClickMenu()&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function mapStateToProps(&#123; onlineCamera, publicModel &#125;) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    gData: onlineCamera.collectTree,</span><br><span class=\"line\">    cameraNum: onlineCamera.cameraNum,</span><br><span class=\"line\">    inspectionCamera: onlineCamera.inspectionCamera,</span><br><span class=\"line\">    _isCollapsed: publicModel._isCollapsed,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default connect(mapStateToProps)(TreeCollect);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"20-直接使用-rc-form-库-createForm，与-antd-Form-的-Form-create-设置样式不同\"><a href=\"#20-直接使用-rc-form-库-createForm，与-antd-Form-的-Form-create-设置样式不同\" class=\"headerlink\" title=\"20 直接使用 rc-form 库 createForm，与 antd Form 的 Form.create() 设置样式不同\"></a>20 直接使用 rc-form 库 createForm，与 antd Form 的 Form.create() 设置样式不同</h2><ul>\n<li>使用 antd Form 的 Form.create()</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\">import PropTypes from &#x27;prop-types&#x27;</span><br><span class=\"line\">import &#123; Form, Button &#125; from &#x27;antd&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">class BalloonContent extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123; form &#125; = this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Form</span><br><span class=\"line\">          size=&#x27;medium&#x27;</span><br><span class=\"line\">          className=&#123;Styles.wrapForm&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &lt;Form.Item</span><br><span class=\"line\">            label=&quot;算子输出&quot;</span><br><span class=\"line\">          &gt;</span><br><span class=\"line\">            &#123;form.getFieldDecorator(&#x27;stdioOutput&#x27;, &#123;</span><br><span class=\"line\">              rules: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                  required: true,</span><br><span class=\"line\">                  message: &#x27;输出不能为空&#x27;,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              ],</span><br><span class=\"line\">            &#125;)(&lt;Input /&gt;)&#125;</span><br><span class=\"line\">          &lt;/Form.Item&gt;</span><br><span class=\"line\">        &lt;/Form&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Form.create()(BalloonContent) // !!!</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NjMwMjY1LTVhZDlkYTIxNGY3YWZmZTEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMzQ1L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>结果样式</p>\n<ul>\n<li>直接使用 rc-form 库 createForm</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\">import PropTypes from &#x27;prop-types&#x27;</span><br><span class=\"line\">import &#123; Form, Button &#125; from &#x27;antd&#x27;</span><br><span class=\"line\">import &#123; createForm &#125; from &#x27;rc-form&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">class BalloonContent extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123; form &#125; = this.props;</span><br><span class=\"line\">    const &#123; getFieldDecorator, getFieldError &#125; = form ;</span><br><span class=\"line\">    const stdioOutputError = getFieldError(&#x27;stdioOutput&#x27;); // !!!</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Form</span><br><span class=\"line\">          size=&#x27;medium&#x27;</span><br><span class=\"line\">          className=&#123;Styles.wrapForm&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &lt;Form.Item</span><br><span class=\"line\">            label=&quot;算子输出&quot;</span><br><span class=\"line\">            required // !!!</span><br><span class=\"line\">            validateState=&#123;stdioOutputError ? &#x27;error&#x27; : &#x27;success&#x27;&#125; // !!!</span><br><span class=\"line\">            help=&#123;stdioOutputError&#125; // !!!</span><br><span class=\"line\">          &gt;</span><br><span class=\"line\">            &#123;form.getFieldDecorator(&#x27;stdioOutput&#x27;, &#123;</span><br><span class=\"line\">              rules: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                  required: true,</span><br><span class=\"line\">                  message: &#x27;输出不能为空&#x27;,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              ],</span><br><span class=\"line\">            &#125;)(&lt;Input /&gt;)&#125;</span><br><span class=\"line\">          &lt;/Form.Item&gt;</span><br><span class=\"line\">        &lt;/Form&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default createForm ()(BalloonContent) // !!!</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NjMwMjY1LWRhOTIwYzUzMzk4N2FkZDIucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMzQyL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>结果</p>\n<h2 id=\"21-Form-表单实时校验-debounce-应用，和不同字段相互校验影响\"><a href=\"#21-Form-表单实时校验-debounce-应用，和不同字段相互校验影响\" class=\"headerlink\" title=\"21 Form 表单实时校验 _.debounce 应用，和不同字段相互校验影响\"></a>21 Form 表单实时校验 _.debounce 应用，和不同字段相互校验影响</h2><p>例如：表单字段，密码和确认密码，改变 Password，如果与 Confirm Password 不一致，也会在 Confirm Password 做提示：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NjMwMjY1LWEzZDhhNDljYzdlMGY0ZWIucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNjgwL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">官网示例：注册新用户，主要代码</span><br><span class=\"line\"></span><br><span class=\"line\">compareToFirstPassword = (rule, value, callback) =&gt; &#123;</span><br><span class=\"line\">  const &#123; form &#125; = this.props;</span><br><span class=\"line\">  if (value &amp;&amp; value !== form.getFieldValue(&#x27;password&#x27;)) &#123;</span><br><span class=\"line\">    callback(&#x27;Two passwords that you enter is inconsistent!&#x27;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">validateToNextPassword = (rule, value, callback) =&gt; &#123;</span><br><span class=\"line\">  const &#123; form &#125; = this.props;</span><br><span class=\"line\">  if (value &amp;&amp; this.state.confirmDirty) &#123;</span><br><span class=\"line\">    form.validateFields([&#x27;confirm&#x27;], &#123; force: true &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  callback();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Form.Item label=&quot;Password&quot; hasFeedback&gt;</span><br><span class=\"line\">  &#123;getFieldDecorator(&#x27;password&#x27;, &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        required: true,</span><br><span class=\"line\">        message: &#x27;Please input your password!&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        validator: this.validateToNextPassword,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;)(&lt;Input.Password /&gt;)&#125;</span><br><span class=\"line\">&lt;/Form.Item&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Form.Item label=&quot;Confirm Password&quot; hasFeedback&gt;</span><br><span class=\"line\">  &#123;getFieldDecorator(&#x27;confirm&#x27;, &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        required: true,</span><br><span class=\"line\">        message: &#x27;Please confirm your password!&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        validator: this.compareToFirstPassword,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;)(&lt;Input.Password onBlur=&#123;this.handleConfirmBlur&#125; /&gt;)&#125;</span><br><span class=\"line\">&lt;/Form.Item&gt;</span><br></pre></td></tr></table></figure>\n\n<p>实际项目例子，选择所属数据库，校验表名：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NjMwMjY1LTFiZWYyNjBiMzY0NTkwYjQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTgxL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">主要代码：</span><br><span class=\"line\"></span><br><span class=\"line\">import _ from &quot;lodash&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写入新表，选择数据库，需要校验已有的表名</span><br><span class=\"line\">validateToTableName = (rule, value, callback) =&gt; &#123;</span><br><span class=\"line\">  const &#123; form: &#123; getFieldValue, validateFields &#125;&#125; = this.props;</span><br><span class=\"line\">  const targetTableCode = getFieldValue(&quot;targetTableCode&quot;);</span><br><span class=\"line\">  if (targetTableCode) &#123;</span><br><span class=\"line\">    validateFields([&#x27;targetTableCode&#x27;], &#123; force: true &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  callback();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写入新表，校验表名</span><br><span class=\"line\">// eslint-disable-next-line</span><br><span class=\"line\">validateTableExist = _.debounce((rule, value, callback) =&gt; &#123;</span><br><span class=\"line\">  const &#123; form: &#123; getFieldValue &#125;, dispatch &#125; = this.props;</span><br><span class=\"line\">  const targetDataSource = getFieldValue(&quot;targetDataSource&quot;);</span><br><span class=\"line\">  const targetTableCode = getFieldValue(&quot;targetTableCode&quot;);</span><br><span class=\"line\">  dispatch(&#123;</span><br><span class=\"line\">    type: &quot;applyDetail/tableExist&quot;,</span><br><span class=\"line\">    payload: &#123;</span><br><span class=\"line\">      dataSourceCode: targetDataSource,</span><br><span class=\"line\">      table: targetTableCode,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;).then(result =&gt; &#123;</span><br><span class=\"line\">    if (result) &#123;</span><br><span class=\"line\">      callback(&quot;该表名已存在&quot;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      callback();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;, 500);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Form.Item label=&quot;所属数据库&quot;&gt;</span><br><span class=\"line\">  &#123;getFieldDecorator(&quot;targetDataSource&quot;, &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        required: true,</span><br><span class=\"line\">        message: &quot;请选择所属数据库&quot;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        validator: this.validateToTableName, // ！！！</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    initialValue:</span><br><span class=\"line\">      exchangeFormat.targetDataSource ||</span><br><span class=\"line\">      (dataSourceList.length &gt; 0</span><br><span class=\"line\">        ? dataSourceList[0].code</span><br><span class=\"line\">        : undefined),</span><br><span class=\"line\">  &#125;)(dataBaseComponent(&#123; className: styles.formInput &#125;))&#125;</span><br><span class=\"line\">&lt;/Form.Item&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Form.Item label=&quot;表名&quot;&gt;</span><br><span class=\"line\">  &#123;getFieldDecorator(&quot;targetTableCode&quot;, &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        required: true,</span><br><span class=\"line\">        message: &quot;请输入新表表名&quot;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        pattern: checkBackEndTableName,</span><br><span class=\"line\">        message: &quot;只支持英文字母、数字、英文格式、下划线&quot;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        validator: this.validateTableExist, // ！！！</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    initialValue:</span><br><span class=\"line\">      (exchangeFormat.formatType === WRITE_IN_NEW_TABLE</span><br><span class=\"line\">        ? exchangeFormat.targetTableCode</span><br><span class=\"line\">        : undefined) || undefined,</span><br><span class=\"line\">  &#125;)(</span><br><span class=\"line\">    &lt;Input</span><br><span class=\"line\">      className=&#123;styles.formInput&#125;</span><br><span class=\"line\">      disabled=&#123;disabled&#125;</span><br><span class=\"line\">      placeholder=&quot;请输入&quot;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  )&#125;</span><br><span class=\"line\">&lt;/Form.Item&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"22-Form-组件方法-getFieldsValue-获取自定义组件的值\"><a href=\"#22-Form-组件方法-getFieldsValue-获取自定义组件的值\" class=\"headerlink\" title=\"22 Form 组件方法 getFieldsValue 获取自定义组件的值\"></a>22 Form 组件方法 getFieldsValue 获取自定义组件的值</h2><p>项目实例：对 antd RangePicker 抽取完独立组件后，form 表单获取不到值</p>\n<p>自定义组件被 getFieldsValue 包裹，会获得以下属性：</p>\n<p>onChange 方法, 子组件调用此方法，可将值传给父组件，从而 Form 可拿到自定义组件的值 value 属性，获得初始值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Form.Item label=&quot;发送时间&quot;&gt;</span><br><span class=\"line\">  &#123;getFieldDecorator(&#x27;range-time-picker&#x27;, &#123;</span><br><span class=\"line\">    rules: [&#123; required: false, message: &#x27;请输入开始时间-结束时间&#x27; &#125;],</span><br><span class=\"line\">  &#125;)(</span><br><span class=\"line\">    &lt;RangePickerPage /&gt;</span><br><span class=\"line\">  )&#125;</span><br><span class=\"line\">&lt;/Form.Item&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面是对 antd RangePicker 进行封装，通过组件 RangePicker 本身的 onChange 方法，调用 this.props.onChange（子组件不用传 onChange 方法，自定义组件被 getFieldsValue 包裹，会自动获取 onChage 属性），则通过 form.validateFields 可以获取到值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * Author: lin.zehong</span><br><span class=\"line\"> * Date: 2019-10-04 09:14:52</span><br><span class=\"line\"> * Last Modified by:   lin.zehong</span><br><span class=\"line\"> * Last Modified time: 2019-10-04 09:14:52</span><br><span class=\"line\"> * Desc: 对 antd RangePicker 进行封装</span><br><span class=\"line\"> */</span><br><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import moment from &quot;moment&quot;;</span><br><span class=\"line\">import &#123; DatePicker &#125; from &quot;antd&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; RangePicker &#125; = DatePicker;</span><br><span class=\"line\"></span><br><span class=\"line\">class RangePickerPage extends React.Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  range = (start, end) =&gt; &#123;</span><br><span class=\"line\">    const result = [];</span><br><span class=\"line\">    for (let i = start; i &lt; end; i += 1) &#123;</span><br><span class=\"line\">      result.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  disabledDate = (current) =&gt; &#123;</span><br><span class=\"line\">    // Can not select days before today and today</span><br><span class=\"line\">    return current &amp;&amp; current &lt; moment().endOf(&#x27;day&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  disabledRangeTime = (_, type) =&gt; &#123;</span><br><span class=\"line\">    if (type === &#x27;start&#x27;) &#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        disabledHours: () =&gt; this.range(0, 60).splice(4, 20),</span><br><span class=\"line\">        disabledMinutes: () =&gt; this.range(30, 60),</span><br><span class=\"line\">        disabledSeconds: () =&gt; [55, 56],</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      disabledHours: () =&gt; this.range(0, 60).splice(20, 4),</span><br><span class=\"line\">      disabledMinutes: () =&gt; this.range(0, 31),</span><br><span class=\"line\">      disabledSeconds: () =&gt; [55, 56],</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  onChange = (dates, dateStrings) =&gt; &#123;</span><br><span class=\"line\">    const &#123; onChange &#125; = this.props;  // ！！！</span><br><span class=\"line\">    onChange(dateStrings);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;RangePicker</span><br><span class=\"line\">        allowClear</span><br><span class=\"line\">        disabledDate=&#123;this.disabledDate&#125;</span><br><span class=\"line\">        disabledTime=&#123;this.disabledRangeTime&#125;</span><br><span class=\"line\">        showTime=&#123;&#123;</span><br><span class=\"line\">          hideDisabledOptions: true,</span><br><span class=\"line\">          defaultValue: [moment(&#x27;00:00:00&#x27;, &#x27;HH:mm:ss&#x27;), moment(&#x27;11:59:59&#x27;, &#x27;HH:mm:ss&#x27;)],</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">        format=&quot;YYYY-MM-DD HH:mm:ss&quot;</span><br><span class=\"line\">        onChange=&#123;this.onChange&#125; // ！！！</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default RangePickerPage;</span><br></pre></td></tr></table></figure>\n\n<p>参考：<a href=\"https://juejin.im/post/5c9c6c08e51d4503e514eaac\">https://juejin.im/post/5c9c6c08e51d4503e514eaac</a></p>\n<h2 id=\"23-Form-表单清空和重置的区别以及方法\"><a href=\"#23-Form-表单清空和重置的区别以及方法\" class=\"headerlink\" title=\"23 Form 表单清空和重置的区别以及方法\"></a>23 Form 表单清空和重置的区别以及方法</h2><p>这里首先需要明确，清空和重置是不同的概念，清空是把内容都清空掉，而重置是恢复 form 表单初始值。</p>\n<p>例如：新增功能，清空和重置就是一样的效果，而对于编辑，清空就是把初始值都清空掉，重置就是恢复刚开始的初始值。</p>\n<ul>\n<li>清空</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">form.setFieldsValue(&#123;&quot;fieldName&quot;: &quot;&quot;&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重置</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">form.resetFields();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"24-DatePicker-组件，部分日期-x2F-时间为可选\"><a href=\"#24-DatePicker-组件，部分日期-x2F-时间为可选\" class=\"headerlink\" title=\"24 DatePicker 组件，部分日期&#x2F;时间为可选\"></a>24 DatePicker 组件，部分日期&#x2F;时间为可选</h2><h3 id=\"24-1-不能选择今天之前的日期，包括今天的日期也不可以选择\"><a href=\"#24-1-不能选择今天之前的日期，包括今天的日期也不可以选择\" class=\"headerlink\" title=\"24.1 不能选择今天之前的日期，包括今天的日期也不可以选择\"></a>24.1 不能选择今天之前的日期，包括今天的日期也不可以选择</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const disabledDate = (current) =&gt; &#123;</span><br><span class=\"line\">  return current &amp;&amp; current &lt; moment().endOf(&#x27;day&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"24-2-不能选择今天之前的日期，今天日期可以选择\"><a href=\"#24-2-不能选择今天之前的日期，今天日期可以选择\" class=\"headerlink\" title=\"24.2 不能选择今天之前的日期，今天日期可以选择\"></a>24.2 不能选择今天之前的日期，今天日期可以选择</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const disabledDate = (current) =&gt; &#123;</span><br><span class=\"line\">  return current &amp;&amp; current &lt; moment().subtract(1, &#x27;day&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"24-3-当前时间之后的时间点，精确到小时\"><a href=\"#24-3-当前时间之后的时间点，精确到小时\" class=\"headerlink\" title=\"24.3 当前时间之后的时间点，精确到小时\"></a>24.3 当前时间之后的时间点，精确到小时</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const [upgradeTime, setUpgradeTime] = useState(moment(&#x27;00:00:00&#x27;, &#x27;HH:mm:ss&#x27;))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const disabledDate = (current) =&gt; &#123;</span><br><span class=\"line\">  return current &amp;&amp; current &lt; moment().subtract(1, &#x27;day&#x27;); // 今天可以选择</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const disabledDateTime = () =&gt; &#123;</span><br><span class=\"line\">  const hours = moment().hours(); // 0~23</span><br><span class=\"line\">  // 当日只能选择当前时间之后的时间点</span><br><span class=\"line\">  if (upgradeTime.date() === moment().date()) &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      disabledHours: () =&gt; range(0, hours + 1),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Form.Item label=&quot;发送时间&quot;&gt;</span><br><span class=\"line\">  &#123;getFieldDecorator(&#x27;pushTime&#x27;, &#123;</span><br><span class=\"line\">    rules: [&#123; required: false, message: &#x27;请输入发送时间&#x27; &#125;],</span><br><span class=\"line\">    initialValue: record.pushType === 0 ? null :</span><br><span class=\"line\">      (record.pushTime ? moment(record.pushTime, &#x27;YYYY-MM-DD HH:mm:ss&#x27;) : null), // 定时发送才显示时间</span><br><span class=\"line\">  &#125;)(</span><br><span class=\"line\">    &lt;DatePicker</span><br><span class=\"line\">      format=&quot;YYYY-MM-DD HH:mm:ss&quot;</span><br><span class=\"line\">      disabledDate=&#123;disabledDate&#125;</span><br><span class=\"line\">      disabledTime=&#123;disabledDateTime&#125;</span><br><span class=\"line\">      style=&#123;&#123; width: &quot;100%&quot; &#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      onChange=&#123;(timer) =&gt; setUpgradeTime(timer)&#125; // ！！！</span><br><span class=\"line\">      showTime=&#123;&#123; defaultValue: moment(upgradeTime) &#125;&#125; // ！！！</span><br><span class=\"line\">    /&gt;,</span><br><span class=\"line\">  )&#125;</span><br><span class=\"line\">&lt;/Form.Item&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"24-4-当前时间之后的时间点，精确到分\"><a href=\"#24-4-当前时间之后的时间点，精确到分\" class=\"headerlink\" title=\"24.4 当前时间之后的时间点，精确到分\"></a>24.4 当前时间之后的时间点，精确到分</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const [upgradeTime, setUpgradeTime] = useState(moment(&#x27;00:00:00&#x27;, &#x27;HH:mm:ss&#x27;))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const disabledDate = (current) =&gt; &#123;</span><br><span class=\"line\">  return current &amp;&amp; current &lt; moment().subtract(1, &#x27;day&#x27;); // 今天可以选择</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const disabledDateTime = () =&gt; &#123;</span><br><span class=\"line\">  const hours = moment().hours(); // 0~23</span><br><span class=\"line\">  const minutes = moment().minutes(); // 0~59</span><br><span class=\"line\">  // 当日只能选择当前时间之后的时间点</span><br><span class=\"line\">  if (upgradeTime.date() === moment().date()) &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      disabledHours: () =&gt; range(0, hours),</span><br><span class=\"line\">      disabledMinutes: () =&gt; range(0, minutes), // 精确到分</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Form.Item label=&quot;发送时间&quot;&gt;</span><br><span class=\"line\">  &#123;getFieldDecorator(&#x27;pushTime&#x27;, &#123;</span><br><span class=\"line\">    rules: [&#123; required: false, message: &#x27;请输入发送时间&#x27; &#125;],</span><br><span class=\"line\">    initialValue: record.pushType === 0 ? null :</span><br><span class=\"line\">      (record.pushTime ? moment(record.pushTime, &#x27;YYYY-MM-DD HH:mm:ss&#x27;) : null), // 定时发送才显示时间</span><br><span class=\"line\">  &#125;)(</span><br><span class=\"line\">    &lt;DatePicker</span><br><span class=\"line\">      format=&quot;YYYY-MM-DD HH:mm:ss&quot;</span><br><span class=\"line\">      disabledDate=&#123;disabledDate&#125;</span><br><span class=\"line\">      disabledTime=&#123;disabledDateTime&#125;</span><br><span class=\"line\">      style=&#123;&#123; width: &quot;100%&quot; &#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      onChange=&#123;(timer) =&gt; setUpgradeTime(timer)&#125; // ！！！</span><br><span class=\"line\">      showTime=&#123;&#123; defaultValue: moment(upgradeTime) &#125;&#125; // ！！！</span><br><span class=\"line\">    /&gt;,</span><br><span class=\"line\">  )&#125;</span><br><span class=\"line\">&lt;/Form.Item&gt;</span><br></pre></td></tr></table></figure>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"d3.js 参考笔记","url":"/2022/12/16/d3-js-%E5%8F%82%E8%80%83%E7%AC%94%E8%AE%B0/","content":"<h2 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h2><h3 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h3><p>D3 的全称是（Data-Driven Documents），顾名思义可以知道是一个被数据驱动的文档。 一个 JavaScript 的函数库，使用它主要是用来做数据可视化的。</p>\n<h3 id=\"2、数据可视化\"><a href=\"#2、数据可视化\" class=\"headerlink\" title=\"2、数据可视化\"></a>2、数据可视化</h3><p>把枯燥乏味复杂的数据，用简单明了的图形表示出来。</p>\n<h3 id=\"3、地位\"><a href=\"#3、地位\" class=\"headerlink\" title=\"3、地位\"></a>3、地位</h3><p>在关于 2014 年流行的 JavaScript 图形库的调查中 D3 排名第 5，高于 JQuery。</p>\n<h3 id=\"4、D3-使用\"><a href=\"#4、D3-使用\" class=\"headerlink\" title=\"4、D3 使用\"></a>4、D3 使用</h3><p>D3 是一个 JavaScript 函数库，并不需要通常所说的“安装”。它只是一个文件，在 HTML 中引用即可。有两种方法：</p>\n<h4 id=\"（1）下载-D3-js-的文件\"><a href=\"#（1）下载-D3-js-的文件\" class=\"headerlink\" title=\"（1）下载 D3.js 的文件\"></a>（1）下载 D3.js 的文件</h4><p><a href=\"https://github.com/mbostock/d3/releases/download/v3.4.8/d3.zip\">https://github.com/mbostock/d3/releases/download/v3.4.8/d3.zip</a><br>解压后，在 HTML 文件中包含相关的 js 文件即可</p>\n<h4 id=\"（2）还可以直接包含网络的链接，这种方法较简单：\"><a href=\"#（2）还可以直接包含网络的链接，这种方法较简单：\" class=\"headerlink\" title=\"（2）还可以直接包含网络的链接，这种方法较简单：\"></a>（2）还可以直接包含网络的链接，这种方法较简单：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但使用的时候要保持网络连接有效，不能在断网的情况下使用。</p>\n<h3 id=\"5、需要工具\"><a href=\"#5、需要工具\" class=\"headerlink\" title=\"5、需要工具\"></a>5、需要工具</h3><p>制作网页常用的工具即可。</p>\n<ul>\n<li>（1）记事本软件：Notepad++、Editplus、Sublime Text 等，选择自己喜欢的即可。</li>\n<li>（2）浏览器：IE9 以上、Firefox、Chrome 等，推荐用 Chrome 。</li>\n</ul>\n<h2 id=\"二、D3-js-选择，绑定，插入数据\"><a href=\"#二、D3-js-选择，绑定，插入数据\" class=\"headerlink\" title=\"二、D3.js 选择，绑定，插入数据\"></a>二、D3.js 选择，绑定，插入数据</h2><h3 id=\"（一）选择元素\"><a href=\"#（一）选择元素\" class=\"headerlink\" title=\"（一）选择元素\"></a>（一）选择元素</h3><p>在 D3 中，用于 选择元素的函数有两个：</p>\n<h4 id=\"1、-d3-select-：是选择所有指定元素的第一个\"><a href=\"#1、-d3-select-：是选择所有指定元素的第一个\" class=\"headerlink\" title=\"1、 d3.select()：是选择所有指定元素的第一个\"></a>1、 d3.select()：是选择所有指定元素的第一个</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">select(&quot;tag&quot;) 通过元素的标签名称来查找元素</span><br><span class=\"line\">实例：select(&quot;input&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">select(&quot;#id&quot;)通过元素的id来查找元素</span><br><span class=\"line\">实例：select(&quot;#mydiv&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">select(&quot;.myclass&quot;)通过sytle样式来查找元素</span><br><span class=\"line\">select(&quot;.mystyle&quot;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、-d3-selectAll-：是选择指定元素的全部\"><a href=\"#2、-d3-selectAll-：是选择指定元素的全部\" class=\"headerlink\" title=\"2、 d3.selectAll()：是选择指定元素的全部\"></a>2、 d3.selectAll()：是选择指定元素的全部</h4><p>这两个函数返回的结果称为 选择集。<br>例子：</p>\n<ul>\n<li>（1）var body&#x3D;d3.select(“body”);&#x2F;&#x2F; 选择文档中的 body 元素</li>\n<li>（2）var p1&#x3D;body.select(“p”); &#x2F;&#x2F;选择 body 中的第一个 p 元素</li>\n<li>（3）var p &#x3D;body.selectAll(“p”); &#x2F;&#x2F;选择 body 中的所有 p 元素</li>\n<li>（4）var svg&#x3D;body.select(“svg”); &#x2F;&#x2F;选择 body 中的 svg 元素</li>\n<li>（5）var rects&#x3D;svg.selectAll(“rect”); &#x2F;&#x2F;选择 svg 中所有的 rect 元素</li>\n</ul>\n<h3 id=\"（二）绑定数据\"><a href=\"#（二）绑定数据\" class=\"headerlink\" title=\"（二）绑定数据\"></a>（二）绑定数据</h3><p>D3 能将数据绑定到 DOM(文件对象模型)上，也是绑定到 文档上<br>D3 中是通过以下两个函数来绑定数据的：</p>\n<h4 id=\"1、datum-：绑定一个数据到选择集上\"><a href=\"#1、datum-：绑定一个数据到选择集上\" class=\"headerlink\" title=\"1、datum( )：绑定一个数据到选择集上\"></a>1、datum( )：绑定一个数据到选择集上</h4><p><strong>datum()实例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;datum&lt;/title&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">        &lt;body&gt;</span><br><span class=\"line\">        &lt;p&gt;Apple&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;Pear&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;Banana&lt;/p&gt;</span><br><span class=\"line\">            &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">            &lt;script&gt;</span><br><span class=\"line\">            var str = &quot;China&quot;;</span><br><span class=\"line\">            var body = d3.select(&quot;body&quot;);</span><br><span class=\"line\">            var p = body.selectAll(&quot;p&quot;);</span><br><span class=\"line\">            p.datum(str);</span><br><span class=\"line\">            p.text(function(d, i)&#123;</span><br><span class=\"line\">                return &quot;第 &quot;+ i + &quot; 个元素绑定的数据是 &quot; + d;&#125;);</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">        &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">第 0 个元素绑定的数据是 China</span><br><span class=\"line\"></span><br><span class=\"line\">第 1 个元素绑定的数据是 China</span><br><span class=\"line\"></span><br><span class=\"line\">第 2 个元素绑定的数据是 China</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、data-：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定\"><a href=\"#2、data-：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定\" class=\"headerlink\" title=\"2、data( )：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定\"></a>2、data( )：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定</h4><p><strong>data( )实例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;datum&lt;/title&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">        &lt;body&gt;</span><br><span class=\"line\">        &lt;p&gt;Apple&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;Pear&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;Banana&lt;/p&gt;</span><br><span class=\"line\">            &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">            &lt;script&gt;</span><br><span class=\"line\">        var dataset = [&quot;I like dogs&quot;,&quot;I like cats&quot;,&quot;I like snakes&quot;];</span><br><span class=\"line\">        var body = d3.select(&quot;body&quot;);</span><br><span class=\"line\">        var p = body.selectAll(&quot;p&quot;);</span><br><span class=\"line\">        p.data(dataset)</span><br><span class=\"line\">        .text(function(d, i)&#123;</span><br><span class=\"line\">        return d;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">        &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">结果</span><br><span class=\"line\">I like dogs</span><br><span class=\"line\"></span><br><span class=\"line\">I like cats</span><br><span class=\"line\"></span><br><span class=\"line\">I like snakes</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、对于已经绑定了数据的选择集，还有一种选择元素的方法，\"><a href=\"#3、对于已经绑定了数据的选择集，还有一种选择元素的方法，\" class=\"headerlink\" title=\"3、对于已经绑定了数据的选择集，还有一种选择元素的方法，\"></a>3、对于已经绑定了数据的选择集，还有一种选择元素的方法，</h4><p>运用 function(d, i)。<br>参数 i 是代表索引号，可以用条件判定语句来指定执行的元素。</p>\n<h3 id=\"（三）插入元素\"><a href=\"#（三）插入元素\" class=\"headerlink\" title=\"（三）插入元素\"></a>（三）插入元素</h3><h4 id=\"1、append-在选择集末尾插入元素\"><a href=\"#1、append-在选择集末尾插入元素\" class=\"headerlink\" title=\"1、append( ):在选择集末尾插入元素\"></a>1、append( ):在选择集末尾插入元素</h4><p><strong>实例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;append&lt;/title&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">        &lt;body&gt;</span><br><span class=\"line\">        &lt;p&gt;Apple&lt;/p&gt;</span><br><span class=\"line\">        &lt;p id=myid&gt;Pear&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;Banana&lt;/p&gt;</span><br><span class=\"line\">            &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">            &lt;script&gt;</span><br><span class=\"line\">            d3.select(&quot;body&quot;).append(&quot;p&quot;).text(&quot;append p element&quot;);</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">        &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">结果：</span><br><span class=\"line\">Apple</span><br><span class=\"line\"></span><br><span class=\"line\">Pear</span><br><span class=\"line\"></span><br><span class=\"line\">Banana</span><br><span class=\"line\"></span><br><span class=\"line\">append p element</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、insert-：在选择集前面插入元素\"><a href=\"#2、insert-：在选择集前面插入元素\" class=\"headerlink\" title=\"2、insert( )：在选择集前面插入元素\"></a>2、insert( )：在选择集前面插入元素</h4><p><strong>实例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;insert&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;p id=myid&gt;Apple&lt;/p&gt;</span><br><span class=\"line\">    &lt;p &gt;Pear&lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;Banana&lt;/p&gt;</span><br><span class=\"line\">    &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        var body=d3.select(&quot;body&quot;).insert(&quot;p&quot;,&quot;#myid&quot;).text(&quot;insert p element&quot;);</span><br><span class=\"line\">        var p=body.select(&quot;#myid&quot;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">结果：</span><br><span class=\"line\"></span><br><span class=\"line\">insert p element</span><br><span class=\"line\"></span><br><span class=\"line\">Apple</span><br><span class=\"line\"></span><br><span class=\"line\">Pear</span><br><span class=\"line\"></span><br><span class=\"line\">Banana</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、画图\"><a href=\"#三、画图\" class=\"headerlink\" title=\"三、画图\"></a>三、画图</h2><h3 id=\"（一）、画布概述\"><a href=\"#（一）、画布概述\" class=\"headerlink\" title=\"（一）、画布概述\"></a>（一）、画布概述</h3><p>要绘图，首先需要的是一块绘图的“画布”。</p>\n<p>HTML5 提供两种强有力的“画布”：</p>\n<h4 id=\"1、SVG（scalable-vector-graphics）可缩放矢量图形\"><a href=\"#1、SVG（scalable-vector-graphics）可缩放矢量图形\" class=\"headerlink\" title=\"1、SVG（scalable vector graphics）可缩放矢量图形\"></a>1、SVG（scalable vector graphics）可缩放矢量图形</h4><h5 id=\"（1）定义\"><a href=\"#（1）定义\" class=\"headerlink\" title=\"（1）定义\"></a>（1）定义</h5><p>是用于描述二维矢量图形的一种图形格式，是由万维网联盟制定的开放标准。SVG 使用 XML 格式来定义图形，除了 IE8 之前的版本外，绝大部分浏览器都支持 SVG，可将 SVG 文本直接嵌入 HTML 中显示。</p>\n<h5 id=\"（2）特点\"><a href=\"#（2）特点\" class=\"headerlink\" title=\"（2）特点\"></a>（2）特点</h5><p>SVG 绘制的是矢量图，因此对图像进行放大不会失真。<br>基于 XML，可以为每个元素添加 JavaScript 事件处理器。<br>每个图形均视为对象，更改对象的属性，图形也会改变。<br>不适合游戏应用。</p>\n<h4 id=\"2、Canvas-帆布\"><a href=\"#2、Canvas-帆布\" class=\"headerlink\" title=\"2、Canvas 帆布\"></a>2、Canvas 帆布</h4><h6 id=\"（1）定义-1\"><a href=\"#（1）定义-1\" class=\"headerlink\" title=\"（1）定义\"></a>（1）定义</h6><p>Canvas 是通过 JavaScript 来绘制 2D 图形，是 HTML5 中新增的元素。</p>\n<h5 id=\"（2）特点-1\"><a href=\"#（2）特点-1\" class=\"headerlink\" title=\"（2）特点\"></a>（2）特点</h5><p>绘制的是位图，图像放大后会失真。</p>\n<p>不支持事件处理器。</p>\n<p>能够以.png 或.jpg 格式保存图像。</p>\n<p>适合游戏应用。</p>\n<h4 id=\"3、注意\"><a href=\"#3、注意\" class=\"headerlink\" title=\"3、注意\"></a>3、注意</h4><p>D3 虽然没有明文规定一定要在 SVG 中绘图，但是 D3 提供了众多的 SVG 图形的生成器，它们都是只支持 SVG 的。因此，建议使用 SVG 画布。</p>\n<h3 id=\"（二）画布添加\"><a href=\"#（二）画布添加\" class=\"headerlink\" title=\"（二）画布添加\"></a>（二）画布添加</h3><h4 id=\"1、-使用-D3-在-body-元素-中-添加-svg\"><a href=\"#1、-使用-D3-在-body-元素-中-添加-svg\" class=\"headerlink\" title=\"1、 使用 D3 在 body 元素 中 添加 svg\"></a>1、 使用 D3 在 body 元素 中 添加 svg</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var width=300;    //画布的宽度</span><br><span class=\"line\">var height=300;    //画布的高度</span><br><span class=\"line\"></span><br><span class=\"line\">var svg=d3.select(&quot;body&quot;)   //选择文档中的body元素</span><br><span class=\"line\">.append(&quot;svg&quot;);    //添加一个SVG元素</span><br><span class=\"line\">.attr(&quot;width&quot;,width);    //设定宽度</span><br><span class=\"line\">.attr(&quot;height&quot;,height);    //设定高度</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、实例：绘制矩形\"><a href=\"#2、实例：绘制矩形\" class=\"headerlink\" title=\"2、实例：绘制矩形\"></a>2、实例：绘制矩形</h4><p>注意：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）矩形的属性，常用的有四个：</span><br><span class=\"line\">    x：矩形左上角的 x 坐标</span><br><span class=\"line\">    y：矩形左上角的 y 坐标</span><br><span class=\"line\">    width：矩形的宽度</span><br><span class=\"line\">    height：矩形的高度</span><br><span class=\"line\">（2）在 SVG 中，x 轴的正方向是水平向右，y 轴的正方向是垂直向下的。</span><br></pre></td></tr></table></figure>\n\n<p>代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;绘制矩形&lt;/title&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">        &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">        &lt;script&gt;</span><br><span class=\"line\">        var width = 300;    //画布的宽度300</span><br><span class=\"line\">        var height = 300;    //画布的高度300</span><br><span class=\"line\">        var svg = d3.select(&quot;body&quot;)    //选择文档中的body元素</span><br><span class=\"line\">                    .append(&quot;svg&quot;)    //添加一个SVG元素</span><br><span class=\"line\">                    .attr(&quot;width&quot;,width)    //设定宽度</span><br><span class=\"line\">                    .attr(&quot;height&quot;,height);    //设定高度</span><br><span class=\"line\">        var dataset = [ 250 , 210 , 170 , 130 , 90 ];    //数据，表示矩形的宽度</span><br><span class=\"line\">        var rectHeight = 25;    //每个矩形所占的像素高度（包括空白处）</span><br><span class=\"line\">        svg.selectAll(&quot;rect&quot;)</span><br><span class=\"line\">           .data(dataset)    //绑定数组</span><br><span class=\"line\">           .enter()    //指定选择集的enter部分</span><br><span class=\"line\">           .append(&quot;rect&quot;)    //添加足够数量的矩形</span><br><span class=\"line\">           .attr(&quot;x&quot;,20)    //取x 坐标为20</span><br><span class=\"line\">           .attr(&quot;y&quot;,function(d,i)&#123;    //取y坐标</span><br><span class=\"line\">               return i * rectHeight;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .attr(&quot;width&quot;,function(d)&#123;    //设定宽度</span><br><span class=\"line\">               return d;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .attr(&quot;height&quot;,rectHeight-2)    //设定高度</span><br><span class=\"line\">           .attr(&quot;fill&quot;,&quot;steelblue&quot;);    //以铁蓝色满填充矩形</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（三）比例尺\"><a href=\"#（三）比例尺\" class=\"headerlink\" title=\"（三）比例尺\"></a>（三）比例尺</h3><h4 id=\"1-为什么需要比例尺\"><a href=\"#1-为什么需要比例尺\" class=\"headerlink\" title=\"1. 为什么需要比例尺\"></a>1. 为什么需要比例尺</h4><p>var dataset&#x3D;[250,210,170,130,90]<br>绘图时，直接使用 250 给矩形的宽度赋值，即矩形的宽度就是 250 个像素。 此方式非常具有局限性，如果数值过大或过小。</p>\n<p>var dataset_1&#x3D;[2.5,2.1,1.7,1.3,0.9]<br>对以上两个数组，绝不可能用 2.5 个像素来代表矩形的宽度，那样根本看不见；也不可能用 2500 个像素来代表矩形的宽度，因为画布没有那么长 。</p>\n<p>比例尺是 D3 中很重要的一个概念，直接用数值的大小来代表像素不是一种好方法<br>将某一区域的值映射到另一区域，其大小关系不变。这就是比例尺（Scale）。</p>\n<h4 id=\"2、有哪些比例尺\"><a href=\"#2、有哪些比例尺\" class=\"headerlink\" title=\"2、有哪些比例尺\"></a>2、有哪些比例尺</h4><p>在数学中，x 的范围被称为 定义域，y 的范围被称为 值域。<br>D3 中的比例尺，也有定义域和值域，分别被称为 domain 和 range。<br>开发者需要指定 domain 和 range 的范围，如此即可得到一个计算关系。</p>\n<h5 id=\"（1）线性比例尺\"><a href=\"#（1）线性比例尺\" class=\"headerlink\" title=\"（1）线性比例尺\"></a>（1）线性比例尺</h5><p>能将一个连续的区间，映射到另一区间。<br>如： var dataset&#x3D;[1.2, 2.3, 0.9, 1.5, 3.3]<br>将 dataset 中最小的值，映射成 0；将最大的值，映射成 300。<br>实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;线性比例尺&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//将 dataset 中最小的值，映射成 0；将最大的值，映射成 300。</span><br><span class=\"line\">    var dataset=[1.2 , 2.3 , 0.9 , 1.5 , 3.3];</span><br><span class=\"line\"></span><br><span class=\"line\">    var min=d3.min(dataset);</span><br><span class=\"line\">    var max=d3.max(dataset);</span><br><span class=\"line\">    var linear=d3.scale.linear().domain([min,max]).range([0,300]);</span><br><span class=\"line\">    alert(&quot;linear(0.9):&quot;+linear(0.9));</span><br><span class=\"line\">    alert(&quot;linear(2.3):&quot;+linear(2.3));</span><br><span class=\"line\">    alert(&quot;linear(3.3):&quot;+linear(3.3));</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中，d3.scale.linear() 返回一个线性比例尺。<br>domain() 和 range() 分别设定比例尺的定义域和值域。<br>在这里还用到了两个函数，它们经常与比例尺一起出现： d3.max() d3.min()<br>这两个函数能够求数组的最大值和最小值，是 D3 提供的。<br>按照以上代码， 比例尺的定义域 domain 为：[0.9, 3.3] ， 比例尺的值域 range 为：[0, 300] 因此，当输入 0.9 时，返回 0；当输入 3.3 时，返回 300。当输入 2.3 时呢？返回 175，这是按照线性函数的规则计算的。<br>有一点请大家记住： d3.scale.linear() 的返回值，是可以当做函数来使用的。因此，才有这样的用法：linear(0.9)。<br>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">linear(0.9);    //返回 0</span><br><span class=\"line\">linear(2.3);    //返回 175</span><br><span class=\"line\">linear(3.3);    //返回 300</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"（2）序数比例尺\"><a href=\"#（2）序数比例尺\" class=\"headerlink\" title=\"（2）序数比例尺\"></a>（2）序数比例尺</h5><p>用于： 定义域和值域不是连续的。<br>实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;序数比例尺&lt;/title&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">        &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        var index=[0,1,2,3,4];</span><br><span class=\"line\">        var color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;black&quot;];</span><br><span class=\"line\">        var ordinal=d3.scale.ordinal()</span><br><span class=\"line\">                      .domain(index)</span><br><span class=\"line\">                      .range(color);</span><br><span class=\"line\">        alert(ordinal(0));    返回 red</span><br><span class=\"line\">        alert(ordinal(2));    //返回 green</span><br><span class=\"line\">        alert(ordinal(4));    //返回 black</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ordinal(0); //返回 red</span><br><span class=\"line\">ordinal(2); //返回 green</span><br><span class=\"line\">ordinal(4); //返回 black</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-实例：-给柱形图添加比例尺\"><a href=\"#3-实例：-给柱形图添加比例尺\" class=\"headerlink\" title=\"3.实例： 给柱形图添加比例尺\"></a>3.实例： 给柱形图添加比例尺</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;给柱形图添加比例尺&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var width = 300;    //画布的宽度300</span><br><span class=\"line\">    var height = 300;    //画布的高度300</span><br><span class=\"line\">    var svg = d3.select(&quot;body&quot;)                //选择文档中的body元素</span><br><span class=\"line\">                .append(&quot;svg&quot;)                //添加一个svg元素</span><br><span class=\"line\">                .attr(&quot;width&quot;, width)        //设定宽度</span><br><span class=\"line\">                .attr(&quot;height&quot;, height);    //设定高度</span><br><span class=\"line\"></span><br><span class=\"line\">    var dataset=[2.5,2.1,1.7,1.3,0.9];    //数据（表示矩形的宽度）</span><br><span class=\"line\">    var linear=d3.scale.linear()</span><br><span class=\"line\">                 .domain([0,d3.max(dataset)])</span><br><span class=\"line\">                 .range([0,250]);</span><br><span class=\"line\">    var rectHeight = 25;    //每个矩形所占的像素高度(包括空白)</span><br><span class=\"line\">    svg.selectAll(&quot;rect&quot;)</span><br><span class=\"line\">          .data(dataset)</span><br><span class=\"line\">          .enter()    //指定选择集的enter部分</span><br><span class=\"line\">          .append(&quot;rect&quot;)    //添加足够数量的矩形</span><br><span class=\"line\">          .attr(&quot;x&quot;,20)        //取x 坐标为20</span><br><span class=\"line\">          .attr(&quot;y&quot;,function(d,i)&#123;        //取y坐标</span><br><span class=\"line\">                return i * rectHeight;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .attr(&quot;width&quot;,function(d)&#123;    //设定宽度</span><br><span class=\"line\">                   return linear(d);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .attr(&quot;height&quot;,rectHeight-2)    //设定高度</span><br><span class=\"line\">          .attr(&quot;fill&quot;,&quot;steelblue&quot;);    //    以铁蓝色满填充矩形</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（四）坐标轴\"><a href=\"#（四）坐标轴\" class=\"headerlink\" title=\"（四）坐标轴\"></a>（四）坐标轴</h3><h4 id=\"1、定义-1\"><a href=\"#1、定义-1\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h4><p>坐标轴，是可视化图表中经常出现的一种图形，由一些列线段和刻度组成。<br>坐标轴在 SVG 中是没有现成的图形元素的，需要用其他的元素组合构成。<br>D3 提供了坐标轴的组件，如此在 SVG 画布中绘制坐标轴变得像添加一个普通元素一样简单。</p>\n<h4 id=\"2、坐标轴的构成\"><a href=\"#2、坐标轴的构成\" class=\"headerlink\" title=\"2、坐标轴的构成\"></a>2、坐标轴的构成</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">在 SVG 画布的预定义元素里，有六种基本图形：</span><br><span class=\"line\">矩形 &lt;rect&gt;</span><br><span class=\"line\">圆形 &lt;circle&gt;</span><br><span class=\"line\">椭圆 &lt;ellipse&gt;</span><br><span class=\"line\">线段 &lt;line&gt;</span><br><span class=\"line\">折线 &lt;polyline&gt;</span><br><span class=\"line\">多边形 &lt;polygon&gt;</span><br><span class=\"line\">路径 &lt;path&gt;</span><br><span class=\"line\">画布中的所有图形，都是由以上七种元素组成。</span><br></pre></td></tr></table></figure>\n\n<p>实例 1：给矩形增加坐标轴</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;给柱形图添加比例尺&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 设定坐标轴的样式和位置</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.axis path,</span><br><span class=\"line\">.axis line&#123;</span><br><span class=\"line\">    fill: none;</span><br><span class=\"line\">    stroke: black;</span><br><span class=\"line\">    shape-rendering: crispEdges;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.axis text &#123;</span><br><span class=\"line\">    font-family: sans-serif;</span><br><span class=\"line\">    font-size: 11px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var width = 300;    //画布的宽度300</span><br><span class=\"line\">    var height = 300;    //画布的高度300</span><br><span class=\"line\">    var svg = d3.select(&quot;body&quot;)                //选择文档中的body元素</span><br><span class=\"line\">                .append(&quot;svg&quot;)                //添加一个svg元素</span><br><span class=\"line\">                .attr(&quot;width&quot;, width)        //设定宽度</span><br><span class=\"line\">                .attr(&quot;height&quot;, height);    //设定高度</span><br><span class=\"line\"></span><br><span class=\"line\">    var dataset=[2.5,2.1,1.7,1.3,0.9];    //数据（表示矩形的宽度）</span><br><span class=\"line\">    var linear=d3.scale.linear()        //定义比例尺</span><br><span class=\"line\">                 .domain([0,d3.max(dataset)])</span><br><span class=\"line\">                 .range([0,250]);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    var rectHeight = 25;    //每个矩形所占的像素高度(包括空白)</span><br><span class=\"line\">    svg.selectAll(&quot;rect&quot;)</span><br><span class=\"line\">          .data(dataset)</span><br><span class=\"line\">          .enter()    //指定选择集的enter部分</span><br><span class=\"line\">          .append(&quot;rect&quot;)    //添加足够数量的矩形</span><br><span class=\"line\">          .attr(&quot;x&quot;,20)        //取x 坐标为20</span><br><span class=\"line\">          .attr(&quot;y&quot;,function(d,i)&#123;        //取y坐标</span><br><span class=\"line\">                return i * rectHeight;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .attr(&quot;width&quot;,function(d)&#123;    //设定宽度</span><br><span class=\"line\">                   return linear(d);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .attr(&quot;height&quot;,rectHeight-2)    //设定高度</span><br><span class=\"line\">          .attr(&quot;fill&quot;,&quot;steelblue&quot;);    //    以铁蓝色满填充矩形</span><br><span class=\"line\"></span><br><span class=\"line\">       var axis = d3.svg.axis()     //D3 中坐标轴的组件，能够在 SVG 中生成组成坐标轴的元素。</span><br><span class=\"line\">                  .scale(linear) //指定比例尺</span><br><span class=\"line\">                  .orient(&quot;bottom&quot;)//指定刻度的方向bottom 表示在坐标轴的下方显示。</span><br><span class=\"line\">                  .ticks(7);  //指定刻度的数量</span><br><span class=\"line\"></span><br><span class=\"line\">    svg.append(&quot;g&quot;)</span><br><span class=\"line\">       .attr(&quot;class&quot;,&quot;axis&quot;)</span><br><span class=\"line\">       .attr(&quot;transform&quot;,&quot;translate(20,130)&quot;)</span><br><span class=\"line\">       .call(axis);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>实例 2：完整的柱形图<br>一个完整的柱形图包括三个部分：矩形，文字，坐标轴</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;完整的柱形图&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .axis path,</span><br><span class=\"line\">    .axis line&#123;</span><br><span class=\"line\">        fill: none;</span><br><span class=\"line\">        stroke: black;</span><br><span class=\"line\">        shape-rendering: crispEdges;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .axis text &#123;</span><br><span class=\"line\">        font-family: sans-serif;</span><br><span class=\"line\">        font-size: 11px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .MyRect &#123;</span><br><span class=\"line\">        fill: steelblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .MyText &#123;</span><br><span class=\"line\">        fill: white;</span><br><span class=\"line\">        text-anchor: middle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">//1、添加 SVG 画布</span><br><span class=\"line\"></span><br><span class=\"line\">//画布大小</span><br><span class=\"line\">    var width = 400;    //画布的宽度</span><br><span class=\"line\">    var height = 400;    //画布的高度</span><br><span class=\"line\"></span><br><span class=\"line\">//在 body 里添加一个 SVG 画布</span><br><span class=\"line\">    var svg = d3.select(&quot;body&quot;)            //选择文档中的body元素</span><br><span class=\"line\">                .append(&quot;svg&quot;)                //添加一个svg元素</span><br><span class=\"line\">                .attr(&quot;width&quot;, width)        //设定宽度</span><br><span class=\"line\">                .attr(&quot;height&quot;, height);    //设定高度</span><br><span class=\"line\">//画布周边的空白</span><br><span class=\"line\">    var padding=&#123;left:30,right:30,top:20,bottom:20&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//2、定义数据和比例尺</span><br><span class=\"line\"></span><br><span class=\"line\">//定义一个数组</span><br><span class=\"line\">    var dataset = [10, 20, 30, 40, 33, 24, 12, 5];    //数据（表示矩形的宽度）</span><br><span class=\"line\">//X轴的比例尺</span><br><span class=\"line\">    var xScale=d3.scale.ordinal()</span><br><span class=\"line\">        .domain(d3.range(dataset.length))</span><br><span class=\"line\">        .rangeRoundBands([0, width - padding.left - padding.right]);</span><br><span class=\"line\">//Y轴的比例尺</span><br><span class=\"line\">    var yScale=d3.scale.linear()</span><br><span class=\"line\">        .domain([0,d3.max(dataset)])</span><br><span class=\"line\">        .range([height - padding.top - padding.bottom, 0]);</span><br><span class=\"line\"></span><br><span class=\"line\">//3. 定义坐标轴</span><br><span class=\"line\"></span><br><span class=\"line\">//定义X轴</span><br><span class=\"line\">var xAxis=d3.svg.axis()</span><br><span class=\"line\">    .scale(xScale)</span><br><span class=\"line\">    .orient(&quot;bottom&quot;);</span><br><span class=\"line\">//定义Y轴</span><br><span class=\"line\">var yAxis=d3.svg.axis()</span><br><span class=\"line\">    .scale(yAxis)</span><br><span class=\"line\">    .orient(&quot;left&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//矩形之间的空白处</span><br><span class=\"line\">var rectPadding=4</span><br><span class=\"line\"></span><br><span class=\"line\">//添加矩形元素</span><br><span class=\"line\">var rects=svg.selectAll(&quot;MyRect&quot;)</span><br><span class=\"line\">    .data(dataset)</span><br><span class=\"line\">    .enter()</span><br><span class=\"line\">    .append(&quot;rect&quot;)</span><br><span class=\"line\">    .attr(&quot;class&quot;,&quot;MyRect&quot;)</span><br><span class=\"line\">    .attr(&quot;transform&quot;,&quot;translate(&quot;+padding.left+&quot;,&quot;+padding.top+&quot;)&quot;)</span><br><span class=\"line\">    .attr(&quot;x&quot;,function(d,i)&#123;</span><br><span class=\"line\">        return xScale(i)+rectPadding/2;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .attr(&quot;y&quot;,function(d)&#123;</span><br><span class=\"line\">        return yScale(d);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .attr(&quot;width&quot;,xScale.rangeBand()-rectPadding)</span><br><span class=\"line\">    .attr(&quot;height&quot;,function(d)&#123;</span><br><span class=\"line\">        return height - padding.top - padding.bottom - yScale(d);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//4、添加文字元素</span><br><span class=\"line\">var texts = svg.selectAll(&quot;.MyText&quot;)</span><br><span class=\"line\">        .data(dataset)</span><br><span class=\"line\">        .enter()</span><br><span class=\"line\">        .append(&quot;text&quot;)</span><br><span class=\"line\">        .attr(&quot;class&quot;,&quot;MyText&quot;)</span><br><span class=\"line\">        .attr(&quot;transform&quot;,&quot;translate(&quot; + padding.left + &quot;,&quot; + padding.top + &quot;)&quot;)</span><br><span class=\"line\">        .attr(&quot;x&quot;, function(d,i)&#123;</span><br><span class=\"line\">            return xScale(i) + rectPadding/2;</span><br><span class=\"line\">        &#125; )</span><br><span class=\"line\">        .attr(&quot;y&quot;,function(d)&#123;</span><br><span class=\"line\">            return yScale(d);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .attr(&quot;dx&quot;,function()&#123;</span><br><span class=\"line\">            return (xScale.rangeBand() - rectPadding)/2;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .attr(&quot;dy&quot;,function(d)&#123;</span><br><span class=\"line\">            return 20;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .text(function(d)&#123;</span><br><span class=\"line\">            return d;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//5、添加坐标轴的元素</span><br><span class=\"line\"></span><br><span class=\"line\">//添加x轴</span><br><span class=\"line\">svg.append(&quot;g&quot;)</span><br><span class=\"line\">  .attr(&quot;class&quot;,&quot;axis&quot;)</span><br><span class=\"line\">  .attr(&quot;transform&quot;,&quot;translate(&quot; + padding.left + &quot;,&quot; + (height - padding.bottom) + &quot;)&quot;)</span><br><span class=\"line\">  .call(xAxis);</span><br><span class=\"line\">//添加y轴</span><br><span class=\"line\">svg.append(&quot;g&quot;)</span><br><span class=\"line\">  .attr(&quot;class&quot;,&quot;axis&quot;)</span><br><span class=\"line\">  .attr(&quot;transform&quot;,&quot;translate(&quot; + padding.left + &quot;,&quot; + padding.top + &quot;)&quot;)</span><br><span class=\"line\"> .call(yAxis);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（五）让图表动起来\"><a href=\"#（五）让图表动起来\" class=\"headerlink\" title=\"（五）让图表动起来\"></a>（五）让图表动起来</h3><p>D3 支持制作动态的图表。有时候，图表的变化需要缓慢的发生，以便于让用户看清楚变化的过程，也能给用户不小的友好感。</p>\n<h4 id=\"1、什么是动态图\"><a href=\"#1、什么是动态图\" class=\"headerlink\" title=\"1、什么是动态图\"></a>1、什么是动态图</h4><p>动态的图表，是指图表在某 一时间段会发生某种变化，可能是形状、颜色、位置等，而且用户是可以看到变化的过程的。<br>例如，有一个圆，圆心为 (100, 100)。现在我们希望圆的 x 坐标从 100 移到 300，并且移动过程在 2 秒的时间内发生。 这种时候就需要用到动态效果，在 D3 里我们称之为过渡（transition）。</p>\n<h4 id=\"2、实现动态的方法\"><a href=\"#2、实现动态的方法\" class=\"headerlink\" title=\"2、实现动态的方法\"></a>2、实现动态的方法</h4><p>D3 提供了 4 个方法用于实现图形的过渡：从状态 A 变为状态 B。</p>\n<p><strong>1、transition()</strong></p>\n<p>D3 会自动对两种颜色（红色和铁蓝色）之间的颜色值（RGB 值）进行插值计算，得到过渡用的颜色值。我们无需知道中间是怎么计算的，只需要结果即可。</p>\n<ul>\n<li>.attr(“fill”,”red”) &#x2F;&#x2F;初始颜色为红色</li>\n<li>.transition () &#x2F;&#x2F;启动过渡</li>\n<li>.attr(“fill”,”steelblue”) &#x2F;&#x2F;终止颜色为铁蓝色</li>\n</ul>\n<p><strong>2、 duration() 指定过渡的持续时间，单位为毫秒。</strong></p>\n<p><strong>3、 ease()</strong></p>\n<p>指定过渡的方式，常用的有：</p>\n<ul>\n<li>linear：普通的线性变化</li>\n<li>circle：慢慢地到达变换的最终状态</li>\n<li>elastic：带有弹跳的到达最终状态</li>\n<li>bounce：在最终状态处弹跳几次<br>调用时，格式形如： ease(“bounce”)。</li>\n</ul>\n<p><strong>4、 delay() 指定延迟的时间，表示一定时间后才开始转变，单位同样为毫秒。</strong><br>此函数可以对整体指定延迟，也可以对个别指定延迟。</p>\n<p><strong>5、实例：实现简单的动态效果</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;实现简单的动态效果&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">var width = 700;    //画布的宽度300</span><br><span class=\"line\">var height = 700;    //画布的高度300</span><br><span class=\"line\">var svg = d3.select(&quot;body&quot;)                //选择文档中的body元素</span><br><span class=\"line\">            .append(&quot;svg&quot;)                //添加一个svg元素</span><br><span class=\"line\">            .attr(&quot;width&quot;, width)        //设定宽度</span><br><span class=\"line\">            .attr(&quot;height&quot;, height);    //设定高度</span><br><span class=\"line\"></span><br><span class=\"line\">    //圆1</span><br><span class=\"line\"> var circle1=svg.append(&quot;circle&quot;)</span><br><span class=\"line\">    .attr(&quot;cx&quot;,100)</span><br><span class=\"line\">    .attr(&quot;cy&quot;,100)</span><br><span class=\"line\">    .attr(&quot;r&quot;,45)</span><br><span class=\"line\">    .style(&quot;fill&quot;,&quot;green&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //在1秒（1000毫秒）内将圆心坐标由100变为300</span><br><span class=\"line\">circle1.transition()</span><br><span class=\"line\">      .duration(1000)</span><br><span class=\"line\">      .attr(&quot;cx&quot;,300);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">          //圆2</span><br><span class=\"line\">var circle2=svg.append(&quot;circle&quot;)</span><br><span class=\"line\">    .attr(&quot;cx&quot;,100)</span><br><span class=\"line\">    .attr(&quot;cy&quot;,100)</span><br><span class=\"line\">    .attr(&quot;r&quot;,45)</span><br><span class=\"line\">    .style(&quot;fill&quot;,&quot;green&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//在1.5秒（1500毫秒）内将圆心坐标由100变为300，</span><br><span class=\"line\">//将颜色从绿色变为红色</span><br><span class=\"line\">circle2.transition()</span><br><span class=\"line\">      .duration(1500)</span><br><span class=\"line\">      .attr(&quot;cx&quot;,300)</span><br><span class=\"line\">      .style(&quot;fill&quot;,&quot;red&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">          //圆3</span><br><span class=\"line\">var circle3=svg.append(&quot;circle&quot;)</span><br><span class=\"line\">    .attr(&quot;cx&quot;,100)</span><br><span class=\"line\">    .attr(&quot;cy&quot;,100)</span><br><span class=\"line\">    .attr(&quot;r&quot;,45)</span><br><span class=\"line\">    .style(&quot;fill&quot;,&quot;green&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//在2秒（2000毫秒）内将圆心坐标由100变为300</span><br><span class=\"line\">//将颜色从绿色变为红色</span><br><span class=\"line\">//将半径从45变成25</span><br><span class=\"line\">//过渡方式采用bounce（在终点处弹跳几次）</span><br><span class=\"line\">circle3.transition()</span><br><span class=\"line\">       .duration(2000)</span><br><span class=\"line\">       .ease(&quot;bounce&quot;)</span><br><span class=\"line\">       .attr(&quot;cx&quot;,300)</span><br><span class=\"line\">       .style(&quot;fill&quot;,&quot;red&quot;)</span><br><span class=\"line\">       .attr(&quot;r&quot;,25);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>6、实例：给柱形图加上动态效果</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;完整的柱形图&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .axis path,</span><br><span class=\"line\">    .axis line&#123;</span><br><span class=\"line\">        fill: none;</span><br><span class=\"line\">        stroke: black;</span><br><span class=\"line\">        shape-rendering: crispEdges;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .axis text &#123;</span><br><span class=\"line\">        font-family: sans-serif;</span><br><span class=\"line\">        font-size: 11px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .MyRect &#123;</span><br><span class=\"line\">        fill: steelblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .MyText &#123;</span><br><span class=\"line\">        fill: white;</span><br><span class=\"line\">        text-anchor: middle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">//1、添加 SVG 画布</span><br><span class=\"line\"></span><br><span class=\"line\">//画布大小</span><br><span class=\"line\">    var width = 400;    //画布的宽度</span><br><span class=\"line\">    var height = 400;    //画布的高度</span><br><span class=\"line\"></span><br><span class=\"line\">//在 body 里添加一个 SVG 画布</span><br><span class=\"line\">    var svg = d3.select(&quot;body&quot;)            //选择文档中的body元素</span><br><span class=\"line\">                .append(&quot;svg&quot;)                //添加一个svg元素</span><br><span class=\"line\">                .attr(&quot;width&quot;, width)        //设定宽度</span><br><span class=\"line\">                .attr(&quot;height&quot;, height);    //设定高度</span><br><span class=\"line\">//画布周边的空白</span><br><span class=\"line\">    var padding=&#123;left:30,right:30,top:20,bottom:20&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//2、定义数据和比例尺</span><br><span class=\"line\"></span><br><span class=\"line\">//定义一个数组</span><br><span class=\"line\">    var dataset = [10, 20, 30, 40, 33, 24, 12, 5];    //数据（表示矩形的宽度）</span><br><span class=\"line\">//X轴的比例尺</span><br><span class=\"line\">    var xScale=d3.scale.ordinal()</span><br><span class=\"line\">        .domain(d3.range(dataset.length))</span><br><span class=\"line\">        .rangeRoundBands([0, width - padding.left - padding.right]);</span><br><span class=\"line\">//Y轴的比例尺</span><br><span class=\"line\">    var yScale=d3.scale.linear()</span><br><span class=\"line\">        .domain([0,d3.max(dataset)])</span><br><span class=\"line\">        .range([height - padding.top - padding.bottom, 0]);</span><br><span class=\"line\"></span><br><span class=\"line\">//3. 定义坐标轴</span><br><span class=\"line\"></span><br><span class=\"line\">//定义X轴</span><br><span class=\"line\">var xAxis=d3.svg.axis()</span><br><span class=\"line\">    .scale(xScale)</span><br><span class=\"line\">    .orient(&quot;bottom&quot;);</span><br><span class=\"line\">//定义Y轴</span><br><span class=\"line\">var yAxis=d3.svg.axis()</span><br><span class=\"line\">    .scale(yAxis)</span><br><span class=\"line\">    .orient(&quot;left&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//矩形之间的空白处</span><br><span class=\"line\">var rectPadding=4</span><br><span class=\"line\"></span><br><span class=\"line\">//添加矩形元素</span><br><span class=\"line\">var rects=svg.selectAll(&quot;.MyRect&quot;)//选择svg中MyRect类中的所有元素</span><br><span class=\"line\">    .data(dataset)</span><br><span class=\"line\">    .enter()</span><br><span class=\"line\">    .append(&quot;rect&quot;)</span><br><span class=\"line\">    .attr(&quot;class&quot;,&quot;MyRect&quot;)</span><br><span class=\"line\">    .attr(&quot;transform&quot;,&quot;translate(&quot;+padding.left+&quot;,&quot;+padding.top+&quot;)&quot;)</span><br><span class=\"line\">    .attr(&quot;x&quot;,function(d,i)&#123;</span><br><span class=\"line\">        return xScale(i)+rectPadding/2;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .attr(&quot;width&quot;,xScale.rangeBand()-rectPadding)</span><br><span class=\"line\"></span><br><span class=\"line\">    .attr(&quot;y&quot;,function(d)&#123;</span><br><span class=\"line\">        var min=yScale.domain()[0];</span><br><span class=\"line\">        return yScale(min);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .attr(&quot;height&quot;,function(d)&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    .transition()</span><br><span class=\"line\">    .delay(function(d,i)&#123;</span><br><span class=\"line\">        return i * 200;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    .duration(2000)</span><br><span class=\"line\">    .ease(&quot;bounce&quot;)</span><br><span class=\"line\">    .attr(&quot;y&quot;,function(d)&#123;</span><br><span class=\"line\">        return yScale(d);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    .attr(&quot;height&quot;,function(d)&#123;</span><br><span class=\"line\">        return height - padding.top - padding.bottom - yScale(d);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//4、添加文字元素</span><br><span class=\"line\">var texts = svg.selectAll(&quot;.MyText&quot;)</span><br><span class=\"line\">        .data(dataset)</span><br><span class=\"line\">        .enter()</span><br><span class=\"line\">        .append(&quot;text&quot;)</span><br><span class=\"line\">        .attr(&quot;class&quot;,&quot;MyText&quot;)</span><br><span class=\"line\">        .attr(&quot;transform&quot;,&quot;translate(&quot; + padding.left + &quot;,&quot; + padding.top + &quot;)&quot;)</span><br><span class=\"line\">        .attr(&quot;x&quot;, function(d,i)&#123;</span><br><span class=\"line\">            return xScale(i) + rectPadding/2;</span><br><span class=\"line\">        &#125; )</span><br><span class=\"line\">        .attr(&quot;y&quot;,function(d)&#123;</span><br><span class=\"line\">            return yScale(d);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .attr(&quot;dx&quot;,function()&#123;</span><br><span class=\"line\">            return (xScale.rangeBand() - rectPadding)/2;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .attr(&quot;dy&quot;,function(d)&#123;</span><br><span class=\"line\">            return 20;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .text(function(d)&#123;</span><br><span class=\"line\">            return d;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .attr(&quot;y&quot;,function(d)&#123;//变化前y的坐标</span><br><span class=\"line\">            var min = yScale.domain()[0];</span><br><span class=\"line\">            return yScale(min);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .transition()//过渡</span><br><span class=\"line\">        .delay(function(d,i)&#123;</span><br><span class=\"line\">            return i * 200;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .duration(2000)</span><br><span class=\"line\">        .ease(&quot;bounce&quot;)</span><br><span class=\"line\">        .attr(&quot;y&quot;,function(d)&#123;//变化后的y坐标</span><br><span class=\"line\">            return yScale(d);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//5、添加坐标轴的元素</span><br><span class=\"line\"></span><br><span class=\"line\">//添加x轴</span><br><span class=\"line\">svg.append(&quot;g&quot;)</span><br><span class=\"line\">  .attr(&quot;class&quot;,&quot;axis&quot;)</span><br><span class=\"line\">  .attr(&quot;transform&quot;,&quot;translate(&quot; + padding.left + &quot;,&quot; + (height - padding.bottom) + &quot;)&quot;)</span><br><span class=\"line\">  .call(xAxis);</span><br><span class=\"line\">//添加y轴</span><br><span class=\"line\">svg.append(&quot;g&quot;)</span><br><span class=\"line\">  .attr(&quot;class&quot;,&quot;axis&quot;)</span><br><span class=\"line\">  .attr(&quot;transform&quot;,&quot;translate(&quot; + padding.left + &quot;,&quot; + padding.top + &quot;)&quot;)</span><br><span class=\"line\"> .call(yAxis);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（七）Update、Enter、Exit\"><a href=\"#（七）Update、Enter、Exit\" class=\"headerlink\" title=\"（七）Update、Enter、Exit\"></a>（七）Update、Enter、Exit</h3><ul>\n<li>1、Update、Enter、Exit 是 D3 中三个非常重要的概念，它处理的是当选择集和数据的数量关系不确定的情况。</li>\n<li>2、假设，在 body 中有三个 p 元素，有一数组 [3, 6, 9]，则可以将数组中的每一项分别与一个 p 元素绑定在一起。但是，有一个问题：当数组的长度与元素数量不一致（数组长度 &gt; 元素数量 or 数组长度 &lt; 元素数量）时呢？这时候就需要理解 Update、Enter、Exit 的概念。</li>\n<li>3、如果数组为 [3, 6, 9, 12, 15]，将此数组绑定到三个 p 元素的选择集上。可以想象，会有两个数据没有元素与之对应，这时候 D3 会建立两个空的元素与数据对应，这一部分就称为 Enter。而有元素与数据对应的部分称为 Update。如果数组为 [3]，则会有两个元素没有数据绑定，那么没有数据绑定的部分被称为 Exit。示意图如下所示。</li>\n<li>4、update 部分的处理办法一般是：更新属性值 enter 部分的处理办法一般是：添加元素后，赋予属性值</li>\n</ul>\n<h3 id=\"（八）交互式操作\"><a href=\"#（八）交互式操作\" class=\"headerlink\" title=\"（八）交互式操作\"></a>（八）交互式操作</h3><p>与图表的交互，指在图形元素上设置一个或多个监听器，当事件发生时，做出相应的反应。</p>\n<h4 id=\"1、什么是交互\"><a href=\"#1、什么是交互\" class=\"headerlink\" title=\"1、什么是交互\"></a>1、什么是交互</h4><p>交互，指的是用户输入了某种指令，程序接受到指令之后必须做出某种响应。对可视化图表来说，交互能使图表更加生动，能表现更多内容。<br>例如，拖动图表中某些图形、鼠标滑到图形上出现提示框、用触屏放大或缩小图形等等。<br>用户用于交互的工具一般有三种：鼠标、键盘、触屏。</p>\n<h4 id=\"2、如何添加交互\"><a href=\"#2、如何添加交互\" class=\"headerlink\" title=\"2、如何添加交互\"></a>2、如何添加交互</h4><p>触屏常用的事件有三个：</p>\n<ul>\n<li>touchstart：当触摸点被放在触摸屏上时。</li>\n<li>touchmove：当触摸点在触摸屏上移动时。</li>\n<li>touchend：当触摸点从触摸屏上拿开时。<br>当某个事件被监听到时，D3 会把当前的事件存到 d3.event 对象，里面保存了当前事件的各种参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var circle = svg.append(&quot;circle&quot;);</span><br><span class=\"line\">circle.on(&quot;click&quot;, function()&#123;</span><br><span class=\"line\"> //在这里添加交互内容</span><br><span class=\"line\">console.log(d3.event); &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>实例：带有交互的柱形图</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;带有交互的柱形图&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .axis path,</span><br><span class=\"line\">    .axis line&#123;</span><br><span class=\"line\">        fill: none;</span><br><span class=\"line\">        stroke: black;</span><br><span class=\"line\">        shape-rendering: crispEdges;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .axis text &#123;</span><br><span class=\"line\">        font-family: sans-serif;</span><br><span class=\"line\">        font-size: 11px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*.MyRect &#123;</span><br><span class=\"line\">        fill: steelblue;</span><br><span class=\"line\">    &#125;*/</span><br><span class=\"line\"></span><br><span class=\"line\">    .MyText &#123;</span><br><span class=\"line\">        fill: red;</span><br><span class=\"line\">        text-anchor: middle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;script src=&quot;js/d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    //画布大小</span><br><span class=\"line\">    var width = 400;</span><br><span class=\"line\">    var height = 400;</span><br><span class=\"line\"></span><br><span class=\"line\">    //在 body 里添加一个 SVG 画布</span><br><span class=\"line\">    var svg = d3.select(&quot;body&quot;)//选择d3文档中的body元素</span><br><span class=\"line\">        .append(&quot;svg&quot;)</span><br><span class=\"line\">        .attr(&quot;width&quot;, width)</span><br><span class=\"line\">        .attr(&quot;height&quot;, height);</span><br><span class=\"line\"></span><br><span class=\"line\">    //画布周边的空白</span><br><span class=\"line\">    var padding = &#123;left:30, right:30, top:20, bottom:20&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    //定义一个数组</span><br><span class=\"line\">    var dataset = [10, 20, 30, 40, 33, 24, 12, 5];</span><br><span class=\"line\"></span><br><span class=\"line\">    //x轴的比例尺</span><br><span class=\"line\">    var xScale = d3.scale.ordinal()</span><br><span class=\"line\">        .domain(d3.range(dataset.length)) //有几个矩形就有几个x刻度</span><br><span class=\"line\">        .rangeRoundBands([0, width - padding.left - padding.right]);</span><br><span class=\"line\"></span><br><span class=\"line\">    //y轴的比例尺</span><br><span class=\"line\">    var yScale = d3.scale.linear()</span><br><span class=\"line\">        .domain([0,d3.max(dataset)])</span><br><span class=\"line\">        .range([height - padding.top - padding.bottom, 0]);</span><br><span class=\"line\"></span><br><span class=\"line\">    //定义x轴</span><br><span class=\"line\">    var xAxis = d3.svg.axis()</span><br><span class=\"line\">        .scale(xScale)</span><br><span class=\"line\">        .orient(&quot;bottom&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //定义y轴</span><br><span class=\"line\">    var yAxis = d3.svg.axis()</span><br><span class=\"line\">        .scale(yScale)</span><br><span class=\"line\">        .orient(&quot;left&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //矩形之间的空白</span><br><span class=\"line\">    var rectPadding = 4;</span><br><span class=\"line\"></span><br><span class=\"line\">    //添加矩形元素</span><br><span class=\"line\">    var rects = svg.selectAll(&quot;.MyRect&quot;)//选择svg中MyRect类中的所有元素</span><br><span class=\"line\">        .data(dataset)</span><br><span class=\"line\">        .enter()</span><br><span class=\"line\">        .append(&quot;rect&quot;)//添加矩形元素</span><br><span class=\"line\">        .attr(&quot;class&quot;,&quot;MyRect&quot;)//清除里面的所有类，并设为自己的类myrect</span><br><span class=\"line\">        .attr(&quot;transform&quot;,&quot;translate(&quot; + padding.left + &quot;,&quot; + padding.top + &quot;)&quot;)</span><br><span class=\"line\">        .attr(&quot;x&quot;, function(d,i)&#123;//矩形左上角的x坐标</span><br><span class=\"line\">            return xScale(i) + rectPadding/2;</span><br><span class=\"line\">        &#125; )</span><br><span class=\"line\">        .attr(&quot;width&quot;, xScale.rangeBand() - rectPadding )//矩形的宽</span><br><span class=\"line\"></span><br><span class=\"line\">         .attr(&quot;y&quot;,function(d)&#123;//变化前的矩形左上角的y坐标</span><br><span class=\"line\">            var min = yScale.domain()[0];</span><br><span class=\"line\">            return yScale(min);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .attr(&quot;height&quot;, function(d)&#123;//变化前的矩形左上角的高</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        .transition()//过度</span><br><span class=\"line\">        .delay(function(d,i)&#123;//延迟</span><br><span class=\"line\">            return i * 200;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .duration(2000)//变化时长</span><br><span class=\"line\">        .ease(&quot;bounce&quot;)//到终点是弹跳</span><br><span class=\"line\"></span><br><span class=\"line\">        .attr(&quot;y&quot;,function(d)&#123;//矩形左上角的y坐标</span><br><span class=\"line\">            return yScale(d);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .attr(&quot;height&quot;, function(d)&#123;//矩形的高</span><br><span class=\"line\">            return height - padding.top - padding.bottom - yScale(d);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">//坐标说明位置，宽高说明大小</span><br><span class=\"line\"></span><br><span class=\"line\">    var rects = svg.selectAll(&quot;.Myrect&quot;)//选择svg中的MyRect类中的所有元素</span><br><span class=\"line\">        .attr(&quot;fill&quot;,&quot;steelblue&quot;)       //填充颜色不要写在CSS里</span><br><span class=\"line\">        .on(&quot;mouseover&quot;,function(d,i)&#123;//鼠标在上，颜色变黄</span><br><span class=\"line\">            d3.select(this)</span><br><span class=\"line\">                .attr(&quot;fill&quot;,&quot;yellow&quot;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .on(&quot;mouseout&quot;,function(d,i)&#123;//鼠标移出，颜色变钢铁蓝</span><br><span class=\"line\">            d3.select(this)</span><br><span class=\"line\">                .transition()//500毫秒渐变</span><br><span class=\"line\">                .duration(500)</span><br><span class=\"line\">                .attr(&quot;fill&quot;,&quot;steelblue&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //添加文字元素</span><br><span class=\"line\">    var texts = svg.selectAll(&quot;.MyText&quot;)//选择svg中的MyText类中的所有元素</span><br><span class=\"line\">        .data(dataset)</span><br><span class=\"line\">        .enter()</span><br><span class=\"line\">        .append(&quot;text&quot;)//添加text元素</span><br><span class=\"line\">        .attr(&quot;class&quot;,&quot;MyText&quot;)//清除里面的所有类，并设为自己的类MyText</span><br><span class=\"line\">        .attr(&quot;transform&quot;,&quot;translate(&quot; + padding.left + &quot;,&quot; + padding.top + &quot;)&quot;)</span><br><span class=\"line\">        .attr(&quot;x&quot;, function(d,i)&#123;//矩形左上角的x坐标</span><br><span class=\"line\">            return xScale(i) + rectPadding/2;</span><br><span class=\"line\">        &#125; )</span><br><span class=\"line\">        .attr(&quot;y&quot;,function(d)&#123;//矩形左上角的y坐标</span><br><span class=\"line\">            return yScale(d);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .attr(&quot;dx&quot;,function()&#123;//text相对于矩形的横向偏移量</span><br><span class=\"line\">            return (xScale.rangeBand() - rectPadding)/2;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .attr(&quot;dy&quot;,function(d)&#123;//text相对于矩形的纵向偏移量</span><br><span class=\"line\">            return 20;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .text(function(d)&#123;//text 的内容</span><br><span class=\"line\">            return d;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        .attr(&quot;y&quot;,function(d)&#123;//变化前y的坐标</span><br><span class=\"line\">            var min = yScale.domain()[0];</span><br><span class=\"line\">            return yScale(min);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .transition()//过渡</span><br><span class=\"line\">        .delay(function(d,i)&#123;</span><br><span class=\"line\">            return i * 200;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .duration(2000)</span><br><span class=\"line\">        .ease(&quot;bounce&quot;)</span><br><span class=\"line\">        .attr(&quot;y&quot;,function(d)&#123;//变化后的y坐标</span><br><span class=\"line\">            return yScale(d);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //添加x轴,分组元素&lt;g&gt;</span><br><span class=\"line\">    svg.append(&quot;g&quot;)</span><br><span class=\"line\">        .attr(&quot;class&quot;,&quot;axis&quot;)</span><br><span class=\"line\">        .attr(&quot;transform&quot;,&quot;translate(&quot; + padding.left + &quot;,&quot; + (height - padding.bottom) + &quot;)&quot;)</span><br><span class=\"line\">        .call(xAxis);</span><br><span class=\"line\"></span><br><span class=\"line\">    //添加y轴,分组元素&lt;g&gt;</span><br><span class=\"line\">    svg.append(&quot;g&quot;)</span><br><span class=\"line\">        .attr(&quot;class&quot;,&quot;axis&quot;)</span><br><span class=\"line\">        .attr(&quot;transform&quot;,&quot;translate(&quot; + padding.left + &quot;,&quot; + padding.top + &quot;)&quot;)</span><br><span class=\"line\">        .call(yAxis);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（九）布局\"><a href=\"#（九）布局\" class=\"headerlink\" title=\"（九）布局\"></a>（九）布局</h3><p>布局不是要直接绘图，而是为了得到绘图所需的数据</p>\n<h4 id=\"1、布局是什么\"><a href=\"#1、布局是什么\" class=\"headerlink\" title=\"1、布局是什么\"></a>1、布局是什么</h4><p>布局，英文是 Layout。<br>从字面看，可以想到有“决定什么元素绘制在哪里”的意思。<br>布局的作用是：将不适合用于绘图的数据转换成了适合用于绘图的数据。</p>\n<h4 id=\"2、布局有哪些\"><a href=\"#2、布局有哪些\" class=\"headerlink\" title=\"2、布局有哪些\"></a>2、布局有哪些</h4><p>D3 总共提供了 12 个布局：</p>\n<ul>\n<li>饼状图（Pie）、</li>\n<li>力导向图（Force）、</li>\n<li>弦图（Chord）、</li>\n<li>树状图（Tree）、</li>\n<li>集群图（Cluster）、</li>\n<li>捆图（Bundle）、</li>\n<li>打包图（Pack）、</li>\n<li>直方图（Histogram）、</li>\n<li>分区图（Partition）、</li>\n<li>堆栈图（Stack）、</li>\n<li>矩阵树图（Treemap）、</li>\n<li>层级图（Hierarchy）。</li>\n</ul>\n<h4 id=\"3、饼状图的制作\"><a href=\"#3、饼状图的制作\" class=\"headerlink\" title=\"3、饼状图的制作\"></a>3、饼状图的制作</h4><p>本文制作一个饼状图。在布局的应用中，最简单的就是饼状图，通过本文你将对布局有一个初步了解。</p>\n<p>源代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"> &lt;head&gt;</span><br><span class=\"line\"> &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;饼状图&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;script src=&quot;d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var width = 400;</span><br><span class=\"line\">var height = 400;</span><br><span class=\"line\">var dataset = [ 110,30 , 10 , 43 , 55 , 13 ];</span><br><span class=\"line\">var svg = d3.select(&quot;body&quot;)</span><br><span class=\"line\">.append(&quot;svg&quot;)</span><br><span class=\"line\">.attr(&quot;width&quot;, width)</span><br><span class=\"line\">.attr(&quot;height&quot;, height);</span><br><span class=\"line\">var pie = d3.layout.pie();</span><br><span class=\"line\">var piedata = pie(dataset);</span><br><span class=\"line\">var outerRadius = 150;    //外半径</span><br><span class=\"line\">var innerRadius = 0;    //内半径，为0则中间没有空白</span><br><span class=\"line\">var arc = d3.svg.arc()    //弧生成器</span><br><span class=\"line\">.innerRadius(innerRadius)    //设置内半径</span><br><span class=\"line\">.outerRadius(outerRadius);    //设置外半径</span><br><span class=\"line\">var color = d3.scale.category10();</span><br><span class=\"line\">var arcs = svg.selectAll(&quot;g&quot;)</span><br><span class=\"line\">.data(piedata)</span><br><span class=\"line\">.enter()</span><br><span class=\"line\">.append(&quot;g&quot;)</span><br><span class=\"line\">.attr(&quot;transform&quot;,&quot;translate(&quot;+ (width/2) +&quot;,&quot;+ (width/2) +&quot;)&quot;);</span><br><span class=\"line\">        arcs.append(&quot;path&quot;)</span><br><span class=\"line\">.attr(&quot;fill&quot;,function(d,i)&#123;</span><br><span class=\"line\">return color(i);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .attr(&quot;d&quot;,function(d)&#123;</span><br><span class=\"line\">return arc(d);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        arcs.append(&quot;text&quot;)</span><br><span class=\"line\">.attr(&quot;transform&quot;,function(d)&#123;</span><br><span class=\"line\">return &quot;translate(&quot; + arc.centroid(d) + &quot;)&quot;;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">.attr(&quot;text-anchor&quot;,&quot;middle&quot;)</span><br><span class=\"line\">.text(function(d)&#123;</span><br><span class=\"line\">return d.data;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\"> &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、-力导向图的制作\"><a href=\"#4、-力导向图的制作\" class=\"headerlink\" title=\"4、 力导向图的制作\"></a>4、 力导向图的制作</h4><p>力导向图中每一个节点都受到力的作用而运动，这是一种非常绚丽的图表 。<br>力导向图（Force-Directed Graph），是绘图的一种算法。在二维或三维空间里配置节点，节点之间用线连接，称为连线。各连线的长度几乎相等，且尽可能不相交。节点和连线都被施加了力的作用，力是根据节点和连线的相对位置计算的。根据力的作用，来计算节点和连线的运动轨迹，并不断降低它们的能量，最终达到一种能量很低的安定状态。</p>\n<p>力导向图能表示节点之间的多对多的关系。</p>\n<p>源代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;力导向图&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">  &lt;script src=&quot;d3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">        &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  var nodes = [ &#123; name: &quot;桂林&quot;    &#125;, &#123; name: &quot;广州&quot; &#125;,</span><br><span class=\"line\">       &#123; name: &quot;厦门&quot;    &#125;, &#123; name: &quot;杭州&quot;   &#125;,</span><br><span class=\"line\">       &#123; name: &quot;上海&quot;   &#125;, &#123; name: &quot;青岛&quot;    &#125;,</span><br><span class=\"line\">       &#123; name: &quot;天津&quot;    &#125; ];</span><br><span class=\"line\"></span><br><span class=\"line\">  var edges = [  &#123; source : 0  , target: 1 &#125; , &#123; source : 0  , target: 2 &#125; ,</span><br><span class=\"line\">        &#123; source : 0  , target: 3 &#125; , &#123; source : 1  , target: 4 &#125; ,</span><br><span class=\"line\">        &#123; source : 1  , target: 5 &#125; , &#123; source : 1  , target: 6 &#125;  ];</span><br><span class=\"line\"></span><br><span class=\"line\">  var width = 400;</span><br><span class=\"line\">  var height = 400;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  var svg = d3.select(&quot;body&quot;)</span><br><span class=\"line\">     .append(&quot;svg&quot;)</span><br><span class=\"line\">     .attr(&quot;width&quot;,width)</span><br><span class=\"line\">     .attr(&quot;height&quot;,height);</span><br><span class=\"line\"></span><br><span class=\"line\">  var force = d3.layout.force()</span><br><span class=\"line\">    .nodes(nodes) //指定节点数组</span><br><span class=\"line\">    .links(edges) //指定连线数组</span><br><span class=\"line\">    .size([width,height]) //指定范围</span><br><span class=\"line\">    .linkDistance(150) //指定连线长度</span><br><span class=\"line\">    .charge(-400); //相互之间的作用力</span><br><span class=\"line\"></span><br><span class=\"line\">  force.start(); //开始作用</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(nodes);</span><br><span class=\"line\">  console.log(edges);</span><br><span class=\"line\"></span><br><span class=\"line\">  //添加连线</span><br><span class=\"line\">  var svg_edges = svg.selectAll(&quot;line&quot;)</span><br><span class=\"line\">       .data(edges)</span><br><span class=\"line\">       .enter()</span><br><span class=\"line\">       .append(&quot;line&quot;)</span><br><span class=\"line\">       .style(&quot;stroke&quot;,&quot;#ccc&quot;)</span><br><span class=\"line\">       .style(&quot;stroke-width&quot;,1);</span><br><span class=\"line\"></span><br><span class=\"line\">  var color = d3.scale.category20();</span><br><span class=\"line\"></span><br><span class=\"line\">  //添加节点</span><br><span class=\"line\">  var svg_nodes = svg.selectAll(&quot;circle&quot;)</span><br><span class=\"line\">       .data(nodes)</span><br><span class=\"line\">       .enter()</span><br><span class=\"line\">       .append(&quot;circle&quot;)</span><br><span class=\"line\">       .attr(&quot;r&quot;,20)</span><br><span class=\"line\">       .style(&quot;fill&quot;,function(d,i)&#123;</span><br><span class=\"line\">        return color(i);</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">       .call(force.drag); //使得节点能够拖动</span><br><span class=\"line\"></span><br><span class=\"line\">  //添加描述节点的文字</span><br><span class=\"line\">  var svg_texts = svg.selectAll(&quot;text&quot;)</span><br><span class=\"line\">       .data(nodes)</span><br><span class=\"line\">       .enter()</span><br><span class=\"line\">       .append(&quot;text&quot;)</span><br><span class=\"line\">       .style(&quot;fill&quot;, &quot;black&quot;)</span><br><span class=\"line\">       .attr(&quot;dx&quot;, 20)</span><br><span class=\"line\">       .attr(&quot;dy&quot;, 8)</span><br><span class=\"line\">       .text(function(d)&#123;</span><br><span class=\"line\">        return d.name;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  force.on(&quot;tick&quot;, function()&#123; //对于每一个时间间隔</span><br><span class=\"line\"></span><br><span class=\"line\">    //更新连线坐标</span><br><span class=\"line\">    svg_edges.attr(&quot;x1&quot;,function(d)&#123; return d.source.x; &#125;)</span><br><span class=\"line\">      .attr(&quot;y1&quot;,function(d)&#123; return d.source.y; &#125;)</span><br><span class=\"line\">      .attr(&quot;x2&quot;,function(d)&#123; return d.target.x; &#125;)</span><br><span class=\"line\">      .attr(&quot;y2&quot;,function(d)&#123; return d.target.y; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //更新节点坐标</span><br><span class=\"line\">    svg_nodes.attr(&quot;cx&quot;,function(d)&#123; return d.x; &#125;)</span><br><span class=\"line\">      .attr(&quot;cy&quot;,function(d)&#123; return d.y; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //更新文字坐标</span><br><span class=\"line\">    svg_texts.attr(&quot;x&quot;, function(d)&#123; return d.x; &#125;)</span><br><span class=\"line\">     .attr(&quot;y&quot;, function(d)&#123; return d.y; &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5、弦图的制作\"><a href=\"#5、弦图的制作\" class=\"headerlink\" title=\"5、弦图的制作\"></a>5、弦图的制作</h4><p>弦图是一种用于描述节点之间联系的图表。</p>\n<p>弦图（Chord），主要用于表示两个节点之间的联系。</p>\n<p>两点之间的连线，表示谁和谁具有联系</p>\n<p>线的粗细表示权重</p>\n<p>源代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;弦图&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    .chord path &#123;</span><br><span class=\"line\">          fill-opacity: 0.67;</span><br><span class=\"line\">          stroke: #000;</span><br><span class=\"line\">          stroke-width: 0.5px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">        &lt;script src=&quot;d3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">        &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        //1.定义数据</span><br><span class=\"line\">        // 城市名</span><br><span class=\"line\">        var city_name = [ &quot;北京&quot; , &quot;上海&quot; , &quot;广州&quot; , &quot;深圳&quot; , &quot;香港&quot;  ];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 城市人口的来源，如</span><br><span class=\"line\">        //                北京        上海</span><br><span class=\"line\">        //    北京        1000        3045</span><br><span class=\"line\">        //    上海        3214        2000</span><br><span class=\"line\">        // 表示北京市的人口有1000个人来自本地，有3045人是来自上海的移民，总人口为 1000 + 3045</span><br><span class=\"line\">        // 上海市的人口有2000个人来自本地，有3214人是来自北京的移民，总人口为 3214 + 2000</span><br><span class=\"line\">        var population = [</span><br><span class=\"line\">          [ 1000,  3045　 , 4567　, 1234 , 3714 ],</span><br><span class=\"line\">          [ 3214,  2000　 , 2060　, 124  , 3234 ],</span><br><span class=\"line\">          [ 8761,  6545　 , 3000　, 8045 , 647  ],</span><br><span class=\"line\">          [ 3211,  1067  , 3214 , 4000  , 1006 ],</span><br><span class=\"line\">          [ 2146,  1034　 , 6745 , 4764  , 5000 ]</span><br><span class=\"line\">        ];</span><br><span class=\"line\"></span><br><span class=\"line\">        //2.转换数据，并输出转换后的数据</span><br><span class=\"line\">        var chord_layout = d3.layout.chord()</span><br><span class=\"line\">                             .padding(0.03)        //节点之间的间隔</span><br><span class=\"line\">                             .sortSubgroups(d3.descending)    //排序</span><br><span class=\"line\">                             .matrix(population);    //输入矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">        var groups = chord_layout.groups();</span><br><span class=\"line\">        var chords = chord_layout.chords();</span><br><span class=\"line\"></span><br><span class=\"line\">        console.log( groups );</span><br><span class=\"line\">        console.log( chords );</span><br><span class=\"line\"></span><br><span class=\"line\">        //3.SVG，弦图，颜色函数的定义</span><br><span class=\"line\">        var width  = 600;</span><br><span class=\"line\">        var height = 600;</span><br><span class=\"line\">        var innerRadius = width/2 * 0.7;</span><br><span class=\"line\">        var outerRadius = innerRadius * 1.1;</span><br><span class=\"line\"></span><br><span class=\"line\">        var color20 = d3.scale.category20();</span><br><span class=\"line\"></span><br><span class=\"line\">        var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;)</span><br><span class=\"line\">            .attr(&quot;width&quot;, width)</span><br><span class=\"line\">            .attr(&quot;height&quot;, height)</span><br><span class=\"line\">            .append(&quot;g&quot;)</span><br><span class=\"line\">            .attr(&quot;transform&quot;, &quot;translate(&quot; + width/2 + &quot;,&quot; + height/2 + &quot;)&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        //4.绘制节点（即分组，有多少个城市画多少个弧形），及绘制城市名称</span><br><span class=\"line\">        var outer_arc =  d3.svg.arc()</span><br><span class=\"line\">                     .innerRadius(innerRadius)</span><br><span class=\"line\">                     .outerRadius(outerRadius);</span><br><span class=\"line\"></span><br><span class=\"line\">        var g_outer = svg.append(&quot;g&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        g_outer.selectAll(&quot;path&quot;)</span><br><span class=\"line\">                .data(groups)</span><br><span class=\"line\">                .enter()</span><br><span class=\"line\">                .append(&quot;path&quot;)</span><br><span class=\"line\">                .style(&quot;fill&quot;, function(d) &#123; return color20(d.index); &#125;)</span><br><span class=\"line\">                .style(&quot;stroke&quot;, function(d) &#123; return color20(d.index); &#125;)</span><br><span class=\"line\">                .attr(&quot;d&quot;, outer_arc );</span><br><span class=\"line\"></span><br><span class=\"line\">        g_outer.selectAll(&quot;text&quot;)</span><br><span class=\"line\">                .data(groups)</span><br><span class=\"line\">                .enter()</span><br><span class=\"line\">                .append(&quot;text&quot;)</span><br><span class=\"line\">                .each( function(d,i) &#123;</span><br><span class=\"line\">                    d.angle = (d.startAngle + d.endAngle) / 2;</span><br><span class=\"line\">                    d.name = city_name[i];</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .attr(&quot;dy&quot;,&quot;.35em&quot;)</span><br><span class=\"line\">                .attr(&quot;transform&quot;, function(d)&#123;</span><br><span class=\"line\">                    return &quot;rotate(&quot; + ( d.angle * 180 / Math.PI ) + &quot;)&quot; +</span><br><span class=\"line\">                           &quot;translate(0,&quot;+ -1.0*(outerRadius+10) +&quot;)&quot; +</span><br><span class=\"line\">                            ( ( d.angle &gt; Math.PI*3/4 &amp;&amp; d.angle &lt; Math.PI*5/4 ) ? &quot;rotate(180)&quot; : &quot;&quot;);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .text(function(d)&#123;</span><br><span class=\"line\">                    return d.name;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        //5.绘制内部弦（即所有城市人口的来源，即有5*5=25条弧）</span><br><span class=\"line\">        var inner_chord =  d3.svg.chord()</span><br><span class=\"line\">                        .radius(innerRadius);</span><br><span class=\"line\"></span><br><span class=\"line\">        svg.append(&quot;g&quot;)</span><br><span class=\"line\">            .attr(&quot;class&quot;, &quot;chord&quot;)</span><br><span class=\"line\">            .selectAll(&quot;path&quot;)</span><br><span class=\"line\">            .data(chords)</span><br><span class=\"line\">            .enter()</span><br><span class=\"line\">            .append(&quot;path&quot;)</span><br><span class=\"line\">            .attr(&quot;d&quot;, inner_chord )</span><br><span class=\"line\">            .style(&quot;fill&quot;, function(d) &#123; return color20(d.source.index); &#125;)</span><br><span class=\"line\">            .style(&quot;opacity&quot;, 1)</span><br><span class=\"line\">            .on(&quot;mouseover&quot;,function(d,i)&#123;</span><br><span class=\"line\">                d3.select(this)</span><br><span class=\"line\">                    .style(&quot;fill&quot;,&quot;yellow&quot;);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .on(&quot;mouseout&quot;,function(d,i) &#123;</span><br><span class=\"line\">                d3.select(this)</span><br><span class=\"line\">                    .transition()</span><br><span class=\"line\">                    .duration(1000)</span><br><span class=\"line\">                    .style(&quot;fill&quot;,color20(d.source.index));</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6、集群图的制作\"><a href=\"#6、集群图的制作\" class=\"headerlink\" title=\"6、集群图的制作\"></a>6、集群图的制作</h4><p>集群图，是一种用于表示包含与被包含关系的图表。</p>\n<p>源代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;集群图&lt;/title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.node circle &#123;</span><br><span class=\"line\">  fill: #fff;</span><br><span class=\"line\">  stroke: steelblue;</span><br><span class=\"line\">  stroke-width: 1.5px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.node &#123;</span><br><span class=\"line\">  font: 12px sans-serif;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.link &#123;</span><br><span class=\"line\">  fill: none;</span><br><span class=\"line\">  stroke: #ccc;</span><br><span class=\"line\">  stroke-width: 1.5px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;script src=&quot;d3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var width = 500,</span><br><span class=\"line\">    height = 500;</span><br><span class=\"line\"></span><br><span class=\"line\">var cluster = d3.layout.cluster()</span><br><span class=\"line\">    .size([width, height - 200]);</span><br><span class=\"line\"></span><br><span class=\"line\">var diagonal = d3.svg.diagonal()</span><br><span class=\"line\">    .projection(function(d) &#123; return [d.y, d.x]; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;)</span><br><span class=\"line\">    .attr(&quot;width&quot;, width)</span><br><span class=\"line\">    .attr(&quot;height&quot;, height)</span><br><span class=\"line\">  .append(&quot;g&quot;)</span><br><span class=\"line\">    .attr(&quot;transform&quot;, &quot;translate(40,0)&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">d3.json(&quot;city.json&quot;, function(error, root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var nodes = cluster.nodes(root);</span><br><span class=\"line\">  var links = cluster.links(nodes);</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(nodes);</span><br><span class=\"line\">  console.log(links);</span><br><span class=\"line\"></span><br><span class=\"line\">  var link = svg.selectAll(&quot;.link&quot;)</span><br><span class=\"line\">      .data(links)</span><br><span class=\"line\">      .enter()</span><br><span class=\"line\">      .append(&quot;path&quot;)</span><br><span class=\"line\">      .attr(&quot;class&quot;, &quot;link&quot;)</span><br><span class=\"line\">      .attr(&quot;d&quot;, diagonal);</span><br><span class=\"line\"></span><br><span class=\"line\">  var node = svg.selectAll(&quot;.node&quot;)</span><br><span class=\"line\">      .data(nodes)</span><br><span class=\"line\">      .enter()</span><br><span class=\"line\">      .append(&quot;g&quot;)</span><br><span class=\"line\">      .attr(&quot;class&quot;, &quot;node&quot;)</span><br><span class=\"line\">      .attr(&quot;transform&quot;, function(d) &#123; return &quot;translate(&quot; + d.y + &quot;,&quot; + d.x + &quot;)&quot;; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  node.append(&quot;circle&quot;)</span><br><span class=\"line\">      .attr(&quot;r&quot;, 4.5);</span><br><span class=\"line\"></span><br><span class=\"line\">  node.append(&quot;text&quot;)</span><br><span class=\"line\">      .attr(&quot;dx&quot;, function(d) &#123; return d.children ? -8 : 8; &#125;)</span><br><span class=\"line\">      .attr(&quot;dy&quot;, 3)</span><br><span class=\"line\">      .style(&quot;text-anchor&quot;, function(d) &#123; return d.children ? &quot;end&quot; : &quot;start&quot;; &#125;)</span><br><span class=\"line\">      .text(function(d) &#123; return d.name; &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7、树状图的制作\"><a href=\"#7、树状图的制作\" class=\"headerlink\" title=\"7、树状图的制作\"></a>7、树状图的制作</h4><p>树状图（ Tree ）用于表示层级、上下级、包含与被包含关系。</p>\n<p>源代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;树状图&lt;/title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.node circle &#123;</span><br><span class=\"line\">  fill: #fff;</span><br><span class=\"line\">  stroke: steelblue;</span><br><span class=\"line\">  stroke-width: 1.5px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.node &#123;</span><br><span class=\"line\">  font: 12px sans-serif;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.link &#123;</span><br><span class=\"line\">  fill: none;</span><br><span class=\"line\">  stroke: #ccc;</span><br><span class=\"line\">  stroke-width: 1.5px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;script src=&quot;d3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var width = 500,</span><br><span class=\"line\">height = 500;</span><br><span class=\"line\"></span><br><span class=\"line\">var tree = d3.layout.tree()</span><br><span class=\"line\">    .size([width, height-200])</span><br><span class=\"line\">    .separation(function(a, b) &#123; return (a.parent == b.parent ? 1 : 2); &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var diagonal = d3.svg.diagonal()</span><br><span class=\"line\">    .projection(function(d) &#123; return [d.y, d.x]; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;)</span><br><span class=\"line\">    .attr(&quot;width&quot;, width)</span><br><span class=\"line\">    .attr(&quot;height&quot;, height)</span><br><span class=\"line\">    .append(&quot;g&quot;)</span><br><span class=\"line\">    .attr(&quot;transform&quot;, &quot;translate(40,0)&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">d3.json(&quot;city_tree.json&quot;, function(error, root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var nodes = tree.nodes(root);</span><br><span class=\"line\">    var links = tree.links(nodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(nodes);</span><br><span class=\"line\">    console.log(links);</span><br><span class=\"line\"></span><br><span class=\"line\">    var link = svg.selectAll(&quot;.link&quot;)</span><br><span class=\"line\">      .data(links)</span><br><span class=\"line\">      .enter()</span><br><span class=\"line\">      .append(&quot;path&quot;)</span><br><span class=\"line\">      .attr(&quot;class&quot;, &quot;link&quot;)</span><br><span class=\"line\">      .attr(&quot;d&quot;, diagonal);</span><br><span class=\"line\"></span><br><span class=\"line\">    var node = svg.selectAll(&quot;.node&quot;)</span><br><span class=\"line\">      .data(nodes)</span><br><span class=\"line\">      .enter()</span><br><span class=\"line\">      .append(&quot;g&quot;)</span><br><span class=\"line\">      .attr(&quot;class&quot;, &quot;node&quot;)</span><br><span class=\"line\">      .attr(&quot;transform&quot;, function(d) &#123; return &quot;translate(&quot; + d.y + &quot;,&quot; + d.x + &quot;)&quot;; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    node.append(&quot;circle&quot;)</span><br><span class=\"line\">      .attr(&quot;r&quot;, 4.5);</span><br><span class=\"line\"></span><br><span class=\"line\">    node.append(&quot;text&quot;)</span><br><span class=\"line\">      .attr(&quot;dx&quot;, function(d) &#123; return d.children ? -8 : 8; &#125;)</span><br><span class=\"line\">      .attr(&quot;dy&quot;, 3)</span><br><span class=\"line\">      .style(&quot;text-anchor&quot;, function(d) &#123; return d.children ? &quot;end&quot; : &quot;start&quot;; &#125;)</span><br><span class=\"line\">      .text(function(d) &#123; return d.name; &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"8、打包图的制作\"><a href=\"#8、打包图的制作\" class=\"headerlink\" title=\"8、打包图的制作\"></a>8、打包图的制作</h4><p>打包图（ Pack ），用于表示包含与被包含的关系，也可表示各对象的权重，通常用一圆套一圆来表示前者，用圆的大小来表示后者。</p>\n<p>源代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;Pack&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;script src=&quot;d3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var width  = 500;</span><br><span class=\"line\">    var height = 500;</span><br><span class=\"line\"></span><br><span class=\"line\">    var pack = d3.layout.pack()</span><br><span class=\"line\">                    .size([ width, height ])</span><br><span class=\"line\">                    .radius(20);</span><br><span class=\"line\"></span><br><span class=\"line\">    var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;)</span><br><span class=\"line\">        .attr(&quot;width&quot;, width)</span><br><span class=\"line\">        .attr(&quot;height&quot;, height)</span><br><span class=\"line\">        .append(&quot;g&quot;)</span><br><span class=\"line\">        .attr(&quot;transform&quot;, &quot;translate(0,0)&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    d3.json(&quot;city2.json&quot;, function(error, root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        var nodes = pack.nodes(root);</span><br><span class=\"line\">        var links = pack.links(nodes);</span><br><span class=\"line\"></span><br><span class=\"line\">        console.log(nodes);</span><br><span class=\"line\">        console.log(links);</span><br><span class=\"line\"></span><br><span class=\"line\">        svg.selectAll(&quot;circle&quot;)</span><br><span class=\"line\">            .data(nodes)</span><br><span class=\"line\">            .enter()</span><br><span class=\"line\">            .append(&quot;circle&quot;)</span><br><span class=\"line\">            .attr(&quot;fill&quot;,&quot;rgb(31, 119, 180)&quot;)</span><br><span class=\"line\">            .attr(&quot;fill-opacity&quot;,&quot;0.4&quot;)</span><br><span class=\"line\">            .attr(&quot;cx&quot;,function(d)&#123;</span><br><span class=\"line\">                return d.x;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .attr(&quot;cy&quot;,function(d)&#123;</span><br><span class=\"line\">                return d.y;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .attr(&quot;r&quot;,function(d)&#123;</span><br><span class=\"line\">                return d.r;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .on(&quot;mouseover&quot;,function(d,i)&#123;</span><br><span class=\"line\">                d3.select(this)</span><br><span class=\"line\">                    .attr(&quot;fill&quot;,&quot;yellow&quot;);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .on(&quot;mouseout&quot;,function(d,i)&#123;</span><br><span class=\"line\">                d3.select(this)</span><br><span class=\"line\">                    .attr(&quot;fill&quot;,&quot;rgb(31, 119, 180)&quot;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        svg.selectAll(&quot;text&quot;)</span><br><span class=\"line\">                      .data(nodes)</span><br><span class=\"line\">                      .enter()</span><br><span class=\"line\">                      .append(&quot;text&quot;)</span><br><span class=\"line\">                      .attr(&quot;font-size&quot;,&quot;10px&quot;)</span><br><span class=\"line\">                      .attr(&quot;fill&quot;,&quot;white&quot;)</span><br><span class=\"line\">                      .attr(&quot;fill-opacity&quot;,function(d)&#123;</span><br><span class=\"line\">                          if(d.depth == 2)</span><br><span class=\"line\">                              return &quot;0.9&quot;;</span><br><span class=\"line\">                          else</span><br><span class=\"line\">                              return &quot;0&quot;;</span><br><span class=\"line\">                      &#125;)</span><br><span class=\"line\">                      .attr(&quot;x&quot;,function(d)&#123; return d.x; &#125;)</span><br><span class=\"line\">                      .attr(&quot;y&quot;,function(d)&#123; return d.y; &#125;)</span><br><span class=\"line\">                      .attr(&quot;dx&quot;,-12)</span><br><span class=\"line\">                      .attr(&quot;dy&quot;,1)</span><br><span class=\"line\">                      .text(function(d)&#123; return d.name; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"9、地图的制作\"><a href=\"#9、地图的制作\" class=\"headerlink\" title=\"9、地图的制作\"></a>9、地图的制作</h4><p>本章以中国地图为例，介绍地图的制作方法。</p>\n<p>在数据可视化中，地图是很重要的一部分。很多情况会与地图有关联，如中国各省的人口多少，GDP 多少等，都可以和地图联系在一起。</p>\n<p>源代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;中国地图&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;script src=&quot;d3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var width  = 1000;</span><br><span class=\"line\">    var height = 1000;</span><br><span class=\"line\"></span><br><span class=\"line\">    var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;)</span><br><span class=\"line\">        .attr(&quot;width&quot;, width)</span><br><span class=\"line\">        .attr(&quot;height&quot;, height)</span><br><span class=\"line\">        .append(&quot;g&quot;)</span><br><span class=\"line\">        .attr(&quot;transform&quot;, &quot;translate(0,0)&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var projection = d3.geo.mercator()</span><br><span class=\"line\">                        .center([107, 31])</span><br><span class=\"line\">                        .scale(850)</span><br><span class=\"line\">                        .translate([width/2, height/2]);</span><br><span class=\"line\"></span><br><span class=\"line\">    var path = d3.geo.path()</span><br><span class=\"line\">                    .projection(projection);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    var color = d3.scale.category20();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    d3.json(&quot;china.geojson&quot;, function(error, root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (error)</span><br><span class=\"line\">            return console.error(error);</span><br><span class=\"line\">        console.log(root.features);</span><br><span class=\"line\"></span><br><span class=\"line\">        svg.selectAll(&quot;path&quot;)</span><br><span class=\"line\">            .data( root.features )</span><br><span class=\"line\">            .enter()</span><br><span class=\"line\">            .append(&quot;path&quot;)</span><br><span class=\"line\">            .attr(&quot;stroke&quot;,&quot;#000&quot;)</span><br><span class=\"line\">            .attr(&quot;stroke-width&quot;,1)</span><br><span class=\"line\">            .attr(&quot;fill&quot;, function(d,i)&#123;</span><br><span class=\"line\">                return color(i);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .attr(&quot;d&quot;, path )</span><br><span class=\"line\">            .on(&quot;mouseover&quot;,function(d,i)&#123;</span><br><span class=\"line\">                d3.select(this)</span><br><span class=\"line\">                    .attr(&quot;fill&quot;,&quot;yellow&quot;);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .on(&quot;mouseout&quot;,function(d,i)&#123;</span><br><span class=\"line\">                d3.select(this)</span><br><span class=\"line\">                    .attr(&quot;fill&quot;,color(i));</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n","categories":["webGL总结"],"tags":["webGL"]},{"title":"electron开发总结","url":"/2022/12/16/electron%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/","content":"<h1 id=\"一、用得到的-electron-开发总结\"><a href=\"#一、用得到的-electron-开发总结\" class=\"headerlink\" title=\"一、用得到的 electron 开发总结\"></a>一、用得到的 electron 开发总结</h1><p>Electron 是由 Github 开发，用 HTML，CSS 和 JavaScript 来构建跨平台桌面应用程序的一个开源库。 Electron 通过将 Chromium 和 Node.js 合并到同一个运行时环境中，并将其打包为 Mac，Windows 和 Linux 系统下的应用来实现这一目的。</p>\n<h3 id=\"添加启动动画\"><a href=\"#添加启动动画\" class=\"headerlink\" title=\"添加启动动画\"></a>添加启动动画</h3><p>由于 Electron 第一次启动比较慢,需要一些启动动画提高下用户体验。在主进程添加以下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const electron = require(&#x27;electron&#x27;)</span><br><span class=\"line\">const app = electron.app</span><br><span class=\"line\">const BrowserWindow = electron.BrowserWindow</span><br><span class=\"line\">let mainWindow</span><br><span class=\"line\"></span><br><span class=\"line\">function createWindow(callback) &#123;</span><br><span class=\"line\">    mainWindow = new BrowserWindow(&#123;</span><br><span class=\"line\">        width: 1400,</span><br><span class=\"line\">        height: 900,</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    mainWindow.once(&#x27;ready-to-show&#x27;, () =&gt; &#123;</span><br><span class=\"line\">      if (callback)&#123;</span><br><span class=\"line\">        callback();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        mainWindow.show()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    mainWindow.loadURL(`file://$&#123;__dirname&#125;/build/index.html`);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">app.on(&#x27;ready&#x27;, () =&gt; &#123;</span><br><span class=\"line\">    const useH = parseInt(0.865 * electron.screen.getPrimaryDisplay().workAreaSize.height);</span><br><span class=\"line\">    const useW = parseInt(0.625 * electron.screen.getPrimaryDisplay().workAreaSize.width);</span><br><span class=\"line\"></span><br><span class=\"line\">    let logoWindow = new BrowserWindow(&#123;</span><br><span class=\"line\">        width: useW,</span><br><span class=\"line\">        height: useH,</span><br><span class=\"line\">        transparent: true,</span><br><span class=\"line\">        frame: false,</span><br><span class=\"line\">        center: true,</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    logoWindow.loadURL(`file://$&#123;__dirname&#125;/build/logo/logo.html`);</span><br><span class=\"line\">    logoWindow.once(&#x27;ready-to-show&#x27;, () =&gt; &#123;</span><br><span class=\"line\">        logoWindow.show();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    const closeLogoWindow = () =&gt; &#123;</span><br><span class=\"line\">        logoWindow.close();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    createWindow(closeLogoWindow);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现自动更新\"><a href=\"#实现自动更新\" class=\"headerlink\" title=\"实现自动更新\"></a>实现自动更新</h3><p>使用 <strong>electron-builder</strong> 结合 <strong>electron-updater</strong> 实现自动更新。</p>\n<p>配置 package.json 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;build&quot;: &#123;</span><br><span class=\"line\">    &quot;publish&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;provider&quot;: &quot;generic&quot;,</span><br><span class=\"line\">        &quot;url&quot;: &quot;http://ossactivity.tongyishidai.com/&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主进程添加自动更新检测和事件监听：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; autoUpdater &#125; from &quot;electron-updater&quot;</span><br><span class=\"line\">import &#123; ipcMain &#125; from &quot;electron&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">function updateHandle() &#123;</span><br><span class=\"line\">  let message = &#123;</span><br><span class=\"line\">    error: &#x27;检查更新出错&#x27;,</span><br><span class=\"line\">    checking: &#x27;正在检查更新……&#x27;,</span><br><span class=\"line\">    updateAva: &#x27;检测到新版本，正在下载……&#x27;,</span><br><span class=\"line\">    updateNotAva: &#x27;现在使用的就是最新版本，不用更新&#x27;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  autoUpdater.setFeedURL(&#x27;http://ossactivity.tongyishidai.com/&#x27;);</span><br><span class=\"line\">  autoUpdater.on(&#x27;error&#x27;, function (error) &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">    sendUpdateMessage(message.error)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  autoUpdater.on(&#x27;checking-for-update&#x27;, function () &#123;</span><br><span class=\"line\">    sendUpdateMessage(message.checking)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  autoUpdater.on(&#x27;update-available&#x27;, function (info) &#123;</span><br><span class=\"line\">    sendUpdateMessage(message.updateAva)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  autoUpdater.on(&#x27;update-not-available&#x27;, function (info) &#123;</span><br><span class=\"line\">    sendUpdateMessage(message.updateNotAva)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 更新下载进度事件</span><br><span class=\"line\">  autoUpdater.on(&#x27;download-progress&#x27;, function (progressObj) &#123;</span><br><span class=\"line\">    mainWindow.webContents.send(&#x27;downloadProgress&#x27;, progressObj)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  autoUpdater.on(&#x27;update-downloaded&#x27;, function (event, releaseNotes, releaseName, releaseDate, updateUrl, quitAndUpdate) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ipcMain.on(&#x27;isUpdateNow&#x27;, (e, arg) =&gt; &#123;</span><br><span class=\"line\">      console.log(arguments);</span><br><span class=\"line\">      console.log(&quot;开始更新&quot;);</span><br><span class=\"line\">      //some code here to handle event</span><br><span class=\"line\">      autoUpdater.quitAndInstall();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    mainWindow.webContents.send(&#x27;isUpdateNow&#x27;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  ipcMain.on(&quot;checkForUpdate&quot;,()=&gt; &#123;</span><br><span class=\"line\">      //执行自动更新检查</span><br><span class=\"line\">      autoUpdater.checkForUpdates();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 通过main进程发送事件给renderer进程，提示更新信息</span><br><span class=\"line\">function sendUpdateMessage(text) &#123;</span><br><span class=\"line\">  mainWindow.webContents.send(&#x27;message&#x27;, text)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>在添加自动更新检测和事件监听之后，在主进程 createWindow 中需要调用一下 updateHandle()。</li>\n<li>这个 autoUpdater 不是 electron 中的 autoUpdater，是 electron-updater 的 autoUpdater。(这里曾报错曾纠结一整天)</li>\n</ul>\n</blockquote>\n<p>在视图（View）层中触发自动更新，并添加自动更新事件的监听。</p>\n<p>触发自动更新：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ipcRenderer.send(&quot;checkForUpdate&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>监听自动更新事件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ipcRenderer.on(&quot;message&quot;, (event, text) =&gt; &#123;</span><br><span class=\"line\">   console.log(text)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ipcRenderer.on(&quot;downloadProgress&quot;, (event, progressObj)=&gt; &#123;</span><br><span class=\"line\">  console.log(progressObj.percent)</span><br><span class=\"line\">  this.setState(&#123;</span><br><span class=\"line\">    downloadPercent: parseInt(progressObj.percent) || 0</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ipcRenderer.on(&quot;isUpdateNow&quot;, () =&gt; &#123;</span><br><span class=\"line\">    ipcRenderer.send(&quot;isUpdateNow&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>为避免多次切换页面造成监听的滥用，切换页面前必须移除监听事件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ipcRenderer.removeAll([&quot;message&quot;, &quot;downloadProgress&quot;, &quot;isUpdateNow&quot;]);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参考地址 segmentfault.com&#x2F;a&#x2F;119000001…</p>\n</blockquote>\n<h3 id=\"使用-electron-builder-打包-exe-安装包\"><a href=\"#使用-electron-builder-打包-exe-安装包\" class=\"headerlink\" title=\"使用 electron-builder 打包 exe 安装包\"></a>使用 electron-builder 打包 exe 安装包</h3><p>package.json 文件配置如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">&quot;build&quot;: &#123;</span><br><span class=\"line\">    &quot;productName&quot;: &quot;CubeScratch&quot;,</span><br><span class=\"line\">    &quot;appId&quot;: &quot;org.develar.CubeScratch&quot;,</span><br><span class=\"line\">    &quot;publish&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;provider&quot;: &quot;generic&quot;,</span><br><span class=\"line\">        &quot;url&quot;: &quot;http://ossactivity.tongyishidai.com/&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;win&quot;: &#123;</span><br><span class=\"line\">      &quot;icon&quot;: &quot;icon.ico&quot;,</span><br><span class=\"line\">      &quot;artifactName&quot;: &quot;$&#123;productName&#125;_Setup_$&#123;version&#125;.$&#123;ext&#125;&quot;,</span><br><span class=\"line\">      &quot;target&quot;: [</span><br><span class=\"line\">        &quot;nsis&quot;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;mac&quot;: &#123;</span><br><span class=\"line\">      &quot;icon&quot;: &quot;icon.icns&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;nsis&quot;: &#123;</span><br><span class=\"line\">      &quot;oneClick&quot;: false,</span><br><span class=\"line\">      &quot;allowElevation&quot;: true,</span><br><span class=\"line\">      &quot;allowToChangeInstallationDirectory&quot;: true,</span><br><span class=\"line\">      &quot;installerIcon&quot;: &quot;icon.ico&quot;,</span><br><span class=\"line\">      &quot;uninstallerIcon&quot;: &quot;icon.ico&quot;,</span><br><span class=\"line\">      &quot;installerHeaderIcon&quot;: &quot;icon.ico&quot;,</span><br><span class=\"line\">      &quot;createDesktopShortcut&quot;: true,</span><br><span class=\"line\">      &quot;createStartMenuShortcut&quot;: true,</span><br><span class=\"line\">      &quot;shortcutName&quot;: &quot;CubeScratch&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;directories&quot;: &#123;</span><br><span class=\"line\">      &quot;buildResources&quot;: &quot;resources&quot;,</span><br><span class=\"line\">      &quot;output&quot;: &quot;release&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;dmg&quot;: &#123;</span><br><span class=\"line\">      &quot;contents&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;x&quot;: 410,</span><br><span class=\"line\">          &quot;y&quot;: 150,</span><br><span class=\"line\">          &quot;type&quot;: &quot;link&quot;,</span><br><span class=\"line\">          &quot;path&quot;: &quot;/Applications&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;x&quot;: 130,</span><br><span class=\"line\">          &quot;y&quot;: 150,</span><br><span class=\"line\">          &quot;type&quot;: &quot;file&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参考地址 juejin.im&#x2F;post&#x2F;684490…</p>\n</blockquote>\n<h3 id=\"windows-平台-serialport-串口编译\"><a href=\"#windows-平台-serialport-串口编译\" class=\"headerlink\" title=\"windows 平台 serialport 串口编译\"></a>windows 平台 serialport 串口编译</h3><p>如果需要 serialport 作为 Electron 项目的依赖项，则必须针对项目使用的 Electron 版本对其进行编译。<br>对于大多数最常见的用例（标准处理器平台上的 Linux，Mac，Windows），我们使用 prebuild 来编译和发布库的二进制文件。<br>使用 nodejs 进行编译 node-gyp 需要使用 Python 2.x，因此请确保已安装它，并且在所有操作系统的路径中。Python 3.x 无法正常工作。<br>安装 windows 构建工具和配置想省时省力请选择以下方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure>\n\n<p>上边命令决定串口编译是否成功。安装过程非常缓慢,安装完成就等于串口编译成功了 99%。<br>手动安装工具和配置请看<a href=\"https://github.com/nodejs/node-gyp/\">https://github.com/nodejs/node-gyp/</a><br>接下来用 electron-rebuild 包重建模块以适配 Electron。这个包可以自动识别当前 Electron 版本，为你的应用自动完成下载 headers、重新编译原生模块等步骤。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;rebuild&quot;: &quot;electron-rebuild&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行以下命令完成串口编译</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run rebuild</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>编译过的串口不同系统不可通用，需在各平台重新编译</li>\n<li>windows 系统最好是正版，或净化版。否正很有可能安装失败。</li>\n</ul>\n</blockquote>\n<h1 id=\"二、Electron：使用-React-作为-Renderer\"><a href=\"#二、Electron：使用-React-作为-Renderer\" class=\"headerlink\" title=\"二、Electron：使用 React 作为 Renderer\"></a>二、Electron：使用 React 作为 Renderer</h1><h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>通过之前对 Electron 的了解，现在多少也能看出 Electron 的一些特点。</p>\n<p>其中，Main Process 用来调度各个 Renderer Process；而各个 Renderer Process 实际上就是 web+（比 web 功能要强，姑且就允许我这么叫一次吧），他们除了 web 应用本身所拥有的特征之外，还可以通过引入 Electron 来扩展，当然也可以使用 NodeJs 的特性，比如在 React 中使用 fs.writeFile()（听起来很诡异）。</p>\n<p>如果之前的意见记不清楚了的话，可以再去翻翻看《<a href=\"https://segmentfault.com/a/1190000021820641\">Electron：Web 应用桌面化</a>》、《<a href=\"https://segmentfault.com/a/1190000021843332\">Electron：主进程与渲染器进程</a>》。</p>\n<p>本篇呢，主要是为了来总结一下如何将 React 与 Electron 结合起来，让编码更加高效。</p>\n<h2 id=\"2-为什么要引入-React-？\"><a href=\"#2-为什么要引入-React-？\" class=\"headerlink\" title=\"2. 为什么要引入 React ？\"></a>2. 为什么要引入 React ？</h2><p>实际上在最初学习的时候直接在 Electron 的应用中写 html+js+css 感觉也不错，但是当场景稍微复杂起来后就会感觉写起来比较繁琐。</p>\n<p>另外还有就是在切换页面的场景，如果复用渲染器进程而直接采用切换 Url 的方式虽然也可以完成导航，但是会有一个“白屏时间”让人挺不舒服的。如果每个页面都起一个自己的渲染器进程，由于新窗口的启动有一个过渡，因此不会感觉到“白屏时间”，但是总感觉每个页面都起一个渲染器进程也并不是适用于任意位置。</p>\n<p>所以说 SPA 是非常合适的一个选择，至于选什么框架并不重要。</p>\n<h3 id=\"最基础的整合\"><a href=\"#最基础的整合\" class=\"headerlink\" title=\"最基础的整合\"></a>最基础的整合</h3><p>通过分别在 Electron 中添加 React 和在 React 中添加 Electron 作比较之后，我发现在 React 中添加 Electron 仿佛要简单一些（也可能目前场景比较简单 🤔）。</p>\n<h3 id=\"新建一个-React-App\"><a href=\"#新建一个-React-App\" class=\"headerlink\" title=\"新建一个 React App\"></a>新建一个 React App</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn create react-app electron-react</span><br></pre></td></tr></table></figure>\n\n<p>结束之后跑起来这个站点，假设站点地址是 <a href=\"http://localhost:3000，成功执行就可以了，保持这个执行状态不用关闭。\">http://localhost:3000，成功执行就可以了，保持这个执行状态不用关闭。</a></p>\n<h3 id=\"添加-Electron\"><a href=\"#添加-Electron\" class=\"headerlink\" title=\"添加 Electron\"></a>添加 Electron</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add electron --dev</span><br></pre></td></tr></table></figure>\n\n<p>在 src&#x2F; 目录下新建 main.js 入口文件，内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// src/main.js</span><br><span class=\"line\">const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.allowRendererProcessReuse = true</span><br><span class=\"line\"></span><br><span class=\"line\">function createWindow () &#123;</span><br><span class=\"line\">  let win = new BrowserWindow(&#123;</span><br><span class=\"line\">    height: 500,</span><br><span class=\"line\">    width: 800,</span><br><span class=\"line\">    webPreferences: &#123;</span><br><span class=\"line\">      nodeIntegration: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  win.loadURL(`http://localhost:3000`)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app.on(&#x27;ready&#x27;, () =&gt; createWindow())</span><br></pre></td></tr></table></figure>\n\n<p>之后修改 package.json 文件，改一下入口文件，加一个 script：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;main&quot;: &quot;src/main.js&quot;,</span><br><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start:main&quot;: &quot;electron .&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn start:main</span><br></pre></td></tr></table></figure>\n\n<p>不出意外应该是成功了的。</p>\n<h3 id=\"在-React-中使用-Electron\"><a href=\"#在-React-中使用-Electron\" class=\"headerlink\" title=\"在 React 中使用 Electron\"></a>在 React 中使用 Electron</h3><p>默认在 React 中 使用 require(‘electron’) 是不行的，会报错:</p>\n<p><img src=\"https://segmentfault.com/img/bVbD0ug\" alt=\"image\"></p>\n<p>报错的原因是通过 <strong>create-react-app</strong> 创建的应用中 target 是 web 环境 ，因此不能识别 node api。</p>\n<p>下面通过两种途径可以来解决这个问题。</p>\n<h4 id=\"1-绕过-Webpack-的检查机制解决\"><a href=\"#1-绕过-Webpack-的检查机制解决\" class=\"headerlink\" title=\"1. 绕过 Webpack 的检查机制解决\"></a>1. 绕过 Webpack 的检查机制解决</h4><p>比较简单的处理办法就是使用 <code>window.require(&#39;electron&#39;)</code> 代替 <code>require(&#39;electron&#39;)</code>。window 对象在 electron 中是指向 global 的，所以它在执行时可以找到 require 函数。</p>\n<h4 id=\"2-修改-React-Webpack-配置解决\"><a href=\"#2-修改-React-Webpack-配置解决\" class=\"headerlink\" title=\"2. 修改 React Webpack 配置解决\"></a>2. 修改 React Webpack 配置解决</h4><p>为了验证上面报错原因的猜测，我尝试 eject 了一个项目去观察，配置中的 target 确实是缺失的，那么理论上把这个 target 修改为对应的 target 就可以支持 <code>require(&#39;electron&#39;)</code> 了。</p>\n<p><a href=\"https://www.webpackjs.com/configuration/target/\">你可以点击这里来查看 target 都有哪些</a></p>\n<p>显然我们需要的是：<code>electron-renderer</code>。</p>\n<p>为了修改这个 target，首先需要把 React 项目 <a href=\"https://create-react-app.dev/docs/available-scripts#npm-run-eject\">eject</a>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run eject</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Note: this is a one-way operation. Once you eject, you can’t go back!（此过程不可逆，请谨慎操作！）</p>\n</blockquote>\n<p>弹出后，打开 <code>config/webpack.config.js</code> 文件，大约在 <strong>130</strong> 行左右，添加代码片段中标记的那一句，我截取了一小段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">return &#123;</span><br><span class=\"line\">   target: &#x27;electron-renderer&#x27;, // &lt;- 添加这一句</span><br><span class=\"line\">   mode: isEnvProduction ? &#x27;production&#x27; : isEnvDevelopment &amp;&amp; &#x27;development&#x27;,</span><br><span class=\"line\">   // Stop compilation early in production</span><br><span class=\"line\">   bail: isEnvProduction,</span><br><span class=\"line\">   devtool: isEnvProduction</span><br><span class=\"line\">     ? shouldUseSourceMap</span><br></pre></td></tr></table></figure>\n\n<p>好了，重新启动后 <code>require(&#39;electron&#39;)</code> 就生效了，值得注意的是 <strong>无法直接在 Chrome 中运行，必须从 Electron 中打开。</strong></p>\n<h3 id=\"取消-React-默认打开浏览器的行为\"><a href=\"#取消-React-默认打开浏览器的行为\" class=\"headerlink\" title=\"取消 React 默认打开浏览器的行为\"></a>取消 React 默认打开浏览器的行为</h3><h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法 1\"></a>方法 1</h4><ul>\n<li><strong>bash</strong>:</li>\n</ul>\n<p>bash 可能还是比较常用的一个 terminal</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 设置临时环境变量</span><br><span class=\"line\">BROWSER=none</span><br><span class=\"line\"># 执行</span><br><span class=\"line\">yarn start:render</span><br><span class=\"line\"></span><br><span class=\"line\">#or</span><br><span class=\"line\"></span><br><span class=\"line\"># 连续命令</span><br><span class=\"line\">BROWSER=none &amp;&amp; yarn start:render</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>cmd</strong>:</li>\n</ul>\n<p>如果你用的是 cmd，你可以使用下面的方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 设置变量</span><br><span class=\"line\">set &quot;BROWSER=none&quot;</span><br><span class=\"line\"># 执行</span><br><span class=\"line\">yarn start:render</span><br><span class=\"line\"></span><br><span class=\"line\"># or</span><br><span class=\"line\"></span><br><span class=\"line\"># 连续命令</span><br><span class=\"line\">set &quot;BROWSER=none&quot; &amp;&amp; yarn start:render</span><br></pre></td></tr></table></figure>\n\n<p>设置临时环境变量只需要一次就可以了，该变量只在当前打开的 cmd 中有效。</p>\n<ul>\n<li><strong>pwsh</strong>:</li>\n</ul>\n<p>power shell 与 cmd 有所不同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 设置变量</span><br><span class=\"line\">$env:BROWSER=&quot;none&quot;</span><br><span class=\"line\"># 执行</span><br><span class=\"line\">yarn start:render</span><br><span class=\"line\"></span><br><span class=\"line\"># or</span><br><span class=\"line\"></span><br><span class=\"line\"># 连续命令(我这里尝试会卡住)</span><br><span class=\"line\">($env:BROWSER=&quot;none&quot;) -and (yarn start:render)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法 2\"></a>方法 2</h4><p>在根目录添加一个 .env 文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// .env</span><br><span class=\"line\">BROWSER=none</span><br></pre></td></tr></table></figure>\n\n<p>之后正常执行就可以。</p>\n<h2 id=\"3-打包-🛠️\"><a href=\"#3-打包-🛠️\" class=\"headerlink\" title=\"3. 打包 🛠️\"></a>3. 打包 🛠️</h2><p>没有打包功能的 Electron App 就没有意义，毕竟软件做出来是给人用的 🙃。</p>\n<p>Electron 方面推荐有两个打包工具：</p>\n<ul>\n<li>electron-forge</li>\n<li>electron-builder<br>相对来讲，electron-forge 更加适合于从零开始，直接基于 electron-forge 提供的模板项目开始开发 electron 应用。而 electron-builder 适合于对已有项目的打包。</li>\n</ul>\n<p>相信一般来到这里的大家或者我自己也是，已经准备好了一个项目，就差打包了，所以大家一般更倾向于使用 electron-builder。</p>\n<h3 id=\"安装-electron-builder\"><a href=\"#安装-electron-builder\" class=\"headerlink\" title=\"安装 electron-builder\"></a>安装 electron-builder</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add --dev electron-builder</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置-electron-builder\"><a href=\"#配置-electron-builder\" class=\"headerlink\" title=\"配置 electron-builder\"></a>配置 electron-builder</h3><p>在根目录创建一个 <strong>electron-builder.yml</strong> 的配置文件，用于配置 <strong>electron-builder</strong> 打包相关内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">appId: com.example.app</span><br><span class=\"line\">copyright: ©2020 bey6</span><br><span class=\"line\">productName: bey6</span><br><span class=\"line\"># asar 加密</span><br><span class=\"line\">asar: false</span><br><span class=\"line\">extends: null</span><br><span class=\"line\"></span><br><span class=\"line\"># 目录</span><br><span class=\"line\">directories:</span><br><span class=\"line\">  buildResources: assets/</span><br><span class=\"line\">  output: dist/</span><br><span class=\"line\"></span><br><span class=\"line\">files:</span><br><span class=\"line\">  - package.json</span><br><span class=\"line\">  - build/</span><br><span class=\"line\">  - node_modules/</span><br><span class=\"line\">  - src/main.js</span><br><span class=\"line\"></span><br><span class=\"line\">dmg:</span><br><span class=\"line\">  contents:</span><br><span class=\"line\">    - type: link</span><br><span class=\"line\">      path: /Applications</span><br><span class=\"line\">      x: 410</span><br><span class=\"line\">      y: 150</span><br><span class=\"line\">    - type: file</span><br><span class=\"line\">      x: 130</span><br><span class=\"line\">      y: 150</span><br><span class=\"line\">win:</span><br><span class=\"line\">  # 目标类型</span><br><span class=\"line\">  target: nsis</span><br><span class=\"line\"></span><br><span class=\"line\">nsis:</span><br><span class=\"line\">  oneClick: false</span><br><span class=\"line\">  # 允许修改安装路径</span><br><span class=\"line\">  allowToChangeInstallationDirectory: true</span><br><span class=\"line\">  # 安装给所有用户</span><br><span class=\"line\">  perMachine: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改-package-json\"><a href=\"#修改-package-json\" class=\"headerlink\" title=\"修改 package.json\"></a>修改 package.json</h3><ul>\n<li>修改 homepage</li>\n<li>scripts 中添加一个打包 win64 的脚本</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;homepage&quot;: &quot;.&quot;,</span><br><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build:win64&quot;: &quot;yarn build &amp;&amp; electron-builder --win --x64&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改-Main-Process\"><a href=\"#修改-Main-Process\" class=\"headerlink\" title=\"修改 Main Process\"></a>修改 Main Process</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// src/main.js</span><br><span class=\"line\">const &#123; app, BrowserWindow, ipcMain &#125; = require(&#x27;electron&#x27;)</span><br><span class=\"line\">const path = require(&#x27;path&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.allowRendererProcessReuse = true</span><br><span class=\"line\"></span><br><span class=\"line\">function createWindow () &#123;</span><br><span class=\"line\">  let win = new BrowserWindow(&#123;</span><br><span class=\"line\">    height: 500,</span><br><span class=\"line\">    width: 800,</span><br><span class=\"line\">    webPreferences: &#123;</span><br><span class=\"line\">      nodeIntegration: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修改这里</span><br><span class=\"line\">    if (process.env.NODE_ENV === &#x27;dev&#x27;) win.loadURL(`http://localhost:3000`)</span><br><span class=\"line\">    else win.loadFile(path.resolve(__dirname, &#x27;../build/index.html&#x27;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn build:win64</span><br></pre></td></tr></table></figure>\n\n<p>打包结束后会在根目录多出来一个 dist&#x2F; 目录，执行其中的 .exe 即可完成安装。</p>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"git如何正确回滚代码","url":"/2022/10/24/git%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9B%9E%E6%BB%9A%E4%BB%A3%E7%A0%81/","content":"<blockquote>\n<p>git 如何正确回滚代码</p>\n</blockquote>\n<h2 id=\"方法一，删除远程分支再提交\"><a href=\"#方法一，删除远程分支再提交\" class=\"headerlink\" title=\"方法一，删除远程分支再提交\"></a>方法一，删除远程分支再提交</h2><h3 id=\"①-首先保证当前工作区是干净的，并且和远程分支代码一致\"><a href=\"#①-首先保证当前工作区是干净的，并且和远程分支代码一致\" class=\"headerlink\" title=\"① 首先保证当前工作区是干净的，并且和远程分支代码一致\"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git co currentBranch</span><br><span class=\"line\">$ git pull origin currentBranch</span><br><span class=\"line\">$ git co ./</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"②-备份当前分支（如有必要）\"><a href=\"#②-备份当前分支（如有必要）\" class=\"headerlink\" title=\"② 备份当前分支（如有必要）\"></a>② 备份当前分支（如有必要）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git branch currentBranchBackUp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"③-恢复到指定的-commit-hash\"><a href=\"#③-恢复到指定的-commit-hash\" class=\"headerlink\" title=\"③ 恢复到指定的 commit hash\"></a>③ 恢复到指定的 commit hash</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git reset --hard resetVersionHash //将当前branch的HEAD指针指向commit hash</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://gtms04.alicdn.com/tps/i4/TB1Q0yyLpXXXXXpXXXXPw.CWFXX-632-320.png\" alt=\"image\"></p>\n<h3 id=\"④-删除当前分支的远程分支\"><a href=\"#④-删除当前分支的远程分支\" class=\"headerlink\" title=\"④ 删除当前分支的远程分支\"></a>④ 删除当前分支的远程分支</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git push origin :currentBranch</span><br><span class=\"line\">$ //或者这么写git push origin --delete currentBranch</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"⑤-把当前分支提交到远程\"><a href=\"#⑤-把当前分支提交到远程\" class=\"headerlink\" title=\"⑤ 把当前分支提交到远程\"></a>⑤ 把当前分支提交到远程</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git push origin currentBranch</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法二，强制-push-远程分支\"><a href=\"#方法二，强制-push-远程分支\" class=\"headerlink\" title=\"方法二，强制 push 远程分支\"></a>方法二，强制 push 远程分支</h2><h3 id=\"①-首先保证当前工作区是干净的，并且和远程分支代码一致-1\"><a href=\"#①-首先保证当前工作区是干净的，并且和远程分支代码一致-1\" class=\"headerlink\" title=\"① 首先保证当前工作区是干净的，并且和远程分支代码一致\"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><h3 id=\"②-备份当前分支（如有必要）-1\"><a href=\"#②-备份当前分支（如有必要）-1\" class=\"headerlink\" title=\"② 备份当前分支（如有必要）\"></a>② 备份当前分支（如有必要）</h3><h3 id=\"③-恢复到指定的-commit-hash-1\"><a href=\"#③-恢复到指定的-commit-hash-1\" class=\"headerlink\" title=\"③ 恢复到指定的 commit hash\"></a>③ 恢复到指定的 commit hash</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git reset --hard resetVersionHash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"④-把当前分支强制提交到远程\"><a href=\"#④-把当前分支强制提交到远程\" class=\"headerlink\" title=\"④ 把当前分支强制提交到远程\"></a>④ 把当前分支强制提交到远程</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git push -f origin currentBranch</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法三，从回滚位置生成新的-commit-hash\"><a href=\"#方法三，从回滚位置生成新的-commit-hash\" class=\"headerlink\" title=\"方法三，从回滚位置生成新的 commit hash\"></a>方法三，从回滚位置生成新的 commit hash</h2><h3 id=\"①-首先保证当前工作区是干净的，并且和远程分支代码一致-2\"><a href=\"#①-首先保证当前工作区是干净的，并且和远程分支代码一致-2\" class=\"headerlink\" title=\"① 首先保证当前工作区是干净的，并且和远程分支代码一致\"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><h4 id=\"②-备份当前分支（如有必要）-2\"><a href=\"#②-备份当前分支（如有必要）-2\" class=\"headerlink\" title=\"② 备份当前分支（如有必要）\"></a>② 备份当前分支（如有必要）</h4><h3 id=\"③-使用-git-revert-恢复到指定的-commit-hash，当前分支恢复到-a-gt-3-版本（见下图）\"><a href=\"#③-使用-git-revert-恢复到指定的-commit-hash，当前分支恢复到-a-gt-3-版本（见下图）\" class=\"headerlink\" title=\"③ 使用 git revert 恢复到指定的 commit hash，当前分支恢复到 a&gt;3 版本（见下图）\"></a>③ 使用 git revert 恢复到指定的 commit hash，当前分支恢复到 a&gt;3 版本（见下图）</h3><h4 id=\"a）此方法会产生一条多余的-commit-hash-amp-log，其实-1c0ce98-和-01592eb-内容上是一致的\"><a href=\"#a）此方法会产生一条多余的-commit-hash-amp-log，其实-1c0ce98-和-01592eb-内容上是一致的\" class=\"headerlink\" title=\"a）此方法会产生一条多余的 commit hash&amp;log，其实 1c0ce98 和 01592eb 内容上是一致的\"></a>a）此方法会产生一条多余的 commit hash&amp;log，其实 1c0ce98 和 01592eb 内容上是一致的</h4><h4 id=\"b）git-revert-是以要回滚的-commit-hash-1c0ce98-为基础，新生成一个-commit-hash-01592eb\"><a href=\"#b）git-revert-是以要回滚的-commit-hash-1c0ce98-为基础，新生成一个-commit-hash-01592eb\" class=\"headerlink\" title=\"b）git revert 是以要回滚的 commit hash(1c0ce98)为基础，新生成一个 commit hash(01592eb)\"></a>b）git revert 是以要回滚的 commit hash(1c0ce98)为基础，新生成一个 commit hash(01592eb)</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git revert resetVersionHash</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://gtms04.alicdn.com/tps/i4/TB1VdurLpXXXXcuXXXX_mKs_XXX-873-308.png\" alt=\"image\"></p>\n<h3 id=\"④-提交远程分支\"><a href=\"#④-提交远程分支\" class=\"headerlink\" title=\"④ 提交远程分支\"></a>④ 提交远程分支</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git push origin currentBranch</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法四，从回滚位置生成新的分支-merge\"><a href=\"#方法四，从回滚位置生成新的分支-merge\" class=\"headerlink\" title=\"方法四，从回滚位置生成新的分支 merge\"></a>方法四，从回滚位置生成新的分支 merge</h2><h3 id=\"①-首先保证当前工作区是干净的，并且和远程分支代码一致-3\"><a href=\"#①-首先保证当前工作区是干净的，并且和远程分支代码一致-3\" class=\"headerlink\" title=\"① 首先保证当前工作区是干净的，并且和远程分支代码一致\"></a>① 首先保证当前工作区是干净的，并且和远程分支代码一致</h3><h3 id=\"②-备份当前分支（如有必要）-3\"><a href=\"#②-备份当前分支（如有必要）-3\" class=\"headerlink\" title=\"② 备份当前分支（如有必要）\"></a>② 备份当前分支（如有必要）</h3><h3 id=\"③-把当前工作区的-HEAD-指针指向回滚的-commit-hash-注意不是-branch-的-HEAD-指针\"><a href=\"#③-把当前工作区的-HEAD-指针指向回滚的-commit-hash-注意不是-branch-的-HEAD-指针\" class=\"headerlink\" title=\"③ 把当前工作区的 HEAD 指针指向回滚的 commit hash(注意不是 branch 的 HEAD 指针)\"></a>③ 把当前工作区的 HEAD 指针指向回滚的 commit hash(注意不是 branch 的 HEAD 指针)</h3><p><strong>Notice:这个时候工作区 HEAD 没有指向分支，称为匿名分支 detached HEAD</strong>。</p>\n<p>这个时候提交 commit 后无法保存状态，git 中的任何提交必须是在当前工作区 HEAD 所在分支的 HEAD 上进行 push hash 入栈，所以 HEAD 必须是属于某个分支的 HEAD 位置，提交才生效。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git co resetVersionHash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"④-以该-commit-hash-创建一个新的分支\"><a href=\"#④-以该-commit-hash-创建一个新的分支\" class=\"headerlink\" title=\"④ 以该 commit hash 创建一个新的分支\"></a>④ 以该 commit hash 创建一个新的分支</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git co -b newRevertedHash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"⑤-切换到当前分支，合并-newRevertedHash。\"><a href=\"#⑤-切换到当前分支，合并-newRevertedHash。\" class=\"headerlink\" title=\"⑤ 切换到当前分支，合并 newRevertedHash。\"></a>⑤ 切换到当前分支，合并 newRevertedHash。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git co currentBranch</span><br><span class=\"line\">$ git merge newRevertedHash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"⑥-进行代码-diff，完成代码回滚，push-到远程-currentBranch\"><a href=\"#⑥-进行代码-diff，完成代码回滚，push-到远程-currentBranch\" class=\"headerlink\" title=\"⑥ 进行代码 diff，完成代码回滚，push 到远程 currentBranch\"></a>⑥ 进行代码 diff，完成代码回滚，push 到远程 currentBranch</h3><p><strong>Notice: 也可以直接 hotfix，从要回滚的地方直接重新打包一个新 tag 包，发版本 hotFixVersion 即可。</strong></p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"js---输出100-200之间所有的素数","url":"/2022/10/24/js-%E8%BE%93%E5%87%BA100-200%E4%B9%8B%E9%97%B4%E6%89%80%E6%9C%89%E7%9A%84%E7%B4%A0%E6%95%B0/","content":"<p>采用两种方式，第一种是标记法，第二种是计数法，两种方法原理是相同的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> //标记法</span><br><span class=\"line\">function fn(m, n) &#123;</span><br><span class=\"line\">    var count = &quot;&quot;;</span><br><span class=\"line\">    for (i = m; i &lt;= n; i++) &#123;//第一次循环</span><br><span class=\"line\">        var flage = true;//设一个标记</span><br><span class=\"line\">        for (j = 2; j &lt; i; j++) &#123;</span><br><span class=\"line\">            if (i % j === 0) &#123;//第二次循环</span><br><span class=\"line\">                flage = false;//不满足条件改变标记，</span><br><span class=\"line\">                break;//跳出循环</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (flage) &#123;//满足条件，也就是为true时</span><br><span class=\"line\">            count += i + &quot;,&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(fn(100, 200)) //调用函数，输出值</span><br><span class=\"line\"></span><br><span class=\"line\">//计数法</span><br><span class=\"line\">function fn(m, n) &#123;</span><br><span class=\"line\">    var sun = &quot;&quot;;</span><br><span class=\"line\">    for (i = m; i &lt;= n; i++) &#123;//第一次循环</span><br><span class=\"line\">        var count = 0;//初值为零</span><br><span class=\"line\">        for (j = 2; j &lt; i; j++) &#123;//第二次循环</span><br><span class=\"line\">            if (i % j === 0) &#123;//不满足条件加1</span><br><span class=\"line\">                count+=1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (count === 0) &#123;</span><br><span class=\"line\">            sun += i + &quot;,&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(fn(100, 200))</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"merge和rebase的区别","url":"/2022/10/24/merge%E5%92%8Crebase%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我从用 git 就一直用 rebase，但是新的公司需要用 merge 命令，我不是很明白，所以查了一些资料，总结了下面的内容，如果有什么不妥的地方，还望指正，我一定虚心学习。</p>\n<h2 id=\"merge-和-rebase\"><a href=\"#merge-和-rebase\" class=\"headerlink\" title=\"merge 和 rebase\"></a>merge 和 rebase</h2><p>标题上的两个命令：merge 和 rebase 都是用来合并分支的。</p>\n<p><strong>这里不解释 rebase 命令，以及两个命令的原理</strong>，详细解释参考<a href=\"http://gitbook.liuhui998.com/4_2.html\">这里</a>。</p>\n<p>下面的内容主要说的是两者在实际操作中的区别。</p>\n<h2 id=\"什么是分支\"><a href=\"#什么是分支\" class=\"headerlink\" title=\"什么是分支\"></a>什么是分支</h2><p>分支就是便于多人在同一项目中的协作开发。比方说：每个人开发不同的功能，在各自的分支开发过程中互不影响，完成后都提交到 develop 分支。极大的提高了开发的效率。</p>\n<h2 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h2><p>每个人创建一个分支进行开发，当开发完成，需要合并到 develop 分支的时候，就需要用到合并的命令。</p>\n<h2 id=\"什么是冲突\"><a href=\"#什么是冲突\" class=\"headerlink\" title=\"什么是冲突\"></a>什么是冲突</h2><p>合并的时候，有可能会产生冲突。</p>\n<p>冲突的产生是因为在合并的时候，不同分支修改了相同的位置。所以在合并的时候 git 不知道那个到底是你想保留的，所以就提出疑问（冲突提醒）让你自己手动选择想要保留的内容，从而解决冲突。</p>\n<h2 id=\"merge-和-rebase-的区别\"><a href=\"#merge-和-rebase-的区别\" class=\"headerlink\" title=\"merge 和 rebase 的区别\"></a>merge 和 rebase 的区别</h2><ol>\n<li>采用 merge 和 rebase 后，git log 的区别，<strong>merge 命令不会保留 merge 的分支的 commit</strong>：</li>\n<li><img src=\"https://images2015.cnblogs.com/blog/759200/201608/759200-20160806092734215-279978821.png\" alt=\"image\"></li>\n</ol>\n<p>处理冲突的方式：</p>\n<ul>\n<li>（一股脑）使用<code>merge</code>命令合并分支，解决完冲突，执行<code>git add .</code>和<code>git commit -m&#39;fix conflict</code>‘。这个时候会产生一个 commit。</li>\n<li>（交互式）使用 rebase 命令合并分支，解决完冲突，执行<code>git add .</code>和<code>git rebase --continue</code>，不会产生额外的 commit。这样的好处是，‘干净’，分支上不会有无意义的解决分支的 commit；坏处，如果合并的分支中存在多个 commit，需要重复处理多次冲突。</li>\n</ul>\n<ol start=\"3\">\n<li><code>git pull</code>和<code>git pull --rebase</code>区别：<code>git pull</code>做了两个操作分别是‘获取’和合并。所以加了 rebase 就是以 rebase 的方式进行合并分支，默认为 merge。</li>\n</ol>\n<h2 id=\"git-merge-和-git-merge-no-ff的区别\"><a href=\"#git-merge-和-git-merge-no-ff的区别\" class=\"headerlink\" title=\"git merge 和 git merge --no-ff的区别\"></a><code>git merge</code> 和 <code>git merge --no-ff</code>的区别</h2><p>1、我自己尝试 merge 命令后，发现：merge 时并没有产生一个 commit。不是说 merge 时会产生一个 merge commit 吗？</p>\n<p>注意：只有在冲突的时候，解决完冲突才会自动产生一个 commit。</p>\n<p>如果想在没有冲突的情况下也自动生成一个 commit，记录此次合并就可以用：git merge –no-ff 命令，下面用一张图来表示两者的区别：</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/759200/201608/759200-20160806092744747-1816899042.png\" alt=\"image\"></p>\n<p>2、如果不加 –no-ff 则被合并的分支之前的 commit 都会被抹去，只会保留一个解决冲突后的 merge commit。</p>\n<h2 id=\"如何选择合并分支的方式\"><a href=\"#如何选择合并分支的方式\" class=\"headerlink\" title=\"如何选择合并分支的方式\"></a>如何选择合并分支的方式</h2><p>我的理解：主要是看哪个命令用的熟练，能够有效的管理自己的代码；还有就是团队用的是哪种方式。</p>\n<p>我对于 rebase 比较熟悉，所以我一般都用<code>rebase</code>，但是现在的公司用的是<code>merge --no-ff</code>命令合并分支。所以，我在工作上就用 merge，个人项目就用 rebase。</p>\n<p>也可以两者结合：</p>\n<p>获取远程项目中最新代码时：<code>git pull --rebase</code>，这个是隐性的合并远程分支的代码不会产生额外的 commit（但是如果存在冲突的 commit 太多就像上面说的，需要处理很多遍冲突）。</p>\n<p>合并到分支的时候：<code>git merge --no-ff</code>，自动一个<code>merge commit</code>，便于管理（这看管理人员怎么认为了）</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>看懂上面的两幅图就行了。</p>\n<ol>\n<li>commit log 的区别</li>\n<li>处理冲突的方式</li>\n</ol>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"mobx学习总结","url":"/2022/12/16/mobx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<h2 id=\"一、Mobx-解决的问题\"><a href=\"#一、Mobx-解决的问题\" class=\"headerlink\" title=\"一、Mobx 解决的问题\"></a>一、Mobx 解决的问题</h2><p>传统 React 使用的数据管理库为 Redux。Redux 要解决的问题是统一数据流，数据流完全可控并可追踪。要实现该目标，便需要进行相关的约束。Redux 由此引出了 dispatch action reducer 等概念，对 state 的概念进行强约束。然而对于一些项目来说，太过强，便失去了灵活性。Mobx 便是来填补此空缺的。</p>\n<p>这里对 Redux 和 Mobx 进行简单的对比：</p>\n<ol>\n<li><p>Redux 的编程范式是函数式的而 Mobx 是面向对象的；</p>\n</li>\n<li><p>因此数据上来说 Redux 理想的是 immutable 的，每次都返回一个新的数据，而 Mobx 从始至终都是一份引用。因此 Redux 是支持数据回溯的；</p>\n</li>\n<li><p>然而和 Redux 相比，使用 Mobx 的组件可以做到精确更新，这一点得益于 Mobx 的 observable；对应的，Redux 是用 dispath 进行广播，通过 Provider 和 connect 来比对前后差别控制更新粒度，有时需要自己写 SCU；Mobx 更加精细一点。</p>\n</li>\n</ol>\n<h2 id=\"二、-Mobx-核心概念\"><a href=\"#二、-Mobx-核心概念\" class=\"headerlink\" title=\"二、 Mobx 核心概念\"></a>二、 Mobx 核心概念</h2><p><img src=\"https://segmentfault.com/img/remote/1460000013810517\" alt=\"image\"></p>\n<p>Mobx 的核心原理是通过 action 触发 state 的变化，进而触发 state 的衍生对象（computed value &amp; Reactions）。</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>在 Mobx 中，State 就对应业务的最原始状态，通过 observable 方法，可以使这些状态变得可观察。</p>\n<p>通常支持被 observable 的类型有三个，分别是 Object, Array, Map；对于原始类型，可以使用 Obserable.box。</p>\n<p>值得注意的一点是，当某一数据被 observable 包装后，他返回的其实是被 observable 包装后的类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const Mobx = require(&quot;mobx&quot;);</span><br><span class=\"line\">const &#123; observable, autorun &#125; = Mobx;</span><br><span class=\"line\">const obArray = observable([1, 2, 3]);</span><br><span class=\"line\">console.log(&quot;ob is Array:&quot;, Array.isArray(obArray));</span><br><span class=\"line\">console.log(&quot;ob:&quot;, obArray);</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ob is Array: false</span><br><span class=\"line\">ob: ObservableArray &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于该问题，解决方法也很简单，可以通过 Mobx 原始提供的 observable.toJS()转换成 JS 再判断，或者直接使用 Mobx 原生提供的 APIisObservableArray 进行判断。</p>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><p>Mobx 中 state 的设计原则和 redux 有一点是相同的，那就是尽可能保证 state 足够小，足够原子。这样设计的原则不言而喻，无论是维护性还是性能。那么对于依赖 state 的数据而衍生出的数据，可以使用 computed。</p>\n<p>简而言之，你有一个值，该值的结果依赖于 state，并且该值也需要被 observable，那么就使用 computed。</p>\n<p>通常应该尽可能的使用计算属性，并且由于其函数式的特点，可以最大化优化性能。如果计算属性依赖的 state 没改变，或者该计算值没有被其他计算值或响应（reaction）使用，computed 便不会运行。在这种情况下，computed 处于暂停状态，此时若该计算属性不再被 observable。那么其便会被 Mobx 垃圾回收。</p>\n<p>简单介绍 computed 的一个使用场景</p>\n<p>假如你观察了一个数组，你想根据数组的长度变化作出反应，在不使用 computed 时代码是这样的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const Mobx = require(&quot;mobx&quot;);</span><br><span class=\"line\">const &#123; observable, autorun, computed &#125; = Mobx;</span><br><span class=\"line\">var numbers = observable([1, 2, 3]);</span><br><span class=\"line\">autorun(() =&gt; console.log(numbers.length));</span><br><span class=\"line\">// 输出 &#x27;3&#x27;</span><br><span class=\"line\">numbers.push(4);</span><br><span class=\"line\">// 输出 &#x27;4&#x27;</span><br><span class=\"line\">numbers[0] = 0;</span><br><span class=\"line\">// 输出 &#x27;4&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>最后一行其实只是改了数组中的一个值，但是也触发了 autorun 的执行。此时如果用 computed 便会解决该问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const Mobx = require(&quot;mobx&quot;);</span><br><span class=\"line\">const &#123; observable, autorun, computed &#125; = Mobx;</span><br><span class=\"line\">var numbers = observable([1, 2, 3]);</span><br><span class=\"line\">var sum = computed(() =&gt; numbers.length);</span><br><span class=\"line\">autorun(() =&gt; console.log(sum.get()));</span><br><span class=\"line\">// 输出 &#x27;3&#x27;</span><br><span class=\"line\">numbers.push(4);</span><br><span class=\"line\">// 输出 &#x27;4&#x27;</span><br><span class=\"line\">numbers[0] = 1;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"autorun\"><a href=\"#autorun\" class=\"headerlink\" title=\"autorun\"></a>autorun</h3><p>另一个响应 state 的 api 便是 autorun。和 computed 类似，每当依赖的值改变时，其都会改变。不同的是，autorun 没有了 computed 的优化（当然，依赖值未改变的情况下也不会重新运行，但不会被自动回收）。因此在使用场景来说，autorun 通常用来执行一些有副作用的。例如打印日志，更新 UI 等等。</p>\n<h3 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h3><p>在 redux 中，唯一可以更改 state 的途径便是 dispatch 一个 action。这种约束性带来的一个好处是可维护性。整个 state 只要改变必定是通过 action 触发的，对此只要找到 reducer 中对应的 action 便能找到影响数据改变的原因。强约束性是好的，但是 Redux 要达到约束性的目的，似乎要写许多样板代码，虽说有许多库都在解决该问题，然而 Mobx 从根本上来说会更加优雅。</p>\n<p>首先 Mobx 并不强制所有 state 的改变必须通过 action 来改变，这主要适用于一些较小的项目。对于较大型的，需要多人合作的项目来说，可以使用 Mobx 提供的 api configure 来强制。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Mobx.configure(&#123;enforceActions: true&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其原理也很简单</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function configure(options)&#123;</span><br><span class=\"line\">    if (options.enforceActions !== undefined) &#123;</span><br><span class=\"line\">        globalState.enforceActions = !!options.enforceActions</span><br><span class=\"line\">        globalState.allowStateChanges = !options.enforceActions</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过改变全局的 strictMode 以及 allowStateChanges 属性的方式来实现强制使用 action。</p>\n<h2 id=\"三、Mobx-异步处理\"><a href=\"#三、Mobx-异步处理\" class=\"headerlink\" title=\"三、Mobx 异步处理\"></a>三、Mobx 异步处理</h2><p>和 Redux 不同的是，Mobx 在异步处理上并不复杂，不需要引入额外的类似 redux-thunk、redux-saga 这样的库。</p>\n<p>唯一需要注意的是，在严格模式下，对于异步 action 里的回调，若该回调也要修改 observable 的值，那么</p>\n<p>该回调也需要绑定 action。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const Mobx = require(&quot;mobx&quot;);</span><br><span class=\"line\">Mobx.configure(&#123; enforceActions: true &#125;);</span><br><span class=\"line\">const &#123; observable, autorun, computed, extendObservable, action &#125; = Mobx;</span><br><span class=\"line\">class Store &#123;</span><br><span class=\"line\">  @observable a = 123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @action</span><br><span class=\"line\">  changeA() &#123;</span><br><span class=\"line\">    this.a = 0;</span><br><span class=\"line\">    setTimeout(this.changeB, 1000);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @action.bound</span><br><span class=\"line\">  changeB() &#123;</span><br><span class=\"line\">    this.a = 1000;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var s = new Store();</span><br><span class=\"line\">autorun(() =&gt; console.log(s.a));</span><br><span class=\"line\">s.changeA();</span><br></pre></td></tr></table></figure>\n\n<p>这里用了 action.bound 语法糖，目的是为了解决 javascript 作用域问题。</p>\n<p>另外一种更简单的写法是直接包装 action</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const Mobx = require(&quot;mobx&quot;);</span><br><span class=\"line\">Mobx.configure(&#123; enforceActions: true &#125;);</span><br><span class=\"line\">const &#123; observable, autorun, computed, extendObservable, action &#125; = Mobx;</span><br><span class=\"line\">class Store &#123;</span><br><span class=\"line\">  @observable a = 123;</span><br><span class=\"line\">  @action</span><br><span class=\"line\">  changeA() &#123;</span><br><span class=\"line\">    this.a = 0;</span><br><span class=\"line\">    setTimeout(action(&#x27;changeB&#x27;,()=&gt;&#123;</span><br><span class=\"line\">      this.a = 1000;</span><br><span class=\"line\">    &#125;), 1000);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var s = new Store();</span><br><span class=\"line\">autorun(() =&gt; console.log(s.a));</span><br><span class=\"line\">s.changeA();</span><br></pre></td></tr></table></figure>\n\n<p>如果不想到处写 action，可以使用 Mobx 提供的工具函数 runInAction 来简化操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"> @action</span><br><span class=\"line\">  changeA() &#123;</span><br><span class=\"line\">    this.a = 0;</span><br><span class=\"line\">    setTimeout(</span><br><span class=\"line\">      runInAction(() =&gt; &#123;</span><br><span class=\"line\">        this.a = 1000;</span><br><span class=\"line\">      &#125;),</span><br><span class=\"line\">      1000</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>通过该工具函数，可以将所有对 observable 值的操作放在一个回调里，而不是命名各种各样的 action。</p>\n<p>最后，Mobx 提供的一个工具函数，其原理 redux-saga，使用 ES6 的 generator 来实现异步操作，可以彻底摆脱 action 的干扰。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@asyncAction</span><br><span class=\"line\">  changeA() &#123;</span><br><span class=\"line\">    this.a = 0;</span><br><span class=\"line\">    const data = yield Promise.resolve(1)</span><br><span class=\"line\">    this.a = data;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Mobx-原理分析\"><a href=\"#四、Mobx-原理分析\" class=\"headerlink\" title=\"四、Mobx 原理分析\"></a>四、Mobx 原理分析</h2><h3 id=\"autorun-1\"><a href=\"#autorun-1\" class=\"headerlink\" title=\"autorun\"></a>autorun</h3><p>Mobx 的核心就是通过 observable 观察某一个变量，当该变量产生变化时，对应的 autorun 内的回调函数就会发生变化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const Mobx = require(&quot;mobx&quot;);</span><br><span class=\"line\">const &#123; observable, autorun &#125; = Mobx;</span><br><span class=\"line\">const ob = observable(&#123; a: 1, b: 1 &#125;);</span><br><span class=\"line\">autorun(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;ob.b:&quot;, ob.b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ob.b = 2;</span><br></pre></td></tr></table></figure>\n\n<p>执行该代码会发现，log 了两遍 ob.b 的值。其实从这个就能猜到，<strong>Mobx 是通过代理变量的 getter 和 setter 来实现的变量更新功能</strong>。首先先代理变量的 getter 函数，然后通过预执行一遍 autorun 中回调，从而触发 getter 函数，来实现观察值的收集，依次来代理 setter。之后只要 setter 触发便执行收集好的回调就 ok 了。<br>具体源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function autorun(view, opts)&#123;</span><br><span class=\"line\">    reaction = new Reaction(name, function () &#123;</span><br><span class=\"line\">           this.track(reactionRunner);</span><br><span class=\"line\">    &#125;, opts.onError);</span><br><span class=\"line\">   function reactionRunner() &#123;</span><br><span class=\"line\">        view(reaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>autorun 的核心就是这一段，这里 view 就是 autorun 里的回调函数。具体到 track 函数，比较关键到代码是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Reaction.prototype.track = function (fn) &#123;</span><br><span class=\"line\">    var result = trackDerivedFunction(this, fn, undefined);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>trackDerivedFunction 函数中会执行 autorun 里的回调函数，紧接着会触发 observable 中代理的函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function generateObservablePropConfig(propName) &#123;</span><br><span class=\"line\">    return (observablePropertyConfigs[propName] ||</span><br><span class=\"line\">        (observablePropertyConfigs[propName] = &#123;</span><br><span class=\"line\">            configurable: true,</span><br><span class=\"line\">            enumerable: true,</span><br><span class=\"line\">            get: function () &#123;</span><br><span class=\"line\">                return this.$mobx.read(this, propName);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            set: function (v) &#123;</span><br><span class=\"line\">                this.$mobx.write(this, propName, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 get 中会将回调与其绑定，之后更改了 observable 中的值时，都会触发这里的 set，然后随即触发绑定的函数。</p>\n<h2 id=\"五、Mobx-的一些坑\"><a href=\"#五、Mobx-的一些坑\" class=\"headerlink\" title=\"五、Mobx 的一些坑\"></a>五、Mobx 的一些坑</h2><p>通过 autorun 的实现原理可以发现，会出现很多我们想象中应该触发，但是没有触发的场景，例如：</p>\n<ol>\n<li>无法收集新增的属性</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const Mobx = require(&quot;mobx&quot;);</span><br><span class=\"line\">const &#123; observable, autorun &#125; = Mobx;</span><br><span class=\"line\">let ob = observable(&#123; a: 1, b: 1 &#125;);</span><br><span class=\"line\">autorun(() =&gt; &#123;</span><br><span class=\"line\">  if(ob.c)&#123;</span><br><span class=\"line\">    console.log(&quot;ob.c:&quot;, ob.c);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ob.c = 1</span><br></pre></td></tr></table></figure>\n\n<p>对于该问题，可以通过 extendObservable(target, props)方法来实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const Mobx = require(&quot;mobx&quot;);</span><br><span class=\"line\">const &#123; observable, autorun, computed, extendObservable &#125; = Mobx;</span><br><span class=\"line\">var numbers = observable(&#123; a: 1, b: 2 &#125;);</span><br><span class=\"line\">extendObservable(numbers, &#123; c: 1 &#125;);</span><br><span class=\"line\">autorun(() =&gt; console.log(numbers.c));</span><br><span class=\"line\">numbers.c = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 3</span><br></pre></td></tr></table></figure>\n\n<p>extendObservable 该 API 会可以为对象新增加 observal 属性。</p>\n<p><strong>当然，如果你对变量的 entry 增删非常关心，应该使用 Map 数据结构而不是 Object。</strong></p>\n<ol start=\"2\">\n<li>回调函数若依赖外部环境，则无法进行收集</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const Mobx = require(&quot;mobx&quot;);</span><br><span class=\"line\">const &#123; observable, autorun &#125; = Mobx;</span><br><span class=\"line\">let ob = observable(&#123; a: 1, b: 1 &#125;);</span><br><span class=\"line\">let x = 0;</span><br><span class=\"line\">autorun(() =&gt; &#123;</span><br><span class=\"line\">  if(x == 1)&#123;</span><br><span class=\"line\">    console.log(&quot;ob.c:&quot;, ob.b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">x = 1;</span><br><span class=\"line\">ob.b = 2;</span><br></pre></td></tr></table></figure>\n\n<p>很好理解，autorun 的回调函数在预执行的时候无法到达 ob.b 那一行代码，所以收集不到。</p>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"mpvue使用手册","url":"/2022/12/16/mpvue%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","content":"<h2 id=\"使用手册\"><a href=\"#使用手册\" class=\"headerlink\" title=\"使用手册\"></a>使用手册</h2><p>mpvue 继承自 Vue.js，其技术规范和语法特点与 Vue.js 保持一致。</p>\n<p>本文档适用于有一定 Vue.js 使用经验的开发者。我们默认你已经掌握 Vue.js 技术体系，如果你是新手，你可能需要先熟悉 Vue.js 官方文档。</p>\n<h2 id=\"五分钟教程\"><a href=\"#五分钟教程\" class=\"headerlink\" title=\"五分钟教程\"></a>五分钟教程</h2><p>通过 Vue.js 命令行工具 vue-cli，你只需在终端窗口输入几条简单命令，即可快速创建和启动一个带热重载、保存时静态检查、内置代码构建功能的小程序项目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 全局安装 vue-cli</span><br><span class=\"line\">$ npm install --global vue-cli</span><br><span class=\"line\"></span><br><span class=\"line\"># 创建一个基于 mpvue-quickstart 模板的新项目</span><br><span class=\"line\">$ vue init mpvue/mpvue-quickstart my-project</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装依赖</span><br><span class=\"line\">$ cd my-project</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\"># 启动构建</span><br><span class=\"line\">$ npm run dev</span><br></pre></td></tr></table></figure>\n\n<p>接下来，你只需要启动微信开发者工具，引入项目即可预览到你的第一个 mpvue 小程序。</p>\n<h2 id=\"框架原理\"><a href=\"#框架原理\" class=\"headerlink\" title=\"框架原理\"></a>框架原理</h2><ul>\n<li>mpvue 保留了 vue.runtime 核心方法，无缝继承了 Vue.js 的基础能力</li>\n<li>mpvue-template-compiler 提供了将 vue 的模板语法转换到小程序的 wxml 语法的能力</li>\n<li>修改了 vue 的建构配置，使之构建出符合小程序项目结构的代码格式： json&#x2F;wxml&#x2F;wxss&#x2F;js 文件</li>\n</ul>\n<h2 id=\"Vue-实例\"><a href=\"#Vue-实例\" class=\"headerlink\" title=\"Vue 实例\"></a>Vue 实例</h2><p><a href=\"https://cn.vuejs.org/v2/guide/instance.html\">支持 官方文档：Vue 实例</a>，同时我们做了一些修改，来适应小程序的独特加载逻辑。</p>\n<h2 id=\"实例生命周期\"><a href=\"#实例生命周期\" class=\"headerlink\" title=\"实例生命周期\"></a>实例生命周期</h2><p>同 vue，不同的是我们会在小程序 onReady 后，再去触发 vue mounted 生命周期，详细的 vue 生命周期文档请看<a href=\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\">生命周期钩子</a></p>\n<ul>\n<li>beforeCreate</li>\n<li>created</li>\n<li>beforeMount</li>\n<li>mounted</li>\n<li>beforeUpdate</li>\n<li>updated</li>\n<li>activated</li>\n<li>deactivated</li>\n<li>beforeDestroy</li>\n<li>destroyed</li>\n</ul>\n<p>除了 Vue 本身的生命周期外，mpvue 还兼容了小程序生命周期，这部分生命周期钩子的来源于<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html\">微信小程序的 Page</a>， 除特殊情况外，不建议使用小程序的生命周期钩子。</p>\n<p><strong>app 部分</strong>：</p>\n<ul>\n<li>onLaunch，初始化</li>\n<li>onShow，当小程序启动，或从后台进入前台显示</li>\n<li>onHide，当小程序从前台进入后台</li>\n</ul>\n<p><strong>page 部分</strong>：</p>\n<ul>\n<li>onLoad，监听页面加载</li>\n<li>onShow，监听页面显示</li>\n<li>onReady，监听页面初次渲染完成</li>\n<li>onHide，监听页面隐藏</li>\n<li>onUnload，监听页面卸载</li>\n<li>onPullDownRefresh，监听用户下拉动作</li>\n<li>onReachBottom，页面上拉触底事件的处理函数</li>\n<li>onShareAppMessage，用户点击右上角分享</li>\n<li>onPageScroll，页面滚动</li>\n<li>onTabItemTap, 当前是 tab 页时，点击 tab 时触发 （mpvue 0.0.16 支持）<br>用法示例：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created () &#123;</span><br><span class=\"line\">    // `this` 指向 vm 实例</span><br><span class=\"line\">    console.log(&#x27;a is: &#x27; + this.a)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onShow () &#123;</span><br><span class=\"line\">    // `this` 指向 vm 实例</span><br><span class=\"line\">    console.log(&#x27;a is: &#x27; + this.a, &#x27;小程序触发的 onshow&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// =&gt; &quot;a is: 1&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意点</strong>：</p>\n<ol>\n<li><p>不要在选项属性或回调上使用箭头函数，比如 created: () &#x3D;&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue &#x3D;&gt; this.myMethod())。因为箭头函数是和父级上下文绑定在一起的，this 不会是如你做预期的 Vue 实例，且 this.a 或 this.myMethod 也会是未定义的。</p>\n</li>\n<li><p>微信小程序的页面的 query 参数是通过 onLoad 获取的，mpvue 对此进行了优化，直接通过 this.$root.$mp.query 获取相应的参数数据，其调用需要在 onLoad 生命周期触发之后使用，比如 onShow 等，具体生命周期调用顺序，见下图。</p>\n</li>\n</ol>\n<h2 id=\"生命周期图示\"><a href=\"#生命周期图示\" class=\"headerlink\" title=\"生命周期图示\"></a>生命周期图示</h2><blockquote>\n<p>你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p>\n</blockquote>\n<p>生命周期的调用关系和顺序图。</p>\n<p><img src=\"http://mpvue.com/assets/img/lifecycle.a8762770.jpg\" alt=\"image\"></p>\n<h2 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h2><p>几乎全支持 <a href=\"https://cn.vuejs.org/v2/guide/syntax.html\">官方文档：模板语法</a>，下面讲下不支持的情况。</p>\n<h3 id=\"不支持-纯-HTML\"><a href=\"#不支持-纯-HTML\" class=\"headerlink\" title=\"不支持 纯-HTML\"></a>不支持 纯-HTML</h3><p>小程序里所有的 BOM／DOM 都不能用，也就是说 v-html 指令不能用。</p>\n<h3 id=\"不支持部分复杂的-JavaScript-渲染表达式\"><a href=\"#不支持部分复杂的-JavaScript-渲染表达式\" class=\"headerlink\" title=\"不支持部分复杂的 JavaScript 渲染表达式\"></a>不支持部分复杂的 JavaScript 渲染表达式</h3><p>我们会把 template 中的 <code>&#123;&#123;&#125;&#125;</code> 双花括号的部分，直接编码到 wxml 文件中，由于微信小程序的能力限制(<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/data.html\">数据绑定</a>)，所以无法支持复杂的 JavaScript 表达式。</p>\n<p>目前可以使用的有 <code>+ - * % ?: ! == === &gt; &lt; [] .</code>，剩下的还待完善。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 这种就不支持，建议写 computed --&gt;</span><br><span class=\"line\">&lt;p&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 但写在 @event 里面的表达式是都支持的，因为这部分的计算放在了 vdom 里面 --&gt;</span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &lt;li v-for=&quot;item in list&quot;&gt;</span><br><span class=\"line\">        &lt;div @click=&quot;clickHandle(item, index, $event)&quot;&gt;&#123;&#123; item.value &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不支持过滤器\"><a href=\"#不支持过滤器\" class=\"headerlink\" title=\"不支持过滤器\"></a>不支持过滤器</h3><p>渲染部分会转成 wxml ，wxml 不支持过滤器，所以这部分功能不支持。</p>\n<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>支持 <a href=\"https://cn.vuejs.org/v2/guide/computed.html\">官方文档：计算属性</a>。</p>\n<h2 id=\"不支持函数\"><a href=\"#不支持函数\" class=\"headerlink\" title=\"不支持函数\"></a>不支持函数</h2><p>不支持在 template 内使用 methods 中的函数。</p>\n<p>#Class 与 Style 绑定<br>为节约性能，我们将 Class 与 Style 的表达式通过 compiler 硬编码到 wxml 中，支持语法和转换效果如下：</p>\n<p>class 支持的语法:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p :class=&quot;&#123; active: isActive &#125;&quot;&gt;111&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;222&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;static&quot; :class=&quot;[activeClass, errorClass]&quot;&gt;333&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;static&quot; v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;444&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;static&quot; v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;555&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p>将分别被转换成:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view class=&quot;_p &#123;&#123;[isActive ? &#x27;active&#x27; : &#x27;&#x27;]&#125;&#125;&quot;&gt;111&lt;/view&gt;</span><br><span class=\"line\">&lt;view class=&quot;_p static &#123;&#123;[isActive ? &#x27;active&#x27; : &#x27;&#x27;, hasError ? &#x27;text-danger&#x27; : &#x27;&#x27;]&#125;&#125;&quot;&gt;222&lt;/view&gt;</span><br><span class=\"line\">&lt;view class=&quot;_p static &#123;&#123;[activeClass, errorClass]&#125;&#125;&quot;&gt;333&lt;/view&gt;</span><br><span class=\"line\">&lt;view class=&quot;_p static &#123;&#123;[isActive ? activeClass : &#x27;&#x27;, errorClass]&#125;&#125;&quot;&gt;444&lt;/view&gt;</span><br><span class=\"line\">&lt;view class=&quot;_p static &#123;&#123;[[isActive ? &#x27;active&#x27; : &#x27;&#x27;], errorClass]&#125;&#125;&quot;&gt;555&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>style 支持的语法:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;666&lt;/p&gt;</span><br><span class=\"line\">&lt;p v-bind:style=&quot;[&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;]&quot;&gt;777&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p>将分别被转换成:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view class=&quot;_p&quot; style=&quot; &#123;&#123;&#x27;color:&#x27; + activeColor + &#x27;;&#x27; + &#x27;font-size:&#x27; + fontSize + &#x27;px&#x27; + &#x27;;&#x27;&#125;&#125;&quot;&gt;666&lt;/view&gt;</span><br><span class=\"line\">&lt;view class=&quot;_p&quot; style=&quot; &#123;&#123;&#x27;color:&#x27; + activeColor + &#x27;;&#x27; + &#x27;font-size:&#x27; + fontSize + &#x27;px&#x27; + &#x27;;&#x27;&#125;&#125;&quot;&gt;777&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>不支持 <a href=\"https://cn.vuejs.org/v2/guide/class-and-style.html\">官方文档：Class 与 Style 绑定</a> 中的 classObject 和 styleObject 语法。</p>\n<p>最佳实践见上文支持的语法，<strong>从性能考虑，建议不要过度依赖此</strong>。</p>\n<p>此外还可以用 computed 方法生成 class 或者 style 字符串，插入到页面中，举例说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;!-- 支持 --&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot; :class=&quot;computedClassStr&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot; :class=&quot;&#123;active: isActive&#125;&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 不支持 --&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot; :class=&quot;computedClassObject&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                isActive: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        computed: &#123;</span><br><span class=\"line\">            computedClassStr () &#123;</span><br><span class=\"line\">                return this.isActive ? &#x27;active&#x27; : &#x27;&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            computedClassObject () &#123;</span><br><span class=\"line\">                return &#123; active: this.isActive &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用在组件上\"><a href=\"#用在组件上\" class=\"headerlink\" title=\"用在组件上\"></a>用在组件上</h3><p>暂不支持在组件上使用 Class 与 Style 绑定</p>\n<h2 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h2><p>全支持 <a href=\"https://cn.vuejs.org/v2/guide/conditional.html\">官方文档：条件渲染</a></p>\n<h2 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h2><p>全支持 <a href=\"https://cn.vuejs.org/v2/guide/list.html\">官方文档：列表渲染</a></p>\n<p>只是需要注意一点，<strong>嵌套列表渲染，必须指定不同的索引！</strong></p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在这种嵌套循环的时候， index 和 itemIndex 这种索引是必须指定，且别名不能相同，正确的写法如下 --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;ul v-for=&quot;(card, index) in list&quot;&gt;</span><br><span class=\"line\">        &lt;li v-for=&quot;(item, itemIndex) in card&quot;&gt;</span><br><span class=\"line\">            &#123;&#123;item.value&#125;&#125;</span><br><span class=\"line\">        &lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件处理器\"><a href=\"#事件处理器\" class=\"headerlink\" title=\"事件处理器\"></a>事件处理器</h2><p>几乎全支持啦<a href=\"https://cn.vuejs.org/v2/guide/events.html\"> 官方文档：事件处理器</a></p>\n<p>我们引入了 Vue.js 的虚拟 DOM ，在前文模版中绑定的事件会被挂在到 vnode 上，同时我们的 compiler 在 wxml 上绑定了小程序的事件，并做了相应的映射，所以你在真实点击的时候通过 runtime 中 handleProxy 通过事件类型分发到 vnode 的事件上，同 Vue 在 WEB 的机制一样，所以可以做到无损支持。同时还顺便支持了自定义事件和 $emit 机制。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 事件映射表，左侧为 WEB 事件，右侧为 小程序 对应事件</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    click: &#x27;tap&#x27;,</span><br><span class=\"line\">    touchstart: &#x27;touchstart&#x27;,</span><br><span class=\"line\">    touchmove: &#x27;touchmove&#x27;,</span><br><span class=\"line\">    touchcancel: &#x27;touchcancel&#x27;,</span><br><span class=\"line\">    touchend: &#x27;touchend&#x27;,</span><br><span class=\"line\">    tap: &#x27;tap&#x27;,</span><br><span class=\"line\">    longtap: &#x27;longtap&#x27;,</span><br><span class=\"line\">    input: &#x27;input&#x27;,</span><br><span class=\"line\">    change: &#x27;change&#x27;,</span><br><span class=\"line\">    submit: &#x27;submit&#x27;,</span><br><span class=\"line\">    blur: &#x27;blur&#x27;,</span><br><span class=\"line\">    focus: &#x27;focus&#x27;,</span><br><span class=\"line\">    reset: &#x27;reset&#x27;,</span><br><span class=\"line\">    confirm: &#x27;confirm&#x27;,</span><br><span class=\"line\">    columnchange: &#x27;columnchange&#x27;,</span><br><span class=\"line\">    linechange: &#x27;linechange&#x27;,</span><br><span class=\"line\">    error: &#x27;error&#x27;,</span><br><span class=\"line\">    scrolltoupper: &#x27;scrolltoupper&#x27;,</span><br><span class=\"line\">    scrolltolower: &#x27;scrolltolower&#x27;,</span><br><span class=\"line\">    scroll: &#x27;scroll&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 input 和 textarea 中 change 事件会被转为 blur 事件。</p>\n<p><strong>踩坑注意</strong>：</p>\n<ul>\n<li>列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将 bind 改为@ @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在 handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 &lt;map @regionchange&#x3D;”functionName” @end&#x3D;”functionName” @begin&#x3D;”functionName”&gt;</map></li>\n<li>小程序能力所致，bind 和 catch 事件同时绑定时候，只会触发 bind ,catch 不会被触发，要避免踩坑。</li>\n<li>事件修饰符<ul>\n<li>.stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！</li>\n<li>.prevent 可以直接干掉，因为小程序里没有什么默认事件，比如 submit 并不会跳转页面</li>\n<li>.capture 支持 1.0.9</li>\n<li>.self 没有可以判断的标识</li>\n<li>.once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑</li>\n</ul>\n</li>\n<li>其他 键值修饰符 等在小程序中压根没键盘，所以。。。</li>\n</ul>\n<h2 id=\"表单控件绑定\"><a href=\"#表单控件绑定\" class=\"headerlink\" title=\"表单控件绑定\"></a>表单控件绑定</h2><p>几乎全支持 <a href=\"https://cn.vuejs.org/v2/guide/forms.html\">官方文档：表单控件绑定</a>，不支持的还没测出来，之所以说几乎，是因为 WEB 表单这么复杂，谁特么知道会出什么奇怪的特性。</p>\n<p>建议开发过程中直接使用 [微信小程序：表单组件]<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/component/button.html\">https://mp.weixin.qq.com/debug/wxadoc/dev/component/button.html</a>) 。用法示例：</p>\n<p><a href=\"https://github.com/Meituan-Dianping/mpvue/issues/58\">select 组件用 picker 组件进行代替</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;picker @change=&quot;bindPickerChange&quot; :value=&quot;index&quot; :range=&quot;array&quot;&gt;</span><br><span class=\"line\">      &lt;view class=&quot;picker&quot;&gt;</span><br><span class=\"line\">        当前选择：&#123;&#123;array[index]&#125;&#125;</span><br><span class=\"line\">      &lt;/view&gt;</span><br><span class=\"line\">    &lt;/picker&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      index: 0,</span><br><span class=\"line\">      array: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    bindPickerChange (e) &#123;</span><br><span class=\"line\">      console.log(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/Meituan-Dianping/mpvue/issues/66\">表单元素 radio 用 radio-group 组件进行代替</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;radio-group class=&quot;radio-group&quot; @change=&quot;radioChange&quot;&gt;</span><br><span class=\"line\">      &lt;label class=&quot;radio&quot; v-for=&quot;(item, index) in items&quot; :key=&quot;item.name&quot;&gt;</span><br><span class=\"line\">        &lt;radio :value=&quot;item.name&quot; :checked=&quot;item.checked&quot;/&gt; &#123;&#123;item.value&#125;&#125;</span><br><span class=\"line\">      &lt;/label&gt;</span><br><span class=\"line\">    &lt;/radio-group&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      items: [</span><br><span class=\"line\">        &#123;name: &#x27;USA&#x27;, value: &#x27;美国&#x27;&#125;,</span><br><span class=\"line\">        &#123;name: &#x27;CHN&#x27;, value: &#x27;中国&#x27;, checked: &#x27;true&#x27;&#125;,</span><br><span class=\"line\">        &#123;name: &#x27;BRA&#x27;, value: &#x27;巴西&#x27;&#125;,</span><br><span class=\"line\">        &#123;name: &#x27;JPN&#x27;, value: &#x27;日本&#x27;&#125;,</span><br><span class=\"line\">        &#123;name: &#x27;ENG&#x27;, value: &#x27;英国&#x27;&#125;,</span><br><span class=\"line\">        &#123;name: &#x27;TUR&#x27;, value: &#x27;法国&#x27;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    radioChange (e) &#123;</span><br><span class=\"line\">      console.log(&#x27;radio发生change事件，携带value值为：&#x27;, e.target.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><h3 id=\"Vue-组件\"><a href=\"#Vue-组件\" class=\"headerlink\" title=\"Vue 组件\"></a>Vue 组件</h3><p>组件是整个 Vue.js 中最复杂的部分，当然要支持 <a href=\"https://cn.vuejs.org/v2/guide/components.html\">官方文档：组件</a> 。</p>\n<p><strong>有且只能使用单文件组件（.vue 组件）的形式进行支持</strong>。其他的诸如：动态组件，自定义 render，和<code>&lt;script type=&quot;text/x-template&quot;&gt;</code> 字符串模版等都不支持。原因很简单，因为我们要预编译出 wxml。</p>\n<p>如果未来小程序支持了动态增删改查 wxml 节点信息，那我们就能做到全支持。</p>\n<p>详细的不支持列表：</p>\n<ul>\n<li>暂不支持在组件引用时，在组件上定义 click 等原生事件、v-show（可用 v-if 代替）和 class style 等样式属性(例：<card class=\"class-name\"> </card> 样式是不会生效的)，因为编译到 wxml，小程序不会生成节点，建议写在内部顶级元素上。</li>\n<li>Slot（scoped 暂时还没做支持）</li>\n<li>动态组件</li>\n<li>异步组件</li>\n<li>inline-template</li>\n<li>X-Templates</li>\n<li>keep-alive</li>\n<li>transition</li>\n<li>class</li>\n<li>style</li>\n</ul>\n<h3 id=\"小程序组件\"><a href=\"#小程序组件\" class=\"headerlink\" title=\"小程序组件\"></a>小程序组件</h3><p>mpvue 可以支持小程序的原生组件，比如： picker,map 等，需要注意的是原生组件上的事件绑定，需要以 vue 的事件绑定语法来绑定，如 bindchange&#x3D;”eventName” 事件，需要写成 @change&#x3D;”eventName”</p>\n<p>示例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;picker mode=&quot;date&quot; :value=&quot;date&quot; start=&quot;2015-09-01&quot; end=&quot;2017-09-01&quot; @change=&quot;bindDateChange&quot;&gt;</span><br><span class=\"line\">    &lt;view class=&quot;picker&quot;&gt;</span><br><span class=\"line\">      当前选择: &#123;&#123;date&#125;&#125;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/picker&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TypeScript-支持\"><a href=\"#TypeScript-支持\" class=\"headerlink\" title=\"TypeScript 支持\"></a>TypeScript 支持</h2><p>目前 mpvue-loader 是可以支持 TypeScript 选项的，配置方法在此。具体 Demo 可以见 mpvue-ts-demo</p>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"1-精简-data-数据\"><a href=\"#1-精简-data-数据\" class=\"headerlink\" title=\"1. 精简 data 数据\"></a>1. 精简 data 数据</h3><p>冗余数据不要挂在 data 里，所有在 data&#x2F;props&#x2F;computed 中的数据，每次变更都会从微信小程序的 JSCore 进程，通过 setData 序列化成字符串后发送到 JSRender 进程。所以，如果你的数据量巨大的时候，会导致页面非常卡顿。</p>\n<h3 id=\"2-优化长列表性能\"><a href=\"#2-优化长列表性能\" class=\"headerlink\" title=\"2. 优化长列表性能\"></a>2. 优化长列表性能</h3><p>一般情况下这种页面会有大量的数据，除了遵从上面的建议外还有额外的建议。</p>\n<ul>\n<li>避免在 v-for 中嵌套子组件，这样可以优化大部分 setData 时的冗余数据。</li>\n<li>通过实践发现 wx:if 和 hidden 的优化肉眼不可见，所以或许可以试试直接通过样式 display 来展示和隐藏。</li>\n<li>如果列表过长，强烈建议产品思考更好的展示形态。比如只展示热门，多余的折叠等形式。<blockquote>\n<p>注：我们对其进行了专门优化，最佳实践时和原生小程序代码的性能相差无几。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"3-合理使用双向绑定-mpvue-建议使用-v-model-lazy-绑定方式以优化性能，此外-v-model-在老基础库下输入框输入时可能存在光标重设的问题。\"><a href=\"#3-合理使用双向绑定-mpvue-建议使用-v-model-lazy-绑定方式以优化性能，此外-v-model-在老基础库下输入框输入时可能存在光标重设的问题。\" class=\"headerlink\" title=\"3. 合理使用双向绑定 mpvue 建议使用 v-model.lazy 绑定方式以优化性能，此外 v-model 在老基础库下输入框输入时可能存在光标重设的问题。\"></a>3. 合理使用双向绑定 mpvue 建议使用 v-model.lazy 绑定方式以优化性能，此外 v-model 在老基础库下输入框输入时可能存在光标重设的问题。</h3><h3 id=\"4-谨慎选择直接使用小程序的-API-如果你有小程序和-H5-复用代码的需要，业务代码需要保持对-WEB-Vue-js-的兼容性。此时我们不建议在代码中直接调用小程序-API，更好的选择是通过桥接适配层屏蔽两端差异。\"><a href=\"#4-谨慎选择直接使用小程序的-API-如果你有小程序和-H5-复用代码的需要，业务代码需要保持对-WEB-Vue-js-的兼容性。此时我们不建议在代码中直接调用小程序-API，更好的选择是通过桥接适配层屏蔽两端差异。\" class=\"headerlink\" title=\"4. 谨慎选择直接使用小程序的 API 如果你有小程序和 H5 复用代码的需要，业务代码需要保持对 WEB Vue.js 的兼容性。此时我们不建议在代码中直接调用小程序 API，更好的选择是通过桥接适配层屏蔽两端差异。\"></a>4. 谨慎选择直接使用小程序的 API 如果你有小程序和 H5 复用代码的需要，业务代码需要保持对 WEB Vue.js 的兼容性。此时我们不建议在代码中直接调用小程序 API，更好的选择是通过桥接适配层屏蔽两端差异。</h3><h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"1-如何获取小程序在-page-onLoad-时候传递的-options\"><a href=\"#1-如何获取小程序在-page-onLoad-时候传递的-options\" class=\"headerlink\" title=\"1. 如何获取小程序在 page onLoad 时候传递的 options\"></a>1. 如何获取小程序在 page onLoad 时候传递的 options</h3><p>在所有 页面 的组件内可以通过 this.$root.$mp.query 进行获取。</p>\n<h3 id=\"2-如何获取小程序在-app-onLaunch-x2F-onShow-时候传递的-options\"><a href=\"#2-如何获取小程序在-app-onLaunch-x2F-onShow-时候传递的-options\" class=\"headerlink\" title=\"2. 如何获取小程序在 app onLaunch&#x2F;onShow 时候传递的 options\"></a>2. 如何获取小程序在 app onLaunch&#x2F;onShow 时候传递的 options</h3><p>在所有的组件内可以通过 this.$root.$mp.appOptions 进行获取。</p>\n<h3 id=\"3-如何捕获-app-的-onError\"><a href=\"#3-如何捕获-app-的-onError\" class=\"headerlink\" title=\"3. 如何捕获 app 的 onError\"></a>3. 如何捕获 app 的 onError</h3><p>由于 onError 并不是完整意义的生命周期，所以只提供一个捕获错误的方法，在 app 的根组件上添加名为 onError 的回调函数即可。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">   // 只有 app 才会有 onLaunch 的生命周期</span><br><span class=\"line\">   onLaunch () &#123;</span><br><span class=\"line\">       // ...</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   // 捕获 app error</span><br><span class=\"line\">   onError (err) &#123;</span><br><span class=\"line\">       console.log(err)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mpvue-框架使用场景汇总\"><a href=\"#mpvue-框架使用场景汇总\" class=\"headerlink\" title=\"mpvue 框架使用场景汇总\"></a>mpvue 框架使用场景汇总</h2><p>mpvue 作为一个前端开发框架，提供了一整套解决方案。但开发者面临的实际情况可能更加复杂，我们整理了 mpvue 可能的使用场景，在这些场景下，我们为你提供了一些建议。</p>\n<p>首先，mpvue 小程序框架包含如下内容：</p>\n<ul>\n<li>运行时 JS SDK</li>\n<li>初始化模板项目（包含推荐的目录结构，webpack 构建，代码检查配置等）</li>\n<li>项目构建所需的 npm 依赖（已经包含在项目模板中，无需手动引入）</li>\n</ul>\n<h2 id=\"开发者可能会面对的四种典型场景\"><a href=\"#开发者可能会面对的四种典型场景\" class=\"headerlink\" title=\"开发者可能会面对的四种典型场景\"></a>开发者可能会面对的四种典型场景</h2><ul>\n<li>单独以 mpvue 框架构建小程序</li>\n<li>mpvue 框架为主，同时使用其它框架（原生开发方式或 wepy 等）</li>\n<li>已经使用其它框架，引入 mpvue 做部分模块的开发</li>\n<li>只使用 mpvue 的 JS SDK，自定义构建策略</li>\n</ul>\n<p>针对上述不同场景，mpvue 框架需要提供的方案和建议如下</p>\n<ul>\n<li>单独以 mpvue 框架构建小程序<ul>\n<li>推荐的方式，无需额外支持。通过框架提供的项目初始化工具初始化项目即可，已经包含完整的构建策略，代码组织方式等.</li>\n</ul>\n</li>\n<li>mpvue 框架为主，同时使用其它框架（原生开发方式或 wepy 等）<ul>\n<li>第三方框架和 mpvue 做分块构建。可能的方案是：不同框架各自的构建策略做好边界分离，最终通过单一入口聚合到一起。或者更简单的，拆成多个子项目，最终输出到同一目录，目标代码符合小程序规范即可。</li>\n</ul>\n</li>\n<li>已经使用其它框架，引入 mpvue 做部分模块的开发<ul>\n<li>mpvue 提供轻量的模块构建工具支持部分构建。对已有小程序项目接入 mpvue 来说，渐进的方式会是乐于接受的，可以先让一部分功能通过 mpvue 编写。此类场景，不再适合通过模板项目初始化项目结构，开发者可以参考模板项目中的代码编写方式，通过我们单独准备的构建工具，定制好构建任务即可。</li>\n</ul>\n</li>\n<li>只使用 mpvue 的 JS SDK，自定义构建策略<ul>\n<li>需要开发者自定义 webpack 构建策略。 框架本身不建议开发者这么使用。但对于高阶的开发者，这是可能的方案。此时，开发者可以参考我们模板项目中的构建策略即可，我们目前只提供 webpack 构建方案。对于其它构建，我们暂不支持。</li>\n</ul>\n</li>\n</ul>\n","categories":["小程序开发"],"tags":["小程序"]},{"title":"npm 常用命令详解","url":"/2022/12/16/npm-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","content":"<h2 id=\"1-npm-是什么\"><a href=\"#1-npm-是什么\" class=\"headerlink\" title=\"1. npm 是什么\"></a>1. npm 是什么</h2><p>NPM 的全称是 Node Package Manager，是随同 NodeJS 一起安装的包管理和分发工具，它很方便让 JavaScript 开发者下载、安装、上传以及管理已经安装的包。</p>\n<h2 id=\"2-npm-install-安装模块\"><a href=\"#2-npm-install-安装模块\" class=\"headerlink\" title=\"2. npm install 安装模块\"></a>2. npm install 安装模块</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install (with no args, in package dir)</span><br><span class=\"line\">npm install [&lt;@scope&gt;/]&lt;name&gt;</span><br><span class=\"line\">npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;tag&gt;</span><br><span class=\"line\">npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version&gt;</span><br><span class=\"line\">npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version range&gt;</span><br><span class=\"line\">npm install &lt;tarball file&gt;</span><br><span class=\"line\">npm install &lt;tarball url&gt;</span><br><span class=\"line\">npm install &lt;folder&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">alias: npm i</span><br><span class=\"line\">common options: [-S|--save|-D|--save-dev|-O|--save-optional] [-E|--save-exact] [--dry-run]</span><br></pre></td></tr></table></figure>\n\n<p>安装包，默认会安装最新的版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install gulp</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images2015.cnblogs.com/blog/278431/201606/278431-20160612163826965-609701972.png\" alt=\"image\"><br>安装指定版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install gulp@3.9.1</span><br></pre></td></tr></table></figure>\n\n<p>安装包并将信息保持到项目的 package.json 文件中</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/278431/201606/278431-20160608175914183-728696602.jpg\" alt=\"image\"></p>\n<p>项目对模块的依赖可以使用下面的 3 种方法来表示（假设当前版本号是 1.1.0 ）：</p>\n<ul>\n<li>兼容模块新发布的补丁版本：~1.1.0、1.1.x、1.1</li>\n<li>兼容模块新发布的小版本、补丁版本：^1.1.0、1.x、1</li>\n<li>兼容模块新发布的大版本、小版本、补丁版本：*、x</li>\n</ul>\n<p><strong>-S, –save 安装包信息将加入到 dependencies（生产阶段的依赖）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install gulp --save 或 npm install gulp -S</span><br></pre></td></tr></table></figure>\n\n<p>package.json 文件的 dependencies 字段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;gulp&quot;: &quot;^3.9.1&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>-D, –save-dev 安装包信息将加入到 devDependencies（开发阶段的依赖），所以开发阶段一般使用它</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install gulp --save-dev 或 npm install gulp -D</span><br></pre></td></tr></table></figure>\n\n<p>package.json 文件的 devDependencies 字段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;gulp&quot;: &quot;^3.9.1&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>-O, –save-optional 安装包信息将加入到 optionalDependencies（可选阶段的依赖）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install gulp --save-optional 或 npm install gulp -O</span><br></pre></td></tr></table></figure>\n\n<p>package.json 文件的 optionalDependencies 字段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;optionalDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;gulp&quot;: &quot;^3.9.1&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>-E, –save-exact 精确安装指定模块版本</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install gulp --save-exact 或 npm install gulp -E</span><br></pre></td></tr></table></figure>\n\n<p>输入命令<strong>npm install gulp -ES</strong>，留意 package.json 文件的 dependencies 字段，可以看出版本号中的^消失了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;gulp&quot;: &quot;3.9.1&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>模块的依赖都被写入了 package.json 文件后，他人打开项目的根目录（项目开源、内部团队合作），使用 npm install 命令可以根据 dependencies 配置安装所有的依赖包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images2015.cnblogs.com/blog/278431/201606/278431-20160608180225886-1359105042.jpg\" alt=\"image\"><br>本地安装（local）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install gulp</span><br></pre></td></tr></table></figure>\n\n<p>全局安装（global）,使用 -g 或 –global</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install gulp -g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-npm-uninstall-卸载模块\"><a href=\"#3-npm-uninstall-卸载模块\" class=\"headerlink\" title=\"3. npm uninstall 卸载模块\"></a>3. npm uninstall 卸载模块</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm uninstall [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]... [-S|--save|-D|--save-dev|-O|--save-optional]</span><br><span class=\"line\"></span><br><span class=\"line\">aliases: remove, rm, r, un, unlink</span><br></pre></td></tr></table></figure>\n\n<p>如卸载开发版本的模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm uninstall gulp --save-dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-npm-update-更新模块\"><a href=\"#4-npm-update-更新模块\" class=\"headerlink\" title=\"4. npm update 更新模块\"></a>4. npm update 更新模块</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm update [-g] [&lt;pkg&gt;...]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-npm-update-g-…\"><a href=\"#5-npm-update-g-…\" class=\"headerlink\" title=\"5. npm update [-g] […]\"></a>5. npm update [-g] [<pkg>…]</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm outdated [[&lt;@scope&gt;/]&lt;pkg&gt; ...]</span><br></pre></td></tr></table></figure>\n\n<p>此命令会列出所有已经过时的包，可以及时进行包的更新</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/278431/201606/278431-20160608184648105-1925655942.jpg\" alt=\"image\"></p>\n<h2 id=\"npm-ls-查看安装的模块\"><a href=\"#npm-ls-查看安装的模块\" class=\"headerlink\" title=\"npm ls 查看安装的模块\"></a>npm ls 查看安装的模块</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm ls [[&lt;@scope&gt;/]&lt;pkg&gt; ...]</span><br><span class=\"line\"></span><br><span class=\"line\">aliases: list, la, ll</span><br></pre></td></tr></table></figure>\n\n<p>查看全局安装的模块及依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm ls -g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-npm-init-在项目中引导创建一个-package-json-文件\"><a href=\"#6-npm-init-在项目中引导创建一个-package-json-文件\" class=\"headerlink\" title=\"6. npm init 在项目中引导创建一个 package.json 文件\"></a>6. npm init 在项目中引导创建一个 package.json 文件</h2><p>安装包的信息可保持到项目的 package.json 文件中，以便后续的其它的项目开发或者他人合作使用，也说 package.json 在项目中是必不可少的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm init [-f|--force|-y|--yes]</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images2015.cnblogs.com/blog/278431/201606/278431-20160612103551324-1085207978.gif\" alt=\"image\"></p>\n<h2 id=\"7-npm-help-查看某条命令的详细帮助\"><a href=\"#7-npm-help-查看某条命令的详细帮助\" class=\"headerlink\" title=\"7. npm help 查看某条命令的详细帮助\"></a>7. npm help 查看某条命令的详细帮助</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm help &lt;term&gt; [&lt;terms..&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>例如输入 npm help install，系统在默认的浏览器或者默认的编辑器中打开本地 nodejs 安装包的文件<code>/nodejs/node_modules/npm/html/doc/cli/npm-install.html</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm help install</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-npm-root-查看包的安装路径\"><a href=\"#8-npm-root-查看包的安装路径\" class=\"headerlink\" title=\"8. npm root 查看包的安装路径\"></a>8. npm root 查看包的安装路径</h2><p>输出 node_modules 的路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm root [-g]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-npm-config-管理-npm-的配置路径\"><a href=\"#9-npm-config-管理-npm-的配置路径\" class=\"headerlink\" title=\"9. npm config 管理 npm 的配置路径\"></a>9. npm config 管理 npm 的配置路径</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set &lt;key&gt; &lt;value&gt; [-g|--global]</span><br><span class=\"line\">npm config get &lt;key&gt;</span><br><span class=\"line\">npm config delete &lt;key&gt;</span><br><span class=\"line\">npm config list</span><br><span class=\"line\">npm config edit</span><br><span class=\"line\">npm get &lt;key&gt;</span><br><span class=\"line\">npm set &lt;key&gt; &lt;value&gt; [-g|--global]</span><br></pre></td></tr></table></figure>\n\n<p>对于 config 这块用得最多应该是<strong>设置代理，解决 npm 安装一些模块失败的问题</strong><br>例如我在公司内网，因为公司的防火墙原因，无法完成任何模块的安装，这个时候设置代理可以解决</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set proxy=http://xxx</span><br></pre></td></tr></table></figure>\n\n<p>又如国内的网络环境问题，某官方的 IP 可能被和谐了，幸好国内有好心人，搭建了镜像，此时我们简单设置镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry=&quot;http://r.cnpmjs.org&quot;</span><br></pre></td></tr></table></figure>\n\n<p>也可以临时配置，如安装淘宝镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">也可以临时配置，如安装淘宝镜像</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-npm-cache-管理模块的缓存\"><a href=\"#10-npm-cache-管理模块的缓存\" class=\"headerlink\" title=\"10. npm cache 管理模块的缓存\"></a>10. npm cache 管理模块的缓存</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm cache add &lt;tarball file&gt;</span><br><span class=\"line\">npm cache add &lt;folder&gt;</span><br><span class=\"line\">npm cache add &lt;tarball url&gt;</span><br><span class=\"line\">npm cache add &lt;name&gt;@&lt;version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">npm cache ls [&lt;path&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">npm cache clean [&lt;path&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>最常用命令无非清除 npm 本地缓存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm cache clean</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-npm-start-启动模块\"><a href=\"#11-npm-start-启动模块\" class=\"headerlink\" title=\"11. npm start 启动模块\"></a>11. npm start 启动模块</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm start [-- &lt;args&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>该命令写在 package.json 文件 scripts 的 start 字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start&quot;: &quot;gulp -ws&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时在 cmd 中输入 npm start 命令相当于执行 gulpfile.js 文件自定义的 watch 和 server 命令。</p>\n<p>如果 package.json 文件没有设置 start，则将直接启动 node server.js</p>\n<h2 id=\"12-npm-stop-停止模块\"><a href=\"#12-npm-stop-停止模块\" class=\"headerlink\" title=\"12. npm stop 停止模块\"></a>12. npm stop 停止模块</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm stop [-- &lt;args&gt;]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-npm-restart-重新启动模块\"><a href=\"#13-npm-restart-重新启动模块\" class=\"headerlink\" title=\"13. npm restart 重新启动模块\"></a>13. npm restart 重新启动模块</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm restart [-- &lt;args&gt;]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-npm-test-测试模块\"><a href=\"#14-npm-test-测试模块\" class=\"headerlink\" title=\"14. npm test 测试模块\"></a>14. npm test 测试模块</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm test [-- &lt;args&gt;]</span><br><span class=\"line\">npm tst [-- &lt;args&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>该命令写在 package.json 文件 scripts 的 test 字段中，可以自定义该命令来执行一些操作，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;test&quot;: &quot;gulp release&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>此时在 cmd 中输入 npm test 命令相当于执行 gulpfile.js 文件自定义的 release 命令。</p>\n<h2 id=\"15-npm-version-查看模块版本\"><a href=\"#15-npm-version-查看模块版本\" class=\"headerlink\" title=\"15. npm version 查看模块版本\"></a>15. npm version 查看模块版本</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x27;npm [-v | --version]&#x27; to print npm version</span><br><span class=\"line\">&#x27;npm view &lt;pkg&gt; version&#x27; to view a package&#x27;s published version</span><br><span class=\"line\">&#x27;npm ls&#x27; to inspect current package/dependency versions</span><br></pre></td></tr></table></figure>\n\n<p>查看模块的版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm version</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images2015.cnblogs.com/blog/278431/201606/278431-20160612110731949-822739413.png\" alt=\"image\"></p>\n<h2 id=\"16-npm-view-查看模块的注册信息\"><a href=\"#16-npm-view-查看模块的注册信息\" class=\"headerlink\" title=\"16. npm view 查看模块的注册信息\"></a>16. npm view 查看模块的注册信息</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm view [&lt;@scope&gt;/]&lt;name&gt;[@&lt;version&gt;] [&lt;field&gt;[.&lt;subfield&gt;]...]</span><br><span class=\"line\"></span><br><span class=\"line\">aliases: info, show, v</span><br></pre></td></tr></table></figure>\n\n<p>查看模块的依赖关系</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm view gulp dependencies</span><br></pre></td></tr></table></figure>\n\n<p>查看模块的源文件地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm view gulp repository.url</span><br></pre></td></tr></table></figure>\n\n<p>查看模块的贡献者，包含邮箱地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm view npm contributors</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"17-npm-adduser-用户登录\"><a href=\"#17-npm-adduser-用户登录\" class=\"headerlink\" title=\"17. npm adduser 用户登录\"></a>17. npm adduser 用户登录</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm adduser [--registry=url] [--scope=@orgname] [--always-auth]</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images2015.cnblogs.com/blog/278431/201701/278431-20170117152013911-489932696.png\" alt=\"image\"></p>\n<p>发布模板到 npm 社区前需要先登录，然后再进入发布的操作</p>\n<h2 id=\"18-npm-publish-发布模块\"><a href=\"#18-npm-publish-发布模块\" class=\"headerlink\" title=\"18. npm publish 发布模块\"></a>18. npm publish 发布模块</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm publish [&lt;tarball&gt;|&lt;folder&gt;] [--tag &lt;tag&gt;] [--access &lt;public|restricted&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">Publishes &#x27;.&#x27; if no argument supplied</span><br><span class=\"line\">Sets tag &#x27;latest&#x27; if no --tag specified</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images2015.cnblogs.com/blog/278431/201701/278431-20170117152224005-1557216239.png\" alt=\"image\"></p>\n<h2 id=\"19-npm-access-在发布的包上设置访问级别\"><a href=\"#19-npm-access-在发布的包上设置访问级别\" class=\"headerlink\" title=\"19. npm access 在发布的包上设置访问级别\"></a>19. npm access 在发布的包上设置访问级别</h2><p>基础语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm access public [&lt;package&gt;]</span><br><span class=\"line\">npm access restricted [&lt;package&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">npm access grant &lt;read-only|read-write&gt; &lt;scope:team&gt; [&lt;package&gt;]</span><br><span class=\"line\">npm access revoke &lt;scope:team&gt; [&lt;package&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">npm access ls-packages [&lt;user&gt;|&lt;scope&gt;|&lt;scope:team&gt;]</span><br><span class=\"line\">npm access ls-collaborators [&lt;package&gt; [&lt;user&gt;]]</span><br><span class=\"line\">npm access edit [&lt;package&gt;]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"20-npm-package-json-的语法\"><a href=\"#20-npm-package-json-的语法\" class=\"headerlink\" title=\"20. npm package.json 的语法\"></a>20. npm package.json 的语法</h2><p><strong>默认值</strong></p>\n<p>npm 会根据包内容设置一些默认值。</p>\n<ul>\n<li>“scripts”: {“start”: “node server.js”}</li>\n</ul>\n<p>如果包的根目录有 server.js 文件，npm 会默认将 start 命令设置为 node server.js。</p>\n<ul>\n<li>“scripts”:{“preinstall”: “node-waf clean || true; node-waf configure build”}</li>\n</ul>\n<p>如果包的根目录有 wscript 文件，npm 会默认将 preinstall 命令用 node-waf 进行编译。</p>\n<ul>\n<li>“scripts”:{“preinstall”: “node-gyp rebuild”}</li>\n</ul>\n<p>如果包的根目录有 binding.gyp 文件，npm 会默认将 preinstall 命令用 node-gyp 进行编译。</p>\n<ul>\n<li>“contributors”: […]</li>\n</ul>\n<p>如果包的根目录有 AUTHORS 文件，npm 会默认逐行按 Name <email> (url)格式处理，邮箱和 url 是可选的。#号和空格开头的行会被忽略。</p>\n<p><strong>name</strong></p>\n<p>在 package.json 中最重要的就是 name 和 version 字段。他们都是必须的，如果没有就无法 install。name 和 version 一起组成的标识在假设中是唯一的。改变包应该同时改变 version。</p>\n<p>name 是这个东西的名字。注意：</p>\n<ul>\n<li>不要把 node 或者 js 放在名字中。因为你写了 package.json 它就被假定成为了 js，不过你可以用”engine”字段指定一个引擎（见后文）。</li>\n<li>这个名字会作为在 URL 的一部分、命令行的参数或者文件夹的名字。任何 non-url-safe 的字符都是不能用的。</li>\n<li>这个名字可能会作为参数被传入 require()，所以它应该比较短，但也要意义清晰。</li>\n<li>在你爱上你的名字之前，你可能要去 npm registry 查看一下这个名字是否已经被使用了。<a href=\"http://registry.npmjs.org/\">http://registry.npmjs.org/</a></li>\n</ul>\n<p><strong>version</strong></p>\n<p>version 必须能被 node-semver 解析，它被包在 npm 的依赖中。（要自己用可以执行 npm install semver）</p>\n<p>可用的“数字”或者“范围”见 semver(7).</p>\n<p><strong>description</strong></p>\n<p>放简介，字符串，方便在 npm search 中搜索</p>\n<p><strong>keywords</strong></p>\n<p>关键字，数组、字符串，方便在 npm search 中搜索</p>\n<p><strong>bugs</strong></p>\n<p>你项目的提交问题的 url 和（或）邮件地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;url&quot; : &quot;http://github.com/owner/project/issues&quot;,</span><br><span class=\"line\">&quot;email&quot; : &quot;project@hostname.com&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>license</strong></p>\n<p>你应该要指定一个许可证，让人知道使用的权利和限制的。</p>\n<p>最简单的方法是，假如你用一个像 BSD 或者 MIT 这样通用的许可证，就只需要指定一个许可证的名字，像这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; &quot;license&quot; : &quot;BSD&quot; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你有更复杂的许可条件，或者想要提供给更多地细节，可以这样:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;licenses&quot; : [</span><br><span class=\"line\">  &#123; &quot;type&quot; : &quot;MyLicense&quot;, &quot;url&quot; : &quot;http://github.com/owner/project/path/to/license&quot; &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>repository</strong></p>\n<p>指定你的代码存放的地方。这个对希望贡献的人有帮助。如果 git 仓库在 github 上，那么 npm docs 命令能找到你。</p>\n<p>这样做：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; &quot;type&quot; : &quot;git&quot;</span><br><span class=\"line\">  , &quot;url&quot; : &quot;http://github.com/isaacs/npm.git&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; &quot;type&quot; : &quot;svn&quot;</span><br><span class=\"line\">  , &quot;url&quot; : &quot;http://v8.googlecode.com/svn/trunk/&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>URL 应该是公开的（即便是只读的）能直接被未经过修改的版本控制程序处理的 url。不应该是一个 html 的项目页面。因为它是给计算机看的。</p>\n<p><strong>scripts</strong></p>\n<p>“scripts”是一个由脚本命令组成的 hash 对象，他们在包不同的生命周期中被执行。key 是生命周期事件，value 是要运行的命令。</p>\n<p>参考上面的 npm start、npm test 命令</p>\n<p>更多详细请看 npm-scripts(7)</p>\n<p><strong>config</strong></p>\n<p>“config” hash 可以用来配置用于包脚本中的跨版本参数。在实例中，如果一个包有下面的配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\"> &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后有一个“start”命令引用了 npm_package_config_port 环境变量，用户可以通过 npm config set foo:port 8001 来重写他。</p>\n<p>参见 npm-config(7) 和 npm-scripts(7)。</p>\n<p><strong>dependencies</strong></p>\n<p>依赖是给一组包名指定版本范围的一个 hash。这个版本范围是一个由一个或多个空格分隔的字符串。依赖还可以用 tarball 或者 git URL。</p>\n<p>请不要将测试或过渡性的依赖放在 dependencieshash 中。见下文的 devDependencies</p>\n<p><strong>详见 semver(7).</strong></p>\n<ul>\n<li>version 必须完全和 version 一致</li>\n<li><blockquote>\n<p>version 必须比 version 大</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>&#x3D;version 同上</p>\n</blockquote>\n</li>\n<li>&lt;version 同上</li>\n<li>&lt;&#x3D;version 同上</li>\n<li>~version 大约一样，见 semver(7)</li>\n<li>1.2.x 1.2.0, 1.2.1, 等，但不包括 1.3.0</li>\n<li>http:&#x2F;&#x2F;… 见下文’依赖 URL’</li>\n<li><ul>\n<li>所有</li>\n</ul>\n</li>\n<li>“” 空，同*</li>\n<li>version1 - version2 同 &gt;&#x3D;version1 &lt;&#x3D;version2.</li>\n<li>range1 || range2 二选一。</li>\n<li>git… 见下文’依赖 Git URL’</li>\n<li>user&#x2F;repo 见下文’GitHub URLs’</li>\n</ul>\n<p>比如下面都是合法的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; &quot;dependencies&quot; :</span><br><span class=\"line\">  &#123; &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot;</span><br><span class=\"line\">  , &quot;bar&quot; : &quot;&gt;=1.0.2 &lt;2.1.2&quot;</span><br><span class=\"line\">  , &quot;baz&quot; : &quot;&gt;1.0.2 &lt;=2.3.4&quot;</span><br><span class=\"line\">  , &quot;boo&quot; : &quot;2.0.1&quot;</span><br><span class=\"line\">  , &quot;qux&quot; : &quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;</span><br><span class=\"line\">  , &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot;</span><br><span class=\"line\">  , &quot;til&quot; : &quot;~1.2&quot;</span><br><span class=\"line\">  , &quot;elf&quot; : &quot;~1.2.3&quot;</span><br><span class=\"line\">  , &quot;two&quot; : &quot;2.x&quot;</span><br><span class=\"line\">  , &quot;thr&quot; : &quot;3.3.x&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>devDependencies</strong></p>\n<p>如果有人要使用你的模块，那么他们可能不需要你开发使用的外部测试或者文档框架。</p>\n<p>在这种情况下，最好将这些附属的项目列在 devDependencies 中。</p>\n<p>这些东西会在执行 npm link 或者 npm install 的时候初始化，并可以像其他 npm 配置参数一样管理。详见 npm-config(7)。</p>\n<p>对于非特定平台的构建步骤，比如需要编译 CoffeeScript，可以用 prepublish 脚本去实现，并把它依赖的包放在 devDependency 中。（译者注：prepublish 定义了在执行 npm publish 的时候先行执行的脚本）</p>\n<p>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; &quot;name&quot;: &quot;ethopia-waza&quot;,</span><br><span class=\"line\">  &quot;description&quot;: &quot;a delightfully fruity coffee varietal&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.2.3&quot;,</span><br><span class=\"line\">  &quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;coffee-script&quot;: &quot;~1.6.3&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;prepublish&quot;: &quot;coffee -o lib/ -c src/waza.coffee&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;lib/waza.js&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>prepublish 脚本会在 publishing 前运行，这样用户就不用自己去 require 来编译就能使用。并且在开发模式中（比如本地运行 npm install）会运行这个脚本以便更好地测试。</p>\n","categories":["常用指令合集"],"tags":["javascript"]},{"title":"pm2常用的命令用法介绍","url":"/2022/12/16/pm2%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/","content":"<p>pm2 是一个带有负载均衡功能的 Node 应用的进程管理器.当你要把你的独立代码利用全部的服务器上的所有 CPU,并保证进程永远都活着,0 秒的重载, PM2 是完美的,下面我们来看 pm2 常用的命令用法介绍吧。</p>\n<p>PM2 （github 上的源码）是开源的基于 Nodejs 的进程管理器，包括守护进程，监控，日志的一整套完整的功能，基本是 Nodejs 应用程序不二的守护进程选择，事实上它并不仅仅可以启动 Nodejs 的程序，只要是一般的脚本的程序它同样可以胜任。</p>\n<p>以下是 pm2 常用的命令行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ pm2 start app.js              # 启动app.js应用程序</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 start app.js -i 4         # cluster mode 模式启动4个app.js的应用实例     # 4个应用程序会自动进行负载均衡</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 start app.js --name=&quot;api&quot; # 启动应用程序并命名为 &quot;api&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 start app.js --watch      # 当文件变化时自动重启应用</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 start script.sh           # 启动 bash 脚本</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 list                      # 列表 PM2 启动的所有的应用程序</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 monit                     # 显示每个应用程序的CPU和内存占用情况</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 show [app-name]           # 显示应用程序的所有信息</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 logs                      # 显示所有应用程序的日志</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 logs [app-name]           # 显示指定应用程序的日志</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 flush</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 stop all                  # 停止所有的应用程序</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 stop 0                    # 停止 id为 0的指定应用程序</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 restart all               # 重启所有应用</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 reload all                # 重启 cluster mode下的所有应用</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 gracefulReload all        # Graceful reload all apps in cluster mode</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 delete all                # 关闭并删除所有应用</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 delete 0                  # 删除指定应用 id 0</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 scale api 10              # 把名字叫api的应用扩展到10个实例</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 reset [app-name]          # 重置重启数量</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 startup                   # 创建开机自启动命令</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 save                      # 保存当前应用列表</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 resurrect                 # 重新加载保存的应用列表</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 update                    # Save processes, kill PM2 and restore processes</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 generate                  # Generate a sample json configuration file</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 deploy app.json prod setup    # Setup &quot;prod&quot; remote server</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 deploy app.json prod          # Update &quot;prod&quot; remote server</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 deploy app.json prod revert 2 # Revert &quot;prod&quot; remote server by 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 module:generate [name]    # Generate sample module with name [name]</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 install pm2-logrotate     # Install module (here a log rotation system)</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 uninstall pm2-logrotate   # Uninstall module</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 publish                   # Increment version, git push and npm publish</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"一-安装\"><a href=\"#一-安装\" class=\"headerlink\" title=\"一.安装\"></a>一.安装</h2><p>全局安装，简直不能更简单。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">​npm install -g pm2</span><br></pre></td></tr></table></figure>\n\n<p>pm2 安装好后，会自动创建下面目录。看文件名基本就知道干嘛的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$HOME/.pm2 will contain all PM2 related files</span><br><span class=\"line\">$HOME/.pm2/logs will contain all applications logs</span><br><span class=\"line\">$HOME/.pm2/pids will contain all applications pids</span><br><span class=\"line\">$HOME/.pm2/pm2.log PM2 logs</span><br><span class=\"line\">$HOME/.pm2/pm2.pid PM2 pid</span><br><span class=\"line\">$HOME/.pm2/rpc.sock Socket file for remote commands</span><br><span class=\"line\">$HOME/.pm2/pub.sock Socket file for publishable events</span><br><span class=\"line\">$HOME/.pm2/conf.js PM2 Configuration</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二-入门教程\"><a href=\"#二-入门教程\" class=\"headerlink\" title=\"二.入门教程\"></a>二.入门教程</h2><p>挑我们最爱的 express 应用来举例。一般我们都是通过 npm start 启动应用，其实就是调用 node .&#x2F;bin&#x2F;www。那么，换成 pm2 就是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 start ./bin/www –watch</span><br></pre></td></tr></table></figure>\n\n<p>注意，这里用了–watch 参数，意味着当你的 express 应用代码发生变化时，pm2 会帮你重启服务，多贴心。</p>\n<p>参数说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不监听的目录，最好通过配置文件。</span><br><span class=\"line\">-i --instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。</span><br><span class=\"line\">--ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;</span><br><span class=\"line\">-n --name：应用的名称。查看应用信息的时候可以用到。</span><br><span class=\"line\">-o --output &lt;path&gt;：标准输出日志文件的路径。</span><br><span class=\"line\">-e --error &lt;path&gt;：错误输出日志文件的路径。</span><br><span class=\"line\">--interpreter &lt;interpreter&gt;：the interpreter pm2 should use for executing app (bash, python...)。比如你用的coffee script来编写应用。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三-重启\"><a href=\"#三-重启\" class=\"headerlink\" title=\"三.重启\"></a>三.重启</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 restart app.js</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四-停止\"><a href=\"#四-停止\" class=\"headerlink\" title=\"四.停止\"></a>四.停止</h2><p>停止特定的应用。可以先通过 pm2 list 获取应用的名字（–name 指定的）或者进程 id。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 stop app_name|app_id</span><br></pre></td></tr></table></figure>\n\n<p>如果要停止所有应用，可以</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 stop all</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五-查看进程状态\"><a href=\"#五-查看进程状态\" class=\"headerlink\" title=\"五.查看进程状态\"></a>五.查看进程状态</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 list</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六-配置文件\"><a href=\"#六-配置文件\" class=\"headerlink\" title=\"六.配置文件\"></a>六.配置文件</h2><p>配置文件里的设置项，跟命令行参数基本是一一对应的。可以选择 yaml 或者 json 文件，就看个人喜好了。json 格式的配置文件，pm2 当作普通的 js 文件来处理，所以可以在里面添加注释或者编写代码，这对于动态调整配置很有好处。<br>　　如果启动的时候指定了配置文件，那么命令行参数会被忽略。（个别参数除外，比如–env）</p>\n<p>举个简单例子，完整配置说明请参考官方文档。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  “name” : “fis-receiver”, // 应用名称</span><br><span class=\"line\">  “script” : “./bin/www”, // 实际启动脚本</span><br><span class=\"line\">  “cwd” : “./”, // 当前工作路径</span><br><span class=\"line\">  “watch”: [ // 监控变化的目录，一旦变化，自动重启</span><br><span class=\"line\">    “bin”,</span><br><span class=\"line\">    “routers”</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  “ignore_watch” : [</span><br><span class=\"line\">    // 从监控目录中排除</span><br><span class=\"line\">    “node_modules”,</span><br><span class=\"line\">    “logs”,</span><br><span class=\"line\">    “public”</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  “watch_options”: &#123;</span><br><span class=\"line\">    “followSymlinks”: false</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  “error_file” : “./logs/app-err.log”, // 错误日志路径</span><br><span class=\"line\">  “out_file” : “./logs/app-out.log”, // 普通日志路径</span><br><span class=\"line\">  “env”: &#123;</span><br><span class=\"line\">    “NODE_ENV”: “production” // 环境参数，当前指定为生产环境</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七-pm2-start-app-js-–watch\"><a href=\"#七-pm2-start-app-js-–watch\" class=\"headerlink\" title=\"七.pm2 start app.js –watch\"></a>七.pm2 start app.js –watch</h2><p>这里是监控整个项目的文件，如果只想监听指定文件和目录，建议通过配置文件的 watch、ignore_watch 字段来设置。</p>\n<h2 id=\"八-环境切换\"><a href=\"#八-环境切换\" class=\"headerlink\" title=\"八.环境切换\"></a>八.环境切换</h2><p>在实际项目开发中，我们的应用经常需要在多个环境下部署，比如开发环境、测试环境、生产环境等。在不同环境下，有时候配置项会有差异，比如链接的数据库地址不同等。</p>\n<p>对于这种场景，pm2 也是可以很好支持的。首先通过在配置文件中通过 env_xx 来声明不同环境的配置，然后在启动应用时，通过–env 参数指定运行的环境。</p>\n<p>首先，在配置文件中，通过 env 选项声明多个环境配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">“env”: &#123; “NODE_ENV”: “production”, “REMOTE_ADDR”: “http://www.example.com/” &#125;,</span><br><span class=\"line\">​”env_dev”: &#123; “NODE_ENV”: “development”, “REMOTE_ADDR”: “http://wdev.example.com/” &#125;,</span><br><span class=\"line\">​”env_test”: &#123; “NODE_ENV”: “test”, “REMOTE_ADDR”: “http://wtest.example.com/” &#125;</span><br></pre></td></tr></table></figure>\n\n<p>env 为默认的环境配置（生产环境），env_dev、env_test 则分别是开发、测试环境。可以看到，不同环境下的 NODE_ENV、REMOTE_ADDR 字段的值是不同的。</p>\n<p>在应用中，可以通过 process.env.REMOTE_ADDR 等来读取配置中声明的变量。</p>\n<p>假设通过下面启动脚本（开发环境），那么，此时 process.env.REMOTE_ADDR 的值就是相应的 <a href=\"http://wdev.example.com/%E3%80%82\">http://wdev.example.com/。</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 start app.js –env dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"九-负载均衡\"><a href=\"#九-负载均衡\" class=\"headerlink\" title=\"九.负载均衡\"></a>九.负载均衡</h2><p>命令如下，表示开启三个进程。如果-i 0，则会根据机器当前核数自动开启尽可能多的进程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 start app.js -i 3 # 开启三个进程</span><br><span class=\"line\">​pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十-日志查看\"><a href=\"#十-日志查看\" class=\"headerlink\" title=\"十.日志查看\"></a>十.日志查看</h2><p>除了可以打开日志文件查看日志外，还可以通过 pm2 logs 来查看实时日志。这点对于线上问题排查非常重要。</p>\n<p>比如某个 node 服务突然异常重启了，那么可以通过 pm2 提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。</p>\n<h2 id=\"十一-开机自动启动\"><a href=\"#十一-开机自动启动\" class=\"headerlink\" title=\"十一.开机自动启动\"></a>十一.开机自动启动</h2><p>可以通过 pm2 startup 来实现开机自启动。细节可参考。大致流程如下：</p>\n<ol>\n<li>通过 pm2 save 保存当前进程状态。</li>\n<li>通过 pm2 startup [platform]生成开机自启动的命令。（记得查看控制台输出）</li>\n<li>将步骤 2 生成的命令，粘贴到控制台进行，搞定。</li>\n</ol>\n<p>假设是在 centos 下，那么运行如下命令，搞定。强烈建议运行完成之后，重启机器，看是否设置成功。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ94wb7tioqZ option_analysis]# pm2 save</span><br><span class=\"line\">​[root@iZ94wb7tioqZ option_analysis]# pm2 startup centos</span><br><span class=\"line\">​[PM2] Generating system init script in /etc/init.d/pm2-init.sh</span><br><span class=\"line\">[PM2] Making script booting at startup…</span><br><span class=\"line\">[PM2] /var/lock/subsys/pm2-init.sh lockfile has been added</span><br><span class=\"line\">[PM2] -centos- Using the command:</span><br><span class=\"line\">su -c “chmod +x /etc/init.d/pm2-init.sh; chkconfig –add pm2-init.sh”</span><br><span class=\"line\">​[PM2] Done.</span><br><span class=\"line\">[root@iZ94wb7tioqZ option_analysis]# pm2 save</span><br><span class=\"line\">​[PM2] Dumping processes</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十二-监控-monitor\"><a href=\"#十二-监控-monitor\" class=\"headerlink\" title=\"十二.监控(monitor)\"></a>十二.监控(monitor)</h2><p>运行如下命令，查看当前通过 pm2 运行的进程的状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 monit</span><br></pre></td></tr></table></figure>\n\n<p>看到类似输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@oneday-dev0 server]# pm2 monit</span><br><span class=\"line\">​ PM2 monitoring (To go further check out https://app.keymetrics.io) [ ] 0 %</span><br><span class=\"line\">​PM2 monitoring (To go further check o[||||||||||||||| ] 196.285 MB</span><br><span class=\"line\">​● fis-receiver [ ] 0 % [1] [fork_mode] [||||| ] 65.773 MB</span><br><span class=\"line\">​● www [ ] 0 % [2] [fork_mode] [||||| ] 74.426 MB</span><br><span class=\"line\">​● oc-server [ ] 0 % [3] [fork_mode] [|||| ] 57.801 MB</span><br><span class=\"line\">​● pm2-http-interface [ ] stopped</span><br><span class=\"line\">[4] [fork_mode] [ ] 0 B</span><br><span class=\"line\">​● start-production</span><br><span class=\"line\">[5] [fork_mode]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十三-内存使用超过上限自动重启\"><a href=\"#十三-内存使用超过上限自动重启\" class=\"headerlink\" title=\"十三.内存使用超过上限自动重启\"></a>十三.内存使用超过上限自动重启</h2><p>如果想要你的应用，在超过使用内存上限后自动重启，那么可以加上–max-memory-restart 参数。（有对应的配置项）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 start big-array.js –max-memory-restart 20M</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十四-pm2-nginx\"><a href=\"#十四-pm2-nginx\" class=\"headerlink\" title=\"十四.pm2 + nginx\"></a>十四.pm2 + nginx</h2><p>无非就是在 nginx 上做个反向代理配置，直接贴配置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">upstream my_nodejs_upstream &#123;</span><br><span class=\"line\">  server 127.0.0.1:3001;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">  listen 80;</span><br><span class=\"line\">  server_name my_nodejs_server;</span><br><span class=\"line\">  root /home/www/project_root;</span><br><span class=\"line\">  location / &#123;</span><br><span class=\"line\">    proxy_set_header X-Forwarded-For proxy_add_x_forwarded_for;</span><br><span class=\"line\">    proxy_set_header Hostproxy_add_x_forwarded_for;</span><br><span class=\"line\">    proxy_set_header Hosthttp_host;</span><br><span class=\"line\">    proxy_set_header X-NginX-Proxy true;</span><br><span class=\"line\">    proxy_http_version 1.1;</span><br><span class=\"line\">    proxy_set_header Upgrade $http_upgrade;</span><br><span class=\"line\">    proxy_set_header Connection “upgrade”;</span><br><span class=\"line\">    proxy_max_temp_file_size 0;</span><br><span class=\"line\">    proxy_pass http://my_nodejs_upstream/;</span><br><span class=\"line\">    proxy_redirect off;</span><br><span class=\"line\">    proxy_read_timeout 240s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>官方文档：<a href=\"http://pm2.keymetrics.io/docs/tutorials/pm2-nginx-production-setup\">http://pm2.keymetrics.io/docs/tutorials/pm2-nginx-production-setup</a></p>\n","categories":["常用指令合集"],"tags":["javascript"]},{"title":"promise 中的异常捕获_前端异常处理方式","url":"/2022/10/24/promise-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7-%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/","content":"<h2 id=\"一、为什么要处理异常？\"><a href=\"#一、为什么要处理异常？\" class=\"headerlink\" title=\"一、为什么要处理异常？\"></a>一、为什么要处理异常？</h2><p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p>\n<ol>\n<li>增强用户体验；</li>\n<li>远程定位问题；</li>\n<li>未雨绸缪，及早发现问题；</li>\n<li>无法复现问题，尤其是移动端，机型，系统都是问题；</li>\n<li>完善的前端方案，前端监控系统；</li>\n</ol>\n<p>对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p>\n<h2 id=\"二、需要处理哪些异常？\"><a href=\"#二、需要处理哪些异常？\" class=\"headerlink\" title=\"二、需要处理哪些异常？\"></a>二、需要处理哪些异常？</h2><p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p>\n<ul>\n<li>JS 语法错误、代码异常</li>\n<li>AJAX 请求异常</li>\n<li>静态资源加载异常</li>\n<li>Promise 异常</li>\n<li>Iframe 异常</li>\n<li>跨域 Script error</li>\n<li>崩溃和卡顿</li>\n</ul>\n<p>下面我会针对每种具体情况来说明如何处理这些异常。</p>\n<h2 id=\"三、Try-Catch-的误区\"><a href=\"#三、Try-Catch-的误区\" class=\"headerlink\" title=\"三、Try-Catch 的误区\"></a>三、Try-Catch 的误区</h2><p>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。</p>\n<ol>\n<li>同步运行时错误：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  let name = &quot;jartto&quot;;</span><br><span class=\"line\">  console.log(nam);</span><br><span class=\"line\">&#125; catch (e) &#123;</span><br><span class=\"line\">  console.log(&quot;捕获到异常：&quot;, e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">捕获到异常：ReferenceError: nam is not defined    at :3:15</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>不能捕获到具体的语法错误，只有一个语法错误提示。我们修改一下代码，删掉一个单引号：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  let name = &#x27;jartto</span><br><span class=\"line\">  console.log(nam);</span><br><span class=\"line\">&#125; catch (e) &#123;</span><br><span class=\"line\">  console.log(&quot;捕获到异常：&quot;, e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught SyntaxError: Invalid or unexpected token不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>异步错误</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    undefined.map((v) =&gt; v);</span><br><span class=\"line\">  &#125;, 1000);</span><br><span class=\"line\">&#125; catch (e) &#123;</span><br><span class=\"line\">  console.log(&quot;捕获到异常：&quot;, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们看看日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught TypeError: Cannot read property &#x27;map&#x27; of undefined    at setTimeout (:3:11)</span><br></pre></td></tr></table></figure>\n\n<p>并没有捕获到异常，这是需要我们特别注意的地方。</p>\n<h2 id=\"四、window-onerror-不是万能的\"><a href=\"#四、window-onerror-不是万能的\" class=\"headerlink\" title=\"四、window.onerror 不是万能的\"></a>四、window.onerror 不是万能的</h2><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**@param &#123;String&#125;  message    错误信息</span><br><span class=\"line\"> * @param &#123;String&#125;  source    出错文件</span><br><span class=\"line\"> * @param &#123;Number&#125;  lineno    行号</span><br><span class=\"line\"> * @param &#123;Number&#125;  colno    列号</span><br><span class=\"line\"> * @param &#123;Object&#125;  error  Error对象(对象)</span><br><span class=\"line\"> * */</span><br><span class=\"line\">window.onerror = function (message, source, lineno, colno, error) &#123;</span><br><span class=\"line\">  console.log(&quot;捕获到异常：&quot;, &#123; message, source, lineno, colno, error &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>首先试试同步运行时错误</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.onerror = function(message, source, lineno, colno, error) &#123;// message：错误信息(字符串)。// source：发生错误的脚本URL(字符串)// lineno：发生错误的行号(数字)// colno：发生错误的列号(数字)// error：Error对象(对象)console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);&#125;Jartto;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，我们捕获到了异常：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c507fb59c15171a328fb7e53d5c6671d.png\" alt=\"image\"></p>\n<ol start=\"2\">\n<li>再试试语法错误呢？</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.onerror = function(message, source, lineno, colno, error) &#123;console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let name = &#x27;Jartto</span><br></pre></td></tr></table></figure>\n\n<p>控制台打印出了这样的异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure>\n\n<p>什么，竟然没有捕获到语法错误？</p>\n<ol start=\"3\">\n<li>怀着忐忑的心，我们最后来试试异步运行时错误：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.onerror = function(message, source, lineno, colno, error) &#123;    console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);&#125;setTimeout(() =&gt; &#123;    Jartto;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">捕获到异常：&#123;message: &quot;Uncaught ReferenceError: Jartto is not defined&quot;, source: &quot;http://127.0.0.1:8001/&quot;, lineno: 36, colno: 5, error: ReferenceError: Jartto is not defined    at setTimeout (http://127.0.0.1:8001/:36:5)&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>接着，我们试试网络请求异常的情况：</li>\n</ol>\n<p><strong>我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。</strong></p>\n<p>补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.onerror = function(message, source, lineno, colno, error) &#123;    console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);    return true;&#125;setTimeout(() =&gt; &#123;    Jartto;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>控制台就不会再有这样的错误了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught ReferenceError: Jartto is not defined    at setTimeout ((index):36)</span><br></pre></td></tr></table></figure>\n\n<p>需要注意：</p>\n<ul>\n<li>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；</li>\n<li>onerror 无法捕获语法错误；</li>\n</ul>\n<p>到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>\n<p>问题又来了，捕获不到静态资源加载异常怎么办？</p>\n<h2 id=\"五、window-addEventListener\"><a href=\"#五、window-addEventListener\" class=\"headerlink\" title=\"五、window.addEventListener\"></a>五、window.addEventListener</h2><p>当一项资源(如图片或脚本)加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过(至少在 Firefox 中)能被单一的 window.addEventListener 捕获。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&#x27;error&#x27;, (error) =&gt; &#123;    console.log(&#x27;捕获到异常：&#x27;, error);&#125;, true)</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c2c41ee8e8ee6be523b3f48eaf511d84.png\" alt=\"image\"></p>\n<p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志再进行排查分析才可以。</p>\n<p><strong>需要注意</strong>：</p>\n<ul>\n<li>不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。</li>\n<li>需要注意避免 addEventListener 重复监听。</li>\n</ul>\n<h2 id=\"六、Promise-Catch\"><a href=\"#六、Promise-Catch\" class=\"headerlink\" title=\"六、Promise Catch\"></a>六、Promise Catch</h2><p>在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。</p>\n<p>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。</p>\n<p>解决方案：为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。使用方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;  console.log(e);&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们继续来尝试一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;  e.preventDefault()  console.log(&#x27;捕获到异常：&#x27;, e);  return true;&#125;);Promise.reject(&#x27;promise error&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>可以看到如下输出：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/cff9879d9b5a8785cddaddfff81f763c.png\" alt=\"image\"></p>\n<p>那如果对 Promise 不进行 catch 呢？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;  e.preventDefault()  console.log(&#x27;捕获到异常：&#x27;, e);  return true;&#125;);new Promise((resolve, reject) =&gt; &#123;  reject(&#x27;jartto: promise error&#x27;);&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>嗯，事实证明，也是会被正常捕获到的。</p>\n<p>所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。</p>\n<p>补充一点：如果去掉控制台的异常显示，需要加上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">event.preventDefault();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、VUE-errorHandler\"><a href=\"#七、VUE-errorHandler\" class=\"headerlink\" title=\"七、VUE errorHandler\"></a>七、VUE errorHandler</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.config.errorHandler = (err, vm, info) =&gt; &#123;  console.error(&#x27;通过vue errorHandler捕获的错误&#x27;);  console.error(err);  console.error(vm);  console.error(info);&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"八、React-异常捕获-React-16-提供了一个内置函数-componentDidCatch，使用它可以非常简单的获取到-react-下的错误信息\"><a href=\"#八、React-异常捕获-React-16-提供了一个内置函数-componentDidCatch，使用它可以非常简单的获取到-react-下的错误信息\" class=\"headerlink\" title=\"八、React 异常捕获 React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息\"></a>八、React 异常捕获 React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentDidCatch(error, info) &#123;    console.log(error, info);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，我们可以了解一下：error boundary UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界(error boundary)的新观念。</p>\n<p>需要注意的是：error boundaries 并不会捕捉下面这些错误。</p>\n<ol>\n<li>事件处理器</li>\n<li>异步代码</li>\n<li>服务端的渲染代码</li>\n<li>在 error boundaries 区域内的错误<br>我们来举一个小例子，在下面这个 componentDIdCatch(error,info) 里的类会变成一个 error boundary：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class ErrorBoundary extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; hasError: false &#125;;  &#125;   componentDidCatch(error, info) &#123;    // Display fallback UI    this.setState(&#123; hasError: true &#125;);    // You can also log the error to an error reporting service    logErrorToMyService(error, info);  &#125;   render() &#123;    if (this.state.hasError) &#123;      // You can render any custom fallback UI      return</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Something-went-wrong\"><a href=\"#Something-went-wrong\" class=\"headerlink\" title=\"Something went wrong.\"></a>Something went wrong.</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">; &#125; return this.props.children; &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们像使用普通组件那样使用它：</p>\n<p>componentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries 。</p>\n<p>实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！</p>\n<h2 id=\"九、iframe-异常\"><a href=\"#九、iframe-异常\" class=\"headerlink\" title=\"九、iframe 异常\"></a>九、iframe 异常</h2><p>对于 iframe 的异常捕获，我们还得借力 window.onerror：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.onerror = function(message, source, lineno, colno, error) &#123;  console.log(&#x27;捕获到异常：&#x27;,&#123;message, source, lineno, colno, error&#125;);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个简单的例子可能如下：</p>\n<h2 id=\"十、Script-error\"><a href=\"#十、Script-error\" class=\"headerlink\" title=\"十、Script error\"></a>十、Script error</h2><p>一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：</p>\n<p>跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。</p>\n<p>或者动态去添加 js 脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const script = document.createElement(&#x27;script&#x27;);script.crossOrigin = &#x27;anonymous&#x27;;script.src = url;document.body.appendChild(script);</span><br></pre></td></tr></table></figure>\n\n<p>特别注意，服务器端需要设置：Access-Control-Allow-Origin</p>\n<p>此外，我们也可以试试这个-解决 Script Error 的另类思路：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const originAddEventListener = EventTarget.prototype.addEventListener;EventTarget.prototype.addEventListener = function (type, listener, options) &#123;  const wrappedListener = function (...args) &#123;    try &#123;      return listener.apply(this, args);    &#125;    catch (err) &#123;      throw err;    &#125;  &#125;  return originAddEventListener.call(this, type, wrappedListener, options);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单解释一下：</p>\n<p>改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(() =&gt; &#123;   const originAddEventListener = EventTarget.prototype.addEventListener;   EventTarget.prototype.addEventListener = function (type, listener, options) &#123;+    // 捕获添加事件时的堆栈+    const addStack = new Error(`Event ($&#123;type&#125;)`).stack;     const wrappedListener = function (...args) &#123;       try &#123;         return listener.apply(this, args);       &#125;       catch (err) &#123;+        // 异常发生时，扩展堆栈+        err.stack += &#x27;&#x27; + addStack;         throw err;       &#125;     &#125;     return originAddEventListener.call(this, type, wrappedListener, options);   &#125; &#125;)();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十一、崩溃和卡顿\"><a href=\"#十一、崩溃和卡顿\" class=\"headerlink\" title=\"十一、崩溃和卡顿\"></a>十一、崩溃和卡顿</h2><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？</p>\n<p>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。</p>\n<ol>\n<li>利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&quot;load&quot;, function () &#123;</span><br><span class=\"line\">  sessionStorage.setItem(&quot;good_exit&quot;, &quot;pending&quot;);</span><br><span class=\"line\">  setInterval(function () &#123;</span><br><span class=\"line\">    sessionStorage.setItem(&quot;time_before_crash&quot;, new Date().toString());</span><br><span class=\"line\">  &#125;, 1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">window.addEventListener(&quot;beforeunload&quot;, function () &#123;</span><br><span class=\"line\">  sessionStorage.setItem(&quot;good_exit&quot;, &quot;true&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">if (</span><br><span class=\"line\">  sessionStorage.getItem(&quot;good_exit&quot;) &amp;&amp;</span><br><span class=\"line\">  sessionStorage.getItem(&quot;good_exit&quot;) !== &quot;true&quot;</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  /* insert crash logging code here   */</span><br><span class=\"line\"></span><br><span class=\"line\">  alert(</span><br><span class=\"line\">    &quot;Hey, welcome back from your crash, looks like you crashed on: &quot; +</span><br><span class=\"line\">      sessionStorage.getItem(&quot;time_before_crash&quot;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控：</li>\n</ol>\n<p>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。</p>\n<h2 id=\"十二、错误上报\"><a href=\"#十二、错误上报\" class=\"headerlink\" title=\"十二、错误上报\"></a>十二、错误上报</h2><p>1.通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。</p>\n<p>2.动态创建 img 标签的形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function report(error) &#123;  let reportUrl = &#x27;http://jartto.wang/report&#x27;;  new Image().src = `$&#123;reportUrl&#125;?logs=$&#123;error&#125;`;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Reporter.send = function(data) &#123;  // 只采集 30%  if(Math.random() &lt; 0.3) &#123;    send(data)      // 上报错误信息  &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。</p>\n<h2 id=\"十三、总结\"><a href=\"#十三、总结\" class=\"headerlink\" title=\"十三、总结\"></a>十三、总结</h2><p>回到我们开头提出的那个问题，如何优雅的处理异常呢？</p>\n<ol>\n<li>可疑区域增加 Try-Catch</li>\n<li>全局监控 JS 异常 window.onerror</li>\n<li>全局监控静态资源异常 window.addEventListener</li>\n<li>捕获没有 Catch 的 Promise 异常：unhandledrejection</li>\n<li>VUE errorHandler 和 React componentDidCatch</li>\n<li>监控网页崩溃：window 对象的 load 和 beforeunload</li>\n<li>跨域 crossOrigin 解决</li>\n</ol>\n<p>其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"react-native开发总结","url":"/2022/12/16/react-native%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li><a href=\"https://gitee.com/liu12fei08fei/rn_test\">项目总结代码地址</a></li>\n<li>记录开发 react-native 中各种有意思的事情</li>\n<li>最新探索，用来进行各种尝试的空间</li>\n<li>完成的探索，记录所有已经完成的模块、功能和效果</li>\n<li>中转站，暂时无用</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"全局脚手架\"><a href=\"#全局脚手架\" class=\"headerlink\" title=\"全局脚手架\"></a>全局脚手架</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i -g react-native-cli</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装基础项目\"><a href=\"#安装基础项目\" class=\"headerlink\" title=\"安装基础项目\"></a>安装基础项目</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">react-native init &lt;项目名称&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><h3 id=\"优化后的运行\"><a href=\"#优化后的运行\" class=\"headerlink\" title=\"优化后的运行\"></a>优化后的运行</h3><ul>\n<li>ios：npm run ios</li>\n<li>android：npm run android</li>\n<li>ios and android：npm run s</li>\n</ul>\n<h3 id=\"原始启动\"><a href=\"#原始启动\" class=\"headerlink\" title=\"原始启动\"></a>原始启动</h3><ul>\n<li>ios：react-native run-ios</li>\n<li>android：react-native run-android</li>\n</ul>\n<h2 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h2><ul>\n<li><a href=\"https://github.com/react-navigation/react-navigation\">navigation 集成</a></li>\n<li><a href=\"https://github.com/oblador/react-native-vector-icons\">集成 icons</a> -<a href=\"https://github.com/crazycodeboy/react-native-easy-toast\"> react-native-easy-toast</a></li>\n<li><a href=\"https://github.com/jondot/awesome-react-native\">rn 资源列表</a></li>\n<li><a href=\"https://github.com/dancormier/react-native-swipeout\">横向滑动展示按钮效果</a></li>\n<li><a href=\"https://github.com/valerybugakov/react-native-custom-actionsheet\">自定义行动列表</a></li>\n<li><a href=\"https://github.com/danchokobo/react-native-code-verification\">密码输入效果</a></li>\n<li><a href=\"https://github.com/skv-headless/react-native-scrollable-tab-view\">选项卡导航之间滑动</a></li>\n<li><a href=\"https://github.com/cssivision/react-native-qrcode\">二维码生成</a></li>\n</ul>\n<h2 id=\"未探索的资源\"><a href=\"#未探索的资源\" class=\"headerlink\" title=\"未探索的资源\"></a>未探索的资源</h2><blockquote>\n<p>365 个库中寻找 77 个</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/beefe/react-native-picker\">select 选择控件</a></li>\n<li><a href=\"https://github.com/App2Sales/react-native-switch-selector\">开关式选择列表</a></li>\n<li><a href=\"https://github.com/yonahforst/react-native-emoji-picker\">表情选择器</a></li>\n<li><a href=\"https://github.com/Tinysymphony/react-native-drawer-menu\">左右滑动层</a></li>\n<li><a href=\"https://github.com/Spikef/react-native-phone-picker\">手机号选择控件</a></li>\n<li><a href=\"https://github.com/zecaptus/react-native-md-motion-buttons\">登录动画</a></li>\n<li><a href=\"https://github.com/merryjs/photo-viewer\">图片查看器</a></li>\n<li><a href=\"https://github.com/SoftZen/react-native-bouncy-drawer\">菜单操作动画</a></li>\n<li><a href=\"https://github.com/charlot567/react-native-comparison-slider\">滑动操作图片展示样式</a></li>\n<li><a href=\"https://github.com/moschan/react-native-newsticker\">操作打字效果</a></li>\n<li><a href=\"https://github.com/prscX/react-native-siri-wave-view\">声音可视化</a></li>\n<li><a href=\"https://github.com/mfrachet/rn-placeholder\">占位符</a></li>\n<li><a href=\"https://github.com/oblador/react-native-lightbox\">图片查看器</a></li>\n<li><a href=\"https://github.com/react-native-community/react-native-blur\">模糊背景效果</a></li>\n<li><a href=\"https://github.com/ivpusic/react-native-image-crop-picker\">本地图片超级操作</a></li>\n<li><a href=\"https://github.com/meteor-factory/react-native-tinder-swipe-cards\">四面八方拖动效果</a></li>\n<li><a href=\"https://github.com/sbycrosz/react-native-credit-card-input\">信用卡输入效果</a></li>\n<li><a href=\"https://github.com/jmurzy/react-native-foldview\">展开动画效果</a></li>\n<li><a href=\"https://github.com/tomauty/react-native-chart\">chart</a></li>\n<li><a href=\"https://github.com/crazycodeboy/react-native-splash-screen\">初始化启动页</a></li>\n<li><a href=\"https://github.com/wix/react-native-calendars\">日期</a></li>\n<li><a href=\"https://github.com/archriss/react-native-snap-carousel\">左右滑动操作卡片效果</a></li>\n<li><a href=\"https://github.com/gitim/react-native-sortable-list\">列表拖拽</a></li>\n<li><a href=\"https://github.com/JesperLekland/react-native-svg-charts\">chart</a></li>\n<li><a href=\"https://github.com/spikef/react-native-gesture-password\">密码锁效果</a></li>\n<li><a href=\"https://github.com/djchie/react-native-star-rating\">星级评价</a></li>\n<li><a href=\"https://github.com/jgrancher/react-native-sketch\">手动签字</a></li>\n<li><a href=\"https://github.com/24ark/react-native-step-indicator\">滑动时间轴效果</a></li>\n<li><a href=\"https://github.com/xcarpentier/react-native-country-picker-modal\">国家 26 字母选择</a></li>\n<li><a href=\"https://github.com/cnjon/react-native-pdf-view\">PDF 查看</a></li>\n<li><a href=\"https://github.com/i6mi6/react-native-alphabetlistview\">26 字母选择</a></li>\n<li><a href=\"https://github.com/naoufal/react-native-activity-view\">分享</a></li>\n<li><a href=\"https://github.com/jeanregisser/react-native-popover\">对话框</a></li>\n<li><a href=\"https://github.com/taskrabbit/react-native-parsed-text\">电话、地址等操作</a></li>\n<li><a href=\"https://github.com/kayla-tech/react-native-privacy-snapshot\">后台信息保护</a></li>\n<li><a href=\"https://github.com/anvilabs/react-native-image-carousel\">图片查看器</a></li>\n<li><a href=\"https://github.com/chitezh/react-native-swiper-animated\">左右滑动动画</a></li>\n<li><a href=\"https://github.com/rauchy/react-native-offline-mode\">无网络操作</a></li>\n<li><a href=\"https://github.com/instea/react-native-color-picker\">颜色选择器</a></li>\n<li><a href=\"https://github.com/wix/react-native-custom-segmented-control\">左右滑动 tab 动效</a></li>\n<li><a href=\"https://github.com/mastermoo/react-native-pulse-loader\">加载中效果</a></li>\n<li><a href=\"https://github.com/machadogj/react-native-carousel-control\">左右滑动效果，类似酷划锁屏</a></li>\n<li><a href=\"https://github.com/awesomejerry/react-native-qrcode-svg\">二维码生成器</a></li>\n<li><a href=\"https://github.com/zachgibson/react-native-parallax-swiper\">图片查看器</a></li>\n<li><a href=\"https://github.com/bamlab/react-native-image-header-scroll-view\">视差效果</a></li>\n<li><a href=\"https://github.com/Tinysymphony/react-native-calendar-select\">日期</a></li>\n<li><a href=\"https://github.com/prscX/react-native-shine-button\">点击效果</a></li>\n<li><a href=\"https://github.com/geremih/react-native-circular-action-menu\">扇形菜单</a></li>\n<li><a href=\"https://github.com/johanneslumpe/react-native-gesture-recognizers/\">手势识别</a></li>\n</ul>\n<h2 id=\"新增页面需要在三个地方进行操作\"><a href=\"#新增页面需要在三个地方进行操作\" class=\"headerlink\" title=\"新增页面需要在三个地方进行操作\"></a>新增页面需要在三个地方进行操作</h2><ol>\n<li>data 里面的 complete.js 中添加数据，方便在完成的探索中出现</li>\n<li>navigators 中的 AppStackNavigators.js 里面进行引入&#x3D;&gt;注册，使得路由正常</li>\n<li>pages 里面添加页面</li>\n</ol>\n<h2 id=\"优化-package-json-使开发更加方便\"><a href=\"#优化-package-json-使开发更加方便\" class=\"headerlink\" title=\"优化 package.json 使开发更加方便\"></a>优化 package.json 使开发更加方便</h2><ul>\n<li>在 scripts 中添加，如下内容：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;ios&quot;:&quot;react-native run-ios&quot;,</span><br><span class=\"line\">&quot;android&quot;:&quot;react-native run-android&quot;,</span><br><span class=\"line\">&quot;s&quot;:&quot;npm run ios &amp;&amp; npm run android&quot;,</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"flex-布局常用属性\"><a href=\"#flex-布局常用属性\" class=\"headerlink\" title=\"flex 布局常用属性\"></a>flex 布局常用属性</h2><ul>\n<li>防止在 flex 中出现，固定元素被挤压的问题，使用 flex:1 进行优化</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">display: &#x27;flex&#x27;;</span><br><span class=\"line\">flexDirection: row | row-reverse | column | column-reverse;</span><br><span class=\"line\">flexWrap: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\">flexFlow: &lt;flex-direction&gt; | &lt;flex-wrap&gt;;</span><br><span class=\"line\">justifyContent: flex-start | flex-end | center | space-between | space-around;</span><br><span class=\"line\">alignItems: flex-start | flex-end | center | baseline | stretch;</span><br><span class=\"line\">alignContent: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class=\"line\"></span><br><span class=\"line\">order: &lt;integer&gt;;</span><br><span class=\"line\">flexGrow: &lt;number&gt;; /* default 0 */</span><br><span class=\"line\">flexShrink: &lt;number&gt;; /* default 1 */</span><br><span class=\"line\">flexBasis: &lt;length&gt; | auto; /* default auto */</span><br><span class=\"line\">flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ]</span><br><span class=\"line\">alignSelf: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><h3 id=\"图片使用\"><a href=\"#图片使用\" class=\"headerlink\" title=\"图片使用\"></a>图片使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Image source=&#123;require(&#x27;./my-icon.png&#x27;)&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><ul>\n<li>icon_test.png</li>\n<li><a href=\"mailto:&#x69;&#99;&#111;&#110;&#95;&#x74;&#x65;&#115;&#x74;&#64;&#x32;&#x78;&#x2e;&#x70;&#x6e;&#x67;\">&#x69;&#99;&#111;&#110;&#95;&#x74;&#x65;&#115;&#x74;&#64;&#x32;&#x78;&#x2e;&#x70;&#x6e;&#x67;</a></li>\n<li><a href=\"mailto:&#x69;&#99;&#x6f;&#110;&#95;&#116;&#101;&#115;&#x74;&#x40;&#51;&#x78;&#46;&#112;&#x6e;&#103;\">&#x69;&#99;&#x6f;&#110;&#95;&#116;&#101;&#115;&#x74;&#x40;&#51;&#x78;&#46;&#112;&#x6e;&#103;</a></li>\n</ul>\n<h2 id=\"链接原生库\"><a href=\"#链接原生库\" class=\"headerlink\" title=\"链接原生库\"></a>链接原生库</h2><p><strong>第一步</strong></p>\n<blockquote>\n<p>安装带原生依赖的库</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install &lt;某个带有原生依赖的库&gt; --save</span><br></pre></td></tr></table></figure>\n\n<p><strong>第二步</strong></p>\n<blockquote>\n<p>运行以下命令，它会根据 package.json 文件中的 dependencies 和 devDependencies 记录来链接所有需要链接的库</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">react-native link</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"开发技巧\"><a href=\"#开发技巧\" class=\"headerlink\" title=\"开发技巧\"></a>开发技巧</h2><ul>\n<li>启动 hot 或者 debug 的时候，切记不要同时启动 ios and android，两者会发生冲突，导致出现程序崩溃，从而影响开发</li>\n<li>最好的方式是，启动一个 hot 或 debug，这样可以良好的进行开发；另一个手动足够了</li>\n</ul>\n<h2 id=\"处理触摸事件\"><a href=\"#处理触摸事件\" class=\"headerlink\" title=\"处理触摸事件\"></a>处理触摸事件</h2><blockquote>\n<p>使用”Touchable”开头的一系列组件<br>通过 onPress 属性接受一个点击事件的处理函数</p>\n</blockquote>\n<ul>\n<li>两种方式绑定事件，并处理点击范围</li>\n<li>推荐第二种，方便传递数据</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">_onPressButton=((item)=&gt;&#123;</span><br><span class=\"line\">  alert(1)</span><br><span class=\"line\">  console.log(item);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;View&gt;</span><br><span class=\"line\">      &lt;TouchableHighlight onPress=&#123;this._onPressButton&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;[S.btn,&#123;backgroundColor:`$&#123;this.state.bg&#125;`&#125;]&#125;&gt;</span><br><span class=\"line\">          &lt;Text style=&#123;S.btnText&#125;&gt;&#123;this.state.bg&#125;&lt;/Text&gt;</span><br><span class=\"line\">        &lt;/View&gt;</span><br><span class=\"line\">      &lt;/TouchableHighlight&gt;</span><br><span class=\"line\">      &lt;TouchableHighlight onPress=&#123;()=&gt;&#123;</span><br><span class=\"line\">        this._onPressButton(this.state.bg)</span><br><span class=\"line\">      &#125;&#125;&gt;</span><br><span class=\"line\">        &lt;View style=&#123;[S.btn,&#123;backgroundColor:`$&#123;this.state.bg&#125;`&#125;]&#125;&gt;</span><br><span class=\"line\">          &lt;Text style=&#123;S.btnText&#125;&gt;&#123;this.state.bg&#125;&lt;/Text&gt;</span><br><span class=\"line\">        &lt;/View&gt;</span><br><span class=\"line\">      &lt;/TouchableHighlight&gt;</span><br><span class=\"line\">    &lt;/View&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解决版本冲突问题\"><a href=\"#解决版本冲突问题\" class=\"headerlink\" title=\"解决版本冲突问题\"></a>解决版本冲突问题</h2><p><strong>js 版本和 rn 版本出现冲突</strong></p>\n<ul>\n<li>Watchman 是由 Facebook 提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager 可以快速捕捉文件的变化从而实现实时刷新）。</li>\n<li>清除 Watchman：watchman watch-del-all</li>\n<li>清除 rn 缓存：react-native start –reset-cache</li>\n</ul>\n<h2 id=\"解决路由失效问题\"><a href=\"#解决路由失效问题\" class=\"headerlink\" title=\"解决路由失效问题\"></a>解决路由失效问题</h2><ul>\n<li><p>createTabNavigator 要在 createStackNavigator 里面进行注册，才能够使用 createStackNavigator 具有的方法，这个是我第二次配置的时候掉进的一个坑<br><strong>this.props.navigation 属性详细说明</strong></p>\n</li>\n<li><p>在 createTabNavigator 里面没有 push、replace 等方法</p>\n</li>\n<li><p>在 createStackNavigator 中存在 push、replace 等方法</p>\n</li>\n</ul>\n<h2 id=\"AsyncStorage-保存报错\"><a href=\"#AsyncStorage-保存报错\" class=\"headerlink\" title=\"AsyncStorage 保存报错\"></a>AsyncStorage 保存报错</h2><blockquote>\n<p>JSON value ‘<null>‘ of type NSNull</p>\n</blockquote>\n<ul>\n<li>当保存值为 undefined 的时候，报错</li>\n<li>防止这种问题发生最好在 this.state 中保存初始值为空，必要时可以提醒用户</li>\n</ul>\n<h2 id=\"react-native-支持的-style-props\"><a href=\"#react-native-支持的-style-props\" class=\"headerlink\" title=\"react-native 支持的 style props\"></a>react-native 支持的 style props</h2><ul>\n<li>查看最新版属性支持情况，最简单的直接在页面使用错误的属性，然后查看报错信息 😂</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Valid style props: [</span><br><span class=\"line\">  &quot;alignContent&quot;,</span><br><span class=\"line\">  &quot;alignItems&quot;,</span><br><span class=\"line\">  &quot;alignSelf&quot;,</span><br><span class=\"line\">  &quot;aspectRatio&quot;,</span><br><span class=\"line\">  &quot;backfaceVisibility&quot;,</span><br><span class=\"line\">  &quot;backgroundColor&quot;,</span><br><span class=\"line\">  &quot;borderBottomColor&quot;,</span><br><span class=\"line\">  &quot;borderBottomEndRadius&quot;,</span><br><span class=\"line\">  &quot;borderBottomLeftRadius&quot;,</span><br><span class=\"line\">  &quot;borderBottomRightRadius&quot;,</span><br><span class=\"line\">  &quot;borderBottomStartRadius&quot;,</span><br><span class=\"line\">  &quot;borderBottomWidth&quot;,</span><br><span class=\"line\">  &quot;borderColor&quot;,</span><br><span class=\"line\">  &quot;borderEndColor&quot;,</span><br><span class=\"line\">  &quot;borderEndWidth&quot;,</span><br><span class=\"line\">  &quot;borderLeftColor&quot;,</span><br><span class=\"line\">  &quot;borderLeftWidth&quot;,</span><br><span class=\"line\">  &quot;borderRadius&quot;,</span><br><span class=\"line\">  &quot;borderRightColor&quot;,</span><br><span class=\"line\">  &quot;borderRightWidth&quot;,</span><br><span class=\"line\">  &quot;borderStartColor&quot;,</span><br><span class=\"line\">  &quot;borderStartWidth&quot;,</span><br><span class=\"line\">  &quot;borderStyle&quot;,</span><br><span class=\"line\">  &quot;borderTopColor&quot;,</span><br><span class=\"line\">  &quot;borderTopEndRadius&quot;,</span><br><span class=\"line\">  &quot;borderTopLeftRadius&quot;,</span><br><span class=\"line\">  &quot;borderTopRightRadius&quot;,</span><br><span class=\"line\">  &quot;borderTopStartRadius&quot;,</span><br><span class=\"line\">  &quot;borderTopWidth&quot;,</span><br><span class=\"line\">  &quot;borderWidth&quot;,</span><br><span class=\"line\">  &quot;bottom&quot;,</span><br><span class=\"line\">  &quot;color&quot;,</span><br><span class=\"line\">  &quot;decomposedMatrix&quot;,</span><br><span class=\"line\">  &quot;direction&quot;,</span><br><span class=\"line\">  &quot;display&quot;,</span><br><span class=\"line\">  &quot;elevation&quot;,</span><br><span class=\"line\">  &quot;end&quot;,</span><br><span class=\"line\">  &quot;flex&quot;,</span><br><span class=\"line\">  &quot;flexBasis&quot;,</span><br><span class=\"line\">  &quot;flexDirection&quot;,</span><br><span class=\"line\">  &quot;flexGrow&quot;,</span><br><span class=\"line\">  &quot;flexShrink&quot;,</span><br><span class=\"line\">  &quot;flexWrap&quot;,</span><br><span class=\"line\">  &quot;fontFamily&quot;,</span><br><span class=\"line\">  &quot;fontSize&quot;,</span><br><span class=\"line\">  &quot;fontStyle&quot;,</span><br><span class=\"line\">  &quot;fontVariant&quot;,</span><br><span class=\"line\">  &quot;fontWeight&quot;,</span><br><span class=\"line\">  &quot;height&quot;,</span><br><span class=\"line\">  &quot;includeFontPadding&quot;,</span><br><span class=\"line\">  &quot;justifyContent&quot;,</span><br><span class=\"line\">  &quot;left&quot;,</span><br><span class=\"line\">  &quot;letterSpacing&quot;,</span><br><span class=\"line\">  &quot;lineHeight&quot;,</span><br><span class=\"line\">  &quot;margin&quot;,</span><br><span class=\"line\">  &quot;marginBottom&quot;,</span><br><span class=\"line\">  &quot;marginEnd&quot;,</span><br><span class=\"line\">  &quot;marginHorizontal&quot;,</span><br><span class=\"line\">  &quot;marginLeft&quot;,</span><br><span class=\"line\">  &quot;marginRight&quot;,</span><br><span class=\"line\">  &quot;marginStart&quot;,</span><br><span class=\"line\">  &quot;marginTop&quot;,</span><br><span class=\"line\">  &quot;marginVertical&quot;,</span><br><span class=\"line\">  &quot;maxHeight&quot;,</span><br><span class=\"line\">  &quot;maxWidth&quot;,</span><br><span class=\"line\">  &quot;minHeight&quot;,</span><br><span class=\"line\">  &quot;minWidth&quot;,</span><br><span class=\"line\">  &quot;opacity&quot;,</span><br><span class=\"line\">  &quot;overflow&quot;,</span><br><span class=\"line\">  &quot;overlayColor&quot;,</span><br><span class=\"line\">  &quot;padding&quot;,</span><br><span class=\"line\">  &quot;paddingBottom&quot;,</span><br><span class=\"line\">  &quot;paddingEnd&quot;,</span><br><span class=\"line\">  &quot;paddingHorizontal&quot;,</span><br><span class=\"line\">  &quot;paddingLeft&quot;,</span><br><span class=\"line\">  &quot;paddingRight&quot;,</span><br><span class=\"line\">  &quot;paddingStart&quot;,</span><br><span class=\"line\">  &quot;paddingTop&quot;,</span><br><span class=\"line\">  &quot;paddingVertical&quot;,</span><br><span class=\"line\">  &quot;position&quot;,</span><br><span class=\"line\">  &quot;resizeMode&quot;,</span><br><span class=\"line\">  &quot;right&quot;,</span><br><span class=\"line\">  &quot;rotation&quot;,</span><br><span class=\"line\">  &quot;scaleX&quot;,</span><br><span class=\"line\">  &quot;scaleY&quot;,</span><br><span class=\"line\">  &quot;shadowColor&quot;,</span><br><span class=\"line\">  &quot;shadowOffset&quot;,</span><br><span class=\"line\">  &quot;shadowOpacity&quot;,</span><br><span class=\"line\">  &quot;shadowRadius&quot;,</span><br><span class=\"line\">  &quot;start&quot;,</span><br><span class=\"line\">  &quot;textAlign&quot;,</span><br><span class=\"line\">  &quot;textAlignVertical&quot;,</span><br><span class=\"line\">  &quot;textDecorationColor&quot;,</span><br><span class=\"line\">  &quot;textDecorationLine&quot;,</span><br><span class=\"line\">  &quot;textDecorationStyle&quot;,</span><br><span class=\"line\">  &quot;textShadowColor&quot;,</span><br><span class=\"line\">  &quot;textShadowOffset&quot;,</span><br><span class=\"line\">  &quot;textShadowRadius&quot;,</span><br><span class=\"line\">  &quot;textTransform&quot;,</span><br><span class=\"line\">  &quot;tintColor&quot;,</span><br><span class=\"line\">  &quot;top&quot;,</span><br><span class=\"line\">  &quot;transform&quot;,</span><br><span class=\"line\">  &quot;transformMatrix&quot;,</span><br><span class=\"line\">  &quot;translateX&quot;,</span><br><span class=\"line\">  &quot;translateY&quot;,</span><br><span class=\"line\">  &quot;width&quot;,</span><br><span class=\"line\">  &quot;writingDirection&quot;,</span><br><span class=\"line\">  &quot;zIndex&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"StatusBar-解决-android-状态栏问题\"><a href=\"#StatusBar-解决-android-状态栏问题\" class=\"headerlink\" title=\"StatusBar 解决 android 状态栏问题\"></a>StatusBar 解决 android 状态栏问题</h2><p>设置 StatusBar</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;StatusBar</span><br><span class=\"line\">     backgroundColor=&quot;transparent&quot;</span><br><span class=\"line\">     translucent</span><br><span class=\"line\">   /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>设置顶部模块的样式</p>\n<ul>\n<li>注：padding 值需要+高度值&#x3D;&gt;height 最终值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">height: 50,</span><br><span class=\"line\">paddingTop: 10,</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Platform-区分-ios-and-android-平台\"><a href=\"#Platform-区分-ios-and-android-平台\" class=\"headerlink\" title=\"Platform 区分 ios and android 平台\"></a>Platform 区分 ios and android 平台</h2><blockquote>\n<p>三种方法实现跨平台：</p>\n</blockquote>\n<ol>\n<li>Platform.OS</li>\n<li>使用 Platform 的 select 方法</li>\n<li>使用不能组件名：ios 使用 header.ios.js；android 使用 header.android.js</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const instructions = Platform.select(&#123;</span><br><span class=\"line\">  ios: &#x27;ios&#x27;,</span><br><span class=\"line\">  android: &#x27;android&#x27;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"请求-fetch-封装\"><a href=\"#请求-fetch-封装\" class=\"headerlink\" title=\"请求 fetch 封装\"></a>请求 fetch 封装</h2><ul>\n<li>HttpUtils.js<br><strong>引入</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import HttpUtils from &#x27;../../HttpUtils&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用</strong></p>\n<ul>\n<li>在全局 global.data.domain 保存请求域名</li>\n<li>请求需要 header 传递 token 的使用,global.data.token</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HttpUtils.post(`$&#123;apiConfig&#125;`, &#123;</span><br><span class=\"line\">    platform: &#x27;ios&#x27;</span><br><span class=\"line\">&#125;,global.data.token)</span><br><span class=\"line\">.then(rtn =&gt; &#123;</span><br><span class=\"line\">    global.data.config = rtn;</span><br><span class=\"line\">    // console.log(`配置=&gt;( $&#123;JSON.stringify(rtn)&#125; )`);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(err =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;error&#x27;, err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"请求环境-请求地址定义\"><a href=\"#请求环境-请求地址定义\" class=\"headerlink\" title=\"请求环境+请求地址定义\"></a>请求环境+请求地址定义</h2><h3 id=\"请求环境\"><a href=\"#请求环境\" class=\"headerlink\" title=\"请求环境\"></a>请求环境</h3><ul>\n<li>在 addr.js 中 env 变量定义</li>\n</ul>\n<h3 id=\"请求地址\"><a href=\"#请求地址\" class=\"headerlink\" title=\"请求地址\"></a>请求地址</h3><ul>\n<li>在 addr.js 中 addrList 统一管理所有请求地址</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import addrList from &#x27;../../addr&#x27;;</span><br><span class=\"line\">const &#123;apiConfig&#125;=addrList;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>react-native-scrollable-tab-view</p>\n</blockquote>\n<ul>\n<li>解决逗号影响的报错问题：在路径~&#x2F;node_modules&#x2F;react-native-scrollable-tab-viewSceneComponent.js 下删除即可</li>\n</ul>\n<h2 id=\"react-native-初始化报错，导致无法初始化\"><a href=\"#react-native-初始化报错，导致无法初始化\" class=\"headerlink\" title=\"react-native 初始化报错，导致无法初始化\"></a>react-native 初始化报错，导致无法初始化</h2><ul>\n<li>重新设置一下地址</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry https://registry.npm.taobao.org</span><br><span class=\"line\">npm config set disturl https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"动态切换状态\"><a href=\"#动态切换状态\" class=\"headerlink\" title=\"动态切换状态\"></a>动态切换状态</h2><ul>\n<li>采用对象的形式来操作，这样可以使用 state 里面的参数，来动态切换</li>\n<li>解决了直接应用的报错问题，以后遇到同样的问题要及时想到对象方式</li>\n</ul>\n<h2 id=\"声明周期-初始渲染-and-检测-goBack\"><a href=\"#声明周期-初始渲染-and-检测-goBack\" class=\"headerlink\" title=\"声明周期-初始渲染 and 检测 goBack()\"></a>声明周期-初始渲染 and 检测 goBack()</h2><ul>\n<li>为了保证页面的数据实时性，最好在初始的时候进行请求</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentDidMount()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"检测-goBack\"><a href=\"#检测-goBack\" class=\"headerlink\" title=\"检测 goBack()\"></a>检测 goBack()</h3><blockquote>\n<p>需要重新加载 app</p>\n</blockquote>\n<p><strong>第一步</strong></p>\n<ul>\n<li>在删除组件的时候，定义 goBack 事件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentWillUnmount()&#123;</span><br><span class=\"line\">  DeviceEventEmitter.emit(&#x27;goBack&#x27;, &#x27;goBack刷新返回页面数据&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>第二步</strong></p>\n<ul>\n<li>在初始渲染中监听，goBack 自定义事件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">  // 接收</span><br><span class=\"line\">  this.deEmitter = DeviceEventEmitter.addListener(&#x27;goBack&#x27;, (a) =&gt; &#123;</span><br><span class=\"line\">    this.loadData();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安卓打包\"><a href=\"#安卓打包\" class=\"headerlink\" title=\"安卓打包\"></a>安卓打包</h2><h3 id=\"第一步：生成-Android-签名证书\"><a href=\"#第一步：生成-Android-签名证书\" class=\"headerlink\" title=\"第一步：生成 Android 签名证书\"></a>第一步：<a href=\"https://developer.android.com/studio/publish/app-signing\">生成 Android 签名证书</a></h3><h3 id=\"第二步：设置-gradle-变量\"><a href=\"#第二步：设置-gradle-变量\" class=\"headerlink\" title=\"第二步：设置 gradle 变量\"></a>第二步：设置 gradle 变量</h3><ul>\n<li>将你的签名证书 copy 到 android&#x2F;app 目录下</li>\n<li>编辑<code>~/.gradle/gradle.properties</code>或<code>../android/gradle.properties</code>(一个是全局 gradle.properties，一个是项目中的 gradle.properties，大家可以根据需要进行修改) ，加入如下代码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">MYAPP_RELEASE_STORE_FILE=ch09-keystore.jks</span><br><span class=\"line\">MYAPP_RELEASE_KEY_ALIAS=ch09-keystore</span><br><span class=\"line\">MYAPP_RELEASE_STORE_PASSWORD=123456</span><br><span class=\"line\">MYAPP_RELEASE_KEY_PASSWORD=123456</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第三步：在-gradle-配置文件中添加签名配置\"><a href=\"#第三步：在-gradle-配置文件中添加签名配置\" class=\"headerlink\" title=\"第三步：在 gradle 配置文件中添加签名配置\"></a>第三步：在 gradle 配置文件中添加签名配置</h3><ul>\n<li>编辑<code>android/app/build.gradle</code>文件添加如下代码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    defaultConfig &#123; ... &#125;</span><br><span class=\"line\">    signingConfigs &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            storeFile file(MYAPP_RELEASE_STORE_FILE)</span><br><span class=\"line\">            storePassword MYAPP_RELEASE_STORE_PASSWORD</span><br><span class=\"line\">            keyAlias MYAPP_RELEASE_KEY_ALIAS</span><br><span class=\"line\">            keyPassword MYAPP_RELEASE_KEY_PASSWORD</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            signingConfig signingConfigs.release</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第四步：签名打包-APK\"><a href=\"#第四步：签名打包-APK\" class=\"headerlink\" title=\"第四步：签名打包 APK\"></a>第四步：签名打包 APK</h3><ul>\n<li>terminal 进入项目下的 android 目录，运行如下代码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./gradlew assembleRelease</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>签名打包成功后你会在 android&#x2F;app&#x2F;build&#x2F;outputs&#x2F;apk&#x2F;目录下看到签名成功后的 app-release.apk 文件。</li>\n<li>提示：如果你需要对 apk 进行混淆打包 编辑 android&#x2F;app&#x2F;build.gradle：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Run Proguard to shrink the Java bytecode in release builds.</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">def enableProguardInReleaseBuilds = true</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fetch(apiLogin, &#123;</span><br><span class=\"line\">    method: &#x27;POST&#x27;,</span><br><span class=\"line\">    headers: &#123;</span><br><span class=\"line\">      &#x27;Accept&#x27;: &#x27;application/json&#x27;,//通过头指定，获取的数据类型是JSON</span><br><span class=\"line\">      &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class=\"line\">      &#x27;Authorization&#x27;:global.data.token,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    body: JSON.stringify(&#123;</span><br><span class=\"line\">      // 请求参数</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(result =&gt; &#123;</span><br><span class=\"line\">    const &#123;status,statusText&#125; = result;</span><br><span class=\"line\">    if(status&gt;=200 &amp;&amp; status&lt;300 || status==304)&#123;</span><br><span class=\"line\">      // 成功</span><br><span class=\"line\">      const promise = result.json()</span><br><span class=\"line\">      promise.then(rtn=&gt;&#123;</span><br><span class=\"line\">        // 成功</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;else if(status==403)&#123;</span><br><span class=\"line\">      // 跳转登录</span><br><span class=\"line\">      this.props.navigation.replace(&#x27;login&#x27;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">      // 提醒 statusText</span><br><span class=\"line\">      this.refs.toast.show(statusText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(error =&gt; &#123;</span><br><span class=\"line\">    if(Object.prototype.toString.call(error) === &#x27;[object Object]&#x27;)&#123;</span><br><span class=\"line\">        this.refs.toast.show(JSON.stringify(error))</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        this.refs.toast.show(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"app-的-logo-and-name\"><a href=\"#app-的-logo-and-name\" class=\"headerlink\" title=\"app 的 logo and name\"></a>app 的 logo and name</h2><h3 id=\"android\"><a href=\"#android\" class=\"headerlink\" title=\"android\"></a>android</h3><p><strong>LOGO</strong></p>\n<ul>\n<li>将 logo 分别放到 android&#x2F;app&#x2F;src&#x2F;main&#x2F;res 下的四个文件夹中,命名为 ic_launcher.png</li>\n<li>没有对应上的文件夹放一张<code>1024*1024</code>或者<code>512*512</code>的即可</li>\n</ul>\n<p><strong>app 名称</strong></p>\n<ul>\n<li>在<code>android/app/src/main/res/values/strings.xml</code>中更改</li>\n</ul>\n<h3 id=\"IOS\"><a href=\"#IOS\" class=\"headerlink\" title=\"IOS\"></a>IOS</h3><p><strong>LOGO</strong></p>\n<ul>\n<li>xcode&gt; 根目录 &gt;Images.xcassets 将生成的图标拖入对应的位置</li>\n</ul>\n<p><strong>app 名称</strong></p>\n<ul>\n<li>xcode&gt; 根目录 &gt;Info.plist 中修改 Bundlename 和 General&gt; Display Name</li>\n</ul>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"react实现路由懒加载（异步组件）","url":"/2022/10/24/react%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%89/","content":"<p><strong>正如标题，react 项目在打包完成后发现 chunk.js 文件比较大，导致打开首页需要时间比较久，因此，需要进行优化。<br>其实仔细考虑一下不难发现，由于打包后将所有资源都打包到了一个 chunk.js 下，导致所有资源都一起加载了，所以，进入页面会很慢。咱们的预期目标是进入首页只加载首页的资源，进入详情页至加载详情页的资源。那么，react-loadable 是你不错的选择。</strong></p>\n<h2 id=\"1、首先，要想使用它需要先安装它。\"><a href=\"#1、首先，要想使用它需要先安装它。\" class=\"headerlink\" title=\"1、首先，要想使用它需要先安装它。\"></a>1、首先，要想使用它需要先安装它。</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add react-loadable</span><br><span class=\"line\">yarn add babel-plugin-syntax-dynamic-import</span><br></pre></td></tr></table></figure>\n\n<p>根据 npm 官网找到 react-loadable 完成配置，当然我为了以后方便使用对 react-loadable 进行了封装。</p>\n<h2 id=\"2-其次，在-utils-文件夹下新建-loadable-js-文件，配置如下：\"><a href=\"#2-其次，在-utils-文件夹下新建-loadable-js-文件，配置如下：\" class=\"headerlink\" title=\"2 其次，在 utils 文件夹下新建 loadable.js 文件，配置如下：\"></a>2 其次，在 utils 文件夹下新建 loadable.js 文件，配置如下：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import &#123; Spin &#125; from &#x27;antd&#x27;;</span><br><span class=\"line\">import Loadable from &quot;react-loadable&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#x27;./index.less&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 加载动画</span><br><span class=\"line\">const loadingComponent = () =&gt; &#123;</span><br><span class=\"line\">  return &lt;div className=&#123;&#x27;spin-loading&#x27;&#125;&gt;</span><br><span class=\"line\">    &lt;div&gt;&lt;Spin size=&quot;large&quot; /&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当不传加载动画时候使用默认的加载动画</span><br><span class=\"line\">export default (loader, loading = loadingComponent) =&gt; &#123;</span><br><span class=\"line\">  return Loadable(&#123;</span><br><span class=\"line\">    loader,</span><br><span class=\"line\">    loading,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、在-index-js-文件里配置路由时候就可以使用如下方式进行懒加载处理\"><a href=\"#3、在-index-js-文件里配置路由时候就可以使用如下方式进行懒加载处理\" class=\"headerlink\" title=\"3、在 index.js 文件里配置路由时候就可以使用如下方式进行懒加载处理\"></a>3、在 index.js 文件里配置路由时候就可以使用如下方式进行懒加载处理</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import ReactDOM from &quot;react-dom&quot;;</span><br><span class=\"line\">import &quot;./index.css&quot;;</span><br><span class=\"line\">import * as serviceWorker from &quot;./serviceWorker&quot;;</span><br><span class=\"line\">import &#123; BrowserRouter as Router, Route &#125; from &quot;react-router-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; createBrowserHistory &#125; from &quot;history&quot;;</span><br><span class=\"line\">import loadable from &#x27;./utils/loadable&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const App = loadable(() =&gt; import(&quot;./router/login/App&quot;));</span><br><span class=\"line\">const MoveVideo = loadable(() =&gt; import(&quot;./router/video&quot;));</span><br><span class=\"line\">const UserReg = loadable(() =&gt; import(&quot;./router/userReg/index&quot;));</span><br><span class=\"line\">const FoodList = loadable(() =&gt; import(&quot;./router/food/index&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Router history=&#123;createBrowserHistory()&#125;&gt;</span><br><span class=\"line\">    &lt;Route exact path=&quot;/&quot; component=&#123;App&#125; /&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/user-reg/&quot; component=&#123;UserReg&#125; /&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/food-list&quot; component=&#123;FoodList&#125; /&gt;</span><br><span class=\"line\">    &lt;Route path=&quot;/video&quot; component=&#123;MoveVideo&#125; /&gt;</span><br><span class=\"line\">  &lt;/Router&gt;,</span><br><span class=\"line\">  document.getElementById(&quot;root&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">serviceWorker.unregister();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、再次进行打包编译，就会发现多出很多-chunk-js-文件，这就是从原来一个拆成多个，这样加载速度就会得到提升。\"><a href=\"#4、再次进行打包编译，就会发现多出很多-chunk-js-文件，这就是从原来一个拆成多个，这样加载速度就会得到提升。\" class=\"headerlink\" title=\"4、再次进行打包编译，就会发现多出很多 chunk.js 文件，这就是从原来一个拆成多个，这样加载速度就会得到提升。\"></a>4、再次进行打包编译，就会发现多出很多 chunk.js 文件，这就是从原来一个拆成多个，这样加载速度就会得到提升。</h2>","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"redis常用命令大全","url":"/2022/12/16/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","content":"<p><img src=\"https://img2018.cnblogs.com/blog/798174/201903/798174-20190321203330649-499029266.png\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.基于内存的key-value数据库</span><br><span class=\"line\">2.基于c语言编写的，可以支持多种语言的api //set每秒11万次，取get 81000次</span><br><span class=\"line\">3.支持数据持久化</span><br><span class=\"line\">4.value可以是string，hash， list， set, sorted set</span><br><span class=\"line\"></span><br><span class=\"line\">使用场景</span><br><span class=\"line\">1. 取最新n个数据的操作</span><br><span class=\"line\">2. 排行榜，取top n个数据 //最佳人气前10条</span><br><span class=\"line\">3. 精确的设置过期时间</span><br><span class=\"line\">4. 计数器</span><br><span class=\"line\">5. 实时系统， 反垃圾系统</span><br><span class=\"line\">6. pub， sub发布订阅构建实时消息系统</span><br><span class=\"line\">7. 构建消息队列</span><br><span class=\"line\">8. 缓存</span><br><span class=\"line\">cmd访问redis</span><br><span class=\"line\">redis-cli.exe -h 127.0.0.1 -p 6379</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">key</span><br><span class=\"line\">    keys * 获取所有的key</span><br><span class=\"line\">    select 0 选择第一个库</span><br><span class=\"line\">    move myString 1 将当前的数据库key移动到某个数据库,目标库有，则不能移动</span><br><span class=\"line\">    flush db      清除指定库</span><br><span class=\"line\">    randomkey     随机key</span><br><span class=\"line\">    type key      类型</span><br><span class=\"line\"></span><br><span class=\"line\">    set key1 value1 设置key</span><br><span class=\"line\">    get key1    获取key</span><br><span class=\"line\">    mset key1 value1 key2 value2 key3 value3</span><br><span class=\"line\">    mget key1 key2 key3</span><br><span class=\"line\">    del key1   删除key</span><br><span class=\"line\">    exists key      判断是否存在key</span><br><span class=\"line\">    expire key 10   10过期</span><br><span class=\"line\">    pexpire key 1000 毫秒</span><br><span class=\"line\">    persist key     删除过期时间</span><br><span class=\"line\"></span><br><span class=\"line\">string</span><br><span class=\"line\">    set name cxx</span><br><span class=\"line\">    get name</span><br><span class=\"line\">    getrange name 0 -1        字符串分段</span><br><span class=\"line\">    getset name new_cxx       设置值，返回旧值</span><br><span class=\"line\">    mset key1 key2            批量设置</span><br><span class=\"line\">    mget key1 key2            批量获取</span><br><span class=\"line\">    setnx key value           不存在就插入（not exists）</span><br><span class=\"line\">    setex key time value      过期时间（expire）</span><br><span class=\"line\">    setrange key index value  从index开始替换value</span><br><span class=\"line\">    incr age        递增</span><br><span class=\"line\">    incrby age 10   递增</span><br><span class=\"line\">    decr age        递减</span><br><span class=\"line\">    decrby age 10   递减</span><br><span class=\"line\">    incrbyfloat     增减浮点数</span><br><span class=\"line\">    append          追加</span><br><span class=\"line\">    strlen          长度</span><br><span class=\"line\">    getbit/setbit/bitcount/bitop    位操作</span><br><span class=\"line\"></span><br><span class=\"line\">hash</span><br><span class=\"line\">    hset myhash name cxx</span><br><span class=\"line\">    hget myhash name</span><br><span class=\"line\">    hmset myhash name cxx age 25 note &quot;i am notes&quot;</span><br><span class=\"line\">    hmget myhash name age note</span><br><span class=\"line\">    hgetall myhash               获取所有的</span><br><span class=\"line\">    hexists myhash name          是否存在</span><br><span class=\"line\">    hsetnx myhash score 100      设置不存在的</span><br><span class=\"line\">    hincrby myhash id 1          递增</span><br><span class=\"line\">    hdel myhash name             删除</span><br><span class=\"line\">    hkeys myhash                 只取key</span><br><span class=\"line\">    hvals myhash                 只取value</span><br><span class=\"line\">    hlen myhash                  长度</span><br><span class=\"line\"></span><br><span class=\"line\">list</span><br><span class=\"line\">    lpush mylist a b c  左插入</span><br><span class=\"line\">    rpush mylist x y z  右插入</span><br><span class=\"line\">    lrange mylist 0 -1  数据集合</span><br><span class=\"line\">    lpop mylist  弹出元素</span><br><span class=\"line\">    rpop mylist  弹出元素</span><br><span class=\"line\">    llen mylist  长度</span><br><span class=\"line\">    lrem mylist count value  删除</span><br><span class=\"line\">    lindex mylist 2          指定索引的值</span><br><span class=\"line\">    lset mylist 2 n          索引设值</span><br><span class=\"line\">    ltrim mylist 0 4         删除key</span><br><span class=\"line\">    linsert mylist before a  插入</span><br><span class=\"line\">    linsert mylist after a   插入</span><br><span class=\"line\">    rpoplpush list list2     转移列表的数据</span><br><span class=\"line\"></span><br><span class=\"line\">set</span><br><span class=\"line\">    sadd myset redis</span><br><span class=\"line\">    smembers myset       数据集合</span><br><span class=\"line\">    srem myset set1         删除</span><br><span class=\"line\">    sismember myset set1 判断元素是否在集合中</span><br><span class=\"line\">    scard key_name       个数</span><br><span class=\"line\">    sdiff | sinter | sunion 操作：集合间运算：差集 | 交集 | 并集</span><br><span class=\"line\">    srandmember          随机获取集合中的元素</span><br><span class=\"line\">    spop                 从集合中弹出一个元素</span><br><span class=\"line\"></span><br><span class=\"line\">zset</span><br><span class=\"line\">    zadd zset 1 one</span><br><span class=\"line\">    zadd zset 2 two</span><br><span class=\"line\">    zadd zset 3 three</span><br><span class=\"line\">    zincrby zset 1 one              增长分数</span><br><span class=\"line\">    zscore zset two                 获取分数</span><br><span class=\"line\">    zrange zset 0 -1 withscores     范围值</span><br><span class=\"line\">    zrangebyscore zset 10 25 withscores 指定范围的值</span><br><span class=\"line\">    zrangebyscore zset 10 25 withscores limit 1 2 分页</span><br><span class=\"line\">    Zrevrangebyscore zset 10 25 withscores  指定范围的值</span><br><span class=\"line\">    zcard zset  元素数量</span><br><span class=\"line\">    Zcount zset 获得指定分数范围内的元素个数</span><br><span class=\"line\">    Zrem zset one two        删除一个或多个元素</span><br><span class=\"line\">    Zremrangebyrank zset 0 1  按照排名范围删除元素</span><br><span class=\"line\">    Zremrangebyscore zset 0 1 按照分数范围删除元素</span><br><span class=\"line\">    Zrank zset 0 -1    分数最小的元素排名为0</span><br><span class=\"line\">    Zrevrank zset 0 -1  分数最大的元素排名为0</span><br><span class=\"line\">    Zinterstore</span><br><span class=\"line\">    zunionstore rank:last_week 7 rank:20150323 rank:20150324 rank:20150325  weights 1 1 1 1 1 1 1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">排序：</span><br><span class=\"line\">    sort mylist  排序</span><br><span class=\"line\">    sort mylist alpha desc limit 0 2 字母排序</span><br><span class=\"line\">    sort list by it:* desc           by命令</span><br><span class=\"line\">    sort list by it:* desc get it:*  get参数</span><br><span class=\"line\">    sort list by it:* desc get it:* store sorc:result  sort命令之store参数：表示把sort查询的结果集保存起来</span><br><span class=\"line\"></span><br><span class=\"line\">订阅与发布：</span><br><span class=\"line\">    订阅频道：subscribe chat1</span><br><span class=\"line\">    发布消息：publish chat1 &quot;hell0 ni hao&quot;</span><br><span class=\"line\">    查看频道：pubsub channels</span><br><span class=\"line\">    查看某个频道的订阅者数量: pubsub numsub chat1</span><br><span class=\"line\">    退订指定频道： unsubscrible chat1   , punsubscribe java.*</span><br><span class=\"line\">    订阅一组频道： psubscribe java.*</span><br><span class=\"line\"></span><br><span class=\"line\">redis事务：</span><br><span class=\"line\">     隔离性，原子性，</span><br><span class=\"line\">     步骤：  开始事务，执行命令，提交事务</span><br><span class=\"line\">             multi  //开启事务</span><br><span class=\"line\">             sadd myset a b c</span><br><span class=\"line\">             sadd myset e f g</span><br><span class=\"line\">             lpush mylist aa bb cc</span><br><span class=\"line\">             lpush mylist dd ff gg</span><br><span class=\"line\"></span><br><span class=\"line\">服务器管理</span><br><span class=\"line\">    dump.rdb</span><br><span class=\"line\">    appendonly.aof</span><br><span class=\"line\">    //BgRewriteAof 异步执行一个aop(appendOnly file)文件重写</span><br><span class=\"line\">    会创建当前一个AOF文件体积的优化版本</span><br><span class=\"line\"></span><br><span class=\"line\">    //BgSave 后台异步保存数据到磁盘，会在当前目录下创建文件dump.rdb</span><br><span class=\"line\">    //save同步保存数据到磁盘，会阻塞主进程，别的客户端无法连接</span><br><span class=\"line\"></span><br><span class=\"line\">    //client kill 关闭客户端连接</span><br><span class=\"line\">    //client list 列出所有的客户端</span><br><span class=\"line\"></span><br><span class=\"line\">    //给客户端设置一个名称</span><br><span class=\"line\">      client setname myclient1</span><br><span class=\"line\">      client getname</span><br><span class=\"line\"></span><br><span class=\"line\">     config get port</span><br><span class=\"line\">     //configRewrite 对redis的配置文件进行改写rdb save 900 1save 300 10save 60 10000aop备份处理appendonly yes    开启持久化appendfsync everysec  每秒备份一次命令：bgsave异步保存数据到磁盘（快照保存）lastsave返回上次成功保存到磁盘的unix的时间戳shutdown同步保存到服务器并关闭redis服务器bgrewriteaof文件压缩处理（命令）</span><br></pre></td></tr></table></figure>\n","categories":["常用指令合集"],"tags":["javascript"]},{"title":"try-catch 能抛出 promise 的异常吗","url":"/2022/10/24/try-catch-%E8%83%BD%E6%8A%9B%E5%87%BA-promise-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%90%97/","content":"<h2 id=\"try-catch-能抛出-promise-的异常吗？\"><a href=\"#try-catch-能抛出-promise-的异常吗？\" class=\"headerlink\" title=\"try-catch 能抛出 promise 的异常吗？\"></a>try-catch 能抛出 promise 的异常吗？</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">\tthrow new Error(&#x27;1&#x27;)</span><br><span class=\"line\">&#125; catch(error) &#123;</span><br><span class=\"line\">\tconsole.log(error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是最常见的 try-catch，会 log 下面的内容：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1Lmx1b3R1eGl1LmNuL2ltZy8yMDIwMDcxMjEwMzkxOS5wbmc?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>注意，这里并不是红色的，因为 js 异常被捕获后，js 是能够正常往下执行的，如果没有被捕获的话，那么 js 将抛出异常，js 执行将会停止！</p>\n<p>例子:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 异步，宏任务</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">\tsetTimeout(function() &#123;</span><br><span class=\"line\">\t\tconsole.log(b);</span><br><span class=\"line\">\t&#125;, 0);</span><br><span class=\"line\">&#125; catch (error) &#123;</span><br><span class=\"line\">\tconsole.log(error); // 这里是不会执行的</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&#x27;out try catch&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1Lmx1b3R1eGl1LmNuL2ltZy8yMDIwMDcxMjA5NTY0OS5wbmc?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>此时 js 会抛出异常，catch 后面的代码都不会执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 异步，微任务</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">\tnew Promise(() =&gt; &#123;</span><br><span class=\"line\">\t\tthrow new Error(&#x27;new promise throw error&#x27;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125; catch (error) &#123;</span><br><span class=\"line\">\tconsole.log(error);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1Lmx1b3R1eGl1LmNuL2ltZy8yMDIwMDcxMjEwMzQ1MS5wbmc?x-oss-process=image/format,png\" alt=\"image\"></p>\n<h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>try-catch 主要用于捕获异常，注意，这里的异常，是指同步函数的异常，如果 try 里面的异步方法出现了异常，此时<strong>catch 是无法捕获到异常的</strong>，原因是因为：当异步函数抛出异常时，对于宏任务而言，执行函数时已经将该函数推入栈，此时并不在 try-catch 所在的栈，所以 try-catch 并不能捕获到错误。对于微任务而言，比如 promise，promise 的构造函数的异常只能被自带的 reject 也就是.catch 函数捕获到。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"对于同步函数\"><a href=\"#对于同步函数\" class=\"headerlink\" title=\"对于同步函数\"></a>对于同步函数</h3><p>放心用 try-catch 即可</p>\n<h3 id=\"对于异步函数-宏任务\"><a href=\"#对于异步函数-宏任务\" class=\"headerlink\" title=\"对于异步函数-宏任务\"></a>对于异步函数-宏任务</h3><p>window 有全局的错误捕获函数 onerror</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">\tsetTimeout(function() &#123;</span><br><span class=\"line\">\t\tconsole.log(b);</span><br><span class=\"line\">\t&#125;, 0);</span><br><span class=\"line\">&#125; catch (error) &#123;</span><br><span class=\"line\">\tconsole.log(error); // 这里是不会执行的</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.onerror = function() &#123;</span><br><span class=\"line\">\tconsole.log(...arguments)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时，是可以捕获到比如 setTimeout 的回调函数异常的，这里可以针对全局的异常做一些处理，比如数据上报等</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1Lmx1b3R1eGl1LmNuL2ltZy8yMDIwMDcxMjEwNTA1MS5wbmc?x-oss-process=image/format,png\" alt=\"image\"></p>\n<h2 id=\"对于异步函数-微任务\"><a href=\"#对于异步函数-微任务\" class=\"headerlink\" title=\"对于异步函数-微任务\"></a>对于异步函数-微任务</h2><p>对于微任务，js 有专门捕获没有写 catch 的 promise，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&#x27;unhandledrejection&#x27;, function() &#123;</span><br><span class=\"line\">\tconsole.log(...arguments)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>执行结果如下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1Lmx1b3R1eGl1LmNuL2ltZy8yMDIwMDcxMjExMzM1NC5wbmc?x-oss-process=image/format,png\" alt=\"image\"></p>\n<h2 id=\"更多知识点\"><a href=\"#更多知识点\" class=\"headerlink\" title=\"更多知识点\"></a>更多知识点</h2><p>try-catch 中的异常只会抛出一层，即不会冒泡，也就是如果你有多层的 try-catch 然后异常已经被内层的 catch 捕获了，外层的 catch 是捕获不到异常的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    throw new Error(&#x27;oops&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  catch (ex) &#123;</span><br><span class=\"line\">    console.error(&#x27;inner&#x27;, ex.message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  finally &#123;</span><br><span class=\"line\">    console.log(&#x27;finally&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">catch (ex) &#123;</span><br><span class=\"line\">  console.error(&#x27;outer&#x27;, ex.message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Output:</span><br><span class=\"line\">// &quot;inner&quot; &quot;oops&quot;</span><br><span class=\"line\">// &quot;finally&quot;</span><br></pre></td></tr></table></figure>\n\n<p>解决方案是可以在内层的 catch 再手动 throw 出异常</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"ts中泛型、泛型方法、泛型类、泛型接口","url":"/2022/10/24/ts%E4%B8%AD%E6%B3%9B%E5%9E%8B%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/","content":"<p>什么是泛型呢？我们可以理解为泛型就是在编译期间不确定方法的类型(广泛之意思)，在方法调用时，由程序员指定泛型具体指向什么类型。泛型在传统面向对象编程语言中是极为常见的，ts 中当然也执行泛型，如果你理解 c#或 java 中的泛型，相信本篇理解起来会很容易。</p>\n<h2 id=\"泛型函数、泛型类、泛型接口。\"><a href=\"#泛型函数、泛型类、泛型接口。\" class=\"headerlink\" title=\"泛型函数、泛型类、泛型接口。\"></a>泛型函数、泛型类、泛型接口。</h2><p><strong>generic.ts</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * ts中泛型</span><br><span class=\"line\"> *    泛型就是在编译期间不确定方法的类型(广泛之意思)，在方法调用时，由程序员指定泛型具体指向什么类型</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">//1 泛型函数</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 获取数组中最小值 （数字）</span><br><span class=\"line\"> * @param &#123;number[]&#125; arr</span><br><span class=\"line\"> * @returns &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">function  getMinNumber(arr:number[]):number&#123;</span><br><span class=\"line\">    var min=arr[0];</span><br><span class=\"line\">    arr.forEach((value)=&gt;&#123;</span><br><span class=\"line\">        if(value&lt;min)&#123;</span><br><span class=\"line\">            min=value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 获取数组中最小值 （字符串）</span><br><span class=\"line\"> * @param &#123;number[]&#125; arr</span><br><span class=\"line\"> * @returns &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">function  getMinStr(arr:string[]):string&#123;</span><br><span class=\"line\">    var min=arr[0];</span><br><span class=\"line\">    arr.forEach((value)=&gt;&#123;</span><br><span class=\"line\">        if(value&lt;min)&#123;</span><br><span class=\"line\">            min=value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(getMinNumber([1, 3, 5, 7, 8]));//1</span><br><span class=\"line\">console.log(getMinStr([&quot;tom&quot;,&quot;jerry&quot;,&quot;jack&quot;,&quot;sunny&quot;]));//jack</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 获取数组中最小值 (T泛型通用)</span><br><span class=\"line\"> * @param &#123;T[]&#125; arr</span><br><span class=\"line\"> * @returns &#123;T&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">function getMin&lt;T&gt;(arr:T[]):T&#123;</span><br><span class=\"line\">   var min=arr[0];</span><br><span class=\"line\">   arr.forEach((value)=&gt;&#123;</span><br><span class=\"line\">      if(value&lt;min)&#123;</span><br><span class=\"line\">          min=value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">    return min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(getMin([1, 3, 5, 7, 8]));</span><br><span class=\"line\">console.log(getMin([&quot;tom&quot;,&quot;jerry&quot;,&quot;jack&quot;,&quot;sunny&quot;]));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//2 泛型类</span><br><span class=\"line\">class GetMin&lt;T&gt;&#123;</span><br><span class=\"line\">     arr:T[]=[];</span><br><span class=\"line\">     add(ele:T)&#123;</span><br><span class=\"line\">         this.arr.push(ele);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    min():T&#123;</span><br><span class=\"line\">       var min=this.arr[0];</span><br><span class=\"line\">       this.arr.forEach(function (value) &#123;</span><br><span class=\"line\">          if(value&lt;min)&#123;</span><br><span class=\"line\">              min=value;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">       return min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  var gm1= new  GetMin&lt;number&gt;();</span><br><span class=\"line\">   gm1.add(5);</span><br><span class=\"line\">   gm1.add(3);</span><br><span class=\"line\">   gm1.add(2);</span><br><span class=\"line\">   gm1.add(9);</span><br><span class=\"line\">console.log(gm1.min());</span><br><span class=\"line\"></span><br><span class=\"line\">var gm2= new  GetMin&lt;string&gt;();</span><br><span class=\"line\">gm2.add(&quot;tom&quot;);</span><br><span class=\"line\">gm2.add(&quot;jerry&quot;);</span><br><span class=\"line\">gm2.add(&quot;jack&quot;);</span><br><span class=\"line\">gm2.add(&quot;sunny&quot;);</span><br><span class=\"line\">console.log(gm2.min());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 3 泛型函数接口</span><br><span class=\"line\"> */</span><br><span class=\"line\">interface ConfigFn&#123;</span><br><span class=\"line\">    &lt;T&gt;(value:T):T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var getData:ConfigFn=function&lt;T&gt;(value:T):T&#123;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getData&lt;string&gt;(&#x27;张三&#x27;);</span><br><span class=\"line\">// getData&lt;string&gt;(1243);  //错误</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 类似  Map&lt;String,Object&gt; Param  接口</span><br><span class=\"line\">interface Param&#123;</span><br><span class=\"line\">    [index:string]:any</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//4 泛型类接口</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * page分页对象</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Page&#123;</span><br><span class=\"line\">    private currentPage:number=1; //当前页码 默认1</span><br><span class=\"line\">    private pageSize:number=10;//每页条数 默认为10</span><br><span class=\"line\">    private sortName:string; //排序字段</span><br><span class=\"line\">    private sortOrder:string=&quot;asc&quot;; // 排序规则 asc | desc 默认为asc正序</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     constructor(param:Param)&#123;</span><br><span class=\"line\">         if(param[&quot;currentPage&quot;])&#123;</span><br><span class=\"line\">             this.currentPage=param[&quot;currentPage&quot;];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         if(param[&quot;pageSize&quot;])&#123;</span><br><span class=\"line\">             this.pageSize=param[&quot;pageSize&quot;];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         if(param[&quot;sortName&quot;])&#123;</span><br><span class=\"line\">             this.sortName=param[&quot;sortName&quot;];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         if(param[&quot;sortOrder&quot;])&#123;</span><br><span class=\"line\">             this.sortOrder=param[&quot;sortOrder&quot;];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public    getStartNum():number&#123;</span><br><span class=\"line\">        return   (this.currentPage-1)*this.pageSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class User&#123;</span><br><span class=\"line\">     id:number;//id主键自增</span><br><span class=\"line\">     name:string;//姓名</span><br><span class=\"line\">     sex:number;//性别 1男 2女</span><br><span class=\"line\">     age:number;//年龄</span><br><span class=\"line\">     city:string;//城市</span><br><span class=\"line\">     describe:string;//描述</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//泛型接口</span><br><span class=\"line\">interface  BaseDao&lt;T&gt; &#123;</span><br><span class=\"line\">     findById(id:number):T;//根据主键id查询一个实体</span><br><span class=\"line\">     findPageList(param:Param,page:Page):T[];//查询分页列表</span><br><span class=\"line\">     findPageCount(param:Param):number;//查询分页count</span><br><span class=\"line\">     save(o:T):void;//保存一个实体</span><br><span class=\"line\">     update(o:T):void;//更新一个实体</span><br><span class=\"line\">     deleteById(id:number);//删除一个实体</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 接口实现类</span><br><span class=\"line\"> */</span><br><span class=\"line\">class UserDao&lt;User&gt; implements BaseDao&lt;User&gt;&#123;</span><br><span class=\"line\">     findById(id:number):User&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return null;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    findPageList(param:Param,page:Page):User[]&#123;</span><br><span class=\"line\">         return [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    findPageCount(param:Param):number&#123;</span><br><span class=\"line\">         return   0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    save(o:User):void&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update(o:User):void&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    deleteById(id:number)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"web worker的介绍和使用","url":"/2022/10/24/web-worker%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>什么是 web worker 呢？从名字上就可以看出，web worker 就是在 web 应用程序中使用的 worker。这个 worker 是独立于 web 主线程的，在后台运行的线程。</p>\n<p>web worker 的优点就是可以将工作交给独立的其他线程去做，这样就不会阻塞主线程。</p>\n<h2 id=\"Web-Workers-的基本概念和使用\"><a href=\"#Web-Workers-的基本概念和使用\" class=\"headerlink\" title=\"Web Workers 的基本概念和使用\"></a>Web Workers 的基本概念和使用</h2><p>web workers 是通过使用 Worker(）来创建的。</p>\n<p>Worker 可以指定后台执行的脚本，并在脚本执行完毕之后通常 creator。</p>\n<p>worker 有一个构造函数如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Worker(&quot;path/to/worker/script&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>我们传入要执行脚本的路径，即可创建 worker。</p>\n<p>Workers 中也可以创建新的 Workers,前提是这些 worker 都是同一个 origin。</p>\n<p>我们看一下 worker 的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Worker extends EventTarget, AbstractWorker &#123;</span><br><span class=\"line\">    onmessage: ((this: Worker, ev: MessageEvent) =&gt; any) | null;</span><br><span class=\"line\">    onmessageerror: ((this: Worker, ev: MessageEvent) =&gt; any) | null;</span><br><span class=\"line\"></span><br><span class=\"line\">    postMessage(message: any, transfer: Transferable[]): void;</span><br><span class=\"line\">    postMessage(message: any, options?: PostMessageOptions): void;</span><br><span class=\"line\"></span><br><span class=\"line\">    terminate(): void;</span><br><span class=\"line\">    addEventListener&lt;K extends keyof WorkerEventMap&gt;(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) =&gt; any, options?: boolean | AddEventListenerOptions): void;</span><br><span class=\"line\">    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;</span><br><span class=\"line\">    removeEventListener&lt;K extends keyof WorkerEventMap&gt;(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) =&gt; any, options?: boolean | EventListenerOptions): void;</span><br><span class=\"line\">    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">declare var Worker: &#123;</span><br><span class=\"line\">    prototype: Worker;</span><br><span class=\"line\">    new(stringUrl: string | URL, options?: WorkerOptions): Worker;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 Worker 的构造函数可以传入两个参数，第一个参数可以是 string 也可以是 URL，表示要执行的脚本路径。</p>\n<p>第二个参数是 WorkerOptions 选项，表示 worker 的类型，名字和权限相关的选项。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface WorkerOptions &#123;</span><br><span class=\"line\">    credentials?: RequestCredentials;</span><br><span class=\"line\">    name?: string;</span><br><span class=\"line\">    type?: WorkerType;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，worker 可以监听 onmessage 和 onmessageerror 两个事件。</p>\n<p>提供了两个方法：postMessage 和 terminate。</p>\n<p>worker 和主线程都可以通过 postMessage 来给对方发送消息，也可以用 onmessage 来接收对方发送的消息。</p>\n<p>还可以添加和移除 EventListener。</p>\n<p>我们看一个使用 worker 的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const first = document.querySelector(&#x27;#number1&#x27;);</span><br><span class=\"line\">const second = document.querySelector(&#x27;#number2&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">const result = document.querySelector(&#x27;.result&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">if (window.Worker) &#123;</span><br><span class=\"line\">\tconst myWorker = new Worker(&quot;worker.js&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfirst.onchange = function() &#123;</span><br><span class=\"line\">\t  myWorker.postMessage([first.value, second.value]);</span><br><span class=\"line\">\t  console.log(&#x27;Message posted to worker&#x27;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsecond.onchange = function() &#123;</span><br><span class=\"line\">\t  myWorker.postMessage([first.value, second.value]);</span><br><span class=\"line\">\t  console.log(&#x27;Message posted to worker&#x27;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmyWorker.onmessage = function(e) &#123;</span><br><span class=\"line\">\t\tresult.textContent = e.data;</span><br><span class=\"line\">\t\tconsole.log(&#x27;Message received from worker&#x27;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;Your browser doesn\\&#x27;t support web workers.&#x27;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子创建了一个 woker，并向 worker post 了一个消息。</p>\n<p>再看一下 worker.js 的内容是怎么样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">onmessage = function(e) &#123;</span><br><span class=\"line\">  console.log(&#x27;Worker: Message received from main script&#x27;);</span><br><span class=\"line\">  const result = e.data[0] * e.data[1];</span><br><span class=\"line\">  if (isNaN(result)) &#123;</span><br><span class=\"line\">    postMessage(&#x27;Please write two numbers&#x27;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    const workerResult = &#x27;Result: &#x27; + result;</span><br><span class=\"line\">    console.log(&#x27;Worker: Posting message back to main script&#x27;);</span><br><span class=\"line\">    postMessage(workerResult);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在主线程中向 worker postmessage，在 worker 中通过 onmessage 监听消息，然后又在 worker 中 post message，可以在 main 线程中通过 onmessage 来监听 woker 发送的消息。</p>\n<p>这样就做到了一次完美的交互。</p>\n<p>再看一下 worker 的兼容性：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201006122512486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_25,color_8F8F8F,t_70\" alt=\"image\"></p>\n<p>可以看到，基本上所有的浏览器都支持 worker，不过有些浏览器只支持部分的方法。</p>\n<p>如果想要立马结束一个 worker，我们可以使用 terminate：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">myWorker.terminate();</span><br></pre></td></tr></table></figure>\n\n<p>要想处理 worker 的异常，可以使用 onerror 来处理异常。</p>\n<p>如果 worker 的 script 比较复杂，需要用到其他的 script 文件，我们可以使用 importScripts 来导入其他的脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">importScripts();                         /* imports nothing */</span><br><span class=\"line\">importScripts(&#x27;foo.js&#x27;);                 /* imports just &quot;foo.js&quot; */</span><br><span class=\"line\">importScripts(&#x27;foo.js&#x27;, &#x27;bar.js&#x27;);       /* imports two scripts */</span><br><span class=\"line\">importScripts(&#x27;//example.com/hello.js&#x27;); /* You can import scripts from other origins */</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Web-Workers-的分类\"><a href=\"#Web-Workers-的分类\" class=\"headerlink\" title=\"Web Workers 的分类\"></a>Web Workers 的分类</h2><p>Web Workers 根据工作环境的不同，可以分为 DedicatedWorker 和 SharedWorker 两种。</p>\n<p>DedicatedWorker 的 Worker 只能从创建该 Woker 的脚本中访问，而 SharedWorker 则可以被多个脚本所访问。</p>\n<p>上面的例子中我们创建的 worker 就是 DedicatedWorker。</p>\n<p>怎么创建 sharedWorker 呢?</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var myWorker = new SharedWorker(&#x27;worker.js&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>SharedWorker 有一个单独的 SharedWorker 类，和 dedicated worker 不同的是 SharedWorker 是通过 port 对象来进行交互的。</p>\n<p>我们看一个 shared worker 的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var first = document.querySelector(&#x27;#number1&#x27;);</span><br><span class=\"line\">var second = document.querySelector(&#x27;#number2&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">var result1 = document.querySelector(&#x27;.result1&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">if (!!window.SharedWorker) &#123;</span><br><span class=\"line\">  var myWorker = new SharedWorker(&quot;worker.js&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  first.onchange = function() &#123;</span><br><span class=\"line\">    myWorker.port.postMessage([first.value, second.value]);</span><br><span class=\"line\">    console.log(&#x27;Message posted to worker&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  second.onchange = function() &#123;</span><br><span class=\"line\">    myWorker.port.postMessage([first.value, second.value]);</span><br><span class=\"line\">    console.log(&#x27;Message posted to worker&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  myWorker.port.onmessage = function(e) &#123;</span><br><span class=\"line\">    result1.textContent = e.data;</span><br><span class=\"line\">    console.log(&#x27;Message received from worker&#x27;);</span><br><span class=\"line\">    console.log(e.lastEventId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有的 postMessage 和 onmessage 都是基于 myWorker.port 来的。</p>\n<p>再看一下 worker 的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">onconnect = function(e) &#123;</span><br><span class=\"line\">  var port = e.ports[0];</span><br><span class=\"line\"></span><br><span class=\"line\">  port.onmessage = function(e) &#123;</span><br><span class=\"line\">    var workerResult = &#x27;Result: &#x27; + (e.data[0] * e.data[1]);</span><br><span class=\"line\">    port.postMessage(workerResult);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>worker 也是通过 port 来进行通信。</p>\n<p>这里我们使用了 onconnect 用来监听父线程的 onmessage 事件或者 start 事件，这两种事件都可以启动一个 SharedWorker。</p>\n<p>再看一下 sharedWorker 的浏览器兼容性：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201006234340881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_25,color_8F8F8F,t_70\" alt=\"image\"></p>\n<p>可以看到，比 worker 的兼容性要低很多，只有部分浏览器才支持这个高级特性。</p>\n<h2 id=\"worker-和-main-thread-之间的数据传输\"><a href=\"#worker-和-main-thread-之间的数据传输\" class=\"headerlink\" title=\"worker 和 main thread 之间的数据传输\"></a>worker 和 main thread 之间的数据传输</h2><p>我们知道 worker 和 main thread 之间是通过 postMessage 和 onMessage 进行交互的。这里面涉及到了数据传输的问题。</p>\n<p>实际上数据在 worker 和 main thread 之间是以拷贝的方式并且是以序列化的形式进行传输的。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"webGL-three.js入门笔记","url":"/2022/12/16/webGL-three-js%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","content":"<p><img src=\"https://upload-images.jianshu.io/upload_images/4923775-9126a81a4cf5c49c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/614/format/webp\" alt=\"image\"></p>\n<p>webGL 的 3D 世界主要由三大要素构成：场景（scene）、相机（camera）和渲染器（renderer），三者缺一不可。渲染的原理是：我们将创建的物体，添加到场景中，再通过相机（可以理解为人的视角）渲染到渲染器，从而呈现在网页中。three.js 是 webGL 一款比较热门的类库，本文以”three.js”: “^0.77.1”为例，通过网上教程和自身实践整理成这篇笔记。</p>\n<h2 id=\"1-场景-scene\"><a href=\"#1-场景-scene\" class=\"headerlink\" title=\"1.场景(scene)\"></a>1.场景(scene)</h2><p>场景就是所有物体的容器，只需创建一个。假设我们要显示一个苹果，那么就将苹果加入到场景中即可，多个物体可加入到一个场景。<br>构造函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var scene = new THREE.Scene();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-相机-camera\"><a href=\"#2-相机-camera\" class=\"headerlink\" title=\"2.相机(camera)\"></a>2.相机(camera)</h2><p>相机决定了场景中哪个角度的景色会显示出来，就像人的视角，分为正投影相机(THREE.OrthographicCamera)和透视投影相机(THREE.PerspectiveCamera)，正投影和透视投影的区别是：透视投影有一个基本点，就是远处的物体比近处的物体小，一般我们采用透视投影相机的情况比较多。<br>构造函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//正投影相机</span><br><span class=\"line\">var camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);</span><br><span class=\"line\">//参数详解：</span><br><span class=\"line\">//left：左平面距离相机中心点的垂直距离</span><br><span class=\"line\">//right：右平面距离相机中心点的垂直距离</span><br><span class=\"line\">//top：顶平面距离相机中心点的垂直距离</span><br><span class=\"line\">//bottom：底平面距离相机中心点的垂直距离</span><br><span class=\"line\">//near：近平面距离相机中心点的垂直距离</span><br><span class=\"line\">//far：远平面距离相机中心点的垂直距离</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//透视投影相机</span><br><span class=\"line\">var camera = new THREE.PerspectiveCamera(fov, aspect, near, far)</span><br><span class=\"line\">//参数详解：</span><br><span class=\"line\">//视角fov：可以理解为视角的大小，如果设置为0，相当于没有了视角，什么也看不到；如果为180，那么可以认为你的视界很广阔，但在180度的时候，往往物体很小，因为物体在你整个可视区域中的比例变小了</span><br><span class=\"line\">//近平面near：表示近处的裁面的距离，也可以认为是眼睛到近处的距离，不能为负数</span><br><span class=\"line\">//远平面far：表示远处的裁面的距离</span><br><span class=\"line\">//纵横比aspect：实际窗口的纵横比，即宽度除以高度，这个值越大，说明宽度越大</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-渲染器-renderer\"><a href=\"#3-渲染器-renderer\" class=\"headerlink\" title=\"3.渲染器(renderer)\"></a>3.渲染器(renderer)</h2><p>渲染器决定了渲染结果应挂接在页面的什么元素上，并以怎样的方式绘制。<br>构造函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var renderer = new THREE.WebGLRenderer();</span><br><span class=\"line\">renderer.setSize(window.innerWidth, window.innerHeight);//设置渲染区域大小</span><br><span class=\"line\">document.body.appendChild(renderer, domElement);//渲染在domElement并挂接到body下</span><br><span class=\"line\">renderer.render(scene, camera); //将场景通过相机视角渲染出来</span><br></pre></td></tr></table></figure>\n\n<p>如果要让物体动起来，那么我们可以利用循环渲染：requestAnimationFrame</p>\n<h2 id=\"4-光源\"><a href=\"#4-光源\" class=\"headerlink\" title=\"4.光源\"></a>4.光源</h2><p>光是我们看见物体的关键，用 Light 表示，是所有光源的基类，底下还有很多分类，我举几个最常用的：</p>\n<p>环境光：环境光是经过多次反射惹来的光，无法确定其最初的方向，是一种无处不在的光。环境光源放出的光线被认为来自任何方向。因此，当你仅为场景设定环境光时，所有的物体无论法向量如何，都将表现为同样的明暗程度。<br>构造函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">THREE.AmbientLight(hex); //hex为一个16进制的颜色值</span><br></pre></td></tr></table></figure>\n\n<p>平行光：是一组没有衰减的平行的光线，类似太阳光的效果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">THREE.DirectionalLight(hex, intensity)</span><br></pre></td></tr></table></figure>\n\n<p>点光源：由这种光源放出的光线来自同一点，且方向辐射自四面八方</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">THREE.PointLight(color, intensity, distance)；</span><br><span class=\"line\">//color代表光的颜色</span><br><span class=\"line\">//intensity：代表光的强度，默认1.0，表示100%强度的灯光</span><br><span class=\"line\">//distance：代表光的距离，从光源所在的位置，经过distance这段距离之后，光的强度将从Intensity衰减为0，默认0.0，表示光源强度不衰减</span><br></pre></td></tr></table></figure>\n\n<p>聚光灯：这种光源的光线从一个椎体中射出，在被照射的物体上产生聚光的效果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">THREE.SpotLight(hex, intensity, distance, angle, exponent)</span><br><span class=\"line\">//angle：聚光灯着色的角度，用弧度作为单位，这个角度是和光源的方向形成的角度</span><br><span class=\"line\">//exponent：光源模型中，衰减的一个参数，越大衰减越快</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-物体\"><a href=\"#5-物体\" class=\"headerlink\" title=\"5.物体\"></a>5.物体</h2><p>创建一个物体可以包含多种元素，几何体，材质，纹理等，创建一个小球的简单示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let geometry =new THREE.SphereGeometry(3, 16, 16);   //球体</span><br><span class=\"line\">let material = new THREE.MeshPhongMaterial(&#123;color:0x48D1CC,specular:0xffffff,shininess:100&#125;);     //材质</span><br><span class=\"line\">var ball = new THREE.Mesh(geometry, material); //两者共同组成一个球体</span><br><span class=\"line\">scene.add(ball); //将球体添加至场景中</span><br></pre></td></tr></table></figure>\n\n<p>关于几何体，材质等种类非常多，具体可以参考[three.js 源码]：<a href=\"https://github.com/mrdoob/three.js/\">https://github.com/mrdoob/three.js/</a></p>\n<h2 id=\"6-动画\"><a href=\"#6-动画\" class=\"headerlink\" title=\"6.动画\"></a>6.动画</h2><p>总结上述步骤：</p>\n<blockquote>\n<ul>\n<li>创建场景、相机、渲染器</li>\n<li>创建光源</li>\n<li>创建物体并添加至场景中</li>\n<li>渲染出场景</li>\n</ul>\n</blockquote>\n<p>这样就构成了一个完整的但也是最基础的流程，网页中能看到我们创造的物体，接下来说到动画，3D 世界中的运动方式总结为三种：移动，旋转和缩放。<br>运动是相对的，场景动起来有两种方式：</p>\n<h3 id=\"1-物体在坐标系中移动，相机不动\"><a href=\"#1-物体在坐标系中移动，相机不动\" class=\"headerlink\" title=\"1). 物体在坐标系中移动，相机不动\"></a>1). 物体在坐标系中移动，相机不动</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function animate()&#123;</span><br><span class=\"line\">  ball.position.x += 1;</span><br><span class=\"line\">  renderer.render(scene, camera);</span><br><span class=\"line\">  requestAnimationFrame(animation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-相机在坐标系中移动，物体不动\"><a href=\"#2-相机在坐标系中移动，物体不动\" class=\"headerlink\" title=\"2). 相机在坐标系中移动，物体不动\"></a>2). 相机在坐标系中移动，物体不动</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function animate()&#123;</span><br><span class=\"line\">  camera.position.x += 1;</span><br><span class=\"line\">  renderer.render(scene, camera);</span><br><span class=\"line\">  requestAnimationFrame(animation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>[demo 展示中心]：<a href=\"https://yomonah.github.io/project/app.html#/webGL-icosahedron\">https://yomonah.github.io/project/app.html#/webGL-icosahedron</a></li>\n<li>[源码]：<a href=\"https://github.com/yomonah/react-demo/tree/master/src/components/webGL_ball\">https://github.com/yomonah/react-demo/tree/master/src/components/webGL_ball</a></li>\n</ul>\n","categories":["webGL总结"],"tags":["webGL"]},{"title":"webpack用法小结","url":"/2022/12/16/webpack%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/","content":"<h2 id=\"1、webpack-是什么\"><a href=\"#1、webpack-是什么\" class=\"headerlink\" title=\"1、webpack 是什么\"></a>1、webpack 是什么</h2><p>根据文档的定义：本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>\n<h2 id=\"2、webpack-四个核心概念\"><a href=\"#2、webpack-四个核心概念\" class=\"headerlink\" title=\"2、webpack 四个核心概念\"></a>2、webpack 四个核心概念</h2><ul>\n<li>入口(entry) 入口，webpack 执行构建的第一步将从 Entry 开始，可抽象成输入</li>\n<li>输出(output) 输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果</li>\n<li>加载器(loader) 模块转换器，用于把模块原内容按照需求转换成新内容。</li>\n<li>插件(plugins) 扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。</li>\n</ul>\n<h3 id=\"2-1entry\"><a href=\"#2-1entry\" class=\"headerlink\" title=\"2.1entry\"></a>2.1entry</h3><ul>\n<li>定义的三种方法</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">第一种用法</span><br><span class=\"line\">    module.exports = &#123;</span><br><span class=\"line\">        entry:&#x27;index.js&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">第二种用法</span><br><span class=\"line\">    module.exports = &#123;</span><br><span class=\"line\">        entry:[&#x27;index.js&#x27;,&#x27;b.js&#x27;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">第三种用法</span><br><span class=\"line\">    module.exports = &#123;</span><br><span class=\"line\">        entry:&#123;</span><br><span class=\"line\">          index:&#x27;index.js&#x27;,</span><br><span class=\"line\">          b:&#x27;b.js&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>推荐使用使用第三种方法，方便分清各个入口的定义</p>\n<h3 id=\"2-2output\"><a href=\"#2-2output\" class=\"headerlink\" title=\"2.2output\"></a>2.2output</h3><ul>\n<li>打包成的文件</li>\n<li>一个或多个</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"> entry:&#123;</span><br><span class=\"line\"> index:&#x27;index.js&#x27;,</span><br><span class=\"line\"> b:&#x27;b.js&#x27;</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> output:&#123;</span><br><span class=\"line\">     path:path.resolve(__dirname,&#x27;dist&#x27;),</span><br><span class=\"line\">     filename:&#x27;[name].min.[hash:5].js&#x27;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中，</p>\n<ul>\n<li>output 中的 name 和 entry 中的 key 相对应</li>\n<li>output 的 filename 可以指定 hash。有两个值可以选择：<ul>\n<li>[hash]：hash 值是特定于整个构建过程的。</li>\n<li>[chunkhash]：hash 值是特定于每一个文件的内容的。<br>我们理想的缓存设计是，在一次版本更新(重新构建)后，只有当一个文件的内容确实发生了变化，它才需要被重新下载，否则应使用缓存。<br>因此，以上两个值中更推荐的是[chunkhash]。你也可以阅读这篇官方的缓存指南了解更多细节。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3loader\"><a href=\"#2-3loader\" class=\"headerlink\" title=\"2.3loader\"></a>2.3loader</h3><ul>\n<li>作用： 通过使用不同的 Loader，Webpack 可以要把不同的文件都转成 JS 文件,比如 CSS、ES6&#x2F;7、JSX 等</li>\n<li>参数<ul>\n<li>test：匹配处理文件的扩展名的正则表达式</li>\n<li>use：loader 名称，就是你要使用模块的名称</li>\n<li>include&#x2F;exclude:手动指定必须处理的文件夹或屏蔽不需要处理的文件夹</li>\n<li>query：为 loaders 提供额外的设置选项<br>下面以 css-loader 为例</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    module: &#123;</span><br><span class=\"line\">+        rules:[</span><br><span class=\"line\">+            &#123;</span><br><span class=\"line\">+                test:/\\.css$/,</span><br><span class=\"line\">+                use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;],</span><br><span class=\"line\">+                include:path.join(__dirname,&#x27;./src&#x27;),</span><br><span class=\"line\">+                exclude:/node_modules/</span><br><span class=\"line\">+            &#125;</span><br><span class=\"line\">+        ]</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>常用的 loader<ul>\n<li>编译相关 babel-loader ts-loader</li>\n<li>样式相关 style-loader css-loader less-loader postcss-loader</li>\n<li>文件相关 file-loader url-loader</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-4plugins\"><a href=\"#2-4plugins\" class=\"headerlink\" title=\"2.4plugins\"></a>2.4plugins</h3><ul>\n<li>参与打包的整个过程</li>\n<li>打包优化和压缩</li>\n<li>配置编译时的变量</li>\n<li>用法(以压缩 js 插件为例)</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        new UglifyjsWebpackPlugin()</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>常用的 plugin<ul>\n<li>优化相关<ul>\n<li>CommonsChunkPlugin</li>\n<li>UglifyjsWebpackPlugin</li>\n</ul>\n</li>\n<li>功能相关<ul>\n<li>ExtractTextWebpackPlugin</li>\n<li>HtmlWebpackPlugin</li>\n<li>HotModuleReplacementPlugin</li>\n<li>CopyWebpackPlugin</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3、webpack-的常用配置\"><a href=\"#3、webpack-的常用配置\" class=\"headerlink\" title=\"3、webpack 的常用配置\"></a>3、webpack 的常用配置</h2><h3 id=\"3-1-配置开发服务器\"><a href=\"#3-1-配置开发服务器\" class=\"headerlink\" title=\"3.1 配置开发服务器\"></a>3.1 配置开发服务器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ devServer:&#123;</span><br><span class=\"line\">+        contentBase:path.resolve(__dirname,&#x27;dist&#x27;),</span><br><span class=\"line\">+        host:&#x27;localhost&#x27;,</span><br><span class=\"line\">+        compress:true,</span><br><span class=\"line\">+        port:8080</span><br><span class=\"line\">+ &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>contentBase 配置开发服务运行时的文件根目录</li>\n<li>host：开发服务器监听的主机地址</li>\n<li>compress 开发服务器是否启动 gzip 等压缩</li>\n<li>port：开发服务器监听的端口</li>\n</ul>\n<h3 id=\"3-2-自动产出-html\"><a href=\"#3-2-自动产出-html\" class=\"headerlink\" title=\"3.2 自动产出 html\"></a>3.2 自动产出 html</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">   plugins: [</span><br><span class=\"line\">+        new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">+       minify: &#123;</span><br><span class=\"line\">+            removeAttributeQuotes:true</span><br><span class=\"line\">+        &#125;,</span><br><span class=\"line\">+        hash: true,</span><br><span class=\"line\">+        template: &#x27;./src/index.html&#x27;,</span><br><span class=\"line\">+        filename:&#x27;index.html&#x27;</span><br><span class=\"line\">    &#125;)]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>minify 是对 html 文件进行压缩，removeAttrubuteQuotes 是去掉属性的双引号</li>\n<li>hash 引入产出资源的时候加上哈希避免缓存</li>\n<li>template 模版路径</li>\n</ul>\n<h3 id=\"3-3-分离-css\"><a href=\"#3-3-分离-css\" class=\"headerlink\" title=\"3.3 分离 css\"></a>3.3 分离 css</h3><p>因为 CSS 的下载和 JS 可以并行，当一个 html 文件很大的时候，我们可以把 css 单独提取出来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">   module: &#123;</span><br><span class=\"line\">+        rules:[</span><br><span class=\"line\">+            &#123;</span><br><span class=\"line\">+               test:/\\.css$/,</span><br><span class=\"line\">+                use: ExtractTextWebpackPlugin.extract(&#123;</span><br><span class=\"line\">+                    use:&#x27;css-loader&#x27;</span><br><span class=\"line\">+                &#125;),</span><br><span class=\"line\">                include:path.join(__dirname,&#x27;./src&#x27;),</span><br><span class=\"line\">                exclude:/node_modules/</span><br><span class=\"line\">+            &#125;</span><br><span class=\"line\">+        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">     plugins: [</span><br><span class=\"line\">+        new ExtractTextWebpackPlugin(&#x27;css/index.css&#x27;)]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-编译-less-和-sass\"><a href=\"#3-4-编译-less-和-sass\" class=\"headerlink\" title=\"3.4 编译 less 和 sass\"></a>3.4 编译 less 和 sass</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i less less-loader -D</span><br><span class=\"line\">npm i node-saas sass-loader -D</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const cssExtract=new ExtractTextWebpackPlugin(&#x27;css.css&#x27;);</span><br><span class=\"line\">const lessExtract=new ExtractTextWebpackPlugin(&#x27;less.css&#x27;);</span><br><span class=\"line\">const sassExtract=new ExtractTextWebpackPlugin(&#x27;sass.css&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">                test:/\\.less$/,</span><br><span class=\"line\">                use: lessExtract.extract(&#123;</span><br><span class=\"line\">                    use:[&#x27;css-loader&#x27;,&#x27;less-loader&#x27;]</span><br><span class=\"line\">                &#125;),</span><br><span class=\"line\">                include:path.join(__dirname,&#x27;./src&#x27;),</span><br><span class=\"line\">                exclude:/node_modules/</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:/\\.scss$/,</span><br><span class=\"line\">                use: sassExtract.extract(&#123;</span><br><span class=\"line\">                    use:[&#x27;css-loader&#x27;,&#x27;sass-loader&#x27;]</span><br><span class=\"line\">                &#125;),</span><br><span class=\"line\">                include:path.join(__dirname,&#x27;./src&#x27;),</span><br><span class=\"line\">                exclude:/node_modules/</span><br><span class=\"line\">            &#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-处理-CSS3-属性前缀\"><a href=\"#3-5-处理-CSS3-属性前缀\" class=\"headerlink\" title=\"3.5 处理 CSS3 属性前缀\"></a>3.5 处理 CSS3 属性前缀</h3><p>为了浏览器的兼容性，有时候我们必须加入-webkit,-ms,-o,-moz 这些前缀</p>\n<ul>\n<li>Trident 内核：主要代表为 IE 浏览器, 前缀为-ms</li>\n<li>Gecko 内核：主要代表为 Firefox, 前缀为-moz</li>\n<li>Presto 内核：主要代表为 Opera, 前缀为-o</li>\n<li>Webkit 内核：产要代表为 Chrome 和 Safari, 前缀为-webkit</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports=&#123;</span><br><span class=\"line\">    plugins:[require(&#x27;autoprefixer&#x27;)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">                test:/\\.css$/,</span><br><span class=\"line\">                use: cssExtract.extract(&#123;</span><br><span class=\"line\">+                   use:[&#x27;css-loader&#x27;,&#x27;postcss-loader&#x27;]</span><br><span class=\"line\">                &#125;),</span><br><span class=\"line\">                include:path.join(__dirname,&#x27;./src&#x27;),</span><br><span class=\"line\">                exclude:/node_modules/</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/postcss/postcss-loader\">postcss-loader</a>其它用法可以参考文档</p>\n<h3 id=\"3-6-转义-ES6-x2F-ES7\"><a href=\"#3-6-转义-ES6-x2F-ES7\" class=\"headerlink\" title=\"3.6 转义 ES6&#x2F;ES7\"></a>3.6 转义 ES6&#x2F;ES7</h3><p>Babel 其实是一个编译 JavaScript 的平台,可以把 ES6&#x2F;ES7,React 的 JSX 转义为 ES5</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i babel-core babel-loader babel-preset-env babel-preset-stage-0 babel-preset-react -D</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test:/\\.jsx?$/,</span><br><span class=\"line\">    use: &#123;</span><br><span class=\"line\">        loader: &#x27;babel-loader&#x27;,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">            presets: [&quot;env&quot;,&quot;stage-0&quot;,&quot;react&quot;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    include:path.join(__dirname,&#x27;./src&#x27;),</span><br><span class=\"line\">    exclude:/node_modules/</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-7-调试打包后的代码\"><a href=\"#3-7-调试打包后的代码\" class=\"headerlink\" title=\"3.7 调试打包后的代码\"></a>3.7 调试打包后的代码</h3><p>webapck 通过配置可以自动给我们 sourcemaps 文件，map 文件是一种对应编译文件和源文件的方法</p>\n<ul>\n<li>source-map 把映射文件生成到单独的文件，最完整最慢</li>\n<li>cheap-module-source-map 在一个单独的文件中产生一个不带列映射的 Map</li>\n<li>eval-source-map 使用 eval 打包源文件模块,在同一个文件中生成完整 sourcemap</li>\n<li>cheap-module-eval-source-map sourcemap 和打包后的 JS 同行显示，没有映射列</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    devtool:&#x27;eval-source-map&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-8watch\"><a href=\"#3-8watch\" class=\"headerlink\" title=\"3.8watch\"></a>3.8watch</h3><p>当代码发生修改后可以自动重新编译</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">new webpack.BannerPlugin(&#x27;&#x27;),</span><br><span class=\"line\"></span><br><span class=\"line\">watch: true,</span><br><span class=\"line\">watchOptions: &#123;</span><br><span class=\"line\">    ignored: /node_modules/, //忽略不用监听变更的目录</span><br><span class=\"line\">    aggregateTimeout: 500, //防止重复保存频繁重新编译,500毫秒内重复保存不打包</span><br><span class=\"line\">    poll:1000 //每秒询问的文件变更的次数</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-9-拷贝静态文件\"><a href=\"#3-9-拷贝静态文件\" class=\"headerlink\" title=\"3.9 拷贝静态文件\"></a>3.9 拷贝静态文件</h3><p>有时项目中没有引用的文件也需要打包到目标目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i copy-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">new CopyWebpackPlugin([&#123;</span><br><span class=\"line\">    from: path.join(__dirname,&#x27;public&#x27;),//静态资源目录源地址</span><br><span class=\"line\">    to:&#x27;./public&#x27; //目标地址，相对于output的path目录</span><br><span class=\"line\">&#125;]),</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-10-打包先清空\"><a href=\"#3-10-打包先清空\" class=\"headerlink\" title=\"3.10 打包先清空\"></a>3.10 打包先清空</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i  clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">new cleanWebpackPlugin(path.join(__dirname,&#x27;dist&#x27;))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-11-压缩-js-x2F-css\"><a href=\"#3-11-压缩-js-x2F-css\" class=\"headerlink\" title=\"3.11 压缩 js &#x2F;css\"></a>3.11 压缩 js &#x2F;css</h3><ul>\n<li><p>压缩 JS 可以让输出的 JS 文件体积更小、加载更快、流量更省，还有混淆代码的加密功能<br><code>npm i uglifyjs-webpack-plugin -D</code><br><code>plugins: [ new UglifyjsWebpackPlugin()]</code></p>\n</li>\n<li><p>webpack 可以消除未使用的 CSS，比如 bootstrap 中那些未使用的样式</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i -D purifycss-webpack purify-css</span><br><span class=\"line\">npm i bootstrap -S</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test:/\\.css$/,</span><br><span class=\"line\">    use: cssExtract.extract(&#123;</span><br><span class=\"line\">        use: [&#123;</span><br><span class=\"line\">             loader: &#x27;css-loader&#x27;,</span><br><span class=\"line\">             options:&#123;minimize:true&#125;</span><br><span class=\"line\">        &#125;,&#x27;postcss-loader&#x27;]</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ new PurifyCSSPlugin(&#123;</span><br><span class=\"line\">+             //purifycss根据这个路径配置遍历你的HTML文件，查找你使用的CSS</span><br><span class=\"line\">+            paths:glob.sync(path.join(__dirname,&#x27;src/*.html&#x27;))</span><br><span class=\"line\">+ &#125;),</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、总结\"><a href=\"#4、总结\" class=\"headerlink\" title=\"4、总结\"></a>4、总结</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">以上是webpack核心概念总结，对概念的理解，有助于总体了解下webpack不同的作用，遇到相关问题，找对应的模块。</span><br></pre></td></tr></table></figure>\n","categories":["前端框架总结"],"tags":["javascript"]},{"title":"上下高度固定，中间自适应，且可以滚动","url":"/2022/10/24/%E4%B8%8A%E4%B8%8B%E9%AB%98%E5%BA%A6%E5%9B%BA%E5%AE%9A%EF%BC%8C%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%8C%E4%B8%94%E5%8F%AF%E4%BB%A5%E6%BB%9A%E5%8A%A8/","content":"<p>html 布局三部分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;main&quot;&gt;</span><br><span class=\"line\">       弹性滚动区域</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>css：</p>\n<p>flex 布局方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">*&#123;</span><br><span class=\"line\">    margin:0;</span><br><span class=\"line\">    padding:0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">html,body&#123;</span><br><span class=\"line\">    height:100%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.wrap&#123;</span><br><span class=\"line\">    display:-webkit-box;</span><br><span class=\"line\">    display:-webkit-flex;</span><br><span class=\"line\">    display:-ms-flexbox;</span><br><span class=\"line\">    display:flex;</span><br><span class=\"line\">    -webkit-box-orient:vertical;</span><br><span class=\"line\">    -webkit-flex-direction:column;</span><br><span class=\"line\">    -ms-flex-direction:column;</span><br><span class=\"line\">    flex-direction:column;</span><br><span class=\"line\">    width:100%;</span><br><span class=\"line\">    height:100%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.header,.footer&#123;</span><br><span class=\"line\">    height:40px;</span><br><span class=\"line\">    line-height:40px;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">    background-color:#D8D8D8;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.main&#123;</span><br><span class=\"line\">    -webkit-box-flex:1;</span><br><span class=\"line\">    -webkit-flex:1;</span><br><span class=\"line\">    -ms-flex:1;</span><br><span class=\"line\">    flex:1;</span><br><span class=\"line\">    width:100%;</span><br><span class=\"line\">    padding:10px;</span><br><span class=\"line\">    box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>absolute 布局方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">*&#123; padding:0; margin:0; &#125;</span><br><span class=\"line\">html,body&#123;height:100%;&#125;</span><br><span class=\"line\">.wrap&#123;width:100%;&#125;</span><br><span class=\"line\">.header,.footer&#123;height:40px;line-height:40px;background-color:#D8D8D8;text-align:center;&#125;</span><br><span class=\"line\">.header&#123;position: absolute;top:0;left:0;width:100%;&#125;</span><br><span class=\"line\">.footer&#123;position: absolute;bottom:0;left:0;width:100%;&#125;</span><br><span class=\"line\">.main&#123;position:absolute;z-index:1;top:40px;left:0;bottom:40px;width:100%;&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"介绍防抖与节流的原理，并动手实现","url":"/2022/10/24/%E4%BB%8B%E7%BB%8D%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E5%B9%B6%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const debounce = (fn,delay) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 介绍防抖函数原理，并实现</span><br><span class=\"line\"></span><br><span class=\"line\">  // your code</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const throttle = (fn,delay = 500) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 介绍节流函数原理，并实现</span><br><span class=\"line\"></span><br><span class=\"line\">   // your code</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-防抖函数\"><a href=\"#1-防抖函数\" class=\"headerlink\" title=\"1)防抖函数\"></a>1)防抖函数</h2><h3 id=\"防抖函数原理\"><a href=\"#防抖函数原理\" class=\"headerlink\" title=\"防抖函数原理:\"></a>防抖函数原理:</h3><p>在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景:\"></a>适用场景:</h3><p>1.按钮提交场景:防止多次提交按钮，只执行最后提交的一次。</p>\n<p>2.服务端验证场景:表单验证需要服务端配合，只执行—段连续的输入事件的最后一次，还有搜索联想词功能类似</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 手写简化版实现</span><br><span class=\"line\"></span><br><span class=\"line\">const debounce = (fn,delay) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  let timer = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (...args) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    clearTimeout(timer);</span><br><span class=\"line\"></span><br><span class=\"line\">    timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      fn.apply(this,args);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,delay)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-节流函数\"><a href=\"#2-节流函数\" class=\"headerlink\" title=\"2)节流函数\"></a>2)节流函数</h2><h3 id=\"节流函数原理\"><a href=\"#节流函数原理\" class=\"headerlink\" title=\"节流函数原理:\"></a>节流函数原理:</h3><p>规定在一个单位时间内，只能触发—次函数。如果这个单位时间内触发多次函数，只有一次生效。防抖是延迟执行，而节流是间隔执行，函数节流即每隔一段时间就执行一次。</p>\n<h3 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景:\"></a>适用场景:</h3><p>1.拖拽场景:固定时间内只执行一次，防止超高频次触发位置变动</p>\n<p>⒉ 缩放场景:监控浏览器 resize</p>\n<p>3.动画场景:避免短时间内多次触发动画引起性能问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 手写简化版实现</span><br><span class=\"line\"></span><br><span class=\"line\">// ①定时器实现</span><br><span class=\"line\"></span><br><span class=\"line\">const throttle = (fn,delay = 500) =&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  let flag = true;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (...args) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!flag) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    flag = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      fn.apply(this,args);</span><br><span class=\"line\"></span><br><span class=\"line\">      flag = true;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,delay);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ②时间戳实现</span><br><span class=\"line\"></span><br><span class=\"line\">const throttle = (fn,delay = 500) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  let preTime = Date.now();</span><br><span class=\"line\"></span><br><span class=\"line\">  return (...args) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const nowTime = Date.now();</span><br><span class=\"line\"></span><br><span class=\"line\">    if(nowTime - preTime &gt;= delay)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          preTime = Date.now();</span><br><span class=\"line\"></span><br><span class=\"line\">          fn.apply(this,args);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"从URL输入到页面展现到底发生什么？","url":"/2022/10/24/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><img src=\"https://segmentfault.com/img/remote/1460000017184704\" alt=\"image\"></p>\n<p>总体来说分为以下几个过程:</p>\n<ul>\n<li>DNS 解析:将域名解析成 IP 地址</li>\n<li>TCP 连接：TCP 三次握手</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>断开连接：TCP 四次挥手</li>\n</ul>\n<h2 id=\"一、URL-到底是啥\"><a href=\"#一、URL-到底是啥\" class=\"headerlink\" title=\"一、URL 到底是啥\"></a>一、URL 到底是啥</h2><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。<br>比如 <a href=\"http://www.w3school.com.cn/html/index.asp\">http://www.w3school.com.cn/ht...</a>，遵守以下的语法规则：</p>\n<ul>\n<li>scheme:&#x2F;&#x2F;host.domain:port&#x2F;path&#x2F;filename</li>\n<li>各部分解释如下：</li>\n<li>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li>\n<li>host - 定义域主机（http 的默认主机是 www）</li>\n<li>domain - 定义因特网域名，比如 w3school.com.cn</li>\n<li>port - 定义主机上的端口号（http 的默认端口号是 80）</li>\n<li>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li>\n<li>filename - 定义文档&#x2F;资源的名称</li>\n</ul>\n<h2 id=\"二、域名解析（DNS）\"><a href=\"#二、域名解析（DNS）\" class=\"headerlink\" title=\"二、域名解析（DNS）\"></a>二、域名解析（DNS）</h2><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。大家这里或许会有个疑问—-计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 <a href=\"http://www.hackr.jp.那怎么不一开始就赋予个/\">www.hackr.jp。那怎么不一开始就赋予个</a> IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址</p>\n<h3 id=\"1-IP-地址\"><a href=\"#1-IP-地址\" class=\"headerlink\" title=\"1.IP 地址\"></a>1.IP 地址</h3><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。<br><strong>域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址</strong>。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。<strong>因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。</strong></p>\n<h3 id=\"2-什么是域名解析\"><a href=\"#2-什么是域名解析\" class=\"headerlink\" title=\"2.什么是域名解析\"></a>2.什么是域名解析</h3><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。<strong>DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">例如 baidu.com  220.114.23.56（服务器外网IP地址）80（服务器端口号）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-浏览器如何通过域名去查询-URL-对应的-IP-呢\"><a href=\"#3-浏览器如何通过域名去查询-URL-对应的-IP-呢\" class=\"headerlink\" title=\"3. 浏览器如何通过域名去查询 URL 对应的 IP 呢\"></a>3. 浏览器如何通过域名去查询 URL 对应的 IP 呢</h3><ul>\n<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>\n<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li>\n<li>路由缓存：路由器也有 DNS 缓存。</li>\n<li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>\n<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184705\" alt=\"image\"></p>\n<h3 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h3><p>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184706\" alt=\"image\"></p>\n<h2 id=\"三、TCP-三次握手\"><a href=\"#三、TCP-三次握手\" class=\"headerlink\" title=\"三、TCP 三次握手\"></a>三、TCP 三次握手</h2><p><strong>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184707\" alt=\"image\"></p>\n<h3 id=\"1-TCP-三次握手的过程如下：\"><a href=\"#1-TCP-三次握手的过程如下：\" class=\"headerlink\" title=\"1.TCP 三次握手的过程如下：\"></a>1.TCP 三次握手的过程如下：</h3><ul>\n<li><strong>客户端发送一个带 SYN&#x3D;1，Seq&#x3D;X 的数据包到服务器端口</strong>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li>\n<li><strong>服务器发回一个带 SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y 的响应包以示传达确认信息</strong>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li>\n<li><strong>客户端再回传一个带 ACK&#x3D;Y+1， Seq&#x3D;Z 的数据包，代表“握手结束”</strong>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li>\n</ul>\n<h3 id=\"2-为啥需要三次握手\"><a href=\"#2-为啥需要三次握手\" class=\"headerlink\" title=\"2.为啥需要三次握手\"></a>2.为啥需要三次握手</h3><p>谢希仁著《计算机网络》中讲“三次握手”的目的是<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>。</p>\n<h2 id=\"四、发送-HTTP-请求\"><a href=\"#四、发送-HTTP-请求\" class=\"headerlink\" title=\"四、发送 HTTP 请求\"></a>四、发送 HTTP 请求</h2><p><strong>TCP 三次握手结束后，开始发送 HTTP 请求报文。</strong><br>请求报文由请求行（request line）、请求头（header）、请求体三个部分组成,如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184708\" alt=\"image\"></p>\n<h3 id=\"1-请求行包含请求方法、URL、协议版本\"><a href=\"#1-请求行包含请求方法、URL、协议版本\" class=\"headerlink\" title=\"1.请求行包含请求方法、URL、协议版本\"></a>1.请求行包含请求方法、URL、协议版本</h3><ul>\n<li>请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li>\n<li>URL 即请求地址，由 &lt;协议&gt;：&#x2F;&#x2F;&lt;主机&gt;：&lt;端口&gt;&#x2F;&lt;路径&gt;?&lt;参数&gt; 组成</li>\n<li>协议版本即 http 版本号</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST /chapter17/user.html HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<p>以上代码中“POST”代表请求方法，“&#x2F;chapter17&#x2F;user.html”表示 URL，“HTTP&#x2F;1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本</p>\n<h3 id=\"2-请求头包含请求的附加信息，由关键字-x2F-值对组成，每行一对，关键字和值用英文冒号“-”分隔。\"><a href=\"#2-请求头包含请求的附加信息，由关键字-x2F-值对组成，每行一对，关键字和值用英文冒号“-”分隔。\" class=\"headerlink\" title=\"2.请求头包含请求的附加信息，由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。\"></a>2.请求头包含请求的附加信息，由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。</h3><p>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：<strong>Host，表示主机名，虚拟主机；Connection,HTTP&#x2F;1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。</strong></p>\n<h3 id=\"3-请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。\"><a href=\"#3-请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。\" class=\"headerlink\" title=\"3.请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。\"></a>3.请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">name=tom&amp;password=1234&amp;realName=tomson</span><br></pre></td></tr></table></figure>\n\n<p>上面代码，承载着 name、password、realName 三个请求参数。</p>\n<h2 id=\"五、服务器处理请求并返回-HTTP-报文\"><a href=\"#五、服务器处理请求并返回-HTTP-报文\" class=\"headerlink\" title=\"五、服务器处理请求并返回 HTTP 报文\"></a>五、服务器处理请求并返回 HTTP 报文</h2><h3 id=\"1-服务器\"><a href=\"#1-服务器\" class=\"headerlink\" title=\"1. 服务器\"></a>1. 服务器</h3><p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。<br><strong>web server 担任管控的角色</strong>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184709\" alt=\"image\"></p>\n<h3 id=\"2-MVC-后台处理阶段\"><a href=\"#2-MVC-后台处理阶段\" class=\"headerlink\" title=\"2.MVC 后台处理阶段\"></a>2.MVC 后台处理阶段</h3><p>后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。<br>MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184710\" alt=\"image\"></p>\n<blockquote>\n<p>1、视图（view）</p>\n</blockquote>\n<p><strong>它是提供给用户的操作界面，是程序的外壳。</strong></p>\n<blockquote>\n<p>2、模型（model）</p>\n</blockquote>\n<p><strong>模型主要负责数据交互</strong>。在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。</p>\n<blockquote>\n<p>3、控制器（controller）</p>\n</blockquote>\n<p><strong>它负责根据用户从”视图层”输入的指令，选取”模型层”中的数据，然后对其进行相应的操作，产生最终结果</strong>。控制器属于管理者角色，从视图接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。<br>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。<br>至于这一阶段发生什么？简而言之，<strong>首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。</strong></p>\n<h3 id=\"3-http-响应报文\"><a href=\"#3-http-响应报文\" class=\"headerlink\" title=\"3.http 响应报文\"></a>3.http 响应报文</h3><p>响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示：<br><img src=\"https://segmentfault.com/img/remote/1460000017184711\" alt=\"image\"></p>\n<p>(1) 响应行包含：协议版本，状态码，状态码描述</p>\n<p>状态码规则如下：</p>\n<ul>\n<li>1xx：指示信息–表示请求已接收，继续处理。</li>\n<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>\n<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>\n<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>\n<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>\n</ul>\n<p>(2) 响应头部包含响应报文的附加信息，由 名&#x2F;值 对组成</p>\n<p>(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</p>\n<h2 id=\"六、浏览器解析渲染页面\"><a href=\"#六、浏览器解析渲染页面\" class=\"headerlink\" title=\"六、浏览器解析渲染页面\"></a>六、浏览器解析渲染页面</h2><p>浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184712\" alt=\"image\"></p>\n<p>浏览器解析渲染页面分为以下五个步骤：</p>\n<ul>\n<li>根据 HTML 解析出 DOM 树</li>\n<li>根据 CSS 解析生成 CSS 规则树</li>\n<li>结合 DOM 树和 CSS 规则树，生成渲染树</li>\n<li>根据渲染树计算每一个节点的信息</li>\n<li>根据计算好的信息绘制页面</li>\n</ul>\n<h3 id=\"1-根据-HTML-解析-DOM-树\"><a href=\"#1-根据-HTML-解析-DOM-树\" class=\"headerlink\" title=\"1.根据 HTML 解析 DOM 树\"></a>1.根据 HTML 解析 DOM 树</h3><ul>\n<li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>\n<li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li>\n</ul>\n<h3 id=\"2-根据-CSS-解析生成-CSS-规则树\"><a href=\"#2-根据-CSS-解析生成-CSS-规则树\" class=\"headerlink\" title=\"2.根据 CSS 解析生成 CSS 规则树\"></a>2.根据 CSS 解析生成 CSS 规则树</h3><ul>\n<li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li>\n<li>浏览器在 CSS 规则树生成之前不会进行渲染。</li>\n</ul>\n<h3 id=\"3-结合-DOM-树和-CSS-规则树，生成渲染树\"><a href=\"#3-结合-DOM-树和-CSS-规则树，生成渲染树\" class=\"headerlink\" title=\"3.结合 DOM 树和 CSS 规则树，生成渲染树\"></a>3.结合 DOM 树和 CSS 规则树，生成渲染树</h3><ul>\n<li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li>\n<li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面响应速度。</li>\n</ul>\n<h3 id=\"4-根据渲染树计算每一个节点的信息（布局）\"><a href=\"#4-根据渲染树计算每一个节点的信息（布局）\" class=\"headerlink\" title=\"4.根据渲染树计算每一个节点的信息（布局）\"></a>4.根据渲染树计算每一个节点的信息（布局）</h3><ul>\n<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li>\n<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>\n</ul>\n<h3 id=\"5-根据计算好的信息绘制页面\"><a href=\"#5-根据计算好的信息绘制页面\" class=\"headerlink\" title=\"5.根据计算好的信息绘制页面\"></a>5.根据计算好的信息绘制页面</h3><ul>\n<li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li>\n<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li>\n<li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li>\n</ul>\n<h2 id=\"七、断开连接\"><a href=\"#七、断开连接\" class=\"headerlink\" title=\"七、断开连接\"></a>七、断开连接</h2><p><strong>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000017184713\" alt=\"image\"></p>\n<ul>\n<li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。</strong>(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>\n<li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。</strong>(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>\n<li><strong>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。</strong>(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>\n<li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。</strong>(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>\n</ul>\n<p><strong>给大家推荐一个好用的 BUG 监控工具[Fundebug]<a href=\"https://www.fundebug.com/?utm_source=liao)%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%85%8D%E8%B4%B9%E8%AF%95%E7%94%A8%EF%BC%81\">https://www.fundebug.com/?utm_source=liao)，欢迎免费试用！</a></strong></p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"利用js实现文件上传","url":"/2022/10/24/%E5%88%A9%E7%94%A8js%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"<h2 id=\"一、前端-HTML-部分\"><a href=\"#一、前端-HTML-部分\" class=\"headerlink\" title=\"一、前端 HTML 部分\"></a>一、前端 HTML 部分</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=&#x27;main&#x27;&gt;</span><br><span class=\"line\">\t&lt;input type=&#x27;file&#x27; class=&#x27;filebutton&#x27; style=&#x27;display:none&#x27; οnchange=&#x27;fileSelected()&#x27;  /&gt; &lt;br&gt;</span><br><span class=\"line\">\t&lt;button class=&quot;upload&quot; οnclick=&#x27;openFileDialog()&#x27; &gt; 选择文件上传 &lt;/button&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;img&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、js-部分\"><a href=\"#二、js-部分\" class=\"headerlink\" title=\"二、js 部分\"></a>二、js 部分</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//点击普通按钮,打开文件选择框</span><br><span class=\"line\">function openFileDialog()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t$(&quot;.filebutton&quot;).click();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//选择一个文件时onchange事件被触发</span><br><span class=\"line\">function fileSelected()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvar fbutton = $(&quot;.filebutton&quot;)[0];//dom元素</span><br><span class=\"line\">\t//读取文件</span><br><span class=\"line\">\tvar reader = new FileReader();</span><br><span class=\"line\">\treader.onload = function(e)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvar dataURL = e.target.result;//&#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;</span><br><span class=\"line\">\t\t//alert(data);</span><br><span class=\"line\">\t\tvar htmlImg = &quot;&lt;img src = &#x27;&quot; + dataURL + &quot;&#x27;/&gt;&quot;;</span><br><span class=\"line\">    \t$(&quot;.img&quot;).html(htmlImg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvar file = fbutton.files[0];</span><br><span class=\"line\">\treader.readAsDataURL(file);</span><br><span class=\"line\"></span><br><span class=\"line\">\tstartFileUpload(file);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//开始上传</span><br><span class=\"line\">function startFileUpload(file)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvar uploadURL = &quot;FileUploadServer&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//手工构造一个form对象</span><br><span class=\"line\">\tvar formData = new FormData();</span><br><span class=\"line\">\tformData.append(&quot;file&quot; , file);// &#x27;file&#x27; 为HTTP Post里的字段名, file 对浏览器里的File对象</span><br><span class=\"line\">\t//手工构造一个请求对象，用这个对象发送表单数据</span><br><span class=\"line\">\t//设置 progress, load, error, abort 4个事件处理器</span><br><span class=\"line\">\tvar request = new XMLHttpRequest();</span><br><span class=\"line\">\trequest.upload.addEventListener(&quot;progress&quot; , window.evt_upload_progress , false);</span><br><span class=\"line\">    request.addEventListener(&quot;load&quot;, window.evt_upload_complete, false);</span><br><span class=\"line\">    request.addEventListener(&quot;error&quot;, window.evt_upload_failed, false);</span><br><span class=\"line\">    request.addEventListener(&quot;abort&quot;, window.evt_upload_cancel, false);</span><br><span class=\"line\">\trequest.open(&quot;POST&quot;, uploadURL ); // 设置服务URL</span><br><span class=\"line\">    request.send(formData);  // 发送表单数据</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.evt_upload_progress = function(evt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(evt.lengthComputable)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar progress = Math.round(evt.loaded * 100 / evt.total);</span><br><span class=\"line\">\t\tconsole.log(&quot;上传进度&quot; + progress);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">window.evt_upload_complete = function (evt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(evt.loaded == 0)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tconsole.log (&quot;上传失败!&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tconsole.log (&quot;上传完成!&quot;);</span><br><span class=\"line\">    \tvar response = JSON.parse(evt.target.responseText);</span><br><span class=\"line\">    \tconsole.log (response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">window.evt_upload_failed = function (evt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconsole.log  (&quot;上传出错&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">window.evt_upload_cancel = function (evt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconsole.log( &quot;上传中止!&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、后端部分，需要两个-jar-包的支持，他们分别是：commons-fileupload-1-3-1-jar-commons-io-2-4-jar\"><a href=\"#三、后端部分，需要两个-jar-包的支持，他们分别是：commons-fileupload-1-3-1-jar-commons-io-2-4-jar\" class=\"headerlink\" title=\"三、后端部分，需要两个 jar 包的支持，他们分别是：commons-fileupload-1.3.1.jar commons-io-2.4.jar\"></a>三、后端部分，需要两个 jar 包的支持，他们分别是：<code>commons-fileupload-1.3.1.jar</code> <code>commons-io-2.4.jar</code></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package my.fileUpload;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.File;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\">import java.io.PrintWriter;</span><br><span class=\"line\">import java.text.SimpleDateFormat;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.UUID;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.servlet.ServletException;</span><br><span class=\"line\">import javax.servlet.http.HttpServlet;</span><br><span class=\"line\">import javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\">import javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.apache.commons.fileupload.FileItemIterator;</span><br><span class=\"line\">import org.apache.commons.fileupload.FileItemStream;</span><br><span class=\"line\">import org.apache.commons.fileupload.servlet.ServletFileUpload;</span><br><span class=\"line\">import org.apache.commons.fileupload.util.Streams;</span><br><span class=\"line\">import org.json.JSONObject;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FileUploadServer extends HttpServlet &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFile tmpDir;//文件保存的临时目录</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void init() throws ServletException &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;初始化&quot;);</span><br><span class=\"line\">\t   File webRoot = new File(getServletContext().getRealPath(&quot;/&quot;));</span><br><span class=\"line\">\t   tmpDir = new File(webRoot , &quot;upload&quot;);</span><br><span class=\"line\">\t   if(!tmpDir.exists()) tmpDir.mkdirs();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class=\"line\">\t\t\tthrows ServletException, IOException &#123;</span><br><span class=\"line\">\t\tdoPost(request , response);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class=\"line\">\t\t\tthrows ServletException, IOException &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;进入&quot;);</span><br><span class=\"line\">\t\tint error = 0;</span><br><span class=\"line\">\t\tString reason = &quot;OK&quot;;</span><br><span class=\"line\">\t\tString data = null;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\t data = doUpload(request , response);</span><br><span class=\"line\">\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\terror = -1;</span><br><span class=\"line\">\t\t\treason = e.getMessage();</span><br><span class=\"line\">\t\t\t// TODO Auto-generated catch block</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tJSONObject jreq = new JSONObject();</span><br><span class=\"line\">\t\tjreq.put(&quot;error&quot;, error);</span><br><span class=\"line\">\t\tjreq.put(&quot;reason&quot;, reason);</span><br><span class=\"line\">\t\tif(data != null) jreq.put(&quot;data&quot;, data);</span><br><span class=\"line\">\t\tresponse.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class=\"line\">\t\tresponse.setContentType(&quot;text/plain&quot;);</span><br><span class=\"line\">\t\tPrintWriter out = response.getWriter();</span><br><span class=\"line\">\t\tout.write(jreq.toString(2));</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String doUpload(HttpServletRequest request, HttpServletResponse response) throws Exception</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tString result = null;</span><br><span class=\"line\">\t\tboolean isMultipart = ServletFileUpload.isMultipartContent(request);</span><br><span class=\"line\">\t\tif(!isMultipart)</span><br><span class=\"line\">\t\t\tthrow new Exception(&quot;请求编码必须为: multipart/form-data !&quot;);</span><br><span class=\"line\">\t\trequest.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class=\"line\">\t\tServletFileUpload upload = new ServletFileUpload();</span><br><span class=\"line\">\t\tFileItemIterator iter = upload.getItemIterator(request);</span><br><span class=\"line\">\t\twhile(iter.hasNext())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t//表单域</span><br><span class=\"line\">\t\t\tFileItemStream item = iter.next();</span><br><span class=\"line\">\t\t\tString fieldName = item.getFieldName();</span><br><span class=\"line\">\t\t\tInputStream fieldStream = item.openStream();</span><br><span class=\"line\">\t\t\tif(item.isFormField())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t//普通表单域直接读取</span><br><span class=\"line\">\t\t\t\tString fieldValue = Streams.asString(fieldStream , &quot;utf-8&quot;);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;表单域:&quot; + fieldName + &quot;=&quot; + fieldValue);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tString realName = item.getName();//原始文件名</span><br><span class=\"line\">\t\t\t\t//文件的后缀名</span><br><span class=\"line\">\t\t\t\tString suffix = realName.substring(realName.lastIndexOf(&quot;.&quot;)+1);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;文件名：&quot; + realName + &quot;.....&quot; + &quot;后缀名：&quot; + suffix);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//创建已个临时文件名</span><br><span class=\"line\">\t\t\t\tString s = UUID.randomUUID().toString();</span><br><span class=\"line\">\t\t\t\tString s2 = s.substring(0,8)+s.substring(9,13)+s.substring(14,18)+s.substring(19,23)+s.substring(24);</span><br><span class=\"line\">\t\t\t\ts2 = s2.toUpperCase();</span><br><span class=\"line\">\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMdd-HHmmss&quot;);</span><br><span class=\"line\">\t\t\t\tString dateStr = sdf.format(new Date());</span><br><span class=\"line\">\t\t\t\tString fileName = dateStr +&quot;-&quot; + s2 + &quot;.&quot; + suffix;</span><br><span class=\"line\">\t\t\t\tresult = fileName;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;文件名：&quot; + fileName);</span><br><span class=\"line\">\t\t\t\tFile file = new File(tmpDir , fileName);</span><br><span class=\"line\">\t\t\t\tlong fileSsize = 0;//文件大小</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;===========文件开始上传=============&quot;);</span><br><span class=\"line\">\t\t\t\t//从FieldStream读取数据，保存到目标文件</span><br><span class=\"line\">\t\t\t\tfile.getParentFile().mkdirs();</span><br><span class=\"line\">\t\t\t\tFileOutputStream fileStream = new FileOutputStream(file);</span><br><span class=\"line\">\t\t\t\ttry</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tbyte[] buf = new byte[1024];</span><br><span class=\"line\">\t\t\t\t\twhile(true)</span><br><span class=\"line\">\t\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t\tint n = fieldStream.read(buf);</span><br><span class=\"line\">\t\t\t\t\t\tif(n &lt; 0) break;</span><br><span class=\"line\">\t\t\t\t\t\tif(n == 0) continue;</span><br><span class=\"line\">\t\t\t\t\t\tfileStream.write(buf, 0, n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\tfileSsize += n;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;finally</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tfileStream.close();</span><br><span class=\"line\">\t\t\t\t\tfieldStream.close();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;上传完成！&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"前端代码开发规范","url":"/2022/12/16/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","content":"<h2 id=\"前端-JS-项目开发规范\"><a href=\"#前端-JS-项目开发规范\" class=\"headerlink\" title=\"前端 JS 项目开发规范\"></a>前端 JS 项目开发规范</h2><p>规范的目的是为了编写高质量的代码，让你的团队成员每天的心情都是愉悦的，大家在一起是快乐的。</p>\n<p>引自《阿里规约》的开头片段：</p>\n<p>—-现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。</p>\n<h2 id=\"一、编程规约\"><a href=\"#一、编程规约\" class=\"headerlink\" title=\"一、编程规约\"></a>一、编程规约</h2><h3 id=\"一-命名规范\"><a href=\"#一-命名规范\" class=\"headerlink\" title=\"(一)命名规范\"></a>(一)命名规范</h3><h4 id=\"1-1-1-项目命名\"><a href=\"#1-1-1-项目命名\" class=\"headerlink\" title=\"1.1.1 项目命名\"></a>1.1.1 项目命名</h4><p>全部采用小写方式， 以中划线分隔。</p>\n<p>正例：<code>mall-management-system</code></p>\n<p>反例：<code>mall_management-system / mallManagementSystem</code></p>\n<h4 id=\"1-1-2-目录命名\"><a href=\"#1-1-2-目录命名\" class=\"headerlink\" title=\"1.1.2 目录命名\"></a>1.1.2 目录命名</h4><p>全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数</p>\n<p>正例： <code>scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc</code></p>\n<p>反例： <code>script / style / demo_scripts / demoStyles / imgs / docs</code></p>\n<p>【特殊】VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名</p>\n<p>正例： <code>head-search / page-loading / authorized / notice-icon</code></p>\n<p>反例： <code>HeadSearch / PageLoading</code></p>\n<p>【特殊】VUE 的项目中除 components 组件目录外的所有目录也使用 kebab-case 命名<br>正例： <code>page-one / shopping-car / user-management</code></p>\n<p>反例： <code>ShoppingCar / UserManagement</code></p>\n<h4 id=\"1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名\"><a href=\"#1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名\" class=\"headerlink\" title=\"1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名\"></a>1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</h4><p>全部采用小写方式， 以中划线分隔</p>\n<p>正例： <code>render-dom.js / signup.css / index.html / company-logo.png</code></p>\n<p>反例： <code>renderDom.js / UserManagement.html</code></p>\n<h4 id=\"1-1-4-命名严谨性\"><a href=\"#1-1-4-命名严谨性\" class=\"headerlink\" title=\"1.1.4 命名严谨性\"></a>1.1.4 命名严谨性</h4><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用</p>\n<p>正例：<code>henan / luoyang / rmb</code> 等国际通用的名称，可视同英文。</p>\n<p>反例：<code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code></p>\n<p>杜绝完全不规范的缩写，避免望文不知义：</p>\n<p>反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</p>\n<h3 id=\"二-HTML-规范-（Vue-Template-同样适用）\"><a href=\"#二-HTML-规范-（Vue-Template-同样适用）\" class=\"headerlink\" title=\"(二)HTML 规范 （Vue Template 同样适用）\"></a>(二)HTML 规范 （Vue Template 同样适用）</h3><h4 id=\"1-2-1-HTML-类型\"><a href=\"#1-2-1-HTML-类型\" class=\"headerlink\" title=\"1.2.1 HTML 类型\"></a>1.2.1 HTML 类型</h4><p>推荐使用 HTML5 的文档类型声明： .<br>（建议使用 text&#x2F;html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application&#x2F;xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p>\n<ul>\n<li>规定字符编码</li>\n<li>IE 兼容模式</li>\n<li>规定字符编码</li>\n<li>doctype 大写<br>正例：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class=\"line\">    &lt;title&gt;Page title&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot; /&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-2-缩进\"><a href=\"#1-2-2-缩进\" class=\"headerlink\" title=\"1.2.2 缩进\"></a>1.2.2 缩进</h4><p>缩进使用 2 个空格（一个 tab）</p>\n<p>嵌套的节点应该缩进。</p>\n<h4 id=\"1-2-3-分块注释\"><a href=\"#1-2-3-分块注释\" class=\"headerlink\" title=\"1.2.3 分块注释\"></a>1.2.3 分块注释</h4><p>在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式</p>\n<p>…</p>\n<h4 id=\"1-2-4-语义化标签\"><a href=\"#1-2-4-语义化标签\" class=\"headerlink\" title=\"1.2.4 语义化标签\"></a>1.2.4 语义化标签</h4><p>HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签</p>\n<p>正例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;header&gt;&lt;/header&gt;</span><br><span class=\"line\">&lt;footer&gt;&lt;/footer&gt;</span><br></pre></td></tr></table></figure>\n\n<p>反例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-5-引号\"><a href=\"#1-2-5-引号\" class=\"headerlink\" title=\"1.2.5 引号\"></a>1.2.5 引号</h4><p>使用双引号(“”) 而不是单引号(‘’) 。</p>\n<p>正例： “”</p>\n<p>反例： ‘’</p>\n<h3 id=\"三-CSS-规范\"><a href=\"#三-CSS-规范\" class=\"headerlink\" title=\"(三) CSS 规范\"></a>(三) CSS 规范</h3><h4 id=\"1-3-1-命名\"><a href=\"#1-3-1-命名\" class=\"headerlink\" title=\"1.3.1 命名\"></a>1.3.1 命名</h4><ul>\n<li>类名使用小写字母，以中划线分隔</li>\n<li>id 采用驼峰式命名</li>\n<li>scss 中的变量、函数、混合、placeholder 采用驼峰式命名<br>ID 和 class 的名称总是使用可以反映元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</li>\n</ul>\n<p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.fw-800 &#123;</span><br><span class=\"line\">  font-weight: 800;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.red &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.heavy &#123;</span><br><span class=\"line\">  font-weight: 800;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.important &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-2-选择器\"><a href=\"#1-3-2-选择器\" class=\"headerlink\" title=\"1.3.2 选择器\"></a>1.3.2 选择器</h4><p>1)css 选择器中避免使用标签名<br>从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。</p>\n<p>2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。</p>\n<p>不推荐:</p>\n<p><code>.content .title &#123;   font-size: 2rem; &#125;</code></p>\n<p>推荐:</p>\n<p><code>.content &gt; .title &#123;   font-size: 2rem; &#125;</code></p>\n<h4 id=\"1-3-3-尽量使用缩写属性\"><a href=\"#1-3-3-尽量使用缩写属性\" class=\"headerlink\" title=\"1.3.3 尽量使用缩写属性\"></a>1.3.3 尽量使用缩写属性</h4><p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">border-top-style: none;</span><br><span class=\"line\">font-family: palatino, georgia, serif;</span><br><span class=\"line\">font-size: 100%;</span><br><span class=\"line\">line-height: 1.6;</span><br><span class=\"line\">padding-bottom: 2em;</span><br><span class=\"line\">padding-left: 1em;</span><br><span class=\"line\">padding-right: 1em;</span><br><span class=\"line\">padding-top: 0;</span><br></pre></td></tr></table></figure>\n\n<p>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">border-top: 0;</span><br><span class=\"line\">font: 100%/1.6 palatino, georgia, serif;</span><br><span class=\"line\">padding: 0 1em 2em;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-4-每个选择器及属性独占一行\"><a href=\"#1-3-4-每个选择器及属性独占一行\" class=\"headerlink\" title=\"1.3.4 每个选择器及属性独占一行\"></a>1.3.4 每个选择器及属性独占一行</h4><p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">button&#123;</span><br><span class=\"line\">  width:100px;height:50px;color:#fff;background:#00a0e9;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">button&#123;</span><br><span class=\"line\">  width:100px;</span><br><span class=\"line\">  height:50px;</span><br><span class=\"line\">  color:#fff;</span><br><span class=\"line\">  background:#00a0e9;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-5-省略-0-后面的单位\"><a href=\"#1-3-5-省略-0-后面的单位\" class=\"headerlink\" title=\"1.3.5 省略 0 后面的单位\"></a>1.3.5 省略 0 后面的单位</h4><p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">  padding-bottom: 0px;</span><br><span class=\"line\">  margin: 0em;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">  padding-bottom: 0;</span><br><span class=\"line\">  margin: 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-6-避免使用-ID-选择器及全局标签选择器防止污染全局样式\"><a href=\"#1-3-6-避免使用-ID-选择器及全局标签选择器防止污染全局样式\" class=\"headerlink\" title=\"1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式\"></a>1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式</h4><p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#header&#123;</span><br><span class=\"line\">  padding-bottom: 0px;</span><br><span class=\"line\">  margin: 0em;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.header&#123;</span><br><span class=\"line\">  padding-bottom: 0px;</span><br><span class=\"line\">  margin: 0em;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四-LESS-规范\"><a href=\"#四-LESS-规范\" class=\"headerlink\" title=\"(四) LESS 规范\"></a>(四) LESS 规范</h3><h4 id=\"1-4-1-代码组织\"><a href=\"#1-4-1-代码组织\" class=\"headerlink\" title=\"1.4.1 代码组织\"></a>1.4.1 代码组织</h4><p>1)将公共 less 文件放置在<code>style/less/common</code>文件夹<br>例:<code>// color.less,common.less</code></p>\n<p>2)按以下顺序组织</p>\n<ul>\n<li>1、@import;</li>\n<li>2、变量声明;</li>\n<li>3、样式声明;</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@import &quot;mixins/size.less&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">@default-text-color: #333;</span><br><span class=\"line\"></span><br><span class=\"line\">.page &#123;</span><br><span class=\"line\">  width: 960px;</span><br><span class=\"line\">  margin: 0 auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-4-2-避免嵌套层级过多\"><a href=\"#1-4-2-避免嵌套层级过多\" class=\"headerlink\" title=\"1.4.2 避免嵌套层级过多\"></a>1.4.2 避免嵌套层级过多</h4><p>将嵌套深度限制在 3 级。对于超过 4 级的嵌套，给予重新评估。这可以避免出现过于详实的 CSS 选择器。<br>避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于 20 行的嵌套规则出现</p>\n<p>不推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.main&#123;</span><br><span class=\"line\">  .title&#123;</span><br><span class=\"line\">    .name&#123;</span><br><span class=\"line\">       color:#fff</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>推荐：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.main-title&#123;</span><br><span class=\"line\">   .name&#123;</span><br><span class=\"line\">      color:#fff</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五-Javascript-规范\"><a href=\"#五-Javascript-规范\" class=\"headerlink\" title=\"(五) Javascript 规范\"></a>(五) Javascript 规范</h3><h4 id=\"1-5-1-命名\"><a href=\"#1-5-1-命名\" class=\"headerlink\" title=\"1.5.1 命名\"></a>1.5.1 命名</h4><ol>\n<li><p>采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束<br>反例： <code>_name / name_ / name$</code></p>\n</li>\n<li><p>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。<br>正例： <code>localValue / getHttpMessage() / inputUserId</code></p>\n</li>\n</ol>\n<p><strong>其中 method 方法命名必须是 动词 或者 动词+名词 形式</strong></p>\n<p>正例：<code>saveShopCarData /openShopCarInfoDialog</code></p>\n<p>反例：<code>save / open / show / go</code></p>\n<p><strong>特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）</strong></p>\n<p><code>add / update / delete / detail / get</code></p>\n<p><strong>附： 函数方法常用的动词:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">get 获取/set 设置,</span><br><span class=\"line\">add 增加/remove 删除</span><br><span class=\"line\">create 创建/destory 移除</span><br><span class=\"line\">start 启动/stop 停止</span><br><span class=\"line\">open 打开/close 关闭,</span><br><span class=\"line\">read 读取/write 写入</span><br><span class=\"line\">load 载入/save 保存,</span><br><span class=\"line\">create 创建/destroy 销毁</span><br><span class=\"line\">begin 开始/end 结束,</span><br><span class=\"line\">backup 备份/restore 恢复</span><br><span class=\"line\">import 导入/export 导出,</span><br><span class=\"line\">split 分割/merge 合并</span><br><span class=\"line\">inject 注入/extract 提取,</span><br><span class=\"line\">attach 附着/detach 脱离</span><br><span class=\"line\">bind 绑定/separate 分离,</span><br><span class=\"line\">view 查看/browse 浏览</span><br><span class=\"line\">edit 编辑/modify 修改,</span><br><span class=\"line\">select 选取/mark 标记</span><br><span class=\"line\">copy 复制/paste 粘贴,</span><br><span class=\"line\">undo 撤销/redo 重做</span><br><span class=\"line\">insert 插入/delete 移除,</span><br><span class=\"line\">add 加入/append 添加</span><br><span class=\"line\">clean 清理/clear 清除,</span><br><span class=\"line\">index 索引/sort 排序</span><br><span class=\"line\">find 查找/search 搜索,</span><br><span class=\"line\">increase 增加/decrease 减少</span><br><span class=\"line\">play 播放/pause 暂停,</span><br><span class=\"line\">launch 启动/run 运行</span><br><span class=\"line\">compile 编译/execute 执行,</span><br><span class=\"line\">debug 调试/trace 跟踪</span><br><span class=\"line\">observe 观察/listen 监听,</span><br><span class=\"line\">build 构建/publish 发布</span><br><span class=\"line\">input 输入/output 输出,</span><br><span class=\"line\">encode 编码/decode 解码</span><br><span class=\"line\">encrypt 加密/decrypt 解密,</span><br><span class=\"line\">compress 压缩/decompress 解压缩</span><br><span class=\"line\">pack 打包/unpack 解包,</span><br><span class=\"line\">parse 解析/emit 生成</span><br><span class=\"line\">connect 连接/disconnect 断开,</span><br><span class=\"line\">send 发送/receive 接收</span><br><span class=\"line\">download 下载/upload 上传,</span><br><span class=\"line\">refresh 刷新/synchronize 同步</span><br><span class=\"line\">update 更新/revert 复原,</span><br><span class=\"line\">lock 锁定/unlock 解锁</span><br><span class=\"line\">check out 签出/check in 签入,</span><br><span class=\"line\">submit 提交/commit 交付</span><br><span class=\"line\">push 推/pull 拉,</span><br><span class=\"line\">expand 展开/collapse 折叠</span><br><span class=\"line\">begin 起始/end 结束,</span><br><span class=\"line\">start 开始/finish 完成</span><br><span class=\"line\">enter 进入/exit 退出,</span><br><span class=\"line\">abort 放弃/quit 离开</span><br><span class=\"line\">obsolete 废弃/depreciate 废旧,</span><br><span class=\"line\">collect 收集/aggregate 聚集</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>正例： <code>MAX_STOCK_COUNT</code></li>\n</ol>\n<p>反例： <code>MAX_COUNT</code></p>\n<h4 id=\"1-5-2-代码格式\"><a href=\"#1-5-2-代码格式\" class=\"headerlink\" title=\"1.5.2 代码格式\"></a>1.5.2 代码格式</h4><ol>\n<li>使用 2 个空格进行缩进<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (x &lt; y) &#123;</span><br><span class=\"line\">  x += 10;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  x += 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。<br>说明：任何情形，没有必要插入多个空行进行隔开。</li>\n</ol>\n<h4 id=\"1-5-3-字符串\"><a href=\"#1-5-3-字符串\" class=\"headerlink\" title=\"1.5.3 字符串\"></a>1.5.3 字符串</h4><p>统一使用单引号(‘’)，不使用双引号(“”)。这在创建 HTML 字符串非常有好处：</p>\n<p>正例:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let str = &#x27;foo&#x27;;</span><br><span class=\"line\">let testDiv = &#x27;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p>反例:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let str = &quot;foo&quot;;</span><br><span class=\"line\">let testDiv = &quot;&lt;div id=&#x27;test&#x27;&gt;&lt;/div&gt;&quot;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-5-4-对象声明\"><a href=\"#1-5-4-对象声明\" class=\"headerlink\" title=\"1.5.4 对象声明\"></a>1.5.4 对象声明</h4><p>1)使用字面值创建对象<br>正例：<code> let user = &#123;&#125;;</code></p>\n<p>反例： <code>let user = new Object();</code></p>\n<ol start=\"2\">\n<li>使用字面量来代替对象构造器<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var user = &#123;</span><br><span class=\"line\">  age: 0,</span><br><span class=\"line\">  name: 1,</span><br><span class=\"line\">  city: 3</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var user = new Object();</span><br><span class=\"line\">user.age = 0;</span><br><span class=\"line\">user.name = 0;</span><br><span class=\"line\">user.city = 0;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-5-5-使用-ES6-7\"><a href=\"#1-5-5-使用-ES6-7\" class=\"headerlink\" title=\"1.5.5 使用 ES6,7\"></a>1.5.5 使用 ES6,7</h4><p>必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</p>\n<p>必须强制使用 ES6, ES7 的新语法，比如箭头函数、await&#x2F;async ， 解构， let ， for…of 等等</p>\n<h4 id=\"1-5-6-括号\"><a href=\"#1-5-6-括号\" class=\"headerlink\" title=\"1.5.6 括号\"></a>1.5.6 括号</h4><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。</p>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (condition) &#123;</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (condition) doSomething();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-5-7-undefined-判断\"><a href=\"#1-5-7-undefined-判断\" class=\"headerlink\" title=\"1.5.7 undefined 判断\"></a>1.5.7 undefined 判断</h4><p>永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。</p>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (typeof person === &#x27;undefined&#x27;) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (person === undefined) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-5-8-条件判断和循环最多三层\"><a href=\"#1-5-8-条件判断和循环最多三层\" class=\"headerlink\" title=\"1.5.8 条件判断和循环最多三层\"></a>1.5.8 条件判断和循环最多三层</h4><p>条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。</p>\n<h4 id=\"1-5-9-this-的转换命名\"><a href=\"#1-5-9-this-的转换命名\" class=\"headerlink\" title=\"1.5.9 this 的转换命名\"></a>1.5.9 this 的转换命名</h4><p>对上下文 this 的引用只能使用’self’来命名</p>\n<h4 id=\"1-5-10-慎用-console-log\"><a href=\"#1-5-10-慎用-console-log\" class=\"headerlink\" title=\"1.5.10 慎用 console.log\"></a>1.5.10 慎用 console.log</h4><p>因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能</p>\n<h2 id=\"二、Vue-项目规范\"><a href=\"#二、Vue-项目规范\" class=\"headerlink\" title=\"二、Vue 项目规范\"></a>二、Vue 项目规范</h2><h3 id=\"一-Vue-编码基础\"><a href=\"#一-Vue-编码基础\" class=\"headerlink\" title=\"(一) Vue 编码基础\"></a>(一) Vue 编码基础</h3><p>vue 项目规范以 Vue 官方规范 （<a href=\"https://cn.vuejs.org/v2/style-guide/%EF%BC%89\">https://cn.vuejs.org/v2/style-guide/）</a> 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</p>\n<p>请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</p>\n<h4 id=\"2-1-1-组件规范\"><a href=\"#2-1-1-组件规范\" class=\"headerlink\" title=\"2.1.1. 组件规范\"></a>2.1.1. 组件规范</h4><ol>\n<li>组件名为多个单词。<br>组件名应该始终是多个单词组成（大于等于 2），且命名规范为 KebabCase 格式。<br>这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</li>\n</ol>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;TodoItem&#x27;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;Todo&#x27;,</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;todo-item&#x27;,</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>组件文件名为 pascal-case 格式<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- my-component.vue</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- myComponent.vue</span><br><span class=\"line\">|- MyComponent.vue</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>基础组件文件名为 base 开头，使用完整单词而不是缩写。<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- base-button.vue</span><br><span class=\"line\">|- base-table.vue</span><br><span class=\"line\">|- base-icon.vue</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- MyButton.vue</span><br><span class=\"line\">|- VueTable.vue</span><br><span class=\"line\">|- Icon.vue</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- todo-list.vue</span><br><span class=\"line\">|- todo-list-item.vue</span><br><span class=\"line\">|- todo-list-item-button.vue</span><br><span class=\"line\">|- user-profile-options.vue （完整单词）</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">components/</span><br><span class=\"line\">|- TodoList.vue</span><br><span class=\"line\">|- TodoItem.vue</span><br><span class=\"line\">|- TodoButton.vue</span><br><span class=\"line\">|- UProfOpts.vue （使用了缩写）</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span><br><span class=\"line\">&lt;MyComponent /&gt;</span><br><span class=\"line\">&lt;Row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/Row&gt;</span><br><span class=\"line\">反例：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;my-component /&gt; &lt;row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/row&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>组件的 data 必须是一个函数<br>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。</li>\n</ol>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      name: &#x27;jack&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    name: &#x27;jack&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>Prop 定义应该尽量详细</li>\n</ol>\n<ul>\n<li>必须使用 camelCase 驼峰命名</li>\n<li>必须指定类型</li>\n<li>必须加上注释，表明其含义</li>\n<li>必须加上 required 或者 default，两者二选其一</li>\n<li>如果有业务需要，必须加上 validator 验证<br>正例：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">  // 组件状态，用于控制组件的颜色</span><br><span class=\"line\">   status: &#123;</span><br><span class=\"line\">     type: String,</span><br><span class=\"line\">     required: true,</span><br><span class=\"line\">     validator: function (value) &#123;</span><br><span class=\"line\">       return [</span><br><span class=\"line\">         &#x27;succ&#x27;,</span><br><span class=\"line\">         &#x27;info&#x27;,</span><br><span class=\"line\">         &#x27;error&#x27;</span><br><span class=\"line\">       ].indexOf(value) !== -1</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">    // 用户级别，用于显示皇冠个数</span><br><span class=\"line\">   userLevel：&#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>为组件样式设置作用域<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 使用 `scoped` 特性 --&gt;</span><br><span class=\"line\">&lt;style scoped&gt;</span><br><span class=\"line\">  .btn-close &#123;</span><br><span class=\"line\">    background-color: red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;!-- 没有使用 `scoped` 特性 --&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  .btn-close &#123;</span><br><span class=\"line\">    background-color: red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li>如果特性元素较多，应该主动换行。<br>正例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class=\"line\">    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class=\"line\">    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;</span><br><span class=\"line\"> /&gt;</span><br><span class=\"line\">反例：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-2-模板中使用简单的表达式\"><a href=\"#2-1-2-模板中使用简单的表达式\" class=\"headerlink\" title=\"2.1.2. 模板中使用简单的表达式\"></a>2.1.2. 模板中使用简单的表达式</h4><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; normalizedFullName &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 复杂表达式已经移入一个计算属性</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  normalizedFullName: function () &#123;</span><br><span class=\"line\">    return this.fullName.split(&#x27; &#x27;).map(function (word) &#123;</span><br><span class=\"line\">      return word[0].toUpperCase() + word.slice(1)</span><br><span class=\"line\">    &#125;).join(&#x27; &#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;p&gt;</span><br><span class=\"line\">       &#123;&#123;</span><br><span class=\"line\">          fullName.split(&#x27; &#x27;).map(function (word) &#123;</span><br><span class=\"line\">             return word[0].toUpperCase() + word.slice(1)</span><br><span class=\"line\">           &#125;).join(&#x27; &#x27;)</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">  &lt;/p&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-3-指令都使用缩写形式\"><a href=\"#2-1-3-指令都使用缩写形式\" class=\"headerlink\" title=\"2.1.3 指令都使用缩写形式\"></a>2.1.3 指令都使用缩写形式</h4><p>指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)</p>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  @input=&quot;onInput&quot;</span><br><span class=\"line\">  @focus=&quot;onFocus&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  v-on:input=&quot;onInput&quot;</span><br><span class=\"line\">  @focus=&quot;onFocus&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-4-标签顺序保持一致\"><a href=\"#2-1-4-标签顺序保持一致\" class=\"headerlink\" title=\"2.1.4 标签顺序保持一致\"></a>2.1.4 标签顺序保持一致</h4><p>单文件组件应该总是让标签顺序保持为 &#96;</p>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;...&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;...&lt;/script&gt;</span><br><span class=\"line\">&lt;style&gt;...&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>反例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;...&lt;/template&gt;</span><br><span class=\"line\">&lt;style&gt;...&lt;/style&gt;</span><br><span class=\"line\">&lt;script&gt;...&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-5-必须为-v-for-设置键值-key\"><a href=\"#2-1-5-必须为-v-for-设置键值-key\" class=\"headerlink\" title=\"2.1.5 必须为 v-for 设置键值 key\"></a>2.1.5 必须为 v-for 设置键值 key</h4><h4 id=\"2-1-6-v-show-与-v-if-选择\"><a href=\"#2-1-6-v-show-与-v-if-选择\" class=\"headerlink\" title=\"2.1.6 v-show 与 v-if 选择\"></a>2.1.6 v-show 与 v-if 选择</h4><p>如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</p>\n<h4 id=\"2-1-7-script-标签内部结构顺序\"><a href=\"#2-1-7-script-标签内部结构顺序\" class=\"headerlink\" title=\"2.1.7 script 标签内部结构顺序\"></a>2.1.7 script 标签内部结构顺序</h4><p>components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</p>\n<h4 id=\"2-1-8-Vue-Router-规范\"><a href=\"#2-1-8-Vue-Router-规范\" class=\"headerlink\" title=\"2.1.8 Vue Router 规范\"></a>2.1.8 Vue Router 规范</h4><ol>\n<li>页面跳转数据传递使用路由参数<br>页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。</li>\n</ol>\n<p>正例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let id = &#x27;123&#x27;;</span><br><span class=\"line\">this.$router.push(&#123; name: &#x27;userCenter&#x27;, query: &#123; id: id &#125; &#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用路由懒加载（延迟加载）机制</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path: &#x27;/uploadAttachment&#x27;,</span><br><span class=\"line\">    name: &#x27;uploadAttachment&#x27;,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &#x27;上传附件&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    component: () =&gt; import(&#x27;@/view/components/uploadAttachment/index.vue&#x27;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>router 中的命名规范<br>path、childrenPoints 命名规范采用 kebab-case 命名规范（尽量 vue 文件的目录结构保持一致，因为目录、文件名都是 kebab-case，这样很方便找到对应的文件）</li>\n</ol>\n<p>name 命名规范采用 KebabCase 命名规范且和 component 组件名保持一致！（因为要保持 keep-alive 特性，keep-alive 按照 component 的 name 进行缓存，所以两者必须高度保持一致）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 动态加载</span><br><span class=\"line\">export const reload = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/reload&#x27;,</span><br><span class=\"line\">    name: &#x27;reload&#x27;,</span><br><span class=\"line\">    component: Main,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &#x27;动态加载&#x27;,</span><br><span class=\"line\">      icon: &#x27;icon iconfont&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;/reload/smart-reload-list&#x27;,</span><br><span class=\"line\">        name: &#x27;SmartReloadList&#x27;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &#x27;SmartReload&#x27;,</span><br><span class=\"line\">          childrenPoints: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              title: &#x27;查询&#x27;,</span><br><span class=\"line\">              name: &#x27;smart-reload-search&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              title: &#x27;执行reload&#x27;,</span><br><span class=\"line\">              name: &#x27;smart-reload-update&#x27;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              title: &#x27;查看执行结果&#x27;,</span><br><span class=\"line\">              name: &#x27;smart-reload-result&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        component: () =&gt;</span><br><span class=\"line\">          import(&#x27;@/views/reload/smart-reload/smart-reload-list.vue&#x27;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>router 中的 path 命名规范<br>path 除了采用 kebab-case 命名规范以外，必须以 &#x2F; 开头，即使是 children 里的 path 也要以 &#x2F; 开头。如下示例</li>\n</ol>\n<p>目的：</p>\n<p>经常有这样的场景：某个页面有问题，要立刻找到这个 vue 文件，如果不用以&#x2F;开头，path 为 parent 和 children 组成的，可能经常需要在 router 文件里搜索多次才能找到，而如果以&#x2F;开头，则能立刻搜索到对应的组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path: &#x27;/file&#x27;,</span><br><span class=\"line\">    name: &#x27;File&#x27;,</span><br><span class=\"line\">    component: Main,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &#x27;文件服务&#x27;,</span><br><span class=\"line\">      icon: &#x27;ios-cloud-upload&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;/file/file-list&#x27;,</span><br><span class=\"line\">        name: &#x27;FileList&#x27;,</span><br><span class=\"line\">        component: () =&gt; import(&#x27;@/views/file/file-list.vue&#x27;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;/file/file-add&#x27;,</span><br><span class=\"line\">        name: &#x27;FileAdd&#x27;,</span><br><span class=\"line\">        component: () =&gt; import(&#x27;@/views/file/file-add.vue&#x27;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;/file/file-update&#x27;,</span><br><span class=\"line\">        name: &#x27;FileUpdate&#x27;,</span><br><span class=\"line\">        component: () =&gt; import(&#x27;@/views/file/file-update.vue&#x27;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二-Vue-项目目录规范\"><a href=\"#二-Vue-项目目录规范\" class=\"headerlink\" title=\"(二) Vue 项目目录规范\"></a>(二) Vue 项目目录规范</h3><h4 id=\"2-2-1-基础\"><a href=\"#2-2-1-基础\" class=\"headerlink\" title=\"2.2.1 基础\"></a>2.2.1 基础</h4><p>vue 项目中的所有命名一定要与后端命名统一。</p>\n<p>比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！</p>\n<h4 id=\"2-2-2-使用-Vue-cli-脚手架\"><a href=\"#2-2-2-使用-Vue-cli-脚手架\" class=\"headerlink\" title=\"2.2.2 使用 Vue-cli 脚手架\"></a>2.2.2 使用 Vue-cli 脚手架</h4><p>使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。</p>\n<h4 id=\"2-2-3-目录说明\"><a href=\"#2-2-3-目录说明\" class=\"headerlink\" title=\"2.2.3 目录说明\"></a>2.2.3 目录说明</h4><p>目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">src                               源码目录</span><br><span class=\"line\">|-- api                              所有api接口</span><br><span class=\"line\">|-- assets                           静态资源，images, icons, styles等</span><br><span class=\"line\">|-- components                       公用组件</span><br><span class=\"line\">|-- config                           配置信息</span><br><span class=\"line\">|-- constants                        常量信息，项目所有Enum, 全局常量等</span><br><span class=\"line\">|-- directives                       自定义指令</span><br><span class=\"line\">|-- filters                          过滤器，全局工具</span><br><span class=\"line\">|-- datas                            模拟数据，临时存放</span><br><span class=\"line\">|-- lib                              外部引用的插件存放及修改文件</span><br><span class=\"line\">|-- mock                             模拟接口，临时存放</span><br><span class=\"line\">|-- plugins                          插件，全局使用</span><br><span class=\"line\">|-- router                           路由，统一管理</span><br><span class=\"line\">|-- store                            vuex, 统一管理</span><br><span class=\"line\">|-- themes                           自定义样式主题</span><br><span class=\"line\">|-- views                            视图目录</span><br><span class=\"line\">|   |-- role                             role模块名</span><br><span class=\"line\">|   |-- |-- role-list.vue                    role列表页面</span><br><span class=\"line\">|   |-- |-- role-add.vue                     role新建页面</span><br><span class=\"line\">|   |-- |-- role-update.vue                  role更新页面</span><br><span class=\"line\">|   |-- |-- index.less                      role模块样式</span><br><span class=\"line\">|   |-- |-- components                      role模块通用组件文件夹</span><br><span class=\"line\">|   |-- employee                         employee模块</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>api 目录</li>\n</ol>\n<ul>\n<li>文件、变量命名要与后端保持一致。</li>\n<li>此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。</li>\n<li>api 中的方法名字要与后端 api url 尽量保持语义高度一致性。</li>\n<li>对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。<br>正例：</li>\n</ul>\n<p>后端 url： EmployeeController.java</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/employee/add</span><br><span class=\"line\">/employee/delete/&#123;id&#125;</span><br><span class=\"line\">/employee/update</span><br></pre></td></tr></table></figure>\n\n<p>前端： employee.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 添加员工</span><br><span class=\"line\">addEmployee: (data) =&gt; &#123;</span><br><span class=\"line\">    return postAxios(&#x27;/employee/add&#x27;, data)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 更新员工信息</span><br><span class=\"line\">updateEmployee: (data) =&gt; &#123;</span><br><span class=\"line\">    return postAxios(&#x27;/employee/update&#x27;, data)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// 删除员工</span><br><span class=\"line\">deleteEmployee: (employeeId) =&gt; &#123;</span><br><span class=\"line\">    return postAxios(&#x27;/employee/delete/&#x27; + employeeId)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>assets 目录<br>assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|assets</span><br><span class=\"line\">|-- icons</span><br><span class=\"line\">|-- images</span><br><span class=\"line\">|   |-- background-color.png</span><br><span class=\"line\">|   |-- upload-header.png</span><br><span class=\"line\">|-- styles</span><br><span class=\"line\">3) components 目录</span><br><span class=\"line\">此目录应按照组件进行目录划分，目录命名为 KebabCase，组件命名规则也为 KebabCase</span><br><span class=\"line\"></span><br><span class=\"line\">|components</span><br><span class=\"line\">|-- error-log</span><br><span class=\"line\">|   |-- index.vue</span><br><span class=\"line\">|   |-- index.less</span><br><span class=\"line\">|-- markdown-editor</span><br><span class=\"line\">|   |-- index.vue</span><br><span class=\"line\">|   |-- index.js</span><br><span class=\"line\">|-- kebab-case</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>constants 目录<br>此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件(<a href=\"https://www.npmjs.com/package/vue-enum\">https://www.npmjs.com/package/vue-enum</a>)</li>\n</ol>\n<p>目录结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|constants</span><br><span class=\"line\">|-- index.js</span><br><span class=\"line\">|-- role.js</span><br><span class=\"line\">|-- employee.js</span><br></pre></td></tr></table></figure>\n\n<p>例子： employee.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export const EMPLOYEE_STATUS = &#123;</span><br><span class=\"line\">  NORMAL: &#123;</span><br><span class=\"line\">    value: 1,</span><br><span class=\"line\">    desc: &#x27;正常&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  DISABLED: &#123;</span><br><span class=\"line\">    value: 1,</span><br><span class=\"line\">    desc: &#x27;禁用&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  DELETED: &#123;</span><br><span class=\"line\">    value: 2,</span><br><span class=\"line\">    desc: &#x27;已删除&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const EMPLOYEE_ACCOUNT_TYPE = &#123;</span><br><span class=\"line\">  QQ: &#123;</span><br><span class=\"line\">    value: 1,</span><br><span class=\"line\">    desc: &#x27;QQ登录&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  WECHAT: &#123;</span><br><span class=\"line\">    value: 2,</span><br><span class=\"line\">    desc: &#x27;微信登录&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  DINGDING: &#123;</span><br><span class=\"line\">    value: 3,</span><br><span class=\"line\">    desc: &#x27;钉钉登录&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  USERNAME: &#123;</span><br><span class=\"line\">    value: 4,</span><br><span class=\"line\">    desc: &#x27;用户名密码登录&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  EMPLOYEE_STATUS,</span><br><span class=\"line\">  EMPLOYEE_ACCOUNT_TYPE</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>router 与 store 目录<br>这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。</li>\n</ol>\n<p>router 尽量按照 views 中的结构保持一致</p>\n<p>store 按照业务进行拆分不同的 js 文件</p>\n<ol start=\"6\">\n<li>views 目录</li>\n</ol>\n<ul>\n<li>命名要与后端、router、api 等保持一致</li>\n<li>components 中组件要使用 PascalCase 规则</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|-- views                            视图目录</span><br><span class=\"line\">|   |-- role                             role模块名</span><br><span class=\"line\">|   |   |-- role-list.vue                    role列表页面</span><br><span class=\"line\">|   |   |-- role-add.vue                     role新建页面</span><br><span class=\"line\">|   |   |-- role-update.vue                  role更新页面</span><br><span class=\"line\">|   |   |-- index.less                      role模块样式</span><br><span class=\"line\">|   |   |-- components                      role模块通用组件文件夹</span><br><span class=\"line\">|   |   |   |-- role-header.vue                        role头部组件</span><br><span class=\"line\">|   |   |   |-- role-modal.vue                         role弹出框组件</span><br><span class=\"line\">|   |-- employee                         employee模块</span><br><span class=\"line\">|   |-- behavior-log                      行为日志log模块</span><br><span class=\"line\">|   |-- code-generator                    代码生成器模块</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-4-注释说明\"><a href=\"#2-2-4-注释说明\" class=\"headerlink\" title=\"2.2.4 注释说明\"></a>2.2.4 注释说明</h4><p>整理必须加注释的地方</p>\n<ul>\n<li>公共组件使用说明</li>\n<li>api 目录的接口 js 文件必须加注释</li>\n<li>store 中的 state, mutation, action 等必须加注释</li>\n<li>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释</li>\n<li>vue 文件的 methods，每个 method 必须添加注释</li>\n<li>vue 文件的 data, 非常见单词要加注释</li>\n</ul>\n<h4 id=\"2-2-5-其他\"><a href=\"#2-2-5-其他\" class=\"headerlink\" title=\"2.2.5 其他\"></a>2.2.5 其他</h4><ol>\n<li><p>尽量不要手动操作 DOM<br>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。</p>\n</li>\n<li><p>删除无用代码<br>因使用了 git&#x2F;svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p>\n</li>\n</ol>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"前端大厂10道经典面试题汇总","url":"/2022/12/16/%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%8E%8210%E9%81%93%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/","content":"<h2 id=\"1、写一个-js-函数，实现对一个数字每-3-位加一个逗号，如输入-100000，-输出-100-000（不考虑负数，小数）—百度前端面试题\"><a href=\"#1、写一个-js-函数，实现对一个数字每-3-位加一个逗号，如输入-100000，-输出-100-000（不考虑负数，小数）—百度前端面试题\" class=\"headerlink\" title=\"1、写一个 js 函数，实现对一个数字每 3 位加一个逗号，如输入 100000， 输出 100,000（不考虑负数，小数）—百度前端面试题\"></a>1、写一个 js 函数，实现对一个数字每 3 位加一个逗号，如输入 100000， 输出 100,000（不考虑负数，小数）—百度前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let arr = []</span><br><span class=\"line\">function main(num) &#123;</span><br><span class=\"line\">    if (num === null) return</span><br><span class=\"line\">    let n = parseInt(num).toString()</span><br><span class=\"line\">    s(n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function s(num) &#123;</span><br><span class=\"line\">    if (num.length &gt; 3) &#123;</span><br><span class=\"line\">        arr[arr.length] = num.slice(-3)</span><br><span class=\"line\">        s(num.slice(0, -3))</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        arr[arr.length] = num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main(123456789)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(arr.reverse().join(&quot;,&quot;))</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>本题是 js 实现 number.toLocaleString()方法，面试题做了简化不考虑负数小数，此题主要是考数据类型及字符串操作，答案不唯一。</p>\n<p>按现实思路解题，现实中添加千位分隔符是从后到前，每 3 位添加逗号，所以这里输入数据转换成字符串后，利用 slice 方法的输入负数参数从后取的特点，从后取三位数字保存在数组中，并把取剩后的数据递归重复取值，直到数据不足 3 位，把剩下一起存入数组中。</p>\n<p>这时数组中按顺序保存从后到前的分割数据。实例中数组是[‘789’,’456’,’123’]。通过 reverse 方法倒序输出，并通过 join 方法添加逗号。</p>\n<h2 id=\"2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题\"><a href=\"#2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题\" class=\"headerlink\" title=\"2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题\"></a>2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// var lengthOfLongestSubstring = function(s) &#123;</span><br><span class=\"line\">//     let n = s.length;</span><br><span class=\"line\">//     let set = new Set();</span><br><span class=\"line\">//     let ans = 0, i = 0, j = 0;</span><br><span class=\"line\">//     while (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">//         if (!set.has(s[j])) &#123;</span><br><span class=\"line\">//             set.add(s[j++]);</span><br><span class=\"line\">//             ans = Math.max(ans, j - i);</span><br><span class=\"line\">//         &#125; else &#123;</span><br><span class=\"line\">//             set.delete(s[i++]);</span><br><span class=\"line\">//         &#125;</span><br><span class=\"line\">//     &#125;</span><br><span class=\"line\">//     return ans;</span><br><span class=\"line\">// &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//时间复杂度：O(2n) = O(n)O(2n)=O(n)，在最糟糕的情况下，每个字符将被 ii 和 jj 访问两次。</span><br><span class=\"line\">//空间复杂度：O(min(m, n))O(min(m,n))，与之前的方法相同。滑动窗口法需要 O(k)O(k) 的空间，其中 kk 表示 Set 的大小。而Set的大小取决于字符串 nn 的大小以及字符集/字母 mm 的大小。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function StrLen(str) &#123;</span><br><span class=\"line\">    let result = 1    //最终要返回的结果的初始值</span><br><span class=\"line\">    let norepeatStr = &#x27;&#x27; //用于存放无重复字符串</span><br><span class=\"line\">    let len = str.length</span><br><span class=\"line\">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        //charAt()获取的是字符串索引对应的具体字符</span><br><span class=\"line\">        let specStr = str.charAt(i)</span><br><span class=\"line\">        //indexOf()查找的是某个字符第一次出现并返回这个索引值，若没有这个字符，返回-1</span><br><span class=\"line\">        let index = norepeatStr.indexOf(specStr)</span><br><span class=\"line\">        if (index === -1) &#123;</span><br><span class=\"line\">            //将遍历得到的字符（未重复）拼接在norepeatStr后面</span><br><span class=\"line\">            norepeatStr = norepeatStr + specStr</span><br><span class=\"line\">            result = result &lt; norepeatStr.length ? norepeatStr.length : result</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //若遇到重复的字符，那么将已出现在norepeatStr里的字符删除，并将新的（重复的添加到末尾）</span><br><span class=\"line\">            norepeatStr = norepeatStr.substr(index + 1) + specStr</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(StrLen(abbbcbd))</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>这题的要点就是无重复字符的理解。首先字符串内字符位置是固定的，我们要采用顺序循环的方式解题，然后就是理解无重复字符的含义，把当前字符串分割，每个小分割内不能出现重复的字符。也就是说分割的字符串是不会互相叠加重复的，每当该段分割的下一个字符与该段分割内字符相同，当即重新开始分割字符。</p>\n<p>所以解题时需要一个存储当前分割片段的对象，用来比较下一个字符。并取这个分割片段的长度，与每个分割片段的最大长度比较即可。本题主要考的是题面的理解，以及字符串方法的运用，需要熟练地运用才能快速解题。</p>\n<h2 id=\"3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题\"><a href=\"#3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题\" class=\"headerlink\" title=\"3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题\"></a>3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function func() &#123;</span><br><span class=\"line\">    let a = &#x27;333333333333333333333333333&#x27;</span><br><span class=\"line\">    let b = &#x27;9999999999999999999&#x27;</span><br><span class=\"line\">    let n1 = a.length</span><br><span class=\"line\">    let n2 = b.length</span><br><span class=\"line\">    for (let i = 0; i &lt; Math.max(n1, n2) - Math.min(n1, n2); i ++) &#123;</span><br><span class=\"line\">        if (n1 &gt; n2) b = &#x27;0&#x27; + b</span><br><span class=\"line\">        if (n2 &gt; n1) a = &#x27;0&#x27; + a</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a = a.split(&#x27;&#x27;).reverse()</span><br><span class=\"line\">    b = b.split(&#x27;&#x27;).reverse()</span><br><span class=\"line\">    //split()基于指定的分隔符将一个字符串分割成多个子字符串并将结果放在一个数组中</span><br><span class=\"line\">    //reverse()反转数组项的顺序（加法计算顺序）</span><br><span class=\"line\">    //现在a，b数组中存储着相同个数的大数字的逆顺序拆解</span><br><span class=\"line\"></span><br><span class=\"line\">    let n = Math.max(n1, n2)</span><br><span class=\"line\">    let result = Array.apply(this, Array(n)).map((item, i) =&gt; &#123;</span><br><span class=\"line\">        return 0</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    //生成一个长度为n的每个元素都为0的数组（用来保存最终结果）</span><br><span class=\"line\"></span><br><span class=\"line\">    for (let k = 0; k &lt; n; k ++) &#123;</span><br><span class=\"line\">        let temp = parseInt(a[k]) + parseInt(b[k])</span><br><span class=\"line\">        if (temp &gt; 9) &#123;</span><br><span class=\"line\">            result[k] += temp - 10</span><br><span class=\"line\">            result[k+1] = 1</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            result[k] += temp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //把ab数组中的数字相加减，注意进位</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(result.reverse().join(&#x27;&#x27;).toString())</span><br><span class=\"line\">    //将数组项基于指定的分隔符以字符串输出</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>首先了解超出存储范围的大数字概念，每种数据类型可存储数据量都是存在范围的</p>\n<p>数字类型的范围：</p>\n<p>Number.MAX_VALUE &#x3D; 1.7976931348623157e+308</p>\n<p>Number.MIN_VALUE &#x3D; 5e-324</p>\n<p>整数类型的范围：-2-53-253</p>\n<p>当超出这个范围，为了避免数据丢失，就要采用其他手段进行运算。在参考答案中，运用数组的方式解决这个问题。首先两个大整数要存储在数组中，要先保证位数对齐，我们比较字符串长度把低位数的大整数字符串前面添加相应的 0 占位， 并逆排序。创建一个新的数组保存运算结果，将两个大整数按从后到前的顺序进行相加减，这里注意进位。把得到的数组反转到正常顺序即可。</p>\n<h2 id=\"4、任意数组的全排列组合—阿里巴巴前端面试题\"><a href=\"#4、任意数组的全排列组合—阿里巴巴前端面试题\" class=\"headerlink\" title=\"4、任意数组的全排列组合—阿里巴巴前端面试题\"></a>4、任意数组的全排列组合—阿里巴巴前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;hello&#x27;,&#x27;world&#x27;];</span><br><span class=\"line\">var count = 1;</span><br><span class=\"line\">function getStr(a)&#123;</span><br><span class=\"line\">\tfor (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">\t\t// indexOf 是es6数组的方法,如果不存在返回-1，存在返回下标</span><br><span class=\"line\">\t\tif(a.indexOf(arr[i])&lt;0)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//数组 a 中不存在 arr[i],将arr[i]添加到数组末尾</span><br><span class=\"line\">\t\t\ta.push(arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif(a.length==arr.length)&#123;</span><br><span class=\"line\">\t\t\t\tconsole.log(count++ + &#x27;: &#x27; +a.join(&quot;&quot;));</span><br><span class=\"line\">\t\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t\t//结束一次for循环  进行了4次递归 getStr([&#x27;foo&#x27;]) getStr([&#x27;bar&#x27;]) getStr([&#x27;hello&#x27;]) getStr([&#x27;world&#x27;])</span><br><span class=\"line\">\t\t\t\tgetStr(a);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//一定从数组 a 中删除arr[i],进行下次循环，如果不删除就只能获得一种结果了</span><br><span class=\"line\">\t\t\ta.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getStr([])</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>本题做法不唯一，这里采用了把多项数组逐步两两相乘的方式，第一次先取二维数组前两项组合，把组合的结果在与第三项组合以此类推。这种递归做法简单易懂，把复杂的多项问题简化成两项问题的逐渐递增。</p>\n<h2 id=\"5、公司最近新研发了一种产品，共生产了-n-件。有-m-个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题\"><a href=\"#5、公司最近新研发了一种产品，共生产了-n-件。有-m-个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题\" class=\"headerlink\" title=\"5、公司最近新研发了一种产品，共生产了 n 件。有 m 个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题\"></a>5、公司最近新研发了一种产品，共生产了 n 件。有 m 个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let n = 3</span><br><span class=\"line\">let m = 4</span><br><span class=\"line\">let arr = [2, 8, 10, 7]</span><br><span class=\"line\">let key = 0, max = 0</span><br><span class=\"line\">arr = arr.sort( (a, b) =&gt; &#123;</span><br><span class=\"line\">    return a - b   //升序</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">if (n &lt; m) &#123;</span><br><span class=\"line\">    arr = arr.slice(m - n)  //截取出价高的人</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for (let i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class=\"line\">    if (max &lt; arr[i] * (arr.length - i)) &#123;</span><br><span class=\"line\">        max = arr[i] * (arr.length - i)</span><br><span class=\"line\">        key = arr[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(key)</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>本题是京东的业务演变题，首先要理清思路。本题中，固定出价，以及出价低于产品的顾客会被拒绝购买是解题核心。</p>\n<p>条件中已知产品总个数，顾客出价。这里有个小陷阱，会出现 N&lt;M 供不应求的情况，要特殊考虑。依据题目，我们首先需要对顾客出价排序，这里按升序排列。当供不应求出现时，我们截取出价高的顾客。然后把每个顾客的出价当做最终售价循环，得出最大化利润下的售价。</p>\n<h2 id=\"6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题\"><a href=\"#6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题\" class=\"headerlink\" title=\"6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题\"></a>6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let s = &#x27;asdaaaaaad&#x27;</span><br><span class=\"line\">let count = 0, char = &#x27;&#x27;         //count出现次数 char字符</span><br><span class=\"line\">let arr = []        // 储存去重后字符</span><br><span class=\"line\">function foo(str) &#123;         // 去重</span><br><span class=\"line\">    return r = str.split(&quot;&quot;).filter(function (element, index, self) &#123;</span><br><span class=\"line\">        return self.indexOf(element) === index     // 输出第一次出现的字符</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">arr = foo(s)</span><br><span class=\"line\">for (let i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class=\"line\">    let n = (s.split(arr[i])).length - 1           //出现次数</span><br><span class=\"line\">    if (count &lt; n) &#123;</span><br><span class=\"line\">        count = n</span><br><span class=\"line\">        char = arr[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&quot;count:&quot; + count + &quot;,char:&quot; + char)</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>计算出全部字符出现次数，并留下最大的。首先利用 filter()与 indexOf()的方法连用字符串去重，再将得到的作为索引，利用 split()分割字符串，得到字符出现次数，比较得出结果。</p>\n<h2 id=\"7、”123456789876543212345678987654321…”的第-n-位是什么？—小米面试题\"><a href=\"#7、”123456789876543212345678987654321…”的第-n-位是什么？—小米面试题\" class=\"headerlink\" title=\"7、”123456789876543212345678987654321…”的第 n 位是什么？—小米面试题\"></a>7、”123456789876543212345678987654321…”的第 n 位是什么？—小米面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let k = &quot;1234567898765432&quot;  //最小循环节</span><br><span class=\"line\">function getNum(n) &#123;</span><br><span class=\"line\">    console.log(k.charAt(n % k.length - 1))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getNum(20)</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>这道题的答案不唯一，这里可以利用数学中最小循环节的概念解题，找到最小循环节后，利用余数查找第 n 位数字。</p>\n<h2 id=\"8、请编写一个-JavaScript-函数-parseQueryString，它的用途是把-URL-参数解析为一个对象—淘宝面试题\"><a href=\"#8、请编写一个-JavaScript-函数-parseQueryString，它的用途是把-URL-参数解析为一个对象—淘宝面试题\" class=\"headerlink\" title=\"8、请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象—淘宝面试题\"></a>8、请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象—淘宝面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function parseQueryString(url) &#123;</span><br><span class=\"line\">  var pos = url.indexOf(&quot;?&quot;)</span><br><span class=\"line\">  var obj = &#123;&#125;</span><br><span class=\"line\">  if (pos != -1) &#123;</span><br><span class=\"line\">    var urlString=url.slice(pos+1)</span><br><span class=\"line\">    var urlArr = urlString.split(&quot;&amp;&quot;)</span><br><span class=\"line\">    var keyValue = []</span><br><span class=\"line\">    for (var i = 0; i &lt; urlArr.length; i++) &#123;</span><br><span class=\"line\">      keyValue = urlArr[i].split(&quot;=&quot;)</span><br><span class=\"line\">      obj[keyValue[0]]=keyValue[1]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>淘宝这道题是很常用的场景题，这里需要处理好分段次序，首先把？分离，然后按&amp;分割最后按&#x3D;分割，主要考察字符串的函数运用以及对象的创建。</p>\n<h2 id=\"9、如果给定的字符串是回文，返回-true，反之，返回-false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是-palindrome-回文-。—网易前端面试题\"><a href=\"#9、如果给定的字符串是回文，返回-true，反之，返回-false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是-palindrome-回文-。—网易前端面试题\" class=\"headerlink\" title=\"9、如果给定的字符串是回文，返回 true，反之，返回 false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是 palindrome(回文)。—网易前端面试题\"></a>9、如果给定的字符串是回文，返回 true，反之，返回 false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是 palindrome(回文)。—网易前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function palindrome(str) &#123;</span><br><span class=\"line\">    let str1 = str.replace(/[^0-9a-zA-Z]/g,&quot;&quot;).toLowerCase()  // 去掉标点符号，转化成小写，比较参数一</span><br><span class=\"line\">    let str2 = str1.split(&quot;&quot;).reverse().join(&quot;&quot;)   // 翻转字符串，比较参数二</span><br><span class=\"line\">    if (str1 === str2) &#123;</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125; else return false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(palindrome(&quot;aBc,./1d42--==EFG0 00 h0 &#x27;;00gfE&#x27; ./.24d 1cBA&quot;)) // 输出结果：true</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。</p>\n<h2 id=\"10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题\"><a href=\"#10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题\" class=\"headerlink\" title=\"10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题\"></a>10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function titleCase(str) &#123;</span><br><span class=\"line\">    let aStr = str.toLowerCase().split(&quot; &quot;)   // 转小写，分割成字符串数组</span><br><span class=\"line\">    for (let i = 0; i &lt; aStr.length; i ++) &#123;</span><br><span class=\"line\">        aStr[i] = aStr[i][0].toUpperCase() + aStr[i].slice(1) // 重新组合字符串元素</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let oString = aStr.join(&quot; &quot;)  //转成字符串</span><br><span class=\"line\">    return oString</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(titleCase(&quot;I&#x27;m a title Case&quot;)) // 输出结果为 I&#x27;m A Title Case</span><br></pre></td></tr></table></figure>\n\n<p>解题思路<br>字符串转化成小写；<br>分割成字符串数组；<br>新组合字符串元素&#x3D;首字母转大写+其余小写。</p>\n<p><a href=\"https://github.com/guochangxindeGH/LeetCode/tree/master/Algorithms/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB\">代码 github 地址</a></p>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"前端面试中的常见的算法问题","url":"/2022/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/","content":"<h2 id=\"Q1-判断一个单词是否是回文？\"><a href=\"#Q1-判断一个单词是否是回文？\" class=\"headerlink\" title=\"Q1 判断一个单词是否是回文？\"></a>Q1 判断一个单词是否是回文？</h2><blockquote>\n<p>回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider .</p>\n</blockquote>\n<p>很多人拿到这样的题目非常容易想到用 for 将字符串颠倒字母顺序然后匹配就行了。其实重要的考察的就是对于 reverse 的实现。其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function checkPalindrom(str) &#123;</span><br><span class=\"line\">    return str == str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q2-去掉一组整型数组重复的值\"><a href=\"#Q2-去掉一组整型数组重复的值\" class=\"headerlink\" title=\"Q2 去掉一组整型数组重复的值\"></a>Q2 去掉一组整型数组重复的值</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">比如输入: [1,13,24,11,11,14,1,2]</span><br><span class=\"line\">输出: [1,13,24,11,14,2]</span><br><span class=\"line\">需要去掉重复的11 和 1 这两个元素。</span><br></pre></td></tr></table></figure>\n\n<p>这道问题出现在诸多的前端面试题中，主要考察个人对 Object 的使用，利用 key 来进行筛选。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* unique an array</span><br><span class=\"line\">**/</span><br><span class=\"line\">let unique = function(arr) &#123;</span><br><span class=\"line\">  let hashTable = &#123;&#125;;</span><br><span class=\"line\">  let data = [];</span><br><span class=\"line\">  for(let i=0,l=arr.length;i&lt;l;i++) &#123;</span><br><span class=\"line\">    if(!hashTable[arr[i]]) &#123;</span><br><span class=\"line\">      hashTable[arr[i]] = true;</span><br><span class=\"line\">      data.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return data</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = unique;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q3-统计一个字符串出现最多的字母\"><a href=\"#Q3-统计一个字符串出现最多的字母\" class=\"headerlink\" title=\"Q3 统计一个字符串出现最多的字母\"></a>Q3 统计一个字符串出现最多的字母</h2><p>给出一段英文连续的英文字符串，找出重复出现次数最多的字母</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入 ： afjghdfraaaasdenas</span><br><span class=\"line\"></span><br><span class=\"line\">输出 ： a</span><br></pre></td></tr></table></figure>\n\n<p>前面出现过去重的算法，这里需要是统计重复次数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function findMaxDuplicateChar(str) &#123;</span><br><span class=\"line\">  if(str.length == 1) &#123;</span><br><span class=\"line\">    return str;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let charObj = &#123;&#125;;</span><br><span class=\"line\">  for(let i=0;i&lt;str.length;i++) &#123;</span><br><span class=\"line\">    if(!charObj[str.charAt(i)]) &#123;</span><br><span class=\"line\">      charObj[str.charAt(i)] = 1;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">      charObj[str.charAt(i)] += 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let maxChar = &#x27;&#x27;,</span><br><span class=\"line\">      maxValue = 1;</span><br><span class=\"line\">  for(var k in charObj) &#123;</span><br><span class=\"line\">    if(charObj[k] &gt;= maxValue) &#123;</span><br><span class=\"line\">      maxChar = k;</span><br><span class=\"line\">      maxValue = charObj[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return maxChar;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = findMaxDuplicateChar;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q4-排序算法\"><a href=\"#Q4-排序算法\" class=\"headerlink\" title=\"Q4 排序算法\"></a>Q4 排序算法</h2><p>如果抽到算法题目的话，应该大多都是比较开放的题目，不限定算法的实现，但是一定要求掌握其中的几种，所以冒泡排序，这种较为基础并且便于理解记忆的算法一定需要熟记于心。冒泡排序算法就是依次比较大小，小的的大的进行位置上的交换。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function bubbleSort(arr) &#123;</span><br><span class=\"line\">    for(let i = 0,l=arr.length;i&lt;l-1;i++) &#123;</span><br><span class=\"line\">        for(let j = i+1;j&lt;l;j++) &#123;</span><br><span class=\"line\">          if(arr[i]&gt;arr[j]) &#123;</span><br><span class=\"line\">                let tem = arr[i];</span><br><span class=\"line\">                arr[i] = arr[j];</span><br><span class=\"line\">                arr[j] = tem;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = bubbleSort;</span><br></pre></td></tr></table></figure>\n\n<p>除了冒泡排序外，其实还有很多诸如 插入排序,快速排序，希尔排序等。每一种排序算法都有各自的特点。全部掌握也不需要，但是心底一定要熟悉几种算法。 比如快速排序，其效率很高，而其基本原理如图(来自 wiki)：</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif\" alt=\"image\"></p>\n<p>算法参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function quickSort(arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if(arr.length&lt;=1) &#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    let leftArr = [];</span><br><span class=\"line\">    let rightArr = [];</span><br><span class=\"line\">    let q = arr[0];</span><br><span class=\"line\">    for(let i = 1,l=arr.length; i&lt;l; i++) &#123;</span><br><span class=\"line\">        if(arr[i]&gt;q) &#123;</span><br><span class=\"line\">            rightArr.push(arr[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            leftArr.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return [].concat(quickSort(leftArr),[q],quickSort(rightArr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = quickSort;</span><br></pre></td></tr></table></figure>\n\n<p>安利大家一个学习的地址，通过动画演示算法的实现。<br><a href=\"http://math.hws.edu/eck/jsdemo/sortlab.html\">HTML5 Canvas Demo: Sorting Algorithms</a></p>\n<h2 id=\"Q5-不借助临时变量，进行两个整数的交换\"><a href=\"#Q5-不借助临时变量，进行两个整数的交换\" class=\"headerlink\" title=\"Q5 不借助临时变量，进行两个整数的交换\"></a>Q5 不借助临时变量，进行两个整数的交换</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入 a = 2, b = 4 输出 a = 4, b =2</span><br></pre></td></tr></table></figure>\n\n<p>这种问题非常巧妙，需要大家跳出惯有的思维，利用 a , b 进行置换。</p>\n<p>主要是利用 + - 去进行运算，类似 a &#x3D; a + ( b - a) 实际上等同于最后 的 a &#x3D; b;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function swap(a , b) &#123;</span><br><span class=\"line\">  b = b - a;</span><br><span class=\"line\">  a = a + b;</span><br><span class=\"line\">  b = a - b;</span><br><span class=\"line\">  return [a,b];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = swap;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q6-使用-canvas-绘制一个有限度的斐波那契数列的曲线？\"><a href=\"#Q6-使用-canvas-绘制一个有限度的斐波那契数列的曲线？\" class=\"headerlink\" title=\"Q6 使用 canvas 绘制一个有限度的斐波那契数列的曲线？\"></a>Q6 使用 canvas 绘制一个有限度的斐波那契数列的曲线？</h2><p><img src=\"http://img1.vued.vanthink.cn/vued90edf7b944ec479ee8b4203cf56e158d.png\" alt=\"image\"></p>\n<p>数列长度限定在 9.</p>\n<p>斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列主要考察递归的调用。我们一般都知道定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fibo[i] = fibo[i-1]+fibo[i-2];</span><br></pre></td></tr></table></figure>\n\n<p>生成斐波那契数组的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getFibonacci(n) &#123;</span><br><span class=\"line\">  var fibarr = [];</span><br><span class=\"line\">  var i = 0;</span><br><span class=\"line\">  while(i&lt;n) &#123;</span><br><span class=\"line\">    if(i&lt;=1) &#123;</span><br><span class=\"line\">      fibarr.push(i);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">      fibarr.push(fibarr[i-1] + fibarr[i-2])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return fibarr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>剩余的工作就是利用 canvas arc 方法进行曲线绘制了</p>\n<p><a href=\"http://codepen.io/Jack_Pu/pen/LRaxZB\">DEMO</a></p>\n<h2 id=\"Q7-找出下列正数组的最大差值比如\"><a href=\"#Q7-找出下列正数组的最大差值比如\" class=\"headerlink\" title=\"Q7 找出下列正数组的最大差值比如:\"></a>Q7 找出下列正数组的最大差值比如:</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入 [10,5,11,7,8,9]</span><br><span class=\"line\"></span><br><span class=\"line\">输出 6</span><br></pre></td></tr></table></figure>\n\n<p>这是通过一道题目去测试对于基本的数组的最大值的查找，很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getMaxProfit(arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var minPrice = arr[0];</span><br><span class=\"line\">    var maxProfit = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        var currentPrice = arr[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        minPrice = Math.min(minPrice, currentPrice);</span><br><span class=\"line\"></span><br><span class=\"line\">        var potentialProfit = currentPrice - minPrice;</span><br><span class=\"line\"></span><br><span class=\"line\">        maxProfit = Math.max(maxProfit, potentialProfit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return maxProfit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q8-随机生成指定长度的字符串\"><a href=\"#Q8-随机生成指定长度的字符串\" class=\"headerlink\" title=\"Q8 随机生成指定长度的字符串\"></a>Q8 随机生成指定长度的字符串</h2><p>实现一个算法，随机生成指定长度的字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">比如给定 长度 8  输出 4ldkfg9j</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function randomString(n) &#123;</span><br><span class=\"line\">  let str = &#x27;abcdefghijklmnopqrstuvwxyz9876543210&#x27;;</span><br><span class=\"line\">  let tmp = &#x27;&#x27;,</span><br><span class=\"line\">      i = 0,</span><br><span class=\"line\">      l = str.length;</span><br><span class=\"line\">  for (i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">    tmp += str.charAt(Math.floor(Math.random() * l));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = randomString;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q9-实现类似-getElementsByClassName-的功能\"><a href=\"#Q9-实现类似-getElementsByClassName-的功能\" class=\"headerlink\" title=\"Q9 实现类似 getElementsByClassName 的功能\"></a>Q9 实现类似 getElementsByClassName 的功能</h2><p>自己实现一个函数，查找某个 DOM 节点下面的包含某个 class 的所有 DOM 节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供 DOM 查找函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function queryClassName(node, name) &#123;</span><br><span class=\"line\">  var starts = &#x27;(^|[ \\n\\r\\t\\f])&#x27;,</span><br><span class=\"line\">       ends = &#x27;([ \\n\\r\\t\\f]|$)&#x27;;</span><br><span class=\"line\">  var array = [],</span><br><span class=\"line\">        regex = new RegExp(starts + name + ends),</span><br><span class=\"line\">        elements = node.getElementsByTagName(&quot;*&quot;),</span><br><span class=\"line\">        length = elements.length,</span><br><span class=\"line\">        i = 0,</span><br><span class=\"line\">        element;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (i &lt; length) &#123;</span><br><span class=\"line\">        element = elements[i];</span><br><span class=\"line\">        if (regex.test(element.className)) &#123;</span><br><span class=\"line\">            array.push(element);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        i += 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q10-使用-JS-实现二叉查找树-Binary-Search-Tree\"><a href=\"#Q10-使用-JS-实现二叉查找树-Binary-Search-Tree\" class=\"headerlink\" title=\"Q10 使用 JS 实现二叉查找树(Binary Search Tree)\"></a>Q10 使用 JS 实现二叉查找树(Binary Search Tree)</h2><p>一般叫全部写完的概率比较少，但是重点考察你对它的理解和一些基本特点的实现。 二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树：</p>\n<ul>\n<li>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>\n<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>\n<li>任意节点的左、右子树也分别为二叉查找树；</li>\n<li>没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。</li>\n</ul>\n<p><img src=\"http://img1.vued.vanthink.cn/vued95685e8f89199babd6273a93651ecd8b.png\" alt=\"image\"></p>\n<p>在写的时候需要足够理解二叉搜素树的特点，需要先设定好每个节点的数据结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Node &#123;</span><br><span class=\"line\">  constructor(data, left, right) &#123;</span><br><span class=\"line\">    this.data = data;</span><br><span class=\"line\">    this.left = left;</span><br><span class=\"line\">    this.right = right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>树是有节点构成，由根节点逐渐延生到各个子节点，因此它具备基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class BinarySearchTree &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.root = null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  insert(data) &#123;</span><br><span class=\"line\">    let n = new Node(data, null, null);</span><br><span class=\"line\">    if (!this.root) &#123;</span><br><span class=\"line\">      return this.root = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let currentNode = this.root;</span><br><span class=\"line\">    let parent = null;</span><br><span class=\"line\">    while (1) &#123;</span><br><span class=\"line\">      parent = currentNode;</span><br><span class=\"line\">      if (data &lt; currentNode.data) &#123;</span><br><span class=\"line\">        currentNode = currentNode.left;</span><br><span class=\"line\">        if (currentNode === null) &#123;</span><br><span class=\"line\">          parent.left = n;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        currentNode = currentNode.right;</span><br><span class=\"line\">        if (currentNode === null) &#123;</span><br><span class=\"line\">          parent.right = n;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  remove(data) &#123;</span><br><span class=\"line\">    this.root = this.removeNode(this.root, data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  removeNode(node, data) &#123;</span><br><span class=\"line\">    if (node == null) &#123;</span><br><span class=\"line\">      return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (data == node.data) &#123;</span><br><span class=\"line\">      // no children node</span><br><span class=\"line\">      if (node.left == null &amp;&amp; node.right == null) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (node.left == null) &#123;</span><br><span class=\"line\">        return node.right;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (node.right == null) &#123;</span><br><span class=\"line\">        return node.left;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      let getSmallest = function(node) &#123;</span><br><span class=\"line\">        if(node.left === null &amp;&amp; node.right == null) &#123;</span><br><span class=\"line\">          return node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(node.left != null) &#123;</span><br><span class=\"line\">          return node.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(node.right !== null) &#123;</span><br><span class=\"line\">          return getSmallest(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      let temNode = getSmallest(node.right);</span><br><span class=\"line\">      node.data = temNode.data;</span><br><span class=\"line\">      node.right = this.removeNode(temNode.right,temNode.data);</span><br><span class=\"line\">      return node;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; else if (data &lt; node.data) &#123;</span><br><span class=\"line\">      node.left = this.removeNode(node.left,data);</span><br><span class=\"line\">      return node;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      node.right = this.removeNode(node.right,data);</span><br><span class=\"line\">      return node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  find(data) &#123;</span><br><span class=\"line\">    var current = this.root;</span><br><span class=\"line\">    while (current != null) &#123;</span><br><span class=\"line\">      if (data == current.data) &#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (data &lt; current.data) &#123;</span><br><span class=\"line\">        current = current.left;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        current = current.right</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return current.data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = BinarySearchTree;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q11-数组全排列\"><a href=\"#Q11-数组全排列\" class=\"headerlink\" title=\"Q11 数组全排列\"></a>Q11 数组全排列</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;hello&#x27;,&#x27;world&#x27;];</span><br><span class=\"line\">var count = 1;</span><br><span class=\"line\">function getStr(a)&#123;</span><br><span class=\"line\">\tfor (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">\t\t// indexOf 是es6数组的方法,如果不存在返回-1，存在返回下标</span><br><span class=\"line\">\t\tif(a.indexOf(arr[i])&lt;0)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//数组 a 中不存在 arr[i],将arr[i]添加到数组末尾</span><br><span class=\"line\">\t\t\ta.push(arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif(a.length==arr.length)&#123;</span><br><span class=\"line\">\t\t\t\tconsole.log(count++ + &#x27;: &#x27; +a.join(&quot;&quot;));</span><br><span class=\"line\">\t\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t\t//结束一次for循环  进行了4次递归 getStr([&#x27;foo&#x27;]) getStr([&#x27;bar&#x27;]) getStr([&#x27;hello&#x27;]) getStr([&#x27;world&#x27;])</span><br><span class=\"line\">\t\t\t\tgetStr(a);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t//一定从数组 a 中删除arr[i],进行下次循环，如果不删除就只能获得一种结果了</span><br><span class=\"line\">\t\t\ta.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getStr([])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>除去注释只用了 15 行代码，通过上面的方法 我们实现了单个数组全排<br><a href=\"http://www.lingchenliang.com/post/134.html\">更多方法阅读</a></p>\n<h2 id=\"Q12-最大连续子序列和\"><a href=\"#Q12-最大连续子序列和\" class=\"headerlink\" title=\"Q12 最大连续子序列和\"></a>Q12 最大连续子序列和</h2><blockquote>\n<p>思路： 比较若干个连续</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 6, -1, 5, 4, -7, 2, 3];</span><br><span class=\"line\">var maxSum = arr[0],</span><br><span class=\"line\">\tsum = arr[0];</span><br><span class=\"line\">for(var i=1;i&lt;arr.length;i++) &#123;</span><br><span class=\"line\">\tif(sum&lt; 0) &#123;</span><br><span class=\"line\">\t\tsum = arr[i];</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tsum += arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif (sum &gt; maxSum) &#123;</span><br><span class=\"line\">\t\tmaxSum = sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> \tconsole.log(sum, maxSum);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(maxSum);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function maxSeq(arr) &#123;</span><br><span class=\"line\">    var sum=arr[0], maxSum = arr[0]</span><br><span class=\"line\"></span><br><span class=\"line\">    for(var i=1; i&lt; arr.length; i++) &#123;</span><br><span class=\"line\">        if (sum &lt; 0) &#123;</span><br><span class=\"line\">            sum = arr[i]</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            sum += arr[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (sum &gt; maxSum) &#123;</span><br><span class=\"line\">            msxSum = sum</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return maxSum</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q13-DOM-遍历深度优先和广度优先算法\"><a href=\"#Q13-DOM-遍历深度优先和广度优先算法\" class=\"headerlink\" title=\"Q13 DOM 遍历深度优先和广度优先算法\"></a>Q13 DOM 遍历深度优先和广度优先算法</h2><h3 id=\"1-深度优先\"><a href=\"#1-深度优先\" class=\"headerlink\" title=\"1. 深度优先\"></a>1. 深度优先</h3><p><img src=\"https://img-blog.csdnimg.cn/20191227181534979.png\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 递归</span><br><span class=\"line\">let arr = []</span><br><span class=\"line\">function deepTraversal(node) &#123;</span><br><span class=\"line\">  if(!node) return;</span><br><span class=\"line\">  arr.push(node)</span><br><span class=\"line\">  for (var i = 0; i&lt; node.children.length; i++) &#123;</span><br><span class=\"line\">    deepTraversal(node.children[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 非递归</span><br><span class=\"line\">let arr =[]</span><br><span class=\"line\">function deepTraversal(node) &#123;</span><br><span class=\"line\">  if(!node) return;</span><br><span class=\"line\">  var stack = [node];</span><br><span class=\"line\">  while (stack.length) &#123;</span><br><span class=\"line\">    var item = stack.shift();</span><br><span class=\"line\">    arr.push(item);</span><br><span class=\"line\">    var children = item.children;</span><br><span class=\"line\">    for (var i = children.length - 1; i &gt;= 0 ; i--) &#123;</span><br><span class=\"line\">      stack.unshift(children[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-广度优先\"><a href=\"#2-广度优先\" class=\"headerlink\" title=\"2. 广度优先\"></a>2. 广度优先</h3><p><img src=\"https://img-blog.csdnimg.cn/2019122718211761.png\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 递归</span><br><span class=\"line\">let nodes = []; //nodes可放函数中</span><br><span class=\"line\">let i = 0;</span><br><span class=\"line\">function wideTraversal(node) &#123;</span><br><span class=\"line\">  if (node) &#123;</span><br><span class=\"line\">    nodes.push(node);</span><br><span class=\"line\">    wideTraversal(node.nextElementSibling);</span><br><span class=\"line\">    node = nodes[i++];</span><br><span class=\"line\">    wideTraversal(node.firstElementChild);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wideTraversal(rootElement);</span><br><span class=\"line\">console.log(nodes);</span><br><span class=\"line\"></span><br><span class=\"line\">let nodes = [rootElement]; //nodes可放函数中</span><br><span class=\"line\">let stack = []</span><br><span class=\"line\">function wideTraversal(node) &#123;</span><br><span class=\"line\">  if (node) &#123;</span><br><span class=\"line\">    for(var i =0; i&lt; node.children.length; i++) &#123;</span><br><span class=\"line\">      nodes.push(node.children[i]);</span><br><span class=\"line\">      stack.push(node.children[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wideTraversal(stack.shift())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wideTraversal(rootElement);</span><br><span class=\"line\"></span><br><span class=\"line\">// 非递归  先进先出</span><br><span class=\"line\">let arr = [];</span><br><span class=\"line\">let stack = [rootElement]</span><br><span class=\"line\">function wideTraversal(node) &#123;</span><br><span class=\"line\">  while(stack.length) &#123;</span><br><span class=\"line\">    let item = stack.shift()</span><br><span class=\"line\">    arr.push(item)</span><br><span class=\"line\">    for (var i = 0; i &lt; item.children.length;i++) &#123;</span><br><span class=\"line\">      stack.push(item.children[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wideTraversal(rootElement);</span><br><span class=\"line\">console.log(arr);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q14-JS-洗牌算法\"><a href=\"#Q14-JS-洗牌算法\" class=\"headerlink\" title=\"Q14 JS 洗牌算法\"></a>Q14 JS 洗牌算法</h2><p>塔罗牌</p>\n<p>举例来说，我们有一个如下图所示的数组，数组长度为 9，数组内元素的值顺次分别是 1~9：</p>\n<p><img src=\"https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/yrpGxAD5lVSqbjgJL7E1BPzC83gibLVIHoa9RjVrBUFdCfoSJUsVXhs4CNROkszm8eibymxzR60nra3UOJwavWYg/640?wx_fmt=png\" alt=\"image\"></p>\n<p>从上面这个数组入手，我们要做的就是打乱数组内元素的顺序：</p>\n<p><img src=\"https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/yrpGxAD5lVSqbjgJL7E1BPzC83gibLVIHR4BDaN36lLZU1BPDTjkvHqqo9aiaK1icRd7Y7riaofelVqiabdF8y6wHKA/640?wx_fmt=png\" alt=\"image\"></p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.prototype.shuffle = function () &#123;</span><br><span class=\"line\">    let input = this;</span><br><span class=\"line\">    for (let i = input.length - 1; i&gt;= 0; i--) &#123;</span><br><span class=\"line\">        let randomIndex = Math.floor(Math.random() * (i + 1));</span><br><span class=\"line\">        let itemAtIndex = input[randomIndex];</span><br><span class=\"line\">        input[randomIndex] = input[i];</span><br><span class=\"line\">        input[i] = itemAtIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们创建了一个 shuffle() 方法，该方法用于随机排列数组内的元素。</p>\n<p>此外，我们将该方法挂载在了 Array 对象的原型下面，所以任何数组都可以直接调用该方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let tempArray = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</span><br><span class=\"line\">tempArray.shuffle();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q15-假设现在有两个函数-function-A-和-function-B-，现在希望创建一个新的函数-function-C-，新函数的逻辑是将自己接收到的前两个参数传给函数-A，剩余所有参数传给函数-B，请用原生-javascript-实现函数-C\"><a href=\"#Q15-假设现在有两个函数-function-A-和-function-B-，现在希望创建一个新的函数-function-C-，新函数的逻辑是将自己接收到的前两个参数传给函数-A，剩余所有参数传给函数-B，请用原生-javascript-实现函数-C\" class=\"headerlink\" title=\"Q15 假设现在有两个函数 function A()和 function B()，现在希望创建一个新的函数 function C()，新函数的逻辑是将自己接收到的前两个参数传给函数 A，剩余所有参数传给函数 B，请用原生 javascript 实现函数 C\"></a>Q15 假设现在有两个函数 function A()和 function B()，现在希望创建一个新的函数 function C()，新函数的逻辑是将自己接收到的前两个参数传给函数 A，剩余所有参数传给函数 B，请用原生 javascript 实现函数 C</h2><p>举例：</p>\n<p>如果调用函数 C：C[a,b,c,d,e]</p>\n<p>相当于调用函数 A 和函数 B：A(a,b),B(c,d,e)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function C()&#123;</span><br><span class=\"line\">     var a_args=Array.prototype.slice.call(arguments,0,2);</span><br><span class=\"line\">     var b_args=Array.prototype.slice.call(arguments,2);</span><br><span class=\"line\">     A.apply(this,a_args);</span><br><span class=\"line\">     B.apply(this,b_args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function C(...s)&#123;</span><br><span class=\"line\">      A.call(this,s[0],s[1]);</span><br><span class=\"line\">      B.apply(this,s.slice(2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function C(...s)&#123;</span><br><span class=\"line\">      A.apply(this,s.slice(0,2));</span><br><span class=\"line\">      B.apply(this,s.slice(2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function C()&#123;</span><br><span class=\"line\">   A(arguments[0],arguments[1]);</span><br><span class=\"line\">   B(Array.prototype.slice.call(arguments,2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function C(a1,a2,...args) &#123;</span><br><span class=\"line\">    A(a1,a2)</span><br><span class=\"line\">    B(...args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Array.prototype.slice 表示数组的原型中的 slice 方法。这个 slice 方法返回的是一个 Array 类型的对象。可以把类数组对象转化成真正的数组，与 Array.from 类似。</p>\n<h2 id=\"Q16-请实现以下-template-方法，用于模板解析\"><a href=\"#Q16-请实现以下-template-方法，用于模板解析\" class=\"headerlink\" title=\"Q16 请实现以下 template 方法，用于模板解析\"></a>Q16 请实现以下 template 方法，用于模板解析</h2><p>var compiled &#x3D; template(“hello &lt;%&#x3D;user%&gt;!”);<br>compiled({“user”:”world”}); &#x3D;&gt; hello world!</p>\n<p>var compiled &#x3D; template(“welocm to &lt;%&#x3D;location%&gt;!”);<br>compiled({“location”:”CVTE”}); &#x3D;&gt; welcom to CVTE!;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function template(source)&#123;</span><br><span class=\"line\">   var temp=source;</span><br><span class=\"line\">   return function(obj)&#123;</span><br><span class=\"line\">       for(var prop in obj)&#123;</span><br><span class=\"line\">              var tpl=&quot;&lt;%=&quot;+prop+&quot;%&gt;&quot;;</span><br><span class=\"line\">              temp=temp.replace(tpl,obj[prop]);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       console.log(temp);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q17-写一个函数，将传进去的数组按深度展开\"><a href=\"#Q17-写一个函数，将传进去的数组按深度展开\" class=\"headerlink\" title=\"Q17 写一个函数，将传进去的数组按深度展开\"></a>Q17 写一个函数，将传进去的数组按深度展开</h2><p>例子：<br>list:[1,2,[3,4],[5,6,[7,8],9],10,11]<br/><br>depth 等于 1 时输出<br/><br>depth &#x3D; 1 :[1,2,3,4,5,6,[7,8],9,10,11]</p>\n<p>depth 等于 2 时输出<br/><br>depth &#x3D; 2 :[1,2,3,4,5,6,7,8,9,10,11]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function flattern(array,num = 0) &#123;</span><br><span class=\"line\">\tvar newArray = array;</span><br><span class=\"line\">\tfor(let i = 0; i &lt; num; i ++) &#123;</span><br><span class=\"line\">\t\tnewArray = [].concat(...newArray)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn newArray;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(flattern([1,2,3,[4,5,[6,7]]],2))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q18-实现一个简单的模板引擎\"><a href=\"#Q18-实现一个简单的模板引擎\" class=\"headerlink\" title=\"Q18 实现一个简单的模板引擎\"></a>Q18 实现一个简单的模板引擎</h2><p>例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let template = &#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;;</span><br><span class=\"line\">let data = &#123;</span><br><span class=\"line\">  name: &#x27;姓名&#x27;,</span><br><span class=\"line\">  age: 18</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">render(template, data); // 我是姓名，年龄18，性别undefined</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">方法1：先将模板与数据中均存在的属性替换掉，再将数据中不存在模板中存在的属性设置为undefined</span><br><span class=\"line\">function render(template, data) &#123;</span><br><span class=\"line\">\tfor(let key in data) &#123;</span><br><span class=\"line\">\t\tif(template.indexOf(key)) &#123;</span><br><span class=\"line\">\t\t\tvar reg =new RegExp(&quot;&#123;&#123;&quot; + key + &quot;&#125;&#125;&quot;,&quot;g&quot;);</span><br><span class=\"line\">\t\t\ttemplate = template.replace(reg,data[key])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemplate = template.replace(/\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;/g,&#x27;undefined&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn template;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">方法2 迭代，一个一个替换，注意exec匹配到的第一项是匹配字符串，第二项为分组内的字符串[&#123;&#123;name&#125;&#125;,name]</span><br><span class=\"line\">function render(template, data) &#123;</span><br><span class=\"line\">  const reg = /\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;/; // 模板字符串正则</span><br><span class=\"line\">  if (reg.test(template)) &#123; // 判断模板里是否有模板字符串</span><br><span class=\"line\">    const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段</span><br><span class=\"line\">    template = template.replace(reg, data[name]); // 将第一个模板字符串渲染</span><br><span class=\"line\">    return render(template, data); // 递归的渲染并返回渲染后的结构</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return template; // 如果模板没有模板字符串直接返回</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Q19-动态规划\"><a href=\"#Q19-动态规划\" class=\"headerlink\" title=\"Q19 动态规划\"></a>Q19 动态规划</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。例如，给定三角形：</p>\n<p>[[2],[3,4],[6,5,7],[4,1,8,3]]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p>\n<p>动态规划我个人的理解是：能将一个大问题分解为一个个小问题，并且这些小问题之间有共性能重复调用。那么如何判断这道题是否可以用到动态规划，首先从底往上看，[6,5,7]对应的最小路径很明显可以看出分别是[1,1,3]，那么后两层的最短路径是[7,6,10]，再往上看[3,4]的最短路径也能明显看出是[9,10]，那么 2 对应的最短路径很明显就是 11。其实从这里就能看出每层分析判断的逻辑是一致的。js 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const minimumTotal = triangle =&gt; &#123;</span><br><span class=\"line\">    // es6方法填充数组</span><br><span class=\"line\">    const dp = Array.of(...triangle[triangle.length - 1])</span><br><span class=\"line\">\tfor (let i = dp.length - 2; i &gt;= 0; i--) &#123;</span><br><span class=\"line\">        for (let j = 0; j &lt; triangle[i].length; j++) &#123;</span><br><span class=\"line\">            // 状态转移方程</span><br><span class=\"line\">            dp[j] = Math.min(dp[j], dp[j + 1]) + triangle[i][j]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dp[0]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"如何编写一个d.ts文件","url":"/2022/10/24/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAd-ts%E6%96%87%E4%BB%B6/","content":"<blockquote>\n<p>这篇文章主要讲怎么写一个 typescript 的描述文件（以 d.ts 结尾的文件名，比如 xxx.d.ts)。</p>\n</blockquote>\n<p>总结一下：<br>从类型 type 角度分为：基本类型（string、number、boolean 等）及其混合；复杂类型（class、function、object）及其混合（比如说又是 class 又是 function）。<br>从代码有效范围分为：全局变量、模块变量和又是全局变量又是模块变量的。<br>从定义文件来说：自己写的.d.ts 文件和扩展别人写的.d.ts 文件。<br>以上三个角度，应该覆盖了描述文件的各个方面了。</p>\n<p>2019.09.12 更新说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.增加了用interface的方式声明函数。</span><br><span class=\"line\">2.增加了在使用模块化导入的情况下如何声明全局变量。</span><br></pre></td></tr></table></figure>\n\n<p>2018.12.18 更新说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.增加了全局声明的原理说明。</span><br><span class=\"line\">2.增加了es6的import、export对应的d.ts文件写法。</span><br><span class=\"line\">3.增加了d.ts文件放置位置的说明。</span><br></pre></td></tr></table></figure>\n\n<p>发现了一个关于 typescript 比较好的入门教程：<a href=\"https://ts.xcatliu.com/basics/declaration-files\">https://ts.xcatliu.com/basics...</a>，这是其中的关于描述文件的文档。</p>\n<p>最近开始从 js 转 ts 了。但是要用到一些描述文件（d.ts），常用的比如 jquery 等都可以通过 npm 下载到别人已经写好的<code>npm install @types/jquery</code>。但是还是有一些小众的或者公司内部的公共库或者以前写过的公用 js 代码需要自己手动写描述文件。</p>\n<p>之前也从网上也找了一些资料，但还是看的云里雾里模糊不清，经过一段摸索，将摸索的结果记录下来，也希望可以给别人一个参考。</p>\n<p>如果你只写 js，d.ts 对你来说也是有用的，大部分编辑器能识别 d.ts 文件，当你写 js 代码的时候给你智能提示。效果像这样：</p>\n<p><img src=\"https://segmentfault.com/img/bVDReN?w=594&h=359\" alt=\"image\"></p>\n<p>详情可以看我以前写过的一些文章<a href=\"https://segmentfault.com/a/1190000007110845\">：https://segmentfault.com/a/11...</a></p>\n<p>通常，我们写 js 的时候有两种引入 js 的方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1，在html文件中通过&lt;script&gt;标签全局引入全局变量。</span><br><span class=\"line\">2，通过模块加载器require其他js文件：比如这样var j=require(&#x27;jquery&#x27;)。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"全局类型\"><a href=\"#全局类型\" class=\"headerlink\" title=\"全局类型\"></a>全局类型</h2><p>首先以第一种方式举例。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>比如现在有一个全局变量，那对应的 d.ts 文件里面这样写。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare var aaa:number</span><br></pre></td></tr></table></figure>\n\n<p>其中关键字 declare 表示声明的意思。<strong>在 d.ts 文件里面，在最外层声明变量或者函数或者类要在前面加上这个关键字。在 typescript 的规则里面，如果一个.ts、.d.ts 文件如果没有用到 import 或者 export 语法的话，那么最顶层声明的变量就是全局变量。</strong></p>\n<p>所以我们在这里声明了一个全局变量 aaa,类型是数字类型（number）。当然了也可以是 string 类型或者其他或者：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare var aaa:number|string //注意这里用的是一个竖线表示&quot;或&quot;的意思</span><br></pre></td></tr></table></figure>\n\n<p>如果是常量的话用关键字 const 表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare const max:200</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>由上面的全局变量的写法我们很自然的推断出一个全局函数的写法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** id是用户的id，可以是number或者string */</span><br><span class=\"line\">declare function getName(id:number|string):string</span><br></pre></td></tr></table></figure>\n\n<p>最后的那个 string 表示的是函数的返回值的类型。如果函数没有返回值可以用 void 表示。<br>在 js 里面调用的时候就会提示：</p>\n<p><img src=\"https://segmentfault.com/img/bVLuCP?w=579&h=122\" alt=\"image\"></p>\n<p>我们上面写的注释，写 js 的时候还可以提示。</p>\n<p>有时候同一个函数有若干种写法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXTD?w=431&h=107\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">get(1234)</span><br><span class=\"line\">get(&quot;zhangsan&quot;,18)</span><br></pre></td></tr></table></figure>\n\n<p>那么 d.ts 对应的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare function get(id: string | number): string</span><br><span class=\"line\">declare function get(name:string,age:number): string</span><br></pre></td></tr></table></figure>\n\n<p>如果有些参数可有可无，可以加个?表示非必须。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare function render(callback?:()=&gt;void): string</span><br></pre></td></tr></table></figure>\n\n<p>js 中调用的时候，回调传不传都可以：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">render()</span><br><span class=\"line\"></span><br><span class=\"line\">render(function () &#123;</span><br><span class=\"line\">    alert(&#x27;finish.&#x27;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用-interface-声明函数\"><a href=\"#用-interface-声明函数\" class=\"headerlink\" title=\"用 interface 声明函数\"></a>用 interface 声明函数</h3><p>也可以用 interface 去声明函数类型：</p>\n<p><img src=\"https://segmentfault.com/img/bVbxExG?w=440&h=178\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//Get是一种类型</span><br><span class=\"line\">declare interface Get&#123;</span><br><span class=\"line\">    (id: string): string</span><br><span class=\"line\">    (name:string,age:number):string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//get是Get类型的</span><br><span class=\"line\">declare var get:Get</span><br></pre></td></tr></table></figure>\n\n<p>用起来长这个样子：</p>\n<p><img src=\"https://segmentfault.com/img/bVbxExy?w=432&h=136\" alt=\"image\"></p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3><p>当然除了变量和函数外，我们还有类（class）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare class Person &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    static maxAge: number //静态变量</span><br><span class=\"line\">    static getMaxAge(): number //静态方法</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(name: string, age: number)  //构造函数</span><br><span class=\"line\">    getName(id: number): string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>constructor 表示的是构造方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXy0?w=651&h=91\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bVMXzk?w=524&h=100\" alt=\"image\"></p>\n<p>其中 static 表示静态的意思，用来表示静态变量和静态方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXAV?w=605&h=96\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bVMXAg?w=568&h=112\" alt=\"image\"></p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare namespace OOO&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然了这个对象上面可能有变量，可能有函数可能有类。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare namespace OOO&#123;</span><br><span class=\"line\">    var aaa: number | string</span><br><span class=\"line\">    function getName(id: number | string): string</span><br><span class=\"line\">    class Person &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        static maxAge: number //静态变量</span><br><span class=\"line\">        static getMaxAge(): number //静态方法</span><br><span class=\"line\"></span><br><span class=\"line\">        constructor(name: string, age: number) //构造函数</span><br><span class=\"line\">        getName(id: number): string //实例方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实就是把上面的那些写法放到这个 namespace 包起来的大括号里面，注意括号里面就不需要 declare 关键字了。<br>效果：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXBu?w=525&h=113\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bVMXBv?w=581&h=63\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bVMXBB?w=617&h=125\" alt=\"image\"></p>\n<p>对象里面套对象也是可以的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare namespace OOO&#123;</span><br><span class=\"line\">    var aaa: number | string</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    namespace O2&#123;</span><br><span class=\"line\">        let b:number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXB5?w=547&h=67\" alt=\"image\"></p>\n<h2 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型</h2><p>有时候有些值既是函数又是 class 又是对象的复杂对象。比如我们常用的 jquery 有各种用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">new $()</span><br><span class=\"line\">$.ajax()</span><br><span class=\"line\">$()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"既是函数又是对象\"><a href=\"#既是函数又是对象\" class=\"headerlink\" title=\"既是函数又是对象\"></a>既是函数又是对象</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare function $2(s:string): void</span><br><span class=\"line\"></span><br><span class=\"line\">declare namespace $2&#123;</span><br><span class=\"line\">    let aaa:number</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p>作为函数用：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXJ8?w=273&h=85\" alt=\"image\"></p>\n<p>作为对象用：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXKa?w=540&h=78\" alt=\"image\"></p>\n<p>也就是 ts 会自动把同名的 namespace 和 function 合并到一起。</p>\n<h3 id=\"既是函数，又是类（可以-new-出来），又是对象\"><a href=\"#既是函数，又是类（可以-new-出来），又是对象\" class=\"headerlink\" title=\"既是函数，又是类（可以 new 出来），又是对象\"></a>既是函数，又是类（可以 new 出来），又是对象</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 实例方法</span><br><span class=\"line\">interface People&#123;</span><br><span class=\"line\">    name: string</span><br><span class=\"line\">    age: number</span><br><span class=\"line\">    getName(): string</span><br><span class=\"line\">    getAge():number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface People_Static&#123;</span><br><span class=\"line\">    /** 构造函数 */</span><br><span class=\"line\">    new (name: string, age: number): People</span><br><span class=\"line\">    new (id:number): People</span><br><span class=\"line\"></span><br><span class=\"line\">    /** 作为对象，调用对象上的方法或者变量 */</span><br><span class=\"line\">    staticA():number</span><br><span class=\"line\">    aaa:string</span><br><span class=\"line\"></span><br><span class=\"line\">    /** 作为函数使用 */</span><br><span class=\"line\">    (w:number):number</span><br><span class=\"line\">    (w:string):number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">declare var People:People_Static</span><br></pre></td></tr></table></figure>\n\n<p>ts3.6 增加了新功能，function 声明和 class 声明可以合并了，所以又有了新的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** 作为函数使用 */</span><br><span class=\"line\">declare function People(w: number): number</span><br><span class=\"line\">declare function People(w: string): number</span><br><span class=\"line\"></span><br><span class=\"line\">declare class People &#123;</span><br><span class=\"line\">    /** 构造函数 */</span><br><span class=\"line\">    constructor(name: string, age: number)</span><br><span class=\"line\">    constructor(id: number)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 实例属性和实例方法</span><br><span class=\"line\">    name: string</span><br><span class=\"line\">    age: number</span><br><span class=\"line\">    getName(): string</span><br><span class=\"line\">    getAge(): number</span><br><span class=\"line\"></span><br><span class=\"line\">    /** 作为对象，调用对象上的方法或者变量 */</span><br><span class=\"line\">    static staticA(): number</span><br><span class=\"line\">    static aaa: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 作为对象，调用对象上的方法或者变量 */</span><br><span class=\"line\">declare namespace People &#123;</span><br><span class=\"line\">    export var abc: number</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数用 function，类用 class 声明，复杂对象就用 namespace，这样的对应关系简洁明了。</p>\n<p>效果：</p>\n<p>作为函数使用：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXNA?w=369&h=77\" alt=\"image\"></p>\n<p>类的静态方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXNN?w=595&h=83\" alt=\"image\"></p>\n<p>类的构造函数：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXNB?w=626&h=103\" alt=\"image\"></p>\n<p>类的实例方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXNE?w=508&h=165\" alt=\"image\"></p>\n<h2 id=\"模块化的全局变量\"><a href=\"#模块化的全局变量\" class=\"headerlink\" title=\"模块化的全局变量\"></a>模块化的全局变量</h2><p>这个是怎么回事呢，就是有时候我们定义全局变量的时候需要引入(别人写的)文件，比如这样的，我想声明个全局变量 req：</p>\n<p><img src=\"https://segmentfault.com/img/bVbxEAj?w=526&h=124\" alt=\"image\"></p>\n<p>由于我们当前的 d.ts 文件使用了 import&#x2F;export 语法，那么 ts 编译器就不把我们通过 declare var xxx:yyy 当成了全局变量了，那么我们就需要通过以下的方式声明全局变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; Request,Response&#125; from &#x27;express&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">declare global &#123;</span><br><span class=\"line\">    var req: Request</span><br><span class=\"line\">    var res: Response</span><br><span class=\"line\"></span><br><span class=\"line\">    namespace OOO &#123;</span><br><span class=\"line\">        var a:number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用起来长这个样子：</p>\n<p><img src=\"https://segmentfault.com/img/bVbxEBp?w=430&h=214\" alt=\"image\"></p>\n<p>其他类型（number、string blabla）就不一一举例了，参照上面的例子去掉 declare 填到 global 的大括号下就行了。</p>\n<h2 id=\"在-Ts-中定义-window-对象\"><a href=\"#在-Ts-中定义-window-对象\" class=\"headerlink\" title=\"在 Ts 中定义 window 对象\"></a>在 Ts 中定义 window 对象</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare global &#123;</span><br><span class=\"line\">  interface Window &#123;</span><br><span class=\"line\">    _czc: any</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模块化（CommonJS）\"><a href=\"#模块化（CommonJS）\" class=\"headerlink\" title=\"模块化（CommonJS）\"></a>模块化（CommonJS）</h2><p>除了上面的全局的方式，我们有时候还是通过 require 的方式引入模块化的代码。</p>\n<p>比如这样的效果：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXOl?w=486&h=134\" alt=\"image\"></p>\n<p>对应的写法是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare module &quot;abcde&quot; &#123;</span><br><span class=\"line\">    export let a: number</span><br><span class=\"line\">    export function b(): number</span><br><span class=\"line\">    export namespace c&#123;</span><br><span class=\"line\">        let cd: string</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实就是外面套了一层 <code>module &quot;xxx&quot;</code>，里面的写法和之前其实差不多，把<code>declare</code>换成了<code>export</code>。</p>\n<p>此外，有时候我们导出去的是一个函数本身，比如这样的：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXOU?w=358&h=110\" alt=\"image\"></p>\n<p>对应的写法很简单，长这个样子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare module &quot;app&quot; &#123;</span><br><span class=\"line\">    function aaa(some:number):number</span><br><span class=\"line\">     export=aaa</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以此类推，导出一个变量或常量的话这么写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare module &quot;ccc&quot; &#123;</span><br><span class=\"line\">    const c:400</span><br><span class=\"line\">     export=c</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXPc?w=671&h=109\" alt=\"image\"></p>\n<h2 id=\"ES6-的模块化方式（import-export）\"><a href=\"#ES6-的模块化方式（import-export）\" class=\"headerlink\" title=\"ES6 的模块化方式（import export）\"></a>ES6 的模块化方式（import export）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare var aaa: 1</span><br><span class=\"line\">declare var bbb: 2</span><br><span class=\"line\">declare var ccc: 3 //因为这个文件里我们使用了import或者export语法，所以bbb和ccc在其他代码里不能访问到，即不是全局变量</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123; aaa &#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; a1, a2 &#125; from &quot;./A&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a1)</span><br><span class=\"line\">console.log(a2)</span><br></pre></td></tr></table></figure>\n\n<p>那么对应的 A.d.ts 文件是这样写的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare var a1: 1</span><br><span class=\"line\">declare var a2: 2</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123; a1,a2 &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然了也能这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export declare var a1: 1</span><br><span class=\"line\">export declare var a2: 2</span><br></pre></td></tr></table></figure>\n\n<p>不过建议之前的第一种写法，原因看这里<a href=\"https://segmentfault.com/a/1190000017419857\">https://segmentfault.com/a/11...</a></p>\n<p>当然了还有人经常问 default 导出的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare var a1: 1</span><br><span class=\"line\">export default a1</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候当然就是这样用了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import a1 from &quot;./A&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a1)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h2><p>有一种代码，既可以通过全局变量访问到，也可以通过 require 的方式访问到。比如我们最常见的 jquery：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXPg?w=539&h=174\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bVMXPf?w=523&h=187\" alt=\"image\"></p>\n<p>其实就是按照全局的方式写 d.ts，写完后在最后加上<code>declare module &quot;xxx&quot;</code>的描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare namespace UUU&#123;</span><br><span class=\"line\">    let a:number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">declare module &quot;UUU&quot; &#123;</span><br><span class=\"line\">    export =UUU</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果这样：</p>\n<p>作为全局变量使用：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXPB?w=520&h=86\" alt=\"image\"></p>\n<p>作为模块加载使用：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXPM?w=513&h=104\" alt=\"image\"></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>有时候我们扩展了一些内置对象。比如我们给 Date 增加了一个 format 的实例方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVMXRR?w=517&h=103\" alt=\"image\"></p>\n<p>对应的 d.ts 描述文件这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Date &#123;</span><br><span class=\"line\">    format(f: string): string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"d-ts-文件放到哪里\"><a href=\"#d-ts-文件放到哪里\" class=\"headerlink\" title=\".d.ts 文件放到哪里\"></a>.d.ts 文件放到哪里</h2><p>经常有人问写出来的 d.ts 文件（A.d.ts）文件放到哪个目录里，如果是模块化的话那就放到和源码（A.js）文件同一个目录下，如果是全局变量的话理论上放到哪里都可以————当然除非你在 tsconfig.json 文件里面特殊配置过。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"封装一个autoTry函数，指定错误情况下重复执行次数，最终返回结果","url":"/2022/10/24/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAautoTry%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8C%87%E5%AE%9A%E9%94%99%E8%AF%AF%E6%83%85%E5%86%B5%E4%B8%8B%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E6%AC%A1%E6%95%B0%EF%BC%8C%E6%9C%80%E7%BB%88%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/","content":"<h2 id=\"一、封装-autoTry-函数\"><a href=\"#一、封装-autoTry-函数\" class=\"headerlink\" title=\"一、封装 autoTry 函数\"></a>一、封装 autoTry 函数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo(params) &#123;</span><br><span class=\"line\">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            JSON.parse(&#x27;&#123;&#123;&#x27;);</span><br><span class=\"line\">            return resolve(params);</span><br><span class=\"line\">          &#125; catch (e) &#123;</span><br><span class=\"line\">            return reject(e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;, 1000);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ========doing======</span><br><span class=\"line\">    function autoTry(fn, times) &#123;</span><br><span class=\"line\">      const retry = (params) =&gt; new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        fn(params).then(</span><br><span class=\"line\">          (response) =&gt; &#123; resolve(response) &#125;</span><br><span class=\"line\">        ).catch(e =&gt; &#123;</span><br><span class=\"line\">          console.log(&#x27;retrying: &#x27; + new Date(), e)</span><br><span class=\"line\">          if (times &gt; 1) &#123;</span><br><span class=\"line\">            times -= 1</span><br><span class=\"line\">            retry()</span><br><span class=\"line\">          &#125; else &#123; reject(e) &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      return retry</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ========test======</span><br><span class=\"line\">    func = autoTry(foo, 3);</span><br><span class=\"line\">    func(&#123; a: 1, b: 2 &#125;).then((res) =&gt; &#123;</span><br><span class=\"line\">      console.log(`结果：$&#123;JSON.stringify(res)&#125;`);</span><br><span class=\"line\">    &#125;, (error) =&gt; &#123;</span><br><span class=\"line\">      console.log(error)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、一个-n-个大小写字母组成的字符串按-ascii-码从小到大排序-查找字符串中第-k-个最小-ascii-码的字母输出该字母所在字符串位置索引\"><a href=\"#二、一个-n-个大小写字母组成的字符串按-ascii-码从小到大排序-查找字符串中第-k-个最小-ascii-码的字母输出该字母所在字符串位置索引\" class=\"headerlink\" title=\"二、一个 n 个大小写字母组成的字符串按 ascii 码从小到大排序 查找字符串中第 k 个最小 ascii 码的字母输出该字母所在字符串位置索引\"></a>二、一个 n 个大小写字母组成的字符串按 ascii 码从小到大排序 查找字符串中第 k 个最小 ascii 码的字母输出该字母所在字符串位置索引</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function lookup(str,key)&#123;</span><br><span class=\"line\">  if(typeof str !=&#x27;string&#x27;||key&lt;1)return -1;</span><br><span class=\"line\">  let value = str.split(&quot;&quot;).sort()[key-1];</span><br><span class=\"line\">  return str.indexOf(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(lookup(&#x27;asasdskdjdfgnsdkfnmsASDdf&#x27;,5)+1)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">let getIndexChar = (str,index)=&gt;&#123;</span><br><span class=\"line\">    let sortChar = []</span><br><span class=\"line\">    for(let i=0;i&lt;str.length;i++) &#123;</span><br><span class=\"line\">        sortChar.push(str.charCodeAt(i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortChar = sortChar.sort((a,b)=&gt;&#123;</span><br><span class=\"line\">        return a-b</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    let indexCode = -1</span><br><span class=\"line\">    for(let i=0;i&lt;str.length;i++) &#123;</span><br><span class=\"line\">        if(str[i].charCodeAt(0)==sortChar[index]) &#123;</span><br><span class=\"line\">            indexCode = i</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return indexCode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getIndexChar(&#x27;asdEQW&#x27;,1) //4</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、ts-工具函数\"><a href=\"#三、ts-工具函数\" class=\"headerlink\" title=\"三、ts 工具函数\"></a>三、ts 工具函数</h2><p><strong>1、实现一个 ts 的工具函数 GetOnlyFnProps<T> ，提取泛型类型 T 中字段类型是函数的工具函数，其中 T 属于一个对象。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type GetOnlyFnKeys&lt;T extends object&gt; = &#123;</span><br><span class=\"line\"> [Key in keyof T]: T[K] extends Function ? K : never</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type GetOnlyFnProps&lt;T extends object&gt; = &#123;</span><br><span class=\"line\"> [K in GetOnlyFnKeys&lt;T&gt;]: T[K]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现一个 ts 的工具函数 UnGenericPromise<T> ，提取 Promise 中的泛型类型</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type UnGenericPromise&lt;T extends Promise&lt;any&gt;&gt; = T extends Promise&lt;infer U&gt; ? U : never</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、分页加载\"><a href=\"#四、分页加载\" class=\"headerlink\" title=\"四、分页加载\"></a>四、分页加载</h2><p><strong>h5_demo</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123;PREFIX_URL ,request ,TITLE&#125; from &#x27;../../common&#x27;;</span><br><span class=\"line\">import DetailedList from &quot;../../components/movie/DetailedListComponent&quot;;</span><br><span class=\"line\">import Loading from &#x27;../../components/common/LoadingComponent&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">const PS = 5;</span><br><span class=\"line\">class FilmList extends Component &#123;</span><br><span class=\"line\">    constructor(...args) &#123;</span><br><span class=\"line\">        super(...args);</span><br><span class=\"line\">        document.title = &#x27;艾米电影推荐&#x27;;</span><br><span class=\"line\">        this.stgId = localStorage.getItem(&quot;stgId&quot;) || &quot;&quot;;</span><br><span class=\"line\">        this.id = this.props.match.params.id;</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            listData: &quot;&quot;,</span><br><span class=\"line\">            page: 1,</span><br><span class=\"line\">            pageSize: PS,</span><br><span class=\"line\">            hasMore: false,</span><br><span class=\"line\">            desc:&#x27;&#x27;,</span><br><span class=\"line\">            loading:true,</span><br><span class=\"line\">            display:&#x27;none&#x27;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async componentWillMount() &#123;</span><br><span class=\"line\">        // console.log(&quot;片单ID--&gt;&quot;, this.id);</span><br><span class=\"line\">        await this.getList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async getList(page=1) &#123;</span><br><span class=\"line\">        let url = `$&#123;PREFIX_URL&#125;movie_client/list`+</span><br><span class=\"line\">            `?stgId=$&#123;this.stgId&#125;&amp;movieListId=$&#123;this.id&#125;&amp;page=$&#123;page&#125;&amp;pageSize=$&#123;this.state.pageSize&#125;`;</span><br><span class=\"line\">        let res = await request(url);</span><br><span class=\"line\">        if (res &amp;&amp; res.success) &#123;</span><br><span class=\"line\">            document.title = res.title;</span><br><span class=\"line\">            let listData = &quot;&quot;;</span><br><span class=\"line\">            if (page === 1) &#123;</span><br><span class=\"line\">                listData = res.data;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                listData = this.state.listData;</span><br><span class=\"line\">                listData = listData.concat(res.data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            await this.setState(&#123;</span><br><span class=\"line\">                listData,</span><br><span class=\"line\">                loading:false,</span><br><span class=\"line\">                display:&#x27;block&#x27;,</span><br><span class=\"line\">                desc:res.desc,</span><br><span class=\"line\">                page:res.page.current,</span><br><span class=\"line\">                hasMore: res.page.current &lt; res.page.pages</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async componentWillUnmount () &#123;</span><br><span class=\"line\">        document.title = TITLE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async refresh () &#123;</span><br><span class=\"line\">        await this.setState(&#123;page: 1&#125;);</span><br><span class=\"line\">        await this.getList(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async loadMore() &#123;</span><br><span class=\"line\">        await this.setState(&#123;page: this.state.page + 1&#125;);</span><br><span class=\"line\">        await this.getList(this.state.page);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;page-movie-detailed-list&quot;&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    !!this.state.listData &amp;&amp;</span><br><span class=\"line\">                    &lt;DetailedList</span><br><span class=\"line\">                        refresh=&#123;this.refresh.bind(this)&#125;</span><br><span class=\"line\">                        loadMore=&#123;this.loadMore.bind(this)&#125;</span><br><span class=\"line\">                        hasMore=&#123;this.state.hasMore&#125;</span><br><span class=\"line\">                        listData=&#123;this.state.listData&#125;</span><br><span class=\"line\">                        desc=&#123;this.state.desc&#125;</span><br><span class=\"line\">                        style=&#123;&#123;&#x27;display&#x27;:this.state.display&#125;&#125;/&gt;&#125;</span><br><span class=\"line\">                &#123;this.state.loading ? &lt;Loading/&gt; : &#x27;&#x27; &#125;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default FilmList;</span><br></pre></td></tr></table></figure>\n\n<p><strong>PC_demo</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; Button, Col, message as Message, Row, Icon &#125; from &#x27;antd&#x27;</span><br><span class=\"line\">import &#123; Link &#125; from &#x27;react-router-dom&#x27;</span><br><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\">import MessageListFilter, &#123; IMessageListFilter &#125; from &#x27;./components/MessageListFilter&#x27;</span><br><span class=\"line\">import MessageListTable from &#x27;./components/MessageListTable&#x27;</span><br><span class=\"line\">import MessageService from &#x27;../../../service/driverManage/MessageService&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class MessageList extends React.Component &#123;</span><br><span class=\"line\">  // public constructor(props: any)&#123;</span><br><span class=\"line\">  //   super(props)</span><br><span class=\"line\">  // &#125;</span><br><span class=\"line\">  public state = &#123;</span><br><span class=\"line\">    filterProps: &#123;</span><br><span class=\"line\">      filter: &#123;</span><br><span class=\"line\">        beginCreatedTime: &#x27;&#x27;,</span><br><span class=\"line\">        endCreatedTime: &#x27;&#x27;, // 日期</span><br><span class=\"line\">        sendStatus: &#x27;-1&#x27;, //发送状态</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    tableProps: &#123;</span><br><span class=\"line\">      page: &#123;</span><br><span class=\"line\">        current: 1,</span><br><span class=\"line\">        pageSize: 10,</span><br><span class=\"line\">        total: 0,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      data: [],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    searching: false,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public componentDidMount() &#123;</span><br><span class=\"line\">    this.reSearch()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public filterChange = (params: IMessageListFilter) =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      filterProps: &#123;</span><br><span class=\"line\">        filter: &#123;</span><br><span class=\"line\">          ...this.state.filterProps.filter,</span><br><span class=\"line\">          ...params,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public search = async () =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      searching: true,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    const &#123; code, message, data &#125; = await MessageService.pageMessageList(&#123;</span><br><span class=\"line\">      ...this.state.filterProps.filter,</span><br><span class=\"line\">      ...&#123;</span><br><span class=\"line\">        sendStatus:</span><br><span class=\"line\">          this.state.filterProps.filter.sendStatus !== &#x27;-1&#x27;</span><br><span class=\"line\">            ? this.state.filterProps.filter.sendStatus</span><br><span class=\"line\">            : null,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pageNum: this.state.tableProps.page.current,</span><br><span class=\"line\">      pageSize: this.state.tableProps.page.pageSize,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      searching: false,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    if (code !== 200) &#123;</span><br><span class=\"line\">      Message.error(message)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const &#123; current, pageSize &#125; = this.state.tableProps.page</span><br><span class=\"line\">    let rows = []</span><br><span class=\"line\">    rows =</span><br><span class=\"line\">      data.rows &amp;&amp; data.rows.length</span><br><span class=\"line\">        ? data.rows.map((item: any, index: number) =&gt; &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">              ...item,</span><br><span class=\"line\">              num: (current - 1) * pageSize + index + 1,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        : []</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      tableProps: &#123;</span><br><span class=\"line\">        page: &#123;</span><br><span class=\"line\">          ...this.state.tableProps.page,</span><br><span class=\"line\">          total: data.total,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data: rows,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public reSearch = () =&gt; &#123;</span><br><span class=\"line\">    const &#123; tableProps &#125; = this.state</span><br><span class=\"line\">    const &#123;</span><br><span class=\"line\">      page: &#123; pageSize, total &#125;,</span><br><span class=\"line\">    &#125; = tableProps</span><br><span class=\"line\"></span><br><span class=\"line\">    this.setState(</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        tableProps: &#123;</span><br><span class=\"line\">          ...tableProps,</span><br><span class=\"line\">          page: &#123;</span><br><span class=\"line\">            pageSize,</span><br><span class=\"line\">            total,</span><br><span class=\"line\">            current: 1,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      () =&gt; &#123;</span><br><span class=\"line\">        this.search()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public pageChange = (page: object) =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      tableProps: &#123;</span><br><span class=\"line\">        ...this.state.tableProps,</span><br><span class=\"line\">        page,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    this.search()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public getDetail = (params: any) =&gt; &#123;</span><br><span class=\"line\">    ;(this.props as any).history.push(&#x27;messageDetail&#x27;, &#123; id: 6, type: 0 &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public render() &#123;</span><br><span class=\"line\">    const &#123; filterProps, tableProps, searching &#125; = this.state</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;section&gt;</span><br><span class=\"line\">        &lt;MessageListFilter</span><br><span class=\"line\">          loading=&#123;searching&#125;</span><br><span class=\"line\">          &#123;...filterProps&#125;</span><br><span class=\"line\">          onChange=&#123;this.filterChange&#125;</span><br><span class=\"line\">          onSearch=&#123;this.reSearch&#125;</span><br><span class=\"line\">        &gt;&lt;/MessageListFilter&gt;</span><br><span class=\"line\">        &lt;Row style=&#123;&#123; marginBottom: &#x27;10px&#x27; &#125;&#125;&gt;</span><br><span class=\"line\">          &lt;Col&gt;</span><br><span class=\"line\">            &lt;Button type=&quot;primary&quot;&gt;</span><br><span class=\"line\">              &lt;Link to=&#123;`/fast/message/messageCreate`&#125;&gt;</span><br><span class=\"line\">                &lt;Icon type=&quot;plus&quot; /&gt;</span><br><span class=\"line\">                &lt;span style=&#123;&#123; marginLeft: &#x27;8px&#x27; &#125;&#125;&gt;新建推送&lt;/span&gt;</span><br><span class=\"line\">              &lt;/Link&gt;</span><br><span class=\"line\">            &lt;/Button&gt;</span><br><span class=\"line\">          &lt;/Col&gt;</span><br><span class=\"line\">        &lt;/Row&gt;</span><br><span class=\"line\">        &lt;MessageListTable</span><br><span class=\"line\">          &#123;...tableProps&#125;</span><br><span class=\"line\">          onPagechange=&#123;this.pageChange&#125;</span><br><span class=\"line\">          getDetail=&#123;this.getDetail&#125;</span><br><span class=\"line\">          onSearch=&#123;this.search&#125;</span><br><span class=\"line\">          loading=&#123;searching&#125;</span><br><span class=\"line\">        &gt;&lt;/MessageListTable&gt;</span><br><span class=\"line\">      &lt;/section&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; Button, Table, Col, Modal, message as Message &#125; from &#x27;antd&#x27;</span><br><span class=\"line\">import React from &#x27;react&#x27;</span><br><span class=\"line\">import &#123; PaginationConf &#125; from &#x27;../../../../config/antd/PaginationConf&#x27;</span><br><span class=\"line\">import &#123; Link &#125; from &#x27;react-router-dom&#x27;</span><br><span class=\"line\">import MessageService from &#x27;../../../../service/driverManage/MessageService&#x27;</span><br><span class=\"line\">export interface IMessageTable &#123;</span><br><span class=\"line\">  num: string | number</span><br><span class=\"line\">  creatTime: string</span><br><span class=\"line\">  driverName: string</span><br><span class=\"line\">  driverPhoneNum: string</span><br><span class=\"line\">  receiptType: number</span><br><span class=\"line\">  receipt: number | string</span><br><span class=\"line\">  output: number | string</span><br><span class=\"line\">  banace: number | string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export interface IProps &#123;</span><br><span class=\"line\">  data: IMessageTable[]</span><br><span class=\"line\">  page: &#123;</span><br><span class=\"line\">    current: number</span><br><span class=\"line\">    pageSize: number</span><br><span class=\"line\">    total: number</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onPagechange?: (page: &#123; current: number; pageSize: number; total: number &#125;) =&gt; void</span><br><span class=\"line\">  getDetail: (param: any) =&gt; void</span><br><span class=\"line\">  onSearch: () =&gt; void</span><br><span class=\"line\">  loading: boolean</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; confirm &#125; = Modal</span><br><span class=\"line\">class MessageListTable extends React.Component&lt;IProps&gt; &#123;</span><br><span class=\"line\">  public constructor(props: IProps) &#123;</span><br><span class=\"line\">    super(props)</span><br><span class=\"line\">    ;(this as any).columns = [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;序号&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;num&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;发送时间&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;sendTime&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;发送范围&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;sendScope&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;消息中心&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;canIntoMessageCenter&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;标题&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;title&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;操作人&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;createdBy&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;创建时间&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;createdTime&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;发送状态&#x27;,</span><br><span class=\"line\">        dataIndex: &#x27;sendStatus&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        title: &#x27;操作&#x27;,</span><br><span class=\"line\">        align: &#x27;center&#x27;,</span><br><span class=\"line\">        render(row: any) &#123;</span><br><span class=\"line\">          return (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">              &#123;row.canCancelSend ? (</span><br><span class=\"line\">                &lt;Col&gt;</span><br><span class=\"line\">                  &lt;Button</span><br><span class=\"line\">                    type=&quot;primary&quot;</span><br><span class=\"line\">                    onClick=&#123;() =&gt; &#123;</span><br><span class=\"line\">                      cancel(row)</span><br><span class=\"line\">                    &#125;&#125;</span><br><span class=\"line\">                  &gt;</span><br><span class=\"line\">                    取消发送</span><br><span class=\"line\">                  &lt;/Button&gt;</span><br><span class=\"line\">                  &#123;new Date(row.sendTime).getTime() - new Date().getTime() &gt; 5 * 60 * 60 * 1000 ? (</span><br><span class=\"line\">                    &lt;Button type=&quot;primary&quot; style=&#123;&#123; marginLeft: &#x27;5px&#x27; &#125;&#125;&gt;</span><br><span class=\"line\">                      &lt;Link to=&#123;`/fast/message/messageUpdate/$&#123;row.id&#125;`&#125;&gt;查看&lt;/Link&gt;</span><br><span class=\"line\">                    &lt;/Button&gt;</span><br><span class=\"line\">                  ) : (</span><br><span class=\"line\">                    &lt;Button type=&quot;primary&quot; style=&#123;&#123; marginLeft: &#x27;5px&#x27; &#125;&#125;&gt;</span><br><span class=\"line\">                      &lt;Link to=&#123;`/fast/message/messageDetail/$&#123;row.id&#125;`&#125;&gt;查看&lt;/Link&gt;</span><br><span class=\"line\">                    &lt;/Button&gt;</span><br><span class=\"line\">                  )&#125;</span><br><span class=\"line\">                &lt;/Col&gt;</span><br><span class=\"line\">              ) : (</span><br><span class=\"line\">                &lt;Button type=&quot;primary&quot;&gt;</span><br><span class=\"line\">                  &lt;Link to=&#123;`/fast/message/messageDetail/$&#123;row.id&#125;`&#125;&gt;查看&lt;/Link&gt;</span><br><span class=\"line\">                &lt;/Button&gt;</span><br><span class=\"line\">              )&#125;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    function cancel(row: any) &#123;</span><br><span class=\"line\">      const &#123; onSearch &#125; = props</span><br><span class=\"line\">      if (new Date(row.sendTime).getTime() - new Date().getTime() &gt; 5 * 60 * 60 * 1000) &#123;</span><br><span class=\"line\">        confirm(&#123;</span><br><span class=\"line\">          title: &#x27;提示&#x27;,</span><br><span class=\"line\">          content: &#x27;是否确认取消&#x27;,</span><br><span class=\"line\">          async onOk() &#123;</span><br><span class=\"line\">            const &#123; code, message &#125; = await MessageService.messageCancel(row.id)</span><br><span class=\"line\">            if (code !== 200) &#123;</span><br><span class=\"line\">              Message.error(message)</span><br><span class=\"line\">              return</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Message.success(&#x27;取消成功&#x27;)</span><br><span class=\"line\">            onSearch()</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          onCancel() &#123;</span><br><span class=\"line\">            return</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        Modal.info(&#123;</span><br><span class=\"line\">          title: &#x27;提示&#x27;,</span><br><span class=\"line\">          content: &lt;div&gt;距离预计发送时间不到5分钟 禁止取消&lt;/div&gt;,</span><br><span class=\"line\">          okText: &#x27;关闭&#x27;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public render() &#123;</span><br><span class=\"line\">    const &#123; data, page, onPagechange, loading &#125; = this.props</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;section&gt;</span><br><span class=\"line\">        &lt;Table</span><br><span class=\"line\">          dataSource=&#123;data&#125;</span><br><span class=\"line\">          loading=&#123;loading&#125;</span><br><span class=\"line\">          // @ts-ignore</span><br><span class=\"line\">          columns=&#123;this.columns&#125;</span><br><span class=\"line\">          rowKey=&#123;&#x27;id&#x27;&#125;</span><br><span class=\"line\">          size=&#123;&#x27;middle&#x27;&#125;</span><br><span class=\"line\">          // scroll=&#123;&#123; x: 2500 &#125;&#125;</span><br><span class=\"line\">          pagination=&#123;&#123;</span><br><span class=\"line\">            ...PaginationConf,</span><br><span class=\"line\">            ...this.props.page,</span><br><span class=\"line\">            onChange: (toCurrent, pageSize) =&gt; &#123;</span><br><span class=\"line\">              page.current = toCurrent</span><br><span class=\"line\">              page.pageSize = pageSize as number</span><br><span class=\"line\"></span><br><span class=\"line\">              if (onPagechange) &#123;</span><br><span class=\"line\">                onPagechange(page)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            onShowSizeChange: (current, toPageSize) =&gt; &#123;</span><br><span class=\"line\">              page.current = current</span><br><span class=\"line\">              page.pageSize = toPageSize</span><br><span class=\"line\"></span><br><span class=\"line\">              if (onPagechange) &#123;</span><br><span class=\"line\">                onPagechange(page)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            showTotal: (total: number) =&gt; `共计 $&#123;total&#125; 条`,</span><br><span class=\"line\">          &#125;&#125;</span><br><span class=\"line\">        &gt;&lt;/Table&gt;</span><br><span class=\"line\">      &lt;/section&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123; MessageListTable &#125;</span><br><span class=\"line\">export default MessageListTable</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"小程序实现原理解析","url":"/2022/12/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>作为一名前端开发，如果你还停留在应用开发层面，那你就 OUT 了，快来跟我一起探讨下小程序框架本身底层实现的一些技术细节吧，让我们从小程序的运行机制来深度了解小程序。<br>小程序是基于 WEB 规范，采用 HTML,CSS 和 JS 等搭建的一套框架，微信官方给它们取了一个很牛逼的名字：WXML,WXSS，但本质上还是在整个 WEB 体系之下构建的。<br>WXML，个人猜测在取这个名字的是微信的 Xml，说到底就是 xml 的一个子集。WXML 采用微信自定义的少量标签 WXSS，大家可以理解为就是自定义的 CSS。实现逻辑部分的 JS 还是通用的 ES 规范，并且 runtime 还是 Webview（IOS WKWEBVIEW, ANDROID X5）。</p>\n<h2 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h2><h3 id=\"小程序目录结构\"><a href=\"#小程序目录结构\" class=\"headerlink\" title=\"小程序目录结构\"></a>小程序目录结构</h3><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjEzNTU5ODQ3?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>一个完整的小程序主要由以下几部分组成：</p>\n<ul>\n<li>一个入口文件：app.js</li>\n<li>一个全局样式：app.wxss</li>\n<li>一个全局配置：app.json</li>\n<li>页面：pages 下，每个页面再按文件夹划分，每个页面 4 个文件</li>\n<li>视图：wxml，wxss</li>\n<li>逻辑：js，json（页面配置，不是必须）</li>\n</ul>\n<p>注：pages 里面还可以再根据模块划分子目录，孙子目录，只需要在 app.json 里注册时填写路径就行。</p>\n<h3 id=\"小程序打包\"><a href=\"#小程序打包\" class=\"headerlink\" title=\"小程序打包\"></a>小程序打包</h3><p>开发完成后，我们就可以通过这里可视化的按钮，点击直接打包上传发布，审核通过后用户就可以搜索到了。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjEzOTI0NjE0?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>那么打包怎么实现的呢？<br>这就涉及到这个编辑器的实现原理和方式了，它本身也是基于 WEB 技术体系实现的，nwjs+react，nwjs 是什么：简单是说就是 node+webkit，node 提供给我们本地 api 能力，而 webkit 提供给我们 web 能力，两者结合就能让我们使用 JS+HTML 实现本地应用程序。<br>既然有 nodejs，那上面的打包选项里的功能就好实现了。<br>ES6 转 ES5：引入 babel-core 的 node 包<br>CSS 补全：引入 postcss 和 autoprefixer 的 node 包（postcss 和 autoprefixer 的原理看这里）<br>代码压缩：引入 uglifyjs 的 node 包</p>\n<p>注：在 android 上使用的 x5 内核，对 ES6 的支持不好，要兼容的话，要么使用 ES5 的语法或者引入 babel-polyfill 兼容库。</p>\n<h3 id=\"打包后的目录结构\"><a href=\"#打包后的目录结构\" class=\"headerlink\" title=\"打包后的目录结构\"></a>打包后的目录结构</h3><p>小程序打包后的结构如下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjE0MzMzMDA3?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>所有的小程序基本都最后都被打成上面的结构</p>\n<ol>\n<li>WAService.js 框架 JS 库，提供逻辑层基础的 API 能力</li>\n<li>WAWebview.js 框架 JS 库，提供视图层基础的 API 能力</li>\n<li>WAConsole.js 框架 JS 库，控制台</li>\n<li>app-config.js 小程序完整的配置，包含我们通过 app.json 里的所有配置，综合了默认配置型</li>\n<li>app-service.js 我们自己的 JS 代码，全部打包到这个文件</li>\n<li>page-frame.html 小程序视图的模板文件，所有的页面都使用此加载渲染，且所有的 WXML 都拆解为 JS 实现打包到这里</li>\n<li>pages 所有的页面，这个不是我们之前的 wxml 文件了，主要是处理 WXSS 转换，使用 js 插入到 header 区域。</li>\n</ol>\n<h2 id=\"小程序架构\"><a href=\"#小程序架构\" class=\"headerlink\" title=\"小程序架构\"></a>小程序架构</h2><p>微信小程序的框架包含两部分 View 视图层、App Service 逻辑层，View 层用来渲染页面结构，AppService 层用来逻辑处理、数据请求、接口调用，它们在两个进程（两个 Webview）里运行。<br>视图层和逻辑层通过系统层的 JSBridage 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。</p>\n<p>小程序架构图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjE1NzI0ODkx?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>小程序启动时会从 CDN 下载小程序的完整包，一般是数字命名的,如：_-2082693788_4.wxapkg</p>\n<h3 id=\"小程序技术实现\"><a href=\"#小程序技术实现\" class=\"headerlink\" title=\"小程序技术实现\"></a>小程序技术实现</h3><p>小程序的 UI 视图和逻辑处理是用多个 webview 实现的，逻辑处理的 JS 代码全部加载到一个 Webview 里面，称之为 AppService，整个小程序只有一个，并且整个生命周期常驻内存，而所有的视图（wxml 和 wxss）都是单独的 Webview 来承载，称之为 AppView。所以一个小程序打开至少就会有 2 个 webview 进程，正是因为每个视图都是一个独立的 webview 进程，考虑到性能消耗，小程序不允许打开超过 5 个层级的页面，当然同是也是为了体验更好。</p>\n<h3 id=\"AppService\"><a href=\"#AppService\" class=\"headerlink\" title=\"AppService\"></a>AppService</h3><p>可以理解 AppService 即一个简单的页面，主要功能是负责逻辑处理部分的执行，底层提供一个 WAService.js 的文件来提供各种 api 接口，主要是以下几个部分：<br>消息通信封装为 WeixinJSBridge（开发环境为 window.postMessage, IOS 下为 WKWebview 的 window.webkit.messageHandlers.invokeHandler.postMessage，android 下用 WeixinJSCore.invokeHandler）</p>\n<ol>\n<li>日志组件 Reporter 封装</li>\n<li>wx 对象下面的 api 方法</li>\n<li>全局的 App,Page,getApp,getCurrentPages 等全局方法</li>\n<li>还有就是对 AMD 模块规范的实现</li>\n</ol>\n<p>然后整个页面就是加载一堆 JS 文件，包括小程序配置 config，上面的 WAService.js（调试模式下有 asdebug.js），剩下就是我们自己写的全部的 js 文件，一次性都加载。</p>\n<h3 id=\"在开发环境下\"><a href=\"#在开发环境下\" class=\"headerlink\" title=\"在开发环境下\"></a>在开发环境下</h3><ol>\n<li>页面模板：app.nw&#x2F;app&#x2F;dist&#x2F;weapp&#x2F;tpl&#x2F;appserviceTpl.js</li>\n<li>配置信息，是直接写入一个 js 变量，__wxConfig。</li>\n<li>其他配置</li>\n</ol>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjIwNDE5NDIz?x-oss-process=image/format,png\" alt=\"image\"></p>\n<h3 id=\"线上环境\"><a href=\"#线上环境\" class=\"headerlink\" title=\"线上环境\"></a>线上环境</h3><p>而在上线后是应用部分会打包为 2 个文件，名称 app-config.json 和 app-service.js，然后微信会打开 webview 去加载。线上部分应该是微信自身提供了相应的模板文件，在压缩包里没有找到。</p>\n<ol>\n<li>WAService.js（底层支持）</li>\n<li>app-config.json（应用配置）</li>\n<li>app-service.js（应用逻辑）</li>\n</ol>\n<p>然后运行在 JavaScriptCore 引擎里面。</p>\n<h3 id=\"AppView\"><a href=\"#AppView\" class=\"headerlink\" title=\"AppView\"></a>AppView</h3><p>这里可以理解为 h5 的页面，提供 UI 渲染，底层提供一个 WAWebview.js 来提供底层的功能,具体如下：</p>\n<ol>\n<li>消息通信封装为 WeixinJSBridge（开发环境为 window.postMessage, IOS 下为 WKWebview 的 window.webkit.messageHandlers.invokeHandler.postMessage，android 下用 WeixinJSCore.invokeHandler）</li>\n<li>日志组件 Reporter 封装</li>\n<li>wx 对象下的 api，这里的 api 跟 WAService 里的还不太一样，有几个跟那边功能差不多，但是大部分都是处理 UI 显示相关的方法</li>\n<li>小程序组件实现和注册</li>\n<li>VirtualDOM，Diff 和 Render UI 实现</li>\n<li>页面事件触发</li>\n</ol>\n<p>在此基础上，AppView 有一个 html 模板文件，通过这个模板文件加载具体的页面，这个模板主要就一个方法，$gwx，主要是返回指定 page 的 VirtualDOM，而在打包的时候，会事先把所有页面的 WXML 转换为 ViirtualDOM 放到模板文件里，而微信自己写了 2 个工具 wcc（把 WXML 转换为 VirtualDOM）和 wcsc（把 WXSS 转换为一个 JS 字符串的形式通过 style 标签 append 到 header 里）。</p>\n<h3 id=\"Service-和-View-通信\"><a href=\"#Service-和-View-通信\" class=\"headerlink\" title=\"Service 和 View 通信\"></a>Service 和 View 通信</h3><p>使用消息 publish 和 subscribe 机制实现两个 Webview 之间的通信，实现方式就是统一封装一个 WeixinJSBridge 对象，而不同的环境封装的接口不一样，具体实现的技术如下：</p>\n<h3 id=\"windows-环境\"><a href=\"#windows-环境\" class=\"headerlink\" title=\"windows 环境\"></a>windows 环境</h3><p>通过 window.postMessage 实现（使用 chrome 扩展的接口注入一个 contentScript.js，它封装了 postMessage 方法，实现 webview 之间的通信，并且它也通过 chrome.runtime.connect 方式，也提供了直接操作 chrome native 原生方法的接口）<br>发送消息：window.postMessage(data, ‘*’);，&#x2F;&#x2F; data 里指定 webviewID<br>接收消息：window.addEventListener(‘message’, messageHandler); &#x2F;&#x2F; 消息处理并分发，同样支持调用 nwjs 的原生能力。<br>在 contentScript 里面看到一句话，证实了 appservice 也是通过一个 webview 实现的，实现原理上跟 view 一样，只是处理的业务逻辑不一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x27;webframe&#x27; === b ? postMessageToWebPage(a) : &#x27;appservice&#x27; === b &amp;&amp; postMessageToWebPage(a)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"IOS\"><a href=\"#IOS\" class=\"headerlink\" title=\"IOS\"></a>IOS</h3><p>通过 WKWebview 的 window.webkit.messageHandlers.NAME.postMessage 实现，微信 navite 代码里实现了两个 handler 消息处理器：<br>invokeHandler: 调用原生能力<br>publishHandler: 消息分发</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjIxMzU1MzAz?x-oss-process=image/format,png\" alt=\"image\"></p>\n<h3 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h3><p>通过 WeixinJSCore.invokeHandler 实现，这个 WeixinJSCore 是微信提供给 JS 调用的接口（native 实现）<br>invokeHandler: 调用原生能力<br>publishHandler: 消息分发</p>\n<h3 id=\"微信组件\"><a href=\"#微信组件\" class=\"headerlink\" title=\"微信组件\"></a>微信组件</h3><p>在 WAWebview.js 里有个对象叫 exparser，它完整的实现小程序里的组件，看具体的实现方式，思路上跟 w3c 的 web components 规范神似，但是具体实现上是不一样的，我们使用的所有组件，都会被提前注册好，在 Webview 里渲染的时候进行替换组装。<br>exparser 有个核心方法：<br>registerBehavior: 注册组件的一些基础行为，供组件继承<br>registerElement：注册组件，跟我们交互接口主要是属性和事件</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjIxNTU5OTYx?x-oss-process=image/format,png\" alt=\"image\"></p>\n<p>组件触发事件（带上 webviewID），调用 WeixinJSBridge 的接口，publish 到 native，然后 native 再分发到 AppService 层指定 webviewID 的 Page 注册事件处理方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>小程序底层还是基于 Webview 来实现的，并没有发明创造新技术，整个框架体系，比较清晰和简单，基于 Web 规范，保证现有技能价值的最大化，只需了解框架规范即可使用已有 Web 技术进行开发。易于理解和开发。</p>\n<p><strong>MSSM</strong>：对逻辑和 UI 进行了完全隔离，这个跟当前流行的 react，angular，vue 有本质的区别，小程序逻辑和 UI 完全运行在 2 个独立的 Webview 里面，而后面这几个框架还是运行在一个 webview 里面的，如果你想，还是可以直接操作 dom 对象，进行 ui 渲染的。</p>\n<p><strong>组件机制</strong>：引入组件化机制，但是不完全基于组件开发，跟 vue 一样大部分 UI 还是模板化渲染，引入组件机制能更好的规范开发模式，也更方便升级和维护。</p>\n<p><strong>多种节制</strong>：不能同时打开超过 5 个窗口，打包文件不能大于 1M，dom 对象不能大于 16000 个等，这些都是为了保证更好的体验。</p>\n","categories":["小程序开发"],"tags":["小程序"]},{"title":"小程序异常监控收集","url":"/2022/12/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E6%94%B6%E9%9B%86/","content":"<h2 id=\"web-端与小程序错误监控差异\"><a href=\"#web-端与小程序错误监控差异\" class=\"headerlink\" title=\"web 端与小程序错误监控差异\"></a>web 端与小程序错误监控差异</h2><ul>\n<li>在 Web 端监测的是页面完整的 url，而小程序端监测的是路由地址；</li>\n<li>小程序页面属于 app 内部的页面，使用时已全部加载完毕，因此监控页面性能时不统计页面加载时长等信息，更多的是对页面内请求、资源请求和用户行为的监控；</li>\n<li>由于微信官方和小程序代码的要求，集成方式对比 Web 端会相对严格一些。</li>\n</ul>\n<h2 id=\"小程序需要监控的数据\"><a href=\"#小程序需要监控的数据\" class=\"headerlink\" title=\"小程序需要监控的数据\"></a>小程序需要监控的数据</h2><ul>\n<li>JavaScript 异常监控：不论是 Web 端还是小程序端，对 JavaScript 异常的监控都是必要的；</li>\n<li>页面内请求监控：对于小程序来说，需要统计发送网络请求的 swan.request() 异常时的请求状态、请求时长、请求地址等；</li>\n<li>资源加载监控：当需要下载资源到本地的 swan.downloadFile() 出现异常时，统计加载时间、异常类型、资源地址等；</li>\n<li>页面性能监控：访问监控、页面来源及流向监控等，方便更好的对小程序进行运营；</li>\n<li>用户数据统计：用户的分布、操作系统及版本、app 版本、IP 地址等，给错误的分析提供更多条件。</li>\n</ul>\n<h3 id=\"简单收集\"><a href=\"#简单收集\" class=\"headerlink\" title=\"简单收集\"></a>简单收集</h3><ul>\n<li>小程序 App()生命周期里提供了 onError 函数，可以通过在 onError 里收集异常信息，具体原理可查看<a href=\"https://www.jb51.net/article/142101.htm\">JS 实现监控微信小程序的原理</a></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">      // 监听错误</span><br><span class=\"line\">      onError: function (err) &#123;</span><br><span class=\"line\">          // 上报错误</span><br><span class=\"line\">          swan.request(&#123;</span><br><span class=\"line\">          url: &quot;https://url&quot;, // 自行定义报告服务器</span><br><span class=\"line\">          method: &quot;POST&quot;,</span><br><span class=\"line\">          errMsg: err</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用户操作路径收集\"><a href=\"#用户操作路径收集\" class=\"headerlink\" title=\"用户操作路径收集\"></a>用户操作路径收集</h3><p>一些较隐蔽的错误如果只有错误栈信息，排查起来会比较难，如果有用户操作的路径，在排查时就方便多了。</p>\n<ul>\n<li>暴力打点方法收集<br/><br>优点：简单直接<br/><br>缺点：污染业务代码，造成较多垃圾代码</li>\n<li>函数劫持<br>需要在 App 函数中的 onLaunch、onShow、onHide 生命周期插入监控代码，通过重写 App 生命周期函数来实现。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">App = function(app) &#123;</span><br><span class=\"line\">      [&quot;onLaunch&quot;, &quot;onShow&quot;, &quot;onHide&quot;].forEach(methodName =&gt; &#123;</span><br><span class=\"line\">          app[methodName] = function(options) &#123;</span><br><span class=\"line\">          // 构造访问日志对象</span><br><span class=\"line\">          var breadcrumb = &#123;</span><br><span class=\"line\">              type: &quot;function&quot;,</span><br><span class=\"line\">              time: utils.now(),</span><br><span class=\"line\">              belong: &quot;App&quot;, // 来源</span><br><span class=\"line\">              method: methodName,</span><br><span class=\"line\">              path: options &amp;&amp; options.path, // 页面路径</span><br><span class=\"line\">              query: options &amp;&amp; options.query, // 页面参数</span><br><span class=\"line\">              scene: options &amp;&amp; options.scene // 场景编号</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">          self.pushToBreadcrumb(breadcrumb); // 把执行对象加入到面包屑中</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这样写，会把用户自定义的内容给覆盖掉，所以还需要把用户定义的函数和监控代码合并。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var originApp = App // 保存原对象</span><br><span class=\"line\">App = function(app) &#123;</span><br><span class=\"line\">    // .... 此处省略监控代码</span><br><span class=\"line\">    // .... 此处省略监控代码</span><br><span class=\"line\">    originApp(app) // 执行用户定义的方法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小程序性能监控插件\"><a href=\"#小程序性能监控插件\" class=\"headerlink\" title=\"小程序性能监控插件\"></a>小程序性能监控插件</h3><ul>\n<li><a href=\"https://www.fundebug.com/\">Fundebug</a> 提供网站、微信小程序和小游戏的 bug 监控服务,例如：API 的一些函数调用情况、监控函数调用的参数、收集 HTTP 请求错误的 body、监控某些特定的自定义函数等。</li>\n<li><a href=\"https://www.frontjs.com/\">FrontJS</a> 的小程序错误监控相比于微信小程序后台的数据监控，增加了对于错误的统计和产生错误的相关用户分析，FrontJS 可以收集精细到 console.log 级别的任何 JavaScript 异常信息并提供 stack trace 信息；对于任何一条错误信息或访问，它都会统计到该用户 IP、屏幕分辨率、DPR、操作系统类型和微信版本，方便更有针对性的去调试出现的错误。</li>\n<li><a href=\"http://dp.baidu.com/\">百度数据统计分析展示平台</a> 提供对 web 页面的性能、访问点击、js 异常、浏览器新特性、跨站资源、XSS 漏洞、自定义事件、Native 性能检测服务，对 百度小程序 的支持还需进一步调研。</li>\n</ul>\n<h2 id=\"白屏监控\"><a href=\"#白屏监控\" class=\"headerlink\" title=\"白屏监控\"></a>白屏监控</h2><p>用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。</p>\n<h3 id=\"白屏时间\"><a href=\"#白屏时间\" class=\"headerlink\" title=\"白屏时间\"></a>白屏时间</h3><p>页面完全空白的时间，web 可以在页面的 head 底部添加的 JS 代码用来做白屏时间的标记。</p>\n<h3 id=\"微信-web-资源离线存储\"><a href=\"#微信-web-资源离线存储\" class=\"headerlink\" title=\"微信 web 资源离线存储\"></a>微信 web 资源离线存储</h3><p>通过使用微信离线存储，Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有 Web App 累计最多可缓存 5M 的资源。这个设计有点类似 HTML5 的 Application Cache。</p>\n","categories":["小程序开发"],"tags":["小程序"]},{"title":"常用算法总结","url":"/2022/12/16/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","content":"<h2 id=\"迭代算法-Iteration\"><a href=\"#迭代算法-Iteration\" class=\"headerlink\" title=\"迭代算法(Iteration)\"></a>迭代算法(Iteration)</h2><h2 id=\"递归算法-Recursion\"><a href=\"#递归算法-Recursion\" class=\"headerlink\" title=\"递归算法(Recursion)\"></a>递归算法(Recursion)</h2><ul>\n<li>二叉树的遍历算法</li>\n</ul>\n<h2 id=\"回溯算法-Backtrack\"><a href=\"#回溯算法-Backtrack\" class=\"headerlink\" title=\"回溯算法(Backtrack)\"></a>回溯算法(Backtrack)</h2><ul>\n<li>八皇后问题</li>\n</ul>\n<h2 id=\"深度优先-Depth-First-Search-DFS\"><a href=\"#深度优先-Depth-First-Search-DFS\" class=\"headerlink\" title=\"深度优先(Depth First Search, DFS)\"></a>深度优先(Depth First Search, DFS)</h2><ul>\n<li>全排列问题</li>\n</ul>\n<h2 id=\"广度优先-Breadth-First-Search-BFS\"><a href=\"#广度优先-Breadth-First-Search-BFS\" class=\"headerlink\" title=\"广度优先(Breadth First Search, BFS)\"></a>广度优先(Breadth First Search, BFS)</h2><p><strong>类型</strong></p>\n<ul>\n<li>不需要确定当前深度</li>\n<li>需要确定当前深度</li>\n</ul>\n<h2 id=\"动态规划-Dynamic-Programming-DP\"><a href=\"#动态规划-Dynamic-Programming-DP\" class=\"headerlink\" title=\"动态规划(Dynamic Programming, DP)\"></a>动态规划(Dynamic Programming, DP)</h2><ul>\n<li>斐波那契数列</li>\n<li>爬楼梯问题</li>\n<li>背包问题</li>\n<li>最长公共子序列</li>\n<li>最优二叉搜索树</li>\n</ul>\n<h2 id=\"分治算法-二分法-Binary-Algorithm\"><a href=\"#分治算法-二分法-Binary-Algorithm\" class=\"headerlink\" title=\"分治算法(二分法, Binary Algorithm)\"></a>分治算法(二分法, Binary Algorithm)</h2><ul>\n<li>二分排序</li>\n<li>二分查找</li>\n</ul>\n<h2 id=\"贪心算法-Greedy-Algorithm\"><a href=\"#贪心算法-Greedy-Algorithm\" class=\"headerlink\" title=\"贪心算法(Greedy Algorithm)\"></a>贪心算法(Greedy Algorithm)</h2><ul>\n<li>霍夫曼编码</li>\n</ul>\n<h2 id=\"滑动窗口-Slipping-Window\"><a href=\"#滑动窗口-Slipping-Window\" class=\"headerlink\" title=\"滑动窗口(Slipping Window)\"></a>滑动窗口(Slipping Window)</h2><h2 id=\"双指针-Double-Pointer\"><a href=\"#双指针-Double-Pointer\" class=\"headerlink\" title=\"双指针(Double Pointer)\"></a>双指针(Double Pointer)</h2><h2 id=\"位运算-Bit\"><a href=\"#位运算-Bit\" class=\"headerlink\" title=\"位运算(Bit)\"></a>位运算(Bit)</h2><p>要点</p>\n<ul>\n<li>异或运算（xor）</li>\n<li>任何数与 0 做异或运算，结果仍为原来的数。即：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a⊕0=a</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任何数和其自身做异或运算，结果为 0。即：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a⊕a=0</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>异或运算满足交换律和结合律。即：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a⊕b=b⊕a</span><br><span class=\"line\">a⊕b⊕c=a⊕(b⊕c)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动机\"><a href=\"#自动机\" class=\"headerlink\" title=\"自动机\"></a>自动机</h2><ul>\n<li>搜索&#x2F;排序算法</li>\n<li>快速排序</li>\n<li>希尔排序</li>\n<li>插入排序</li>\n<li>拓扑排序</li>\n<li>二分排序</li>\n<li>堆排序</li>\n</ul>\n<h2 id=\"关于链表-List\"><a href=\"#关于链表-List\" class=\"headerlink\" title=\"关于链表(List)\"></a>关于链表(List)</h2><ul>\n<li>单向链表</li>\n<li>双向链表</li>\n<li>广义表</li>\n</ul>\n<h2 id=\"关于树-Tree\"><a href=\"#关于树-Tree\" class=\"headerlink\" title=\"关于树(Tree)\"></a>关于树(Tree)</h2><ul>\n<li>二叉树遍历<ul>\n<li>前序遍历</li>\n<li>中序遍历</li>\n<li>后序遍历</li>\n<li>层序遍历</li>\n</ul>\n</li>\n<li>二叉搜索树</li>\n<li>红黑树</li>\n<li>kd 树</li>\n<li>B 树</li>\n<li>堆</li>\n<li>极大堆</li>\n</ul>\n<h2 id=\"关于图-Graph\"><a href=\"#关于图-Graph\" class=\"headerlink\" title=\"关于图(Graph)\"></a>关于图(Graph)</h2><ul>\n<li>最小生成树</li>\n<li>最短路径问题</li>\n</ul>\n<h2 id=\"关于栈、队列、散列表-queue-stack-hashlist\"><a href=\"#关于栈、队列、散列表-queue-stack-hashlist\" class=\"headerlink\" title=\"关于栈、队列、散列表(queue, stack, hashlist)\"></a>关于栈、队列、散列表(queue, stack, hashlist)</h2><ul>\n<li>栈对于二叉树层序遍历的实现</li>\n<li>最大优先级队列</li>\n</ul>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"彻底弄懂强缓存与协商缓存","url":"/2022/10/24/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/","content":"<p>在工作中，前端代码打包之后生成的静态资源就要发布到静态服务器上，这时候就要对这些静态资源做一些运维配置，其中，gzip 和设置缓存是必不可少的。这两项是最直接影响到网站性能和用户体验的。</p>\n<p>缓存的优点：</p>\n<ul>\n<li>减少了不必要的数据传输，节省带宽</li>\n<li>减少服务器的负担，提升网站性能</li>\n<li>加快了客户端加载网页的速度</li>\n<li>用户体验友好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>资源如果有更改但是客户端不及时更新会造成用户获取信息滞后，如果老版本有 bug 的话，情况会更加糟糕。</li>\n</ul>\n<p><strong>所以，为了避免设置缓存错误，掌握缓存的原理对于我们工作中去更加合理的配置缓存是非常重要的。</strong></p>\n<h2 id=\"一、强缓存\"><a href=\"#一、强缓存\" class=\"headerlink\" title=\"一、强缓存\"></a>一、强缓存</h2><p>到底什么是强缓存？强在哪？其实强是强制的意思。当浏览器去请求某个文件的时候，服务端就在 response header 里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体表现为：<br>response header 的 cache-control，常见的设置是 max-age public private no-cache no-store 等</p>\n<p>如下图,<br>设置了<strong>cache-control:max-age&#x3D;31536000,public,immutable</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6782944-2953183b0a2ab1dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/751/format/webp\" alt=\"image\"></p>\n<p>max-age 表示缓存的时间是 31536000 秒（1 年），public 表示可以被浏览器和代理服务器缓存，代理服务器一般可用 nginx 来做。immutable 表示该资源永远不变，但是实际上该资源并不是永远不变，它这么设置的意思是为了让用户在刷新页面的时候不要去请求服务器！啥意思？就是说，如果你只设置了 cache-control:max-age&#x3D;31536000,public 这属于强缓存，每次用户正常打开这个页面，浏览器会判断缓存是否过期，没有过期就从缓存中读取数据；但是有一些 “聪明” 的用户会点击浏览器左上角的刷新按钮去刷新页面，这时候就算资源没有过期（1 年没这么快过），浏览器也会直接去请求服务器，这就是额外的请求消耗了，这时候就相当于是走协商缓存的流程了（下面会讲到）。如果 cache-control:max-age&#x3D;315360000,public 再加个 immutable 的话，就算用户刷新页面，浏览器也不会发起请求去服务器，浏览器会直接从本地磁盘或者内存中读取缓存并返回 200 状态，看上图的红色框（from memory cache）。这是 2015 年 facebook 团队向制定 HTTP 标准的 IETF 工作组提到的建议：他们希望 HTTP 协议能给 Cache-Control 响应头增加一个属性字段表明该资源永不过期，浏览器就没必要再为这些资源发送条件请求了。</p>\n<h3 id=\"强缓存总结\"><a href=\"#强缓存总结\" class=\"headerlink\" title=\"强缓存总结\"></a>强缓存总结</h3><ol>\n<li><p>cache-control: max-age&#x3D;xxxx，public<br>客户端和代理服务器都可以缓存该资源；<br>客户端在 xxx 秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,status code:200 ，如果用户做了刷新操作，就向服务器发起 http 请求</p>\n</li>\n<li><p>cache-control: max-age&#x3D;xxxx，private<br>只让客户端可以缓存该资源；代理服务器不缓存<br>客户端在 xxx 秒内直接读取缓存,status code:200</p>\n</li>\n<li><p>cache-control: max-age&#x3D;xxxx，immutable<br>客户端在 xxx 秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起 http 请求</p>\n</li>\n<li><p>cache-control: no-cache<br>跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了 no-cache 就不会走强缓存了，每次请求都会询问服务端。</p>\n</li>\n<li><p>cache-control: no-store<br>不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。</p>\n</li>\n</ol>\n<h2 id=\"二、协商缓存\"><a href=\"#二、协商缓存\" class=\"headerlink\" title=\"二、协商缓存\"></a>二、协商缓存</h2><p>上面说到的强缓存就是给资源设置个过期时间，客户端每次请求资源时都会看是否过期；只有在过期才会去询问服务器。所以，强缓存就是为了给客户端自给自足用的。而当某天，客户端请求该资源时发现其过期了，这时就会去请求服务器了，而这时候去请求服务器的这过程就可以设置协商缓存。这时候，协商缓存就是需要客户端和服务器两端进行交互的。</p>\n<p><strong>怎么设置协商缓存？</strong></p>\n<p>response header 里面的设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">etag: &#x27;5c20abbd-e2e8&#x27;</span><br><span class=\"line\">last-modified: Mon, 24 Dec 2018 09:49:49 GMT</span><br></pre></td></tr></table></figure>\n\n<p>etag：每个文件有一个，改动文件了就变了，就是个文件 hash，每个文件唯一，就像用 webpack 打包的时候，每个资源都会有这个东西，如： app.js 打包后变为 app.c20abbde.js，加个唯一 hash，也是为了解决缓存问题。</p>\n<p>last-modified：文件的修改时间，精确到秒</p>\n<p>也就是说，每次请求返回来 response header 中的 etag 和 last-modified，在下次请求时在 request header 就把这两个带上，服务端把你带过来的标识进行对比，然后判断资源是否更改了，如果更改就直接返回新的资源，和更新对应的 response header 的标识 etag、last-modified。如果资源没有变，那就不变 etag、last-modified，这时候对客户端来说，每次请求都是要进行协商缓存了，即：</p>\n<p>发请求–&gt;看资源是否过期–&gt;过期–&gt;请求服务器–&gt;服务器对比资源是否真的过期–&gt;没过期–&gt;返回 304 状态码–&gt;客户端用缓存的老资源。</p>\n<p>这就是一条完整的协商缓存的过程。</p>\n<p>当然，当服务端发现资源真的过期的时候，会走如下流程：</p>\n<p>发请求–&gt;看资源是否过期–&gt;过期–&gt;请求服务器–&gt;服务器对比资源是否真的过期–&gt;过期–&gt;返回 200 状态码–&gt;客户端如第一次接收该资源一样，记下它的 cache-control 中的 max-age、etag、last-modified 等。</p>\n<p>所以协商缓存步骤总结：</p>\n<p>请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。<br>如果资源没更改，返回 304，浏览器读取本地缓存。<br>如果资源有更改，返回 200，返回最新的资源。</p>\n<p>补充一点，response header 中的 etag、last-modified 在客户端重新向服务端发起请求时，会在 request header 中换个 key 名：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// response header</span><br><span class=\"line\">etag: &#x27;5c20abbd-e2e8&#x27;</span><br><span class=\"line\">last-modified: Mon, 24 Dec 2018 09:49:49 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">// request header 变为</span><br><span class=\"line\">if-none-matched: &#x27;5c20abbd-e2e8&#x27;</span><br><span class=\"line\">if-modified-since: Mon, 24 Dec 2018 09:49:49 GMT</span><br></pre></td></tr></table></figure>\n\n<p><strong>为什么要有 etag？</strong></p>\n<p>你可能会觉得使用 last-modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 etag 呢？HTTP1.1 中 etag 的出现（也就是说，etag 是新增的，为了解决之前只有 If-Modified 的缺点）主要是为了解决几个 last-modified 比较难解决的问题：</p>\n<ol>\n<li><p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 get；</p>\n</li>\n<li><p>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，if-modified-since 能检查到的粒度是秒级的，这种修改无法判断(或者说 UNIX 记录 MIME 只能精确到秒)；</p>\n</li>\n<li><p>某些服务器不能精确的得到文件的最后修改时间。</p>\n</li>\n</ol>\n<p><strong>怎么设置强缓存与协商缓存</strong></p>\n<ol>\n<li>后端服务器如 nodejs:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">res.setHeader(&#x27;max-age&#x27;: &#x27;3600 public&#x27;)</span><br><span class=\"line\">res.setHeader(etag: &#x27;5c20abbd-e2e8&#x27;)</span><br><span class=\"line\">res.setHeader(&#x27;last-modified&#x27;: Mon, 24 Dec 2018 09:49:49 GMT)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>nginx 配置</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6782944-b8701adefe6341e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp\" alt=\"image\"></p>\n<p>偶尔自己折腾一番非前端的东西时，若心中有数，自然不会手忙脚乱。</p>\n<p><strong>怎么去用？</strong></p>\n<p>举个例子，像目前用 vue-cli 打包后生成的单页文件是有一个 html，与及一堆 js css img 资源，怎么去设置这些文件呢，核心需求是</p>\n<ol>\n<li>要有缓存，毋庸置疑</li>\n<li>当发新包的时候，要避免加载老的缓存资源</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6782944-618911ae2fbba06c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/236/format/webp\" alt=\"image\"></p>\n<p><strong>我的做法是：</strong></p>\n<p>index.html 文件采用协商缓存，理由就是要用户每次请求 index.html 不拿浏览器缓存，直接请求服务器，这样就保证资源更新了，用户能马上访问到新资源，如果服务端返回 304，这时候再拿浏览器的缓存的 index.html，<strong>切记不要设置强缓存！！！</strong></p>\n<p>其他资源采用强缓存 + 协商缓存,理由就不多说了。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"微信小程序开发总结与心得","url":"/2022/12/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BF%83%E5%BE%97/","content":"<h2 id=\"1-微信小程序基本知识与概念\"><a href=\"#1-微信小程序基本知识与概念\" class=\"headerlink\" title=\"1 微信小程序基本知识与概念\"></a>1 微信小程序基本知识与概念</h2><p>微信小程序开发，入门算是非常简单，只要看官方文档即可<a href=\"https://developers.weixin.qq.com/miniprogram/dev/\">小程序简易教程</a>。如何申请小程序账号，如何开发自己第一个小程序，如何发布，这一系列 hello world 操作官方文档都有手把手教学。小程序开发的每个步骤，提供的能力文档里都有，个人觉得，做小程序开发，有事没事都看下文档，因为小程序更新比较快速，同时一些细小的能力我们可能会漏掉，所以多看文档。</p>\n<h3 id=\"1-1-简单说下目录结构和-app-json\"><a href=\"#1-1-简单说下目录结构和-app-json\" class=\"headerlink\" title=\"1.1 简单说下目录结构和 app.json\"></a>1.1 简单说下目录结构和 app.json</h3><p><strong>文件目录结构很灵活</strong></p>\n<p>先来看看小程序项目的文件目录结构</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-101ad1c2c34b78e2?imageMogr2/auto-orient/strip%7CimageView2/2/w/358/format/webp\" alt=\"image\"></p>\n<p>除了 app.json 必须位于根目录下，其他文件随意，并且都可以删。并且页面文件可以放到任何位置，只要在 app.json 中的 pages 中配置了就可以。可以说是很灵活。你还可以多个页面放在同个文件夹下。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-34ea9f7b6d403430?imageMogr2/auto-orient/strip%7CimageView2/2/w/294/format/webp\" alt=\"image\"></p>\n<p><strong>接下来简单介绍下各个文件</strong>:</p>\n<p>全局配置文件 app.json<br>对于一个小程序项目而言，最重要的文件是 app.json，它也是开发工具识别一个文件夹是否为小程序项目的标识。当使用开发者工具创建一个项目时，如果选择的是空文件夹，它会创建一个新的项目。如果是一个有文件的文件夹，它会看该文件夹中是否有 app.json 文件，如果有，则它会认为是一个小程序项目，则会打开该项目，如果文件夹中没有 app.json 文件，则提示无法创建项目。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-f636fee7c8bb0521?imageMogr2/auto-orient/strip%7CimageView2/2/w/411/format/webp\" alt=\"image\"></p>\n<p>app.json 必须放置于项目的根目录下，它是小程序项目的全局配置文件。在小程序代码包准备完成进行启动后（下文会详细介绍小程序从用户点击打开小程序到小程序销毁的整个过程），会先读取 app.json 文件，进行小程序的初始化，比如初始化整个小程序外框样式，获取首页页面地址等。</p>\n<blockquote>\n<p>其实小程序就是微信提供的一个容器，各个页面就在这个容器里加载运行销毁</p>\n</blockquote>\n<p>下面介绍下小程序的全局配置选项:</p>\n<p>注意：</p>\n<blockquote>\n<ul>\n<li>所有配置项 key 必须使用双引号括起来，value 值为字符串类型的也必须使用双引号，不支持单引号</li>\n<li>因为小程序功能迭代非常迅速，基础库版本更新也很快，所以下面的介绍是截止目前的最新版本库 2.4.0</li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>pages</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;pages&quot;: [</span><br><span class=\"line\">        &quot;pages/index/index&quot;,</span><br><span class=\"line\">        &quot;pages/log/log&quot;</span><br><span class=\"line\">    ]</span><br></pre></td></tr></table></figure>\n\n<p>在 app.json 中，pages 选项是必须配置的。该配置项注册了小程序所有页面的地址，其中每一项都是页面的 <strong>路径+文件名</strong> 。配置的字符串其实就是每个页面 wxml 路径，去掉.wxml 后缀。因为框架会自动去寻找路径下.json、.js、.wxml、.wxss 四个文件进行整合。也就意味着.json、.js、.wxss 这三个文件的文件名必须要和.wxml 的一致，否则不生效。所以一个页面至少必须得有.wxml 文件。</p>\n<blockquote>\n<p>总结：</p>\n<p>页面的.json、.js、.wxss 文件必须与.wxml 文件同名，否则不生效<br>每个页面都必须在 pages 下注册，没有注册的页面，如果不访问，编译能通过，一旦试图访问该页面则会报错<br>可以通过在 pages 下添加一个选项快速新建一个页面，开发工具会自动生成对应的文件</p>\n</blockquote>\n<ul>\n<li><strong>window</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;window&quot;:&#123;</span><br><span class=\"line\">    &quot;enablePullDownRefresh&quot;: ture,</span><br><span class=\"line\">    &quot;navigationStyle&quot;: &quot;custom&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>该配置项用于配置小程序的全局外观样式，具体请查阅文档。这里重点提一下两个比较实用的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//去掉默认的导航栏，轻松实现全面屏</span><br><span class=\"line\">&quot;navigationStyle&quot;: &quot;custom&quot; ,</span><br><span class=\"line\">//开启自带的下拉刷新，减少自己写样式</span><br><span class=\"line\">&quot;enablePullDownRefresh&quot;: true,</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>tabBar</strong><br>该选项可以让我们轻松实现导航栏 tab 效果，不过有个不足就是跳转可操作性非常低。就是每个 tab 只能跳当前小程序页面，不能跳到其他小程序。如果需要跳到其他小程序，还需自己封装个组件。</p>\n</li>\n<li><p><strong>networkTimeout</strong><br>这是网络请求超时时间，可以设置不同类型请求的超时时间，比如 wx.request、wx.uploadFile 等。其实很多时候我们都会忽略这个选项，小程序默认是 60s 超时，但我们应该手动设置更低的值，因为我们的接口一般都会在 10s 内完成请求（如果超过 10s，那你是时候优化了），所以如果网络或者服务器出问题了，那么会让用户等 60s，最后还是失败，这对用户很不友好，还不如提前告诉用户，现在出问题了，请稍后再试。</p>\n</li>\n</ul>\n<p>前段时间由于公司服务器网关出现了点小问题，导致有些请求连接不上，出现大量连接超时。通过之前添加的错误信息收集插件(这个是性能优化，下文有讲到)看到了很多接口返回 time-out 60s。让用户等了 60s 还是失败，这不友好。所以这个超时时间一般设置 15s-30s 比较好。</p>\n<ul>\n<li><p><strong>debug</strong><br>是否开启 debug 功能，开启后查看更多的调试信息，方便定位问题，开发阶段可以考虑开启</p>\n</li>\n<li><p><strong>functionalPages</strong><br>这个是结合插件使用的，因为微信小程序插件有很大限制，插件里提供的 api 很有限，wx.login 和 wx.requestPayment 在插件中不能使用，如果需要获取用户信息和进行支付，就必须通过插件提供的功能去实现。当你的小程序下的插件启用了插件功能时，必须设置该选项为 true</p>\n</li>\n</ul>\n<blockquote>\n<p>小程序插件必须挂载在一个微信小程序中，一个小程序也只能开通一个插件。当你小程序开通的插件启用了插件功能时，必须设置该选项为 true</p>\n</blockquote>\n<ul>\n<li><strong>plugins</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;plugins&quot;: &#123;</span><br><span class=\"line\">    &quot;myPlugin&quot;: &#123;</span><br><span class=\"line\">        &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">        &quot;provider&quot;: &quot;wxidxxxxxxxxxxxxxxxx&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当小程序使用了插件就必须在这里声明引入。小程序自身开通的小程序不能在本身应用</p>\n<ul>\n<li><strong>navigateToMiniProgramAppIdList</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;navigateToMiniProgramAppIdList&quot;: [</span><br><span class=\"line\">    &quot;wxe5f52902cf4de896&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>之前小程序之间只要是关联了通过公众号就可以相互跳转，如今微信做出了限制，要这里配置好需要跳转的小程序，上限为 10 个，还必须写死，不支持配置。所以当小程序有跳转到其他小程序，一定要配好这个，否则无法跳转。</p>\n<ul>\n<li><strong>usingComponents</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;usingComponents&quot;: &#123;</span><br><span class=\"line\">    &quot;hello-component&quot;: &quot;plugin://myPlugin/hello-component&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用自定义组件或者插件提供的组件前，必须先在这里声明</p>\n<h3 id=\"1-2-小程序启动与生命周期\"><a href=\"#1-2-小程序启动与生命周期\" class=\"headerlink\" title=\"1.2 小程序启动与生命周期\"></a>1.2 小程序启动与生命周期</h3><p>下面来说说小程序从用户点击打开到销毁的整个过程。用图说话更清晰，特地画了个流程图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-453ef44118136478?imageMogr2/auto-orient/strip%7CimageView2/2/w/985/format/webp\" alt=\"image\"></p>\n<blockquote>\n<p>小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。 假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。</p>\n</blockquote>\n<p>上面的流程图包含了所有内容，但毕竟文字有限，接下来详细说下几个点。</p>\n<ol>\n<li>小程序会先检测本地是否有代码包，然后先使用本地代码包进行小程序启动，再异步去检测远端版本。这就是小程序的离线能力，相对于 H5，这是优点，能加快小程序启动速度。</li>\n<li>当本地有小程序代码包时，会异步去请求远端是否有最新版本。有则下载到本地，但该次的启动还是会用之前的代码。所以当我们发布了最新的版本，需要用户两次冷启动，才能使用到最新版本。如果想要用户一次冷启动就可以使用到最新版本，可以使用小程序提供的版本更新<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/update/wx.getUpdateManager.html\">API 更新</a>。代码如下，只要在 app.js 的 onShow 函数加上以下代码，每次小程序有更新，都会提示用户更新小程序。不过这个每次提示更新，一定程度上影响用户体验。如果结合后端配置，每次进来读取配置，就可以实现根据需要是否进行该版本的更新，比如一定需要用户更新才能使用的，那就使用强制更新。对于一些小版本，就不需要使用这个强制更新。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (wx.canIUse(&#x27;getUpdateManager&#x27;)) &#123;</span><br><span class=\"line\">        //检测是否有版本更新</span><br><span class=\"line\">        var updateManager = wx.getUpdateManager()</span><br><span class=\"line\">        updateManager.onCheckForUpdate(function (res) &#123;</span><br><span class=\"line\">            // 请求完新版本信息的回调，有更新</span><br><span class=\"line\">            if (res.hasUpdate) &#123;</span><br><span class=\"line\">                wx.showLoading(&#123;</span><br><span class=\"line\">                    title: &#x27;检测到新版本&#x27;,</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        updateManager.onUpdateReady(function () &#123;</span><br><span class=\"line\">            wx.hideLoading();</span><br><span class=\"line\">            wx.showModal(&#123;</span><br><span class=\"line\">                title: &#x27;更新提示&#x27;,</span><br><span class=\"line\">                content: &#x27;新版本已经准备好，是否重启应用？&#x27;,</span><br><span class=\"line\">                success: function (res) &#123;</span><br><span class=\"line\">                    if (res.confirm) &#123;</span><br><span class=\"line\">                        //清楚本地缓存</span><br><span class=\"line\">                        try &#123;</span><br><span class=\"line\">                            wx.clearStorageSync()</span><br><span class=\"line\">                        &#125; catch (e) &#123;</span><br><span class=\"line\">                            // Do something when catch error</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span><br><span class=\"line\">                        updateManager.applyUpdate()</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        updateManager.onUpdateFailed(function () &#123;</span><br><span class=\"line\">            // 新的版本下载失败</span><br><span class=\"line\">            console.log(&#x27;新版本下载失败&#x27;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-开发工具\"><a href=\"#1-3-开发工具\" class=\"headerlink\" title=\"1.3 开发工具\"></a>1.3 开发工具</h3><p>对于小程序开发工具，还没有一款让开发者满意的工具，至少我不满意，哈哈哈！微信提供的<a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html\">微信开发者工具</a>。除了编译器不行外，其他都还行。但由于开发工具、ios、android 三个平台运行小程序的内核不同。所以有时会出现开发工具上没问题，真机有问题的情况，特别是样式，可以通过在开发工具中设置<strong>上传代码时样式自动补全</strong>来解决大多数问题。另外微信开发者工具提供了真机调试功能，该功能对真机调试非常方便</p>\n<p>还有就是可以自定义编译条件</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-9d9e1ef862ec01a2?imageMogr2/auto-orient/strip%7CimageView2/2/w/668/format/webp\" alt=\"image\"></p>\n<p>可以模拟任意场景值、设置页面参数、模拟更新等。基本满足了所有的调试。不过还有一些效果，开发工具和真机可能会不同，所以还是需要在真机上确认。</p>\n<h3 id=\"1-4-测试-审核-上线的那些事\"><a href=\"#1-4-测试-审核-上线的那些事\" class=\"headerlink\" title=\"1.4 测试-审核-上线的那些事\"></a>1.4 测试-审核-上线的那些事</h3><p>服务器域名 request 合法域名每个月只能修改 5 次。所以不应该每次请求一个新域名就添加一次。在开发阶段，在微信开发者工具上勾上不校验合法域名，真机上需要开启调试模式，就可以先不配置合法域名的情况下请求任何域名甚至 ip 地址。待开发完成了，再一次性配置所有合法域名，在微信开发者工具上取消不校验合法域名，真机上关闭调试模式，然后开始测试。</p>\n<p>使用体验版+线上环境的接口，这就是和线上环境一模一样的，所以在发布前，使用体验版+线上环境过一遍。如果没问题，发布以后也就没问题了。</p>\n<p>小程序二维码只要发布了线上版本调用生成小程序二维码接口才能成功返回二维码。而且二维码识别是线上版本，所以还未发布的小程序是无法生成二维码的。</p>\n<p>线上版本有个版本回退功能，这里有个坑，就是版本回退以后，退回的版本需要重新审核才能发布</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-7f06298163544864?imageMogr2/auto-orient/strip%7CimageView2/2/w/307/format/webp\" alt=\"image\"></p>\n<p>还有设置体验版时可以设置指定路径和参数，这样很方便测试</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-5430f5ac8e795afe?imageMogr2/auto-orient/strip%7CimageView2/2/w/610/format/webp\" alt=\"image\"></p>\n<h2 id=\"2-重点介绍几个组件\"><a href=\"#2-重点介绍几个组件\" class=\"headerlink\" title=\"2 重点介绍几个组件\"></a>2 重点介绍几个组件</h2><p>接下来说说使用频率比较多，功能强大，但又有比较多坑的几个组件</p>\n<h3 id=\"2-1-web-view\"><a href=\"#2-1-web-view\" class=\"headerlink\" title=\"2.1 web-view\"></a>2.1 web-view</h3><p>web-view 的出现，让小程序和 H5 网页之前的跳转成为了可能。通过把 H5 页面放置到 web-view 中，可以让 H5 页面在小程序内运行。同时在 H5 页面中也可以跳转回小程序页面。可以说是带来了很大的便利，但同时由于 web-view 的诸多限制，用起来也不是很舒服。</p>\n<blockquote>\n<ol>\n<li>需要打开的 H5 页面必须在后台业务页面中配置，这其中还有个服务校验。另外 H5 页面必须是 https 协议，否则无法打开</li>\n<li>web-view 中无法在页面中调起分享，如果需要分享，比如跳回小程序原生页面</li>\n<li>小程序与 web-view 里 H5 通信问题。小程序向 web-view 传递，不敏感信息可以通过页面 url 传递。如果是敏感信息比如用户 token 等，可以让服务端重定向，比如请求服务端一个地址，让他把敏感信息写在 cookie 中，再重定向到我们的 H5 页面。之后 H5 页面就可以通过在 cookie 中拿这些敏感数据了，或者 http-only，发送请求时直接带上。</li>\n<li>每次 web-view 中 src 值有变化就会重新加载一次页面。所以用 src 拼接参数时，需要先赋值给一个变量拼接好，再一次性 setData 给 web-view 的 src，防止页面重复刷新</li>\n<li>从微信客户端 6.7.2 版本开始，navigationStyle: custom 对<web-view>组件无效。也就意味着使用 web-view 时，自带的导航栏无法去掉。</li>\n<li>因为导航栏无法去掉，这里就出现了一个巨大的坑。实现全屏效果问题。如果想要实现 H5 页面全屏，就是不滑动，全屏显示完所有内容。这时如果你使用 width:100%;height:100%，你会发现，你页面底部可能会缺失一段。上图:</li>\n</ol>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-9488d1d3f38ec3b2?imageMogr2/auto-orient/strip%7CimageView2/2/w/864/format/webp\" alt=\"image\"></p>\n<p>因为 web-view 是默认铺满全屏的，也就是 web-view 宽高和屏幕宽高一样。然后 H5 页面这是高度 100%，这是相对 web-view 的高度，也是屏幕高度。但是关键问题：<strong>web-view 里 H5 页面是从导航栏下开始渲染的</strong>。这就导致了 H5 页面溢出了屏幕，无法达到全屏效果。</p>\n<p><strong>解决方法</strong></p>\n<p>这个问题我在前段时间的实际项目碰到过，我们要做个 H5 游戏，要求是全屏，刚开始我也是设置高度 100%。后来发现底部一块不见了。我的解决方法比较粗暴，如果有更好的解决方法，欢迎评论交流。<br>我的解决方法是：通过拼接宽高参数在 H5 页面 url 上，这个宽高是在 web-view 外层计算好的。H5 页面直接读取 url 上的宽高，动态设置页面的宽高。页面高度的计算，根据上图，很显然就是屏幕高度减去导航栏高度。宽度都是一样的，直接是屏幕宽度。</p>\n<p>但问题又来了，貌似没有途径获取导航栏高度。而且对于不同机型的手机，导航栏高度不同。经过了对多个机型导航栏跟屏幕高度的比较。发现了一个规律，导航栏高度与屏幕高度、屏幕宽高比有一定的关系。所以根据多个机型就计算出了这个比例。这解决了 95%以上手机的适配问题，只有少数机型适配不是很好。基本实现了全屏效果。具体代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">onLoad (options) &#123;</span><br><span class=\"line\">    //同步获取屏幕信息，现在用到的是屏幕宽高</span><br><span class=\"line\">    var res = wx.getSystemInfoSync();</span><br><span class=\"line\">    if (res) &#123;</span><br><span class=\"line\">        var widHeight = res.screenHeight;</span><br><span class=\"line\">        //对于大多数手机，屏幕高度/屏幕宽度 = 1.78。此时导航栏占屏幕高度比为0.875</span><br><span class=\"line\">        var raito = 0.875;</span><br><span class=\"line\">        if (res.screenHeight / res.screenWidth &gt; 1.95) &#123;</span><br><span class=\"line\">            //对于全屏手机，这个占比会更高些</span><br><span class=\"line\">            raito = 0.885;</span><br><span class=\"line\">        &#125; else if (res.screenHeight / res.screenWidth &gt; 1.885) &#123;</span><br><span class=\"line\">            raito = 0.88;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //做兼容处理，只有微信版本库高于6.7.2，有导航栏才去兼容，否则可以直接使用高度100%。res.statusBarHeight是手机顶部状态栏高度</span><br><span class=\"line\">        //如果微信版本号大于6.7.2，有导航栏</span><br><span class=\"line\">        if (util.compareVersion(res.version, &quot;6.7.2&quot;) &gt; 0) &#123;</span><br><span class=\"line\">            widHeight = Math.round(widHeight * raito) + (res.statusBarHeight || 0);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.setDate(&#123;</span><br><span class=\"line\">            //将H5页面宽高拼接在url上，赋值给web-view的src即可加载出H5页面</span><br><span class=\"line\">            webview_src: util.joinParams(h5_src, &#123;</span><br><span class=\"line\">                &quot;height&quot;: widHeight,</span><br><span class=\"line\">                &quot;width&quot;: res.screenWidth</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-scroll-view\"><a href=\"#2-2-scroll-view\" class=\"headerlink\" title=\"2.2 scroll-view\"></a>2.2 scroll-view</h3><p>当我们要实现一个区域内滑动效果时，在 H5 页面中我们设置<code>overflow-y: scroll</code>即可。但在小程序中，没有该属性。需要用到 scroll-view 标签。具体操作实现我们可以查看文件<a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html\">scroll-view</a>。</p>\n<p>锚点定位在前端开发中会经常用到，在 H5 页面中，我们会在 url 后面加上#来实现锚点定位效果。但是在小程序中这样是不起作用的，因为小程序内渲染页面的容器不是一个浏览器，无法实时监听 Hash 值的变化。但是使用 scroll-view，我们可以实现锚点定位效果。主要是使用 scroll-into-view 属性，具体实现我们直接上代码</p>\n<blockquote>\n<p>scroll-into-view | String | 值应为某子元素 id（id 不能以数字开头）。设置哪个方向可滚动，则在哪个方向滚动到该元素</p>\n</blockquote>\n<blockquote>\n<p>wxml 文件</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--toView的值动态变化，当toView为luckydraw时，会定位到id为luckydraw的view</span><br><span class=\"line\">    需要注意的是，这里需要设置高度为屏幕高度--&gt;</span><br><span class=\"line\">    &lt;scroll-view scroll-y scroll-into-view=&quot;&#123;&#123;toView&#125;&#125;&quot;</span><br><span class=\"line\">    scroll-with-animation = &quot;true&quot; style=&quot;height: 100%; white-space:nowrap&quot;&gt;</span><br><span class=\"line\">        &lt;view id=&quot;top&quot;&gt;&lt;/view&gt;</span><br><span class=\"line\">        &lt;view id=&quot;luckydraw&quot;&gt;&lt;/view&gt;</span><br><span class=\"line\">        &lt;view id=&quot;secskill&quot;&gt;&lt;/view&gt;</span><br><span class=\"line\">    &lt;scroll-view&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-canvas\"><a href=\"#2-3-canvas\" class=\"headerlink\" title=\"2.3 canvas\"></a>2.3 canvas</h3><p>画布标签，它是原生组件，所以它必须位于屏幕最上边，而且是不能隐藏的。所以如果想要使用 canvas 动态生成分享照片。那你要设置她的宽高和屏幕一样。要不导出为照片时就会失真。因为这个原因，所以生成分享照片还是由服务端实现吧，照片失真太严重了。</p>\n<h2 id=\"3-formid-收集\"><a href=\"#3-formid-收集\" class=\"headerlink\" title=\"3 formid 收集\"></a>3 formid 收集</h2><p>给用户发送消息对一个小程序是非常重要的，它可以召唤回用户，导量效果非常明显。我们可以通过模板消息向小程序用户发送消息，但前提是我们得获取到 openid 和 formid。用户登录我们即可获取到用户 openid。而只要用户有点击行为，我们即可<a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/form.html\">获取 formid</a>。所以说 formid 是很重要的。我们可以提前收集好 formid，在需要的时候给用户推送消息。我们可以给每个 button 都包上 form 标签，只要有用户点击行为都可以收集到 formid.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;form bindsubmit=&quot;formSubmit&quot; report-submit=&#x27;true&#x27;&gt;</span><br><span class=\"line\">    &lt;button  formType=&quot;submit&quot;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们实现一个 formid 收集系统，为了尽量减少冗余代码和减少对业务的影响，我们的设计是这样的</p>\n<ol>\n<li>在整个页面的最外层包裹 form 标签，不是每个 button 都包裹一个，这样只要是页面中<code>formType=submit</code>的 button 有点击都能获取到 formid。</li>\n<li>formid 保存在全局变量数组中，当小程序切换到后台是一次性发送。</li>\n<li>对于需要实时发送消息的，不添加到全局数组中，直接保存在页面变量中。</li>\n</ol>\n<blockquote>\n<p>wxml 文件</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--在整个页面的最外层包裹form标签，这样就不必对每个button都包裹一个form标签，代码简洁--&gt;</span><br><span class=\"line\">&lt;form bindsubmit=&quot;formSubmit&quot; report-submit=&#x27;true&#x27;&gt;</span><br><span class=\"line\">    &lt;view&gt;页面内容&lt;/view&gt;</span><br><span class=\"line\">    &lt;view&gt;页面内容&lt;/view&gt;</span><br><span class=\"line\">    &lt;button  formType=&quot;submit&quot;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">    &lt;view&gt;页面内容&lt;/view&gt;</span><br><span class=\"line\">    &lt;view&gt;</span><br><span class=\"line\">        &lt;button  formType=&quot;submit&quot;&gt;点击&lt;/button&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>page.js 文件</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//每次用户有点击，都将formid添加到全局数组中</span><br><span class=\"line\">formSubmit(e) &#123;</span><br><span class=\"line\">    //需要实时发送的，不添加</span><br><span class=\"line\">    if(e.target.dataset.sendMsg)&#123;</span><br><span class=\"line\">        formid =  e.detail.formId;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    app.appData.formIdArr.push(e.detail.formId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>app.js</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">onHide: function () &#123;</span><br><span class=\"line\">    //小程序切到后台时上传formid</span><br><span class=\"line\">    this.submitFormId();</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-性能优化相关\"><a href=\"#4-性能优化相关\" class=\"headerlink\" title=\"4 性能优化相关\"></a>4 性能优化相关</h2><p>从用户打开小程序到小程序销毁，我们可以想想有哪些地方是可以优化的。首先是打开速度。小程序打开速度直接影响了用户留存。在小程序后台，运维中心-监控告警下有个加载性能监控数据，我们可以看到小程序启动总耗时、下载耗时、首次渲染耗时等加载相关的数据。而这里的打开速度其实就是小程序的启动总耗时。它包括了代码包下载、首次渲染，微信内环境初始化等步凑。在这一步，我们能做的就是<strong>如何加快代码包下载速度和减少首次渲染时间</strong></p>\n<p>在小程序呈现给用户之后，接下来就是如何提高用户体验，增强小程序健壮性的问题了。每个程序都有 bug。只是我们没发现而已，尽管在测试阶段，我们进行了详尽的测试。但是在实际生产环境，不同的用户环境，不同的操作路径，随时会触发一些隐藏的 bug。这时如果用户没有向我们报告，我们是无法获知的。所以有必要给我们的小程序<strong>增加错误信息收集</strong>，js 脚本错误，意味着整个程序挂掉了，无法响应用户操作。所以对于运行时的脚本错误，我们应该上报。对出现的 bug 及时修复，增强程序健壮性，提高用户体验。</p>\n<p>每个程序都有大量的前后端数据交互，这是通过 http 请求进行的。因此，还有一个错误信息收集就是接口错误信息收集。对那些请求状态码非 2XX、3XX 的，或者请求接口成功了，但是数据不是我们预期的，都可以进行信息采集。</p>\n<p>通过对小程序运行时脚本和 http 请求进行监控，我们就可以实时了解我们线上小程序的运行状况，有什么问题可以及时发现，及时修复，极高地提高了用户体验性。</p>\n<h3 id=\"4-1-让小程序更快\"><a href=\"#4-1-让小程序更快\" class=\"headerlink\" title=\"4.1 让小程序更快\"></a>4.1 让小程序更快</h3><p>让小程序快，主要因素有两个，代码包下载和首屏渲染。<br>我们来看一个数据：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-59f56fb9a79610ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp\" alt=\"image\"></p>\n<p>前面状态小程序代码大小是 650Kb 左右，这是下载耗时（虽然跟用户网络有关，但这个是全部用户平均时间）是 1.3s 左右。但是经过优化，将代码包降低至 200kb 左右时。下载耗时只有 0.6s 左右。所以说，代码包减少 500kb，下载耗时能减少 0.5s。这个数据还是非常明显的。所以说，在不影响业务逻辑的情况下，我们小程序代码包应该尽可能地小。那么如何降低代码包大小呢？以下有几点可以参考</p>\n<ol>\n<li><p>因为我们上传代码到微信服务器时，它会将我们的代码进行压缩的，所以用户下载的代码包并不是我们开发时的那个大小。对此，开发时也没必要删空行、删注释这些。在开发工具项目详情中可以看到上次上传大小，这个大小就是用户最终使用的大小。如果觉得微信压缩还不够好，可以通过第三方工具对我们代码进行一次压缩再上传，然后对比效果，有没有更小。这个没有使用过。如果有什么好工具，欢迎推荐。</p>\n</li>\n<li><p>将静态资源文件上传到我们自己服务器或者 cdn 上。一个小程序，最耗空间的往往是图片文件。所以我们可以抽离出来，图片文件可以异步获取，在小程序启动以后再去获取。这样，代码包就会小很多。</p>\n</li>\n<li><p>使用分包加载。小程序提供了分包加载功能。如果你的小程序很庞大，可以考虑使用分包加载功能，先加载必要功能代码。这样就可以极大降低代码包大小<br>接下来是首屏渲染，从上图的小程序生命周期可以看出，从加载首页代码到首页完成渲染，这段时间就是白屏时间，也就是首次渲染时间。而小程序在这段时间内，主要工作是：加载首页代码、创建 View 和 AppService 层、初始数据传输、页面渲染。在这四个步骤中，加载首页代码，前面已经说过；创建 View 和 AppService 层，是微信完成的，跟用户手机有关，这不是我们可控的。我们能做的就是减少初始数据传输时间和页面渲染时间。</p>\n</li>\n<li><p>我们知道 page.js 中的 data 对象在首次渲染时会通过数据管道传到视图层进行页面渲染。所以我们应该控制这个 data 对象的大小。对于与视图渲染无关的数据，不要放在 data 里面，可以设置个全局变量来保存。</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">        //与页面渲染有关的数据放这里</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            goods_list:[]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        //与页面渲染无关的数据放这里</span><br><span class=\"line\">        _data: &#123;</span><br><span class=\"line\">            timer: null</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>页面渲染速度还跟 html 的 dom 结构有关。这一点的优化空间算是非常少了，就是写高质量 html 代码，减少 dom 嵌套，让页面渲染速度快一丢丢。</li>\n</ol>\n<h3 id=\"4-2-让小程序更强\"><a href=\"#4-2-让小程序更强\" class=\"headerlink\" title=\"4.2 让小程序更强\"></a>4.2 让小程序更强</h3><p>接下来就是给小程序增加错误信息收集，包括 js 脚本错误信息收集和 http 请求错误信息收集。前段时间，在实际工作开发中，为了更好的复用和管理，我把这个错误信息收集功能做成了插件。然而做成插件并没有想象中的那么美好，下面再具体说。</p>\n<p><strong>脚本错误收集</strong></p>\n<p>对于脚本错误收集，这个相对比较简单，因为在 app.js 中提供了监听错误的 onError 函数</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-0bbdba7dbe77acc9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1118/format/webp\" alt=\"image\"></p>\n<p>只不过错误信息是包括堆栈等比较详细的错误信息，然后当上传时我们并不需要这么多信息，第一浪费宽带，第二看着累又无用。我们需要的信息是：错误类型、错误信息描述、错误位置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">thirdScriptError</span><br><span class=\"line\">aa is not defined;at pages/index/index page test function</span><br><span class=\"line\">ReferenceError: aa is not defined</span><br><span class=\"line\">    at e.test (http://127.0.0.1:62641/appservice/pages/index/index.js:17:3)</span><br><span class=\"line\">    at e.&lt;anonymous&gt; (http://127.0.0.1:62641/appservice/__dev__/WAService.js:16:31500)</span><br><span class=\"line\">    at e.a (http://127.0.0.1:62641/appservice/__dev__/WAService.js:16:26386)</span><br><span class=\"line\">    at J (http://127.0.0.1:62641/appservice/__dev__/WAService.js:16:20800)</span><br><span class=\"line\">    at Function.&lt;anonymous&gt; (http://127.0.0.1:62641/appservice/__dev__/WAService.js:16:22389)</span><br><span class=\"line\">    at http://127.0.0.1:62641/appservice/__dev__/WAService.js:16:27889</span><br><span class=\"line\">    at http://127.0.0.1:62641/appservice/__dev__/WAService.js:6:16777</span><br><span class=\"line\">    at e.(anonymous function) (http://127.0.0.1:62641/appservice/__dev__/WAService.js:4:3403)</span><br><span class=\"line\">    at e (http://127.0.0.1:62641/appservice/appservice?t=1543326089806:1080:20291)</span><br><span class=\"line\">    at r.registerCallback.t (http://127.0.0.1:62641/appservice/appservice?t=1543326089806:1080:20476)</span><br></pre></td></tr></table></figure>\n\n<p>这是错误信息字符串，接下来我们对它进行截取只需要拿我们想要的信息即可。我们发现这个字符串是有规则的。第一行是错误类型，第二行是错误详情和发生的位置，并且是”;”分号分开。所以我们还是很容易就可以拿到我们想要的信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//格式化错误信息</span><br><span class=\"line\">function formateErroMsg(errorMsg)&#123;</span><br><span class=\"line\">    //包一层try catch 不要让信息收集影响了业务</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        var detailMsg = &#x27;&#x27;;</span><br><span class=\"line\">        var detailPosition= &#x27;&#x27;;</span><br><span class=\"line\">        var arr = errorMsg.split(&#x27;\\n&#x27;)</span><br><span class=\"line\">        if (arr.length &gt; 1) &#123;</span><br><span class=\"line\">            //错误详情和错误位置在第二行并用分好隔开</span><br><span class=\"line\">            var detailArr = arr[1].split(&#x27;;&#x27;)</span><br><span class=\"line\">            detailMsg = detailArr.length &gt; 0 ? detailArr[0] : &#x27;&#x27;;</span><br><span class=\"line\">            if (detailArr.length &gt; 1) &#123;</span><br><span class=\"line\">                detailArr.shift()</span><br><span class=\"line\">                detailPosition = detailArr.join(&#x27;;&#x27;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var obj = &#123;</span><br><span class=\"line\">            //错误类型就是第一行</span><br><span class=\"line\">            error_type: arr.length &gt; 0 ? arr[0] : &#x27;&#x27;,</span><br><span class=\"line\">            error_msg: detailMsg,</span><br><span class=\"line\">            error_position: detailPosition</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        return obj</span><br><span class=\"line\">    &#125;catch(e)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获取到我们想要的信息，就可以发送到我们服务后台，进行数据整理和显示，这个需要服务端配合，就不深入讲了，我们拿到了数据，其他都不是事。</p>\n<p><strong>http 请求错误信息收集</strong></p>\n<p>对于 http 请求错误信息收集方式，我们尽量不要暴力埋点，每个请求发送前发送后加上我们的埋点。这样工作量太大，也不易维护。因此，我们可以从底层出发，<strong>拦截 wx.request 请求</strong>。使用 Object.defineProperty 对 wx 对象的 request 进行重新定义。具体实现如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function rewriteRequest()&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        const originRequest = wx.request;</span><br><span class=\"line\">        Object.defineProperty(wx, &#x27;request&#x27;, &#123;</span><br><span class=\"line\">            configurable:true,</span><br><span class=\"line\">            enumerable: true,</span><br><span class=\"line\">            writable: true,</span><br><span class=\"line\">            value: function()&#123;</span><br><span class=\"line\">                let options = arguments[0] || &#123;&#125;;</span><br><span class=\"line\">                //对于发送错误信息的接口不收集，防止死循环</span><br><span class=\"line\">                var regexp = new RegExp(&quot;https://xxxx/error&quot;,&quot;g&quot;);</span><br><span class=\"line\">                if (regexp.test(options.url)) &#123;</span><br><span class=\"line\">                    //这里要执行原来的方法</span><br><span class=\"line\">                    return originRequest.call(this, options)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                //这里拦截请求成功或失败接口，拿到请求后的数据</span><br><span class=\"line\">                [&quot;success&quot;, &quot;fail&quot;].forEach((methodName) =&gt; &#123;</span><br><span class=\"line\">                    let defineMethod = options[methodName];</span><br><span class=\"line\">                    options[methodName] = function()&#123;</span><br><span class=\"line\">                        try&#123;          //在重新定义函数中执行原先的函数，不影响正常逻辑</span><br><span class=\"line\">                            defineMethod &amp;&amp; defineMethod.apply(this, arguments);</span><br><span class=\"line\">                            //开始信息收集</span><br><span class=\"line\">                            let statusCode, result, msg;</span><br><span class=\"line\">                            //请求失败</span><br><span class=\"line\">                            if (methodName == &#x27;fail&#x27;) &#123;</span><br><span class=\"line\">                                statusCode = 0;</span><br><span class=\"line\">                                result = &#x27;fail&#x27;;</span><br><span class=\"line\">                                msg = ( arguments[0] &amp;&amp; arguments[0].errMsg ) || &quot;&quot;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            //请求成功，</span><br><span class=\"line\">                            //收集规则为:</span><br><span class=\"line\">                            // 1、 statusCode非2xx,3xx</span><br><span class=\"line\">                            // 2、 statusCode是2xx,3xx，但接口返回result不为ok</span><br><span class=\"line\">                            if (methodName == &#x27;success&#x27;) &#123;</span><br><span class=\"line\">                                let data = arguments[0] || &#123;&#125;;</span><br><span class=\"line\">                                statusCode = data.statusCode || &quot;&quot;;</span><br><span class=\"line\">                                if (data.statusCode &amp;&amp; Number(data.statusCode) &gt;= 200 &amp;&amp; Number(data.statusCode) &lt; 400 ) &#123;</span><br><span class=\"line\">                                    let resData = data.data ? (typeof data.data == &#x27;object&#x27; ? data.data : JSON.parse(data.data)) : &#123;&#125;;</span><br><span class=\"line\">                                    //请求成功，不收集</span><br><span class=\"line\">                                    if (resData.result == &#x27;ok&#x27;) &#123;</span><br><span class=\"line\">                                        return;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                    result = resData.result || &quot;&quot;;</span><br><span class=\"line\">                                    msg = resData.msg || &quot;&quot;;</span><br><span class=\"line\">                                &#125;else&#123;</span><br><span class=\"line\">                                    result = &quot;&quot;;</span><br><span class=\"line\">                                    msg = data.data || &quot;&quot;;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            //过滤掉header中的敏感信息</span><br><span class=\"line\">                            if (options.header) &#123;</span><br><span class=\"line\">                                options.header.userid &amp;&amp; (delete options.header.userid)</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            //过滤掉data中的敏感信息</span><br><span class=\"line\">                            if (options.data) &#123;</span><br><span class=\"line\">                                options.data.userid &amp;&amp; (delete options.data.userid)</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            var collectInfo = &#123;</span><br><span class=\"line\">                                &quot;url&quot;: options.url || &#x27;&#x27;,   //请求地址</span><br><span class=\"line\">                                &quot;method&quot;: options.method || &quot;GET&quot;,  //请求方法</span><br><span class=\"line\">                                &quot;request_header&quot;: JSON.stringify(options.header || &#123;&#125;), //请求头部信息</span><br><span class=\"line\">                                &quot;request_data&quot;: JSON.stringify(options.data || &#123;&#125;), //请求参数</span><br><span class=\"line\">                                &quot;resp_code&quot;: statusCode + &#x27;&#x27;,   //请求状态码</span><br><span class=\"line\">                                &quot;resp_result&quot;: result, //请求返回结果</span><br><span class=\"line\">                                &quot;resp_msg&quot;: msg, //请求返回描述信息</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            //提交参数与上一次不同，或者参数相同，隔了1s</span><br><span class=\"line\">                            if (JSON.stringify(collectInfo) != lastParams.paramStr || (new Date().getTime() - lastParams.timestamp &gt; 1000)) &#123;</span><br><span class=\"line\">                                //上传错误信息</span><br><span class=\"line\">                                Post.post_error(_miniapp, &#x27;http&#x27;, collectInfo)</span><br><span class=\"line\">                                lastParams.paramStr = JSON.stringify(collectInfo);</span><br><span class=\"line\">                                lastParams.timestamp = new Date().getTime()</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125;catch(e)&#123;</span><br><span class=\"line\">                            //console.log(e);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                return originRequest.call(this, options)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">        // Do something when catch error</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在不使用插件的小程序中，我们可以在使用 wx.request 方法执行上面的代码，对 wx.request 进行拦截，然后其他无需加任何代码就可以收集 http 请求了。<br>上面说了，当我们封装成到插件时，这个就不管用了，因为当使用插件时，小程序不允许我们修改全局变量。所以执行上面代码时会报错。这时，我们退而求其次，只能是在插件中自己封装个方法，这个方法其实就是 wx.request 发送请求，但是在插件中我们就可以拦截 wx.request 了。具体实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function my_request()&#123;</span><br><span class=\"line\">    //只要执行一次拦截代码即可</span><br><span class=\"line\">    !_isInit &amp;&amp; rewriteRequest();</span><br><span class=\"line\">    return  wx.request(options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们看下后台数据</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-a5ed578b7aca2063?imageMogr2/auto-orient/strip%7CimageView2/2/w/855/format/webp\" alt=\"image\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9224001-d8b9492d94d3f88d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp\" alt=\"image\"></p>\n<p>持续监控，会帮我们找出很多隐藏的 bug</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h2><p>洋洋洒洒写了这么多，或许有些地方说的不太清楚，慢慢锻炼吧。然后后面几点只是挑了重要的讲，我相信有过小程序开发经验的朋友应该没问题。然后有时间再补充和优化了。先到此，有缘看到的朋友，欢迎留言交流。</p>\n","categories":["小程序开发"],"tags":["小程序"]},{"title":"微信小程序插件 - 开发教程","url":"/2022/12/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8F%92%E4%BB%B6-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/","content":"<p>昨天（2018.3.13），微信小程序发布了重大功能更新，支持插件的使用和开发，个人预计，不超过 2 个月，优质服务的插件将会如雨后春笋般涌现。</p>\n<p>这篇文章，我将会带大家，从 0 开始，学习如何开发和使用插件。文章分为 3 个章节：</p>\n<ul>\n<li>1、什么是微信小程序插件</li>\n<li>2、如何开发微信小程序插件</li>\n<li>3、如何使用第三方微信小程序插件</li>\n</ul>\n<blockquote>\n<p>备注：为了节省文字内容，我会将“微信小程序插件”简称为“插件”。</p>\n</blockquote>\n<h2 id=\"什么是微信小程序插件？\"><a href=\"#什么是微信小程序插件？\" class=\"headerlink\" title=\"什么是微信小程序插件？\"></a>什么是微信小程序插件？</h2><p>插件是一组由 js 和自定义组件封装的代码库，插件无法单独使用、也无法预览，必须被其他小程序应用嵌入，才能使用。它和 NPM 的依赖、Maven 的依赖库是一个道理。</p>\n<p>不过，插件和 NPM、Maven 依赖管理不同的是：</p>\n<ul>\n<li>插件拥有独立的 API 接口和域名列表，不被小程序本身的域名列表限制。（NPM 依赖进来的库不能进行第三方数据请求）</li>\n<li>插件必须由腾讯审核通过才能使用（NPM 无需腾讯审核）</li>\n<li>使用第三方插件必须向第三方申请 （通过 NPM 使用第三方库无需向第三方申请）</li>\n</ul>\n<p>所以，我觉得：在未来，插件应该会被第三方打包成为服务，而不仅仅只是一个代码库。</p>\n<h2 id=\"如何开发微信小程序插件？\"><a href=\"#如何开发微信小程序插件？\" class=\"headerlink\" title=\"如何开发微信小程序插件？\"></a>如何开发微信小程序插件？</h2><p>下载最新的微信小程序开发者工具，（必须是 1.02.1803130 版本以上），打开开发者工具，进入小程序项目，我们会看到“代码片段”标签，如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1616815-c6f3a6b865ae37c2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp\" alt=\"image\"></p>\n<p>点击，右下角的 “创建” 按钮，就可以创建插件了，如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1616815-20d14a6cd6712658?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp\" alt=\"image\"></p>\n<p>插件的 AppId 和之前的微信小程序的 AppId 是同个道理，需要在微信开发者后台新建一个微信小程序插件：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1616815-d30a11aca90b571e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp\" alt=\"image\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1616815-68a854ff3b5a6afe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp\" alt=\"image\"></p>\n<p>微信小程序插件的名称也必须是独一无二的，申请完毕后就可以获得 插件的 AppId 了。</p>\n<p>填写名称和插件 AppID 后，进入小程序项目，如下图显示：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1616815-7c686881dbbc0445?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp\" alt=\"image\"></p>\n<p>项目的代码目录结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── miniprogram</span><br><span class=\"line\">│ ├── app.js</span><br><span class=\"line\">│ ├── app.json</span><br><span class=\"line\">│ └── pages</span><br><span class=\"line\">├── plugin</span><br><span class=\"line\">│ ├── api</span><br><span class=\"line\">│ ├── components</span><br><span class=\"line\">│ ├── index.js</span><br><span class=\"line\">│ └── plugin.json</span><br><span class=\"line\">└── project.config.json</span><br></pre></td></tr></table></figure>\n\n<p>在文件 <code> project.config.json</code> 中，我们看到代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;miniprogramRoot&quot;: &quot;./miniprogram&quot;,</span><br><span class=\"line\">    &quot;pluginRoot&quot;: &quot;./plugin&quot;,</span><br><span class=\"line\">    &quot;compileType&quot;: &quot;plugin&quot;,</span><br><span class=\"line\">    &quot;setting&quot;: &#123;</span><br><span class=\"line\">        &quot;newFeature&quot;: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;appid&quot;: &quot;.....&quot;,</span><br><span class=\"line\">    &quot;projectname&quot;: &quot;videoPlayer&quot;,</span><br><span class=\"line\">    &quot;condition&quot;: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>miniprogramRoot</strong>：配置小程序的根目录，可以使用小程序来测试编写的插件</li>\n<li><strong>pluginRoot</strong>：插件相关代码所在的根目录</li>\n<li><strong>compileType</strong>：项目的编译类型，必须配置为 plugin，在上传代码的时候才会以插件的方式上传到腾讯服务器。</li>\n</ul>\n<p>在 <code>plugin/plugin.json</code> 文件中，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;publicComponents&quot;: &#123;</span><br><span class=\"line\">    &quot;hgPlayer&quot;: &quot;components/player/player&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;index.js&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>publicComponents</strong>：配置的是插件可以给使用的小程序提供哪些组件，一个插件可以定义很多个组件，组件和组件之间相互引用，但是小程序只能使用在 publicComponents 里配置的组件。</p>\n</li>\n<li><p><strong>main</strong>：定义入口文件，在入口文件 <code>index.js</code> 中定义小程序可以使用插件的那些接口。</p>\n</li>\n</ul>\n<p>在 <code>plugin/index.js</code> 文件中，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var data = require(&#x27;./api/data.js&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  getData: data.getData,</span><br><span class=\"line\">  setData: data.setData</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>plugin/index.js</code> 定义了对外抛出接口为 <code>getData</code> 和 <code>setData</code>，小程序在使用这个插件的时候，只能使用到插件提供的这两个接口，插件的其他接口（或方法）小程序无法使用。</p>\n<p>做好以上配置后，就可以开始在 <code>plugin/components</code> 编写组件代码了，例如我写了我的播放器组件，代码如下：</p>\n<p>player.js：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    myData:[]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>player.wxml:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view class=&quot;section tc&quot;&gt;</span><br><span class=\"line\">  &lt;video id=&quot;myVideo&quot; src=&quot;...&quot;  enable-danmu danmu-btn controls&gt;</span><br><span class=\"line\">  &lt;/video&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是：</p>\n<ol>\n<li><p>编写组件是调用 Component() 定义组件代码，和 App() 、Page()一样的道理。</p>\n</li>\n<li><p>在组件能够调用的微信 API 受限，比如说不能调用 wx.login() 获取用户信息，具体限制在：<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/plugin/api-limit.html\">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/plugin/api-limit.html</a></p>\n</li>\n</ol>\n<p>代码编写完毕后，注意在 <code>plugin/plugin.json</code> 文件配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;publicComponents&quot;: &#123;</span><br><span class=\"line\">    &quot;hgPlayer&quot;: &quot;components/player/player&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;index.js&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>表示使用该插件的小程序，可以使用 hgPlayer 这个组件，组件 hgPlayer 对应的代码是 <code>&quot;components/player/player&quot;</code></p>\n<p>配置好后，我就可以上传插件代码到腾讯服务器，进入微信小程序开发者后台提交审核，腾讯审核通过后，第三方小程序就可以使用我们编写的这个插件了。</p>\n<h2 id=\"如何使用第三方插件\"><a href=\"#如何使用第三方插件\" class=\"headerlink\" title=\"如何使用第三方插件\"></a>如何使用第三方插件</h2><p>使用第三方插件之前，需要进入微信小程序开发者后台，在第三方服务里添加插件：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1616815-d43faf041d0750fd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp\" alt=\"image\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1616815-234e52acfda89cda?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp\" alt=\"image\"></p>\n<p>填写第三方插件的 AppId，点击添加按钮，对方账号的 <code>小程序插件 &gt; 申请管理</code> 会出现你的申请，如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1616815-c4abc1566d2dfbb9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp\" alt=\"image\"></p>\n<p>需要第三方同意你的申请后，你就可以开始使用第三方插件了。</p>\n<p>使用第三方插件的时候，需要在 我们自己的小程序的 <code>app.json</code> 做如下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;pages&quot;: [</span><br><span class=\"line\">    &quot;pages/index/index&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;plugins&quot;: &#123;</span><br><span class=\"line\">    &quot;myPlugin&quot;: &#123;</span><br><span class=\"line\">      &quot;version&quot;: &quot;dev&quot;,</span><br><span class=\"line\">      &quot;provider&quot;: &quot;填写申请通过的插件AppId&quot;</span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">    &quot;plugin1&quot;: &#123;</span><br><span class=\"line\">      &quot;version&quot;: &quot;dev&quot;,</span><br><span class=\"line\">      &quot;provider&quot;: &quot;填写申请通过的插件AppId&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">     &quot;plugin2&quot;: &#123;</span><br><span class=\"line\">      &quot;version&quot;: &quot;dev&quot;,</span><br><span class=\"line\">      &quot;provider&quot;: &quot;填写申请通过的插件AppId&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>plugins： 配置的要使用的第三方插件列表。</p>\n<p>插件列表配置好后，由于每个插件可能会有多个组件，所以需要我们在每个页面定义要使用到的组件，例如，在 <code>index.js</code> 中要使用 <code>hgPlayer</code> 这个组件，需要在 <code>index.json</code> 配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;usingComponents&quot;: &#123;</span><br><span class=\"line\">    &quot;player&quot;: &quot;plugin://myPlugin/hgPlayer&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>&quot;player&quot;: &quot;plugin://myPlugin/hgPlayer&quot;</code> 的含义是：要本页面使用插件 myPlugin 的组件 hgPlayer，同时在本页面的别名为 ：player 。</p>\n<p>配置好 <code>index.json</code> 后，就可以在 <code>index.wxml</code> 直接使用了，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view class=&quot;xxxx&quot;&gt;</span><br><span class=\"line\">    &lt;player /&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>到目前为止，我们已经讲完了：</p>\n<ul>\n<li>1、什么是微信小程序插件</li>\n<li>2、如何开发微信小程序插件</li>\n<li>3、如何使用第三方微信小程序插件</li>\n</ul>\n","categories":["小程序开发"],"tags":["小程序"]},{"title":"搭建vue框架并使用element-ui","url":"/2022/12/16/%E6%90%AD%E5%BB%BAvue%E6%A1%86%E6%9E%B6%E5%B9%B6%E4%BD%BF%E7%94%A8element-ui/","content":"<h2 id=\"1-构建-node-下载环境\"><a href=\"#1-构建-node-下载环境\" class=\"headerlink\" title=\"1.构建 node 下载环境\"></a>1.构建 node 下载环境</h2><p>在 nodejs 官网下载 node 并且安装 nodejs 在 wind10（推荐下载长期支持版）下载地址:<a href=\"https://nodejs.org/zh-cn/download/current/\">https://nodejs.org/zh-cn/download/current/</a></p>\n<p>完成安装后打开电脑的 cmd 测试 node 环境:</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018152304127.png#pic_center\" alt=\"image\"></p>\n<p>出现以上显示表示 node 环境已经构建好了。</p>\n<h2 id=\"2-换淘宝的源提升下载速度\"><a href=\"#2-换淘宝的源提升下载速度\" class=\"headerlink\" title=\"2.换淘宝的源提升下载速度\"></a>2.换淘宝的源提升下载速度</h2><p>cmd 中输入命令:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm –registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p>下载完成后，输入测试命令:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm -v</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20201018152753844.png#pic_center\" alt=\"image\"></p>\n<p>出现以上显示表示换源成功，以后在用到 npm 的地方就用 cnpm 就好了，可提升效率</p>\n<h2 id=\"3-搭建-vue-前端框架环境\"><a href=\"#3-搭建-vue-前端框架环境\" class=\"headerlink\" title=\"3.搭建 vue 前端框架环境:\"></a>3.搭建 vue 前端框架环境:</h2><p>在 cmd 中输入命令:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm install --global vue-cli</span><br></pre></td></tr></table></figure>\n\n<p>等待下载完成，速度很快，大概 30 秒</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018153346851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjU5MTk2Mg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>测试 vue 是否搭建完成:</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018153550205.png#pic_center\" alt=\"image\"></p>\n<p>显示版本号即搭建 vue 框架完成(注意 vue 和 cli 与中间的-要有空格)</p>\n<h2 id=\"4-新建-vue-框架项目\"><a href=\"#4-新建-vue-框架项目\" class=\"headerlink\" title=\"4.新建 vue 框架项目\"></a>4.新建 vue 框架项目</h2><h3 id=\"1-打开集成环境-我这里用的是-WebStorm\"><a href=\"#1-打开集成环境-我这里用的是-WebStorm\" class=\"headerlink\" title=\"1.打开集成环境(我这里用的是 WebStorm)\"></a>1.打开集成环境(我这里用的是 WebStorm)</h3><p>打开后,点击左下角的 Terminal 进入 cmd 命令框输入命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vue init webpack element-test</span><br></pre></td></tr></table></figure>\n\n<p>vue init webpack +项目名，我这里用 element-test 为例</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018154607544.png#pic_center\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018155020882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjU5MTk2Mg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>说明：</p>\n<p>Vue build &#x3D;&#x3D;&gt; 打包方式，回车即可；</p>\n<p>Install vue-router &#x3D;&#x3D;&gt; 是否要安装 vue-router，项目中肯定要使用到 所以 Y 回车；</p>\n<p>Use ESLint to lint your code &#x3D;&#x3D;&gt; 是否需要 js 语法检测 目前我们不需要 所以 n 回车；</p>\n<p>Set up unit tests &#x3D;&#x3D;&gt; 是否安装 单元测试工具 目前我们不需要 所以 n 回车；</p>\n<p>Setup e2e tests with Nightwatch &#x3D;&#x3D;&gt; 是否需要 端到端测试工具 目前我们不需要 所以 n 回车；<br>使用到的下载工具，我这里以 npm 为例<br>等待安装 vue 项目即创建了 vue 框架项目:</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018155332274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjU5MTk2Mg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<h3 id=\"2-测试-vue-框架项目是否搭建成功\"><a href=\"#2-测试-vue-框架项目是否搭建成功\" class=\"headerlink\" title=\"2.测试 vue 框架项目是否搭建成功\"></a>2.测试 vue 框架项目是否搭建成功</h3><p>打开 cmd 控制台</p>\n<ol>\n<li>打开项目所在位置的文件夹</li>\n<li>运行 cnpm start</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018160132611.png#pic_center\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018160216598.png#pic_center\" alt=\"image\"></p>\n<p>点击访问网址: <a href=\"http://localhost:8081,显示\">http://localhost:8081,显示</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018160334354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjU5MTk2Mg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>表示项目构建成功！</p>\n<h2 id=\"5-使用-element-ui-框架\"><a href=\"#5-使用-element-ui-框架\" class=\"headerlink\" title=\"5.使用 element-ui 框架\"></a>5.使用 element-ui 框架</h2><h3 id=\"1-安装-element-框架依赖\"><a href=\"#1-安装-element-框架依赖\" class=\"headerlink\" title=\"1.安装 element 框架依赖\"></a>1.安装 element 框架依赖</h3><p>在 cmd 控制台输入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm i element-ui -S</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20201018160838992.png#pic_center\" alt=\"image\"></p>\n<p>安装完毕</p>\n<h3 id=\"2-在-main-js-中引入-element-ui\"><a href=\"#2-在-main-js-中引入-element-ui\" class=\"headerlink\" title=\"2.在 main.js 中引入 element-ui\"></a>2.在 main.js 中引入 element-ui</h3><p>main.js 在(你的项目)\\src 文件夹下，我这里是 element-test\\src\\</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App&#x27;</span><br><span class=\"line\">import router from &#x27;./router&#x27;</span><br><span class=\"line\">import ElementUI from &#x27;element-ui&#x27;;</span><br><span class=\"line\">//引入elementui</span><br><span class=\"line\">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br><span class=\"line\">Vue.config.productionTip = false</span><br><span class=\"line\"></span><br><span class=\"line\">//在vue中使用elementui</span><br><span class=\"line\">Vue.use(ElementUI);</span><br><span class=\"line\">/* eslint-disable no-new */</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app&#x27;,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  template: &#x27;&lt;App/&gt;&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>如上图，引入并使用 element-ui</p>\n<h3 id=\"3-element-ui-的使用实例\"><a href=\"#3-element-ui-的使用实例\" class=\"headerlink\" title=\"3.element-ui 的使用实例\"></a>3.element-ui 的使用实例</h3><p>1.在 src\\components 的目录下新建一个组件(这里以 Button.vue 为例)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018162204506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjU5MTk2Mg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>2.注册 Button.vue 组件</p>\n<p>在 src\\router\\index.js 中写入 import Button from “..&#x2F;components&#x2F;Button”; 路由 组件 如下图:</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018162621318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjU5MTk2Mg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>3.修改 App.vue 文件</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201018162903891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjU5MTk2Mg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>4.引入 element-ui 样式(进入<a href=\"https://element.eleme.cn/#/zh-CN/component/installation\">element-ui 官网</a>可使用其他大量组件)</p>\n<p>修改 Button.vue 文件，写入以下代码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;el-row&gt;</span><br><span class=\"line\">  &lt;el-button plain&gt;朴素按钮&lt;/el-button&gt;</span><br><span class=\"line\">  &lt;el-button type=&quot;primary&quot; plain&gt;主要按钮&lt;/el-button&gt;</span><br><span class=\"line\">  &lt;el-button type=&quot;success&quot; plain&gt;成功按钮&lt;/el-button&gt;</span><br><span class=\"line\">  &lt;el-button type=&quot;info&quot; plain&gt;信息按钮&lt;/el-button&gt;</span><br><span class=\"line\">  &lt;el-button type=&quot;warning&quot; plain&gt;警告按钮&lt;/el-button&gt;</span><br><span class=\"line\">  &lt;el-button type=&quot;danger&quot; plain&gt;危险按钮&lt;/el-button&gt;</span><br><span class=\"line\">&lt;/el-row&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20201018164250212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjU5MTk2Mg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>保存在运行此项目(在控制台使用 cnpm start)</p>\n<p>点击超链接</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2020101816545912.png#pic_center\" alt=\"image\"></p>\n<p>即成功引用 element-ui 框架</p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h2><h3 id=\"1-安装-nodejs\"><a href=\"#1-安装-nodejs\" class=\"headerlink\" title=\"1.安装 nodejs\"></a>1.安装 nodejs</h3><h3 id=\"2-在-cmd-中\"><a href=\"#2-在-cmd-中\" class=\"headerlink\" title=\"2.在 cmd 中:\"></a>2.在 cmd 中:</h3><h4 id=\"1-换源-：npm-install-g-cnpm-–registry-x3D-https-registry-npm-taobao-org\"><a href=\"#1-换源-：npm-install-g-cnpm-–registry-x3D-https-registry-npm-taobao-org\" class=\"headerlink\" title=\"1.换源 ：npm install -g cnpm –registry&#x3D;https://registry.npm.taobao.org\"></a>1.换源 ：npm install -g cnpm –registry&#x3D;<a href=\"https://registry.npm.taobao.org/\">https://registry.npm.taobao.org</a></h4><h4 id=\"2-安装-vue\"><a href=\"#2-安装-vue\" class=\"headerlink\" title=\"2.安装 vue:\"></a>2.安装 vue:</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm install --global vue-cli</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-新建-vue-框架项目-切换至-WS-控制台\"><a href=\"#3-新建-vue-框架项目-切换至-WS-控制台\" class=\"headerlink\" title=\"3.新建 vue 框架项目(切换至 WS 控制台)\"></a>3.新建 vue 框架项目(切换至 WS 控制台)</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vue init webpack element-test</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-下载-element-ui-依赖\"><a href=\"#4-下载-element-ui-依赖\" class=\"headerlink\" title=\"4.下载 element-ui 依赖\"></a>4.下载 element-ui 依赖</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm i element-ui -S</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-修改-main-js-文件\"><a href=\"#5-修改-main-js-文件\" class=\"headerlink\" title=\"5.修改 main.js 文件\"></a>5.修改 main.js 文件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import App from &#x27;./App&#x27;</span><br><span class=\"line\">import router from &#x27;./router&#x27;</span><br><span class=\"line\">import ElementUI from &#x27;element-ui&#x27;;</span><br><span class=\"line\">//引入elementui</span><br><span class=\"line\">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br><span class=\"line\">Vue.config.productionTip = false</span><br><span class=\"line\"></span><br><span class=\"line\">//在vue中使用elementui</span><br><span class=\"line\">Vue.use(ElementUI);</span><br><span class=\"line\">/* eslint-disable no-new */</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app&#x27;,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  template: &#x27;&lt;App/&gt;&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>重点看&#x2F;&#x2F;后面的注释</p>\n","categories":["前端UI框架"],"tags":["javascript"]},{"title":"数据结构有哪些，常用数据结构详解","url":"/2022/12/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/","content":"<p>数据结构大致包含以下几种存储结构：</p>\n<ul>\n<li>线性表，还可细分为顺序表、链表、栈和队列；</li>\n<li>树结构，包括普通树，二叉树，线索二叉树等；</li>\n<li>图存储结构；</li>\n</ul>\n<p>下面对各种数据结构做详细讲解。</p>\n<h2 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h2><p>线性表结构存储的数据往往是可以依次排列的，就像小朋友手拉手，每位学生的前面和后面都仅有一个小朋友和他拉手，具备这种“一对一”关系的数据就可以使用线性表来存储。</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH151411.gif\" alt=\"image\"></p>\n<p>例如，存储类似 {1,3,5,7,9} 这样的数据时，各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（除首元素和尾元素），因此可以使用线性表存储。</p>\n<p>线性表并不是一种具体的存储结构，它包含顺序存储结构和链式存储结构，是顺序表和链表的统称。</p>\n<h3 id=\"顺序表\"><a href=\"#顺序表\" class=\"headerlink\" title=\"顺序表\"></a>顺序表</h3><p>顺序表，简单地理解，就是常用的数组，只是换了个名字而已，例如使用顺序表存储 {1,3,5,7,9}，如图 1 所示：</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QI9559D.gif\" alt=\"image\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">由于顺序表结构的底层实现借助的就是数组，因此对于初学者来说，可以把顺序表完全等价为数组，但实则不是这样。数据结构是研究数据存储方式的一门学科，它囊括的都是各种存储结构，而数组只是各种编程语言中的基本数据类型，并不属于数据结构的范畴。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><p>我们知道，使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的，如图 1 所示。</p>\n<p>链表则完全不同，使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。</p>\n<p>为了给各个数据块建立“依次排列”的关系，链表给各数据块增设一个指针，每个数据块的指针都指向下一个数据块（最后一个数据块的指针指向 NULL），就如同一个个小学生都伸手去拉住下一个小学生的手，这样，看似毫无关系的数据块就建立了“依次排列”的关系，也就形成了链表，如图 2 所示：</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH334H1.gif\" alt=\"image\"></p>\n<h3 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h3><p>栈和队列隶属于线性表，是特殊的线性表，因为它们对线性表中元素的进出做了明确的要求。</p>\n<p>栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈。</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH634D9.gif\" alt=\"image\"></p>\n<p>栈结构如图 3 所示，像一个木桶，栈中含有 3 个元素，分别是 A、B 和 C，从在栈中的状态可以看出 A 最先进的栈，然后 B 进栈，最后 C 进栈。根据“先进后出”的原则，3 个元素出栈的顺序应该是：C 最先出栈，然后 B 出栈，最后才是 A 出栈。</p>\n<p>队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列。</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QHIJO.gif\" alt=\"image\"></p>\n<p>队列结构如图 4 所示，队列中有 3 个元素，分别是 A、B 和 C，从在队列中的状态可以看出是 A 先进队列，然后 B 进，最后 C 进。根据“先进先出”的原则，3 个元素出队列的顺序应该是 A 最先出队列，然后 B 出，最后 C 出。</p>\n<h2 id=\"树存储结构\"><a href=\"#树存储结构\" class=\"headerlink\" title=\"树存储结构\"></a>树存储结构</h2><p>树存储结构适合存储具有“一对多”关系的数据。</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QJJ0142.gif\" alt=\"image\"></p>\n<p>如图 5 所示，其中张平只有一个父亲，但他却有两（多）个孩子，这就是“一对多”的关系，满足这种关系的数据可以使用树存储结构。</p>\n<h2 id=\"图存储结构\"><a href=\"#图存储结构\" class=\"headerlink\" title=\"图存储结构\"></a>图存储结构</h2><p>图存储结构适合存储具有“多对多”关系的数据。</p>\n<p><img src=\"http://data.biancheng.net/uploads/allimg/181118/1-1Q11QIFS44.gif\" alt=\"image\"></p>\n<p>如图 6 所示，从 V1 可以到达 V2、V3、V4，同样，从 V2、V3、V4 也可以到达 V1，这就是“多对多”的关系，满足这种关系的数据可以使用图存储结构。</p>\n","categories":["前端算法"],"tags":["javascript"]},{"title":"数组和链表的区别","url":"/2022/10/24/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<p>数组和链表是两种基本的数据结构，他们在内存存储上的表现不一样，所以也有各自的特点。</p>\n<p>大致总结一下特点和区别，拿几个人一起去看电影时坐座位为例。</p>\n<h2 id=\"数组的特点\"><a href=\"#数组的特点\" class=\"headerlink\" title=\"数组的特点\"></a>数组的特点</h2><ul>\n<li>在内存中，数组是一块连续的区域。 拿上面的看电影来说，这几个人在电影院必须坐在一起。</li>\n<li>数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。 比如看电影时，为了保证 10 个人能坐在一起，必须提前订好 10 个连续的位置。这样的好处就是能保证 10 个人可以在一起。但是这样的缺点是，如果来的人不够 10 个，那么剩下的位置就浪费了。如果临时又多来了个人，那么 10 个就不够用了，这时可能需要将第 11 个位置上的人挪走，或者是他们 11 个人重新去找一个 11 连坐的位置，效率都很低。如果没有找到符合要求的座位，那么就没法坐了。</li>\n<li>插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。 比如原来去了 5 个人，然后后来又去了一个人要坐在第三个位置上，那么第三个到第五个都要往后移动一个位子，将第三个位置留给新来的人。 当这个人走了的时候，因为他们要连在一起的，所以他后面几个人要往前移动一个位置，把这个空位补上。</li>\n<li>随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到该地址的数据。</li>\n<li>并且不利于扩展，数组定义的空间不够时要重新定义数组。</li>\n</ul>\n<h2 id=\"链表的特点\"><a href=\"#链表的特点\" class=\"headerlink\" title=\"链表的特点\"></a>链表的特点</h2><ul>\n<li>在内存中可以存在任何地方，不要求连续。 在电影院几个人可以随便坐。</li>\n<li>每一个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据。 第一个人知道第二个人的座位号，第二个人知道第三个人的座位号……</li>\n<li>增加数据和删除数据很容易。 再来个人可以随便坐，比如来了个人要做到第三个位置，那他只需要把自己的位置告诉第二个人，然后问第二个人拿到原来第三个人的位置就行了。其他人都不用动。</li>\n<li>查找数据时效率低，因为不具有随机访问性，所以访问某个位置的数据都要从第一个数据开始访问，然后根据第一个数据保存的下一个数据的地址找到第二个数据，以此类推。 要找到第三个人，必须从第一个人开始问起。</li>\n<li>不指定大小，扩展方便。链表大小不用定义，数据随意增删。</li>\n</ul>\n<h2 id=\"各自的优缺点\"><a href=\"#各自的优缺点\" class=\"headerlink\" title=\"各自的优缺点\"></a>各自的优缺点</h2><h3 id=\"数组的优点\"><a href=\"#数组的优点\" class=\"headerlink\" title=\"数组的优点\"></a>数组的优点</h3><ul>\n<li>随机访问性强</li>\n<li>查找速度快</li>\n</ul>\n<h3 id=\"数组的缺点\"><a href=\"#数组的缺点\" class=\"headerlink\" title=\"数组的缺点\"></a>数组的缺点</h3><ul>\n<li>插入和删除效率低</li>\n<li>可能浪费内存</li>\n<li>内存空间要求高，必须有足够的连续内存空间。</li>\n<li>数组大小固定，不能动态拓展</li>\n</ul>\n<h3 id=\"链表的优点\"><a href=\"#链表的优点\" class=\"headerlink\" title=\"链表的优点\"></a>链表的优点</h3><ul>\n<li>插入删除速度快</li>\n<li>内存利用率高，不会浪费内存</li>\n<li>大小没有固定，拓展很灵活。</li>\n</ul>\n<h3 id=\"链表的缺点\"><a href=\"#链表的缺点\" class=\"headerlink\" title=\"链表的缺点\"></a>链表的缺点</h3><ul>\n<li><p>不能随机查找，必须从第一个开始遍历，查找效率低</p>\n</li>\n<li><p>| 数组 | 链表 |<br>| —- | —- | —- |<br>| 读取 | O(1) | O(n) |<br>| 插入 | O(n) | O(1) |<br>| 删除 | O(n) | O(1) |</p>\n</li>\n</ul>\n<p><img src=\"http://privateimage.oss-cn-hongkong.aliyuncs.com/%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%87%B5%E9%80%BC.gif\" alt=\"image\"></p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"浅析koa的洋葱模型实现","url":"/2022/10/24/%E6%B5%85%E6%9E%90koa%E7%9A%84%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>koa 被认为是第二代 node web framework，它最大的特点就是独特的中间件流程控制，是一个典型的洋葱模型。koa 和 koa2 中间件的思路是一样的，但是实现方式有所区别，koa2 在 node7.6 之后更是可以直接用 async&#x2F;await 来替代 generator 使用中间件，本文以最后一种情况举例。</p>\n<h2 id=\"洋葱模型\"><a href=\"#洋葱模型\" class=\"headerlink\" title=\"洋葱模型\"></a>洋葱模型</h2><p>下面两张图是网上找的，很清晰的表明了一个请求是如何经过中间件最后生成响应的，这种模式中开发和使用中间件都是非常方便的</p>\n<p><img src=\"https://segmentfault.com/img/bV6DZG?w=478&h=435\" alt=\"image\"></p>\n<p><img src=\"https://segmentfault.com/img/bV6D5Z?w=470&h=411\" alt=\"image\"></p>\n<p>来看一个 koa2 的 demo:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const Koa = require(&#x27;koa&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\">const PORT = 3000;</span><br><span class=\"line\"></span><br><span class=\"line\">// #1</span><br><span class=\"line\">app.use(async (ctx, next)=&gt;&#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// #2</span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    console.log(3)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(PORT);</span><br><span class=\"line\">console.log(`http://localhost:$&#123;PORT&#125;`);</span><br></pre></td></tr></table></figure>\n\n<p>访问 <a href=\"http://localhost:3000，控制台打印：\">http://localhost:3000，控制台打印：</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>怎么样，是不是有一点点感觉了。当程序运行到 await next()的时候就会暂停当前程序，进入下一个中间件，处理完之后才会在回过头来继续处理。也就是说，当一个请求进入，#1 会被第一个和最后一个经过，#2 则是被第二和倒数第二个经过，依次类推。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>koa 的实现有几个最重要的点</p>\n<ol>\n<li>context 的保存和传递</li>\n<li>中间件的管理和 next 的实现</li>\n</ol>\n<p>翻看源码我们发现<br>app.listen 使用了 this.callback()来生成 node 的 httpServer 的回调函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">listen(...args) &#123;</span><br><span class=\"line\">    debug(&#x27;listen&#x27;);</span><br><span class=\"line\">    const server = http.createServer(this.callback());</span><br><span class=\"line\">    return server.listen(...args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那就再来看 this.callback</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">callback() &#123;</span><br><span class=\"line\">    const fn = compose(this.middleware);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!this.listeners(&#x27;error&#x27;).length) this.on(&#x27;error&#x27;, this.onerror);</span><br><span class=\"line\"></span><br><span class=\"line\">    const handleRequest = (req, res) =&gt; &#123;</span><br><span class=\"line\">      const ctx = this.createContext(req, res);</span><br><span class=\"line\">      return this.handleRequest(ctx, fn);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    return handleRequest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里用 compose 处理了一下 this.middleware，创建了 ctx 并赋值为 createContext 的返回值，最后返回了 handleRequest。</p>\n<p>this.middleware 看起来应该是中间件的集合，查了下代码，果不其然：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">this.middleware = [];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">use(fn) &#123;</span><br><span class=\"line\">    if (typeof fn !== &#x27;function&#x27;) throw new TypeError(&#x27;middleware must be a function!&#x27;);</span><br><span class=\"line\">    if (isGeneratorFunction(fn)) &#123;</span><br><span class=\"line\">      deprecate(&#x27;Support for generators will be removed in v3. &#x27; +</span><br><span class=\"line\">                &#x27;See the documentation for examples of how to convert old middleware &#x27; +</span><br><span class=\"line\">                &#x27;https://github.com/koajs/koa/blob/master/docs/migration.md&#x27;);</span><br><span class=\"line\">      fn = convert(fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debug(&#x27;use %s&#x27;, fn._name || fn.name || &#x27;-&#x27;);</span><br><span class=\"line\">    this.middleware.push(fn);</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抛开兼容和判断，这段代码只做了一件事：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">use(fn) &#123;</span><br><span class=\"line\">    this.middleware.push(fn);</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来当我们 app.use 的时候，只是把方法存在了一个数组里。<br>那么 compose 又是什么呢。跟踪源码可以看到 compose 来自 koa-compose 模块，代码也不多：（去掉了一些不影响主逻辑的判断）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function compose (middleware) &#123;</span><br><span class=\"line\">  return function (context, next) &#123;</span><br><span class=\"line\">    // last called middleware #</span><br><span class=\"line\">    let index = -1</span><br><span class=\"line\">    return dispatch(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    function dispatch (i) &#123;</span><br><span class=\"line\">      if (i &lt;= index) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;))</span><br><span class=\"line\">      index = i</span><br><span class=\"line\">      let fn = middleware[i]</span><br><span class=\"line\">      if (i === middleware.length) fn = next</span><br><span class=\"line\">      if (!fn) return Promise.resolve()</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        return Promise.resolve(fn(context, function next () &#123;</span><br><span class=\"line\">          return dispatch(i + 1)</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">      &#125; catch (err) &#123;</span><br><span class=\"line\">        return Promise.reject(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比较关键的就是这个 dispatch 函数了，它将遍历整个 middleware，然后将 context 和 dispatch(i + 1)传给 middleware 中的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">return Promise.resolve(fn(context, function next () &#123;</span><br><span class=\"line\">      return dispatch(i + 1)</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<p>这段代码就很巧妙的实现了两点:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 将`context`一路传下去给中间件</span><br><span class=\"line\"></span><br><span class=\"line\">2. 将`middleware`中的下一个中间件`fn`作为未来`next`的返回值</span><br></pre></td></tr></table></figure>\n\n<p>这两点也是洋葱模型实现的核心。<br>再往下看代码实际上就没有太多花样了。<br>createContext 和 handleRequest 做的事实际上是把 ctx 和中间件进行绑定，也就是第一次调用 compose 返回值的地方。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">createContext(req, res) &#123;</span><br><span class=\"line\">   const context = Object.create(this.context);</span><br><span class=\"line\">   const request = context.request = Object.create(this.request);</span><br><span class=\"line\">   const response = context.response = Object.create(this.response);</span><br><span class=\"line\">   context.app = request.app = response.app = this;</span><br><span class=\"line\">   context.req = request.req = response.req = req;</span><br><span class=\"line\">   context.res = request.res = response.res = res;</span><br><span class=\"line\">   request.ctx = response.ctx = context;</span><br><span class=\"line\">   request.response = response;</span><br><span class=\"line\">   response.request = request;</span><br><span class=\"line\">   context.originalUrl = request.originalUrl = req.url;</span><br><span class=\"line\">   context.cookies = new Cookies(req, res, &#123;</span><br><span class=\"line\">     keys: this.keys,</span><br><span class=\"line\">     secure: request.secure</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   request.ip = request.ips[0] || req.socket.remoteAddress || &#x27;&#x27;;</span><br><span class=\"line\">   context.accept = request.accept = accepts(req);</span><br><span class=\"line\">   context.state = &#123;&#125;;</span><br><span class=\"line\">   return context;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> handleRequest(ctx, fnMiddleware) &#123;</span><br><span class=\"line\">   const res = ctx.res;</span><br><span class=\"line\">   res.statusCode = 404;</span><br><span class=\"line\">   const onerror = err =&gt; ctx.onerror(err);</span><br><span class=\"line\">   const handleResponse = () =&gt; respond(ctx);</span><br><span class=\"line\">   onFinished(res, onerror);</span><br><span class=\"line\">   return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"浅谈支付宝小程序与微信小程序开发的区别","url":"/2022/12/16/%E6%B5%85%E8%B0%88%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<h2 id=\"一、app-json\"><a href=\"#一、app-json\" class=\"headerlink\" title=\"一、app.json\"></a>一、app.json</h2><h3 id=\"（1）设置小程序通用的的状态栏、导航条、标题、窗口背景色\"><a href=\"#（1）设置小程序通用的的状态栏、导航条、标题、窗口背景色\" class=\"headerlink\" title=\"（1）设置小程序通用的的状态栏、导航条、标题、窗口背景色\"></a>（1）设置小程序通用的的状态栏、导航条、标题、窗口背景色</h3><h4 id=\"支付宝小程序\"><a href=\"#支付宝小程序\" class=\"headerlink\" title=\"支付宝小程序\"></a>支付宝小程序</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;window&quot;: &#123;</span><br><span class=\"line\">    &quot;defaultTitle&quot;: &quot;病案到家&quot;,   //页面标题</span><br><span class=\"line\">    &quot;titleBarColor&quot;: &quot;#1688FB&quot;    //导航栏背景色</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"微信小程序\"><a href=\"#微信小程序\" class=\"headerlink\" title=\"微信小程序\"></a>微信小程序</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;window&quot;: &#123;</span><br><span class=\"line\">    &quot;backgroundTextStyle&quot;: &quot;light&quot;,//窗口的背景色</span><br><span class=\"line\">    &quot;navigationBarBackgroundColor&quot;: &quot;#1688FB&quot;,//导航栏背景颜色</span><br><span class=\"line\">    &quot;navigationBarTitleText&quot;: &quot;病案到家&quot;,//导航栏标题文字内容</span><br><span class=\"line\">    &quot;navigationBarTextStyle&quot;: &quot;white&quot;//导航栏标题颜色，仅支持 black/white</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（2）设置-tabBar\"><a href=\"#（2）设置-tabBar\" class=\"headerlink\" title=\"（2）设置 tabBar\"></a>（2）设置 tabBar</h3><h4 id=\"支付宝小程序-1\"><a href=\"#支付宝小程序-1\" class=\"headerlink\" title=\"支付宝小程序\"></a>支付宝小程序</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;tabBar&quot;: &#123;</span><br><span class=\"line\">    &quot;textColor&quot;: &quot;#333333&quot;,//默认颜色</span><br><span class=\"line\">    &quot;selectedColor&quot;: &quot;#1688FB&quot;,//选中颜色</span><br><span class=\"line\">    &quot;backgroundColor&quot;: &quot;#ffffff&quot;,//背景色</span><br><span class=\"line\">    &quot;items&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;icon&quot;: &quot;/images/indexGrey.png&quot;,</span><br><span class=\"line\">        &quot;activeIcon&quot;: &quot;/images/indexWhite.png&quot;,</span><br><span class=\"line\">        &quot;pagePath&quot;: &quot;pages/homeIndex/homeIndex&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;首页&quot;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;icon&quot;: &quot;/images/personGrey.png&quot;,</span><br><span class=\"line\">        &quot;activeIcon&quot;: &quot;/images/personWhite.png&quot;,</span><br><span class=\"line\">        &quot;pagePath&quot;: &quot;pages/orderList/orderList&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;我的&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"微信小程序-1\"><a href=\"#微信小程序-1\" class=\"headerlink\" title=\"微信小程序\"></a>微信小程序</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;tabBar&quot;: &#123;</span><br><span class=\"line\">    &quot;color&quot;: &quot;#333333&quot;,</span><br><span class=\"line\">    &quot;selectedColor&quot;: &quot;#1688FB&quot;,</span><br><span class=\"line\">    &quot;backgroundColor&quot;: &quot;#ffffff&quot;,</span><br><span class=\"line\">    &quot;borderStyle&quot;: &quot;#e5e5e5&quot;,</span><br><span class=\"line\">    &quot;list&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;iconPath&quot;: &quot;/images/indexGrey.png&quot;,</span><br><span class=\"line\">        &quot;selectedIconPath&quot;: &quot;/images/indexWhite.png&quot;,</span><br><span class=\"line\">        &quot;pagePath&quot;: &quot;pages/homeIndex/homeIndex&quot;,</span><br><span class=\"line\">        &quot;text&quot;: &quot;首页&quot;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;iconPath&quot;: &quot;/images/personGrey.png&quot;,</span><br><span class=\"line\">        &quot;selectedIconPath&quot;: &quot;/images/personWhite.png&quot;,</span><br><span class=\"line\">        &quot;pagePath&quot;: &quot;pages/orderList/orderList&quot;,</span><br><span class=\"line\">        &quot;text&quot;: &quot;我的&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、pages\"><a href=\"#二、pages\" class=\"headerlink\" title=\"二、pages\"></a>二、pages</h2><h3 id=\"（1）文件命名不同\"><a href=\"#（1）文件命名不同\" class=\"headerlink\" title=\"（1）文件命名不同\"></a>（1）文件命名不同</h3><h4 id=\"支付宝小程序-2\"><a href=\"#支付宝小程序-2\" class=\"headerlink\" title=\"支付宝小程序\"></a>支付宝小程序</h4><p><img src=\"https://img-blog.csdnimg.cn/20181120105925562.png\" alt=\"image\"></p>\n<h4 id=\"微信小程序-2\"><a href=\"#微信小程序-2\" class=\"headerlink\" title=\"微信小程序\"></a>微信小程序</h4><p><img src=\"https://img-blog.csdnimg.cn/2018112010585493.png\" alt=\"image\"></p>\n<p><strong>我分别在微信小程序和支付宝小程序建立了页面，区别在于</strong>：</p>\n<ol>\n<li>支付宝小程序里面的视图层页面文件后缀是“axml”，样式文件后缀是“acss”；</li>\n<li>微信小程序里面的视图层页面文件后缀是“wxml”，样式文件后缀是“wxss”。</li>\n</ol>\n<h3 id=\"（2）视图层页面-axml-以及-wxml\"><a href=\"#（2）视图层页面-axml-以及-wxml\" class=\"headerlink\" title=\"（2）视图层页面 axml 以及 wxml\"></a>（2）视图层页面 axml 以及 wxml</h3><h4 id=\"1-冒泡事件和非冒泡事件\"><a href=\"#1-冒泡事件和非冒泡事件\" class=\"headerlink\" title=\"1.冒泡事件和非冒泡事件\"></a>1.冒泡事件和非冒泡事件</h4><p><strong>支付宝小程序</strong></p>\n<p>onTap, catchTap</p>\n<p>on 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button class=&quot;weui-btn&quot; onTap=&quot;login&quot; type=&quot;primary&quot;&gt;登录&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<p>bindtap、catchtouchstart</p>\n<p>bind 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button class=&quot;weui-btn&quot; bindtap=&#x27;login&#x27; type=&quot;primary&quot;&gt;登录&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-列表渲染\"><a href=\"#2-列表渲染\" class=\"headerlink\" title=\"2.列表渲染\"></a>2.列表渲染</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    list: [&#123;</span><br><span class=\"line\">      Title: &#x27;支付宝&#x27;,</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      Title: &#x27;微信&#x27;,</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>支付宝小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;block a:for=&quot;&#123;&#123;list&#125;&#125;&quot;&gt;</span><br><span class=\"line\">  &lt;view key=&quot;item-&#123;&#123;index&#125;&#125;&quot; index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;&#123;&#123;item.Title&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">&lt;/block&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;block wx:for=&quot;&#123;&#123;list&#125;&#125;&quot;&gt;</span><br><span class=\"line\">  &lt;view wx:key=&quot;this&quot; wx:for-item=&quot;item&quot;&gt;&#123;&#123;item.Title&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">&lt;/block&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-条件渲染\"><a href=\"#3-条件渲染\" class=\"headerlink\" title=\"3.条件渲染\"></a>3.条件渲染</h4><p><strong>支付宝小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view a:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 1 &lt;/view&gt;</span><br><span class=\"line\">&lt;view a:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 2 &lt;/view&gt;</span><br><span class=\"line\">&lt;view a:else&gt; 3 &lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view wx:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 1 &lt;/view&gt;</span><br><span class=\"line\">&lt;view wx:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 2 &lt;/view&gt;</span><br><span class=\"line\">&lt;view wx:else&gt; 3 &lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、开发过程中常用到的两个小程序中组件的不同用法\"><a href=\"#三、开发过程中常用到的两个小程序中组件的不同用法\" class=\"headerlink\" title=\"三、开发过程中常用到的两个小程序中组件的不同用法\"></a>三、开发过程中常用到的两个小程序中组件的不同用法</h2><h3 id=\"（1）交互\"><a href=\"#（1）交互\" class=\"headerlink\" title=\"（1）交互\"></a>（1）交互</h3><h4 id=\"1-消息提示框\"><a href=\"#1-消息提示框\" class=\"headerlink\" title=\"1.消息提示框\"></a>1.消息提示框</h4><p><strong>支付宝小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">my.showToast(&#123;</span><br><span class=\"line\">  type: &#x27;success&#x27;,//默认 none，支持 success / fail / exception / none’。</span><br><span class=\"line\">  content: &#x27;操作成功&#x27;,//文字内容</span><br><span class=\"line\">  duration: 3000,//显示时长，单位为 ms，默认 2000</span><br><span class=\"line\">  success: () =&gt; &#123;</span><br><span class=\"line\">    my.alert(&#123;</span><br><span class=\"line\">      title: &#x27;toast 消失了&#x27;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">my.hideToast()//隐藏弱提示。</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">wx.showToast(&#123;</span><br><span class=\"line\">  title: &#x27;成功&#x27;,//提示的内容</span><br><span class=\"line\">  icon: &#x27;success&#x27;,//success\t显示成功图标;loading\t显示加载图标;none不显示图标</span><br><span class=\"line\">  duration: 2000</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//icon为“success”“loading”时 title 文本最多显示 7 个汉字长度</span><br><span class=\"line\">wx.hideToast() //隐藏</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-消息提示框\"><a href=\"#2-消息提示框\" class=\"headerlink\" title=\"2.消息提示框\"></a>2.消息提示框</h4><p><strong>支付宝小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">my.showLoading(&#123;</span><br><span class=\"line\">  content: &#x27;加载中...&#x27;,</span><br><span class=\"line\">  delay: 1000,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">my.hideLoading();</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">wx.showLoading(&#123;</span><br><span class=\"line\">  title: &#x27;加载中&#x27;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">wx.hideLoading()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-http-请求\"><a href=\"#3-http-请求\" class=\"headerlink\" title=\"3.http 请求\"></a>3.http 请求</h4><p><strong>支付宝小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">my.httpRequest(&#123;</span><br><span class=\"line\">  url: &#x27;http://httpbin.org/post&#x27;,</span><br><span class=\"line\">  method: &#x27;POST&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    from: &#x27;支付宝&#x27;,</span><br><span class=\"line\">    production: &#x27;AlipayJSAPI&#x27;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  headers:&quot;&quot;,//默认 &#123;&#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;&#125;</span><br><span class=\"line\">  dataType: &#x27;json&#x27;,</span><br><span class=\"line\">  success: function(res) &#123;</span><br><span class=\"line\">    my.alert(&#123;content: &#x27;success&#x27;&#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  fail: function(res) &#123;</span><br><span class=\"line\">    my.alert(&#123;content: &#x27;fail&#x27;&#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  complete: function(res) &#123;</span><br><span class=\"line\">    my.hideLoading();</span><br><span class=\"line\">    my.alert(&#123;content: &#x27;complete&#x27;&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">wx.request(&#123;</span><br><span class=\"line\">  url: &#x27;test.php&#x27;, //仅为示例，并非真实的接口地址</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    x: &#x27;&#x27;,</span><br><span class=\"line\">    y: &#x27;&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  header: &#123;</span><br><span class=\"line\">    &#x27;content-type&#x27;: &#x27;application/json&#x27; // 默认值</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  success (res) &#123;</span><br><span class=\"line\">    console.log(res.data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其实微信小程序和支付宝小程序提供的 api 方法大致相同，只是微信小程序是以“wx.”起头，支付宝小程序是以“my.”起头，其余可能只是 api 方法里面字段“text、content、name、title”等命名不同。</p>\n<h3 id=\"（2）选择器\"><a href=\"#（2）选择器\" class=\"headerlink\" title=\"（2）选择器\"></a>（2）选择器</h3><h4 id=\"1-时间选择器\"><a href=\"#1-时间选择器\" class=\"headerlink\" title=\"1.时间选择器\"></a>1.时间选择器</h4><p><strong>支付宝小程序</strong></p>\n<p>支付宝小程序提供了一个 api，my.datePicker(object)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">my.datePicker(&#123;</span><br><span class=\"line\">  format: &#x27;yyyy-MM-dd&#x27;,//返回的日期格式，</span><br><span class=\"line\">  currentDate: &#x27;2012-12-12&#x27;,//初始选择的日期时间，默认当前时间</span><br><span class=\"line\">  startDate: &#x27;2012-12-10&#x27;,//最小日期时间</span><br><span class=\"line\">  endDate: &#x27;2012-12-15&#x27;,//最大日期时间</span><br><span class=\"line\">  success: (res) =&gt; &#123;</span><br><span class=\"line\">    my.alert(&#123;</span><br><span class=\"line\">\t  content: res.date,</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<p>微信小程序是通过 picker 组件来实现的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view class=&quot;section&quot;&gt;</span><br><span class=\"line\">  &lt;view class=&quot;section__title&quot;&gt;日期选择器&lt;/view&gt;</span><br><span class=\"line\">  &lt;picker mode=&quot;date&quot; value=&quot;&#123;&#123;date&#125;&#125;&quot; start=&quot;2015-09-01&quot; end=&quot;2017-09-01&quot; bindchange=&quot;bindDateChange&quot;&gt;</span><br><span class=\"line\">    &lt;view class=&quot;picker&quot;&gt;</span><br><span class=\"line\">      当前选择: &#123;&#123;date&#125;&#125;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/picker&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    date: &#x27;2016-09-01&#x27;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  bindDateChange: function(e) &#123;</span><br><span class=\"line\">    console.log(&#x27;picker发送选择改变，携带值为&#x27;, e.detail.value)</span><br><span class=\"line\">    this.setData(&#123;</span><br><span class=\"line\">      date: e.detail.value</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-省市区选择器\"><a href=\"#2-省市区选择器\" class=\"headerlink\" title=\"2.省市区选择器\"></a>2.省市区选择器</h4><p><strong>支付宝小程序</strong></p>\n<p>支付宝小程序提供了一个 api，my.multiLevelSelect(Object)</p>\n<p>级联选择功能主要使用在于多级关联数据选择，比如说省市区的信息选择。</p>\n<p>1.1、引入一个省市区的 json 格式文件 <a href=\"http://blog.shzhaoqi.com/uploads/js/city_json.zip\">http://blog.shzhaoqi.com/uploads/js/city_json.zip</a></p>\n<p>1.2、在 js 中引入这个文件</p>\n<p>1.3、使用 my.multiLevelSelect(Object)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var citysJSON = require(&#x27;../../utils/city.js&#x27;);</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    provinces: &#x27;陕西省&#x27;,</span><br><span class=\"line\">    city: &#x27;西安市&#x27;,</span><br><span class=\"line\">    area: &#x27;碑林区&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  chooseAddress: function () &#123;</span><br><span class=\"line\">    my.multiLevelSelect(&#123;</span><br><span class=\"line\">      title: &#x27;选择省市区&#x27;,//级联选择标题</span><br><span class=\"line\">      list: citysJSON.citys,</span><br><span class=\"line\">      success: (res) =&gt; &#123;</span><br><span class=\"line\">        this.setData(&#123;</span><br><span class=\"line\">          provinces: res.result[0].name,</span><br><span class=\"line\">          city: res.result[1].name,</span><br><span class=\"line\">          area: res.result[2].name,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<p>微信小程序依然是通过 picker 组件来实现的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view class=&quot;section&quot;&gt;</span><br><span class=\"line\">  &lt;view class=&quot;section__title&quot;&gt;省市区选择器&lt;/view&gt;</span><br><span class=\"line\">  &lt;picker mode=&quot;region&quot; bindchange=&quot;bindRegionChange&quot; value=&quot;&#123;&#123;region&#125;&#125;&quot; custom-item=&quot;&#123;&#123;customItem&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;view class=&quot;picker&quot;&gt;</span><br><span class=\"line\">      当前选择：&#123;&#123;region[0]&#125;&#125;，&#123;&#123;region[1]&#125;&#125;，&#123;&#123;region[2]&#125;&#125;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/picker&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//custom-item   可为每一列的顶部添加一个自定义的项,可为空</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    region: [&#x27;广东省&#x27;, &#x27;广州市&#x27;, &#x27;海珠区&#x27;],</span><br><span class=\"line\">    customItem: &#x27;全部&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  bindRegionChange: function (e) &#123;</span><br><span class=\"line\">    console.log(&#x27;picker发送选择改变，携带值为&#x27;, e.detail.value)</span><br><span class=\"line\">    this.setData(&#123;</span><br><span class=\"line\">      region: e.detail.value</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）小程序唤起支付\"><a href=\"#（3）小程序唤起支付\" class=\"headerlink\" title=\"（3）小程序唤起支付\"></a>（3）小程序唤起支付</h4><p><strong>支付宝小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">my.tradePay(&#123;</span><br><span class=\"line\">  tradeNO: &#x27;201711152100110410533667792&#x27;, // 调用统一收单交易创建接口（alipay.trade.create），获得返回字段支付宝交易号trade_no</span><br><span class=\"line\">  success: (res) =&gt; &#123;</span><br><span class=\"line\">    my.alert(&#123;</span><br><span class=\"line\">\t  content: JSON.stringify(res),</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  fail: (res) =&gt; &#123;</span><br><span class=\"line\">    my.alert(&#123;</span><br><span class=\"line\">\t  content: JSON.stringify(res),</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">wx.requestPayment(&#123;</span><br><span class=\"line\">  timeStamp: &#x27;&#x27;,//时间戳，从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间</span><br><span class=\"line\">  nonceStr: &#x27;&#x27;,//随机字符串，长度为32个字符以下</span><br><span class=\"line\">  package: &#x27;&#x27;,//统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=***</span><br><span class=\"line\">  signType: &#x27;MD5&#x27;,//签名算法</span><br><span class=\"line\">  paySign: &#x27;&#x27;,//签名</span><br><span class=\"line\">  success (res) &#123; &#125;,</span><br><span class=\"line\">  fail (res) &#123; &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）电话\"><a href=\"#（4）电话\" class=\"headerlink\" title=\"（4）电话\"></a>（4）电话</h4><p><strong>支付宝小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">my.makePhoneCall(&#123;</span><br><span class=\"line\">\tnumber: &#x27;400-8097-114&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">wx.makePhoneCall(&#123;</span><br><span class=\"line\">  phoneNumber: &#x27;400-8097-114&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（5）获取登录凭证（code）\"><a href=\"#（5）获取登录凭证（code）\" class=\"headerlink\" title=\"（5）获取登录凭证（code）\"></a>（5）获取登录凭证（code）</h4><p><strong>支付宝小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">my.getAuthCode(&#123;</span><br><span class=\"line\">  success (res) &#123;</span><br><span class=\"line\">    if (res.authCode) &#123;</span><br><span class=\"line\">      console.log(res.authCode)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>微信小程序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">wx.login(&#123;</span><br><span class=\"line\">  success (res) &#123;</span><br><span class=\"line\">    if (res.code) &#123;</span><br><span class=\"line\">      console.log(res.code)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","categories":["小程序开发"],"tags":["小程序"]},{"title":"深入理解react中的虚拟DOM、diff算法","url":"/2022/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E3%80%81diff%E7%AE%97%E6%B3%95/","content":"<p>文章结构：</p>\n<ul>\n<li>React 中的虚拟 DOM 是什么？</li>\n<li>虚拟 DOM 的简单实现（diff 算法）</li>\n<li>虚拟 DOM 的内部工作原理</li>\n<li>React 中的虚拟 DOM 与 Vue 中的虚拟 DOM 比较</li>\n</ul>\n<h2 id=\"React-中的虚拟-DOM-是什么？\"><a href=\"#React-中的虚拟-DOM-是什么？\" class=\"headerlink\" title=\"React 中的虚拟 DOM 是什么？\"></a>React 中的虚拟 DOM 是什么？</h2><p>虽然 React 中的虚拟 DOM 很好用，但是这是一个无心插柳的结果。</p>\n<p><strong>React 的核心思想：一个 Component 拯救世界，忘掉烦恼，从此不再操心界面</strong>。</p>\n<h3 id=\"1-Virtual-Dom-快，有两个前提\"><a href=\"#1-Virtual-Dom-快，有两个前提\" class=\"headerlink\" title=\"1. Virtual Dom 快，有两个前提\"></a>1. Virtual Dom 快，有两个前提</h3><h4 id=\"1-1-Javascript-很快\"><a href=\"#1-1-Javascript-很快\" class=\"headerlink\" title=\"1.1 Javascript 很快\"></a>1.1 Javascript 很快</h4><p><strong>Chrome 刚出来的时候，在 Chrome 里跑 Javascript 非常快，给了其它浏览器很大压力</strong>。而现在经过几轮你追我赶，各主流浏览器的 Javascript 执行速度都很快了。</p>\n<p>在 <a href=\"https://julialang.org/benchmarks/\">https://julialang.org/benchmarks/</a> 这个网站上，我们可以看到，JavaScript 语言已经非常快了，和 C 就是几倍的关系，和 java 在同一个量级。<strong>所以说，单纯的 JavaScript 还是很快的。</strong></p>\n<h4 id=\"1-2-Dom-很慢\"><a href=\"#1-2-Dom-很慢\" class=\"headerlink\" title=\"1.2 Dom 很慢\"></a>1.2 Dom 很慢</h4><p>当创建一个元素比如 div，有以下几项内容需要实现： <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement\">HTML element</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element\">Element</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers\">GlobalEventHandler</a>。简单的说，就是插入一个 Dom 元素的时候，这个元素上本身或者继承很多属性如 width、height、offsetHeight、style、title，另外还需要注册这个元素的诸多方法，比如 onfocus、onclick 等等。 这还只是一个元素，如果元素比较多的时候，还涉及到嵌套，那么元素的属性和方法等等就会很多，效率很低。</p>\n<p>比如，我们在一个空白网页的 body 中添加一个 div 元素，如下所示：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170801225429255-521935350.png\" alt=\"image\"></p>\n<p>这个元素<strong>会挂载默认的 styles、得到这个元素的 computed 属性、注册相应的 Event Listener、DOM Breakpoints 以及大量的 properties，这些属性、方法的注册肯定是需要耗费大量时间的</strong>。</p>\n<p>尤其是在 js 操作 DOM 的过程中，不仅有 dom 本身的繁重，js 的操作也需要浪费时间，我们认为 js 和 DOM 之间有一座桥，如果你频繁的在桥两边走动，显然效率是很低的，<strong>如果你的 JavaScript 操作 DOM 的方式还非常不合理，那么显然就会更糟糕了</strong>。</p>\n<p><strong>而 React 的虚拟 DOM 就是解决这个问题的！</strong> 虽然它解决不了 DOM 自身的繁重，但是<strong>虚拟 DOM 可以对 JavaScript 操作 DOM 这一部分内容进行优化</strong>。</p>\n<p>比如说，现在你的 list 是这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &lt;li&gt;0&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;1&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;2&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;3&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n<p>你希望把它变成下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &lt;li&gt;6&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;7&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;8&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;9&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;10&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>通常的操作是什么?</strong></p>\n<p>先把 0， 1，2，3 这些 Element 删掉，然后加几个新的 Element 6，7，8，9，10 进去，这里面就有 4 次 Element 删除，5 次 Element 添加。共计 9 次 DOM 操作。</p>\n<p><strong>那 React 的虚拟 DOM 可以怎么做呢？</strong></p>\n<p>而 React 会把这两个做一下 Diff，然后发现其实不用删除 0，1，2，3，而是可以直接改 innerHTML，然后只需要添加一个 Element（10）就行了，这样就是 4 次 innerHTML 操作加 1 个 Element 添加。<strong>共计 5 次操作，这样效率的提升是非常可观的。</strong></p>\n<h3 id=\"2、-关于-React\"><a href=\"#2、-关于-React\" class=\"headerlink\" title=\"2、 关于 React\"></a>2、 关于 React</h3><h4 id=\"2-1-接口和设计\"><a href=\"#2-1-接口和设计\" class=\"headerlink\" title=\"2.1 接口和设计\"></a>2.1 接口和设计</h4><p><strong>在 React 的设计中，是完全不需要你来操作 DOM 的。我们也可以认为，在 React 中根本就没有 DOM 这个概念，有的只是 Component。</strong></p>\n<p>当你写好一个 Component 以后，Component 会完全负责 UI，你不需要也不应该去也不能够指挥 Component 怎么显示，你只能告诉它你想要显示一个香蕉还是两个梨。</p>\n<p><strong>隔离 DOM 并不仅仅是因为 DOM 慢，而也是为了把界面和业务完全隔离，操作数据的只关心数据，操作界面的只关心界面</strong>。比如在 websocket 聊天室的创建房间时，我们可以首先把 Component 写好，然后当获取到数据的时候，只要把数据放在 redux 中就好，然后 Component 就自动把房间添加到页面中去，而不是你先拿到数据，然后使用 js 操作 DOM 把数据显示在页面上。</p>\n<p>即<strong>我提供一个 Component，然后你只管给我数据，界面的事情完全不用你操心，我保证会把界面变成你想要的样子。所以说 React 的着力点就在于 View 层，即 React 专注于 View 层</strong>。你可以把一个 React 的 Component 想象成一个 Pure Function，只要你给的数据是[1, 2, 3]，我保证显示的是[1, 2, 3]。没有什么删除一个 Element，添加一个 Element 这样的事情。NO。你要我显示什么就给我一个完整的列表。</p>\n<p>另外，Flux 虽然说的是单向的 Data Flow(redux 也是)，但是实际上就是单向的 Observer，Store-&gt;View-&gt;Action-&gt;Store（箭头是数据流向，实现上可以理解为 View 监听 Store，View 直接 trigger action，然后 Store 监听 Action）。</p>\n<h4 id=\"2-2-实现\"><a href=\"#2-2-实现\" class=\"headerlink\" title=\"2.2 实现\"></a>2.2 实现</h4><p>那么 react 如何实现呢？ 最简单的方法就是当数据变化时，我直接把原先的 DOM 卸载，然后把最新数据的 DOM 替换上去。 但是，虚拟 DOM 哪去了？ 这样做的效率显然是极低的。</p>\n<p>所以虚拟 DOM 就来救场了。</p>\n<p>那么虚拟 DOM 和 DOM 之间的关系是什么呢？</p>\n<p>首先，Virtual DOM 并没有完全实现 DOM，即虚拟 DOM 和真正地 DOM 是不一样的，Virtual DOM 最主要的还是保留了 Element 之间的层次关系和一些基本属性。因为真实 DOM 实在是太复杂，一个空的 Element 都复杂得能让你崩溃，并且几乎所有内容我根本不关心好吗。所以 Virtual DOM 里每一个 Element 实际上只有几个属性，即最重要的，最为有用的，并且没有那么多乱七八糟的引用，比如一些注册的属性和函数啊，这些都是默认的，创建虚拟 DOM 进行 diff 的过程中大家都一致，是不需要进行比对的。所以哪怕是直接把 Virtual DOM 删了，根据新传进来的数据重新创建一个新的 Virtual DOM 出来都非常非常非常快。（每一个 component 的 render 函数就是在做这个事情，给新的 virtual dom 提供 input）。</p>\n<p>所以，引入了 Virtual DOM 之后，React 是这么干的：你给我一个数据，我根据这个数据生成一个全新的 Virtual DOM，然后跟我上一次生成的 Virtual DOM 去 diff，得到一个 Patch，然后把这个 Patch 打到浏览器的 DOM 上去。完事。并且这里的 patch 显然不是完整的虚拟 DOM，而是新的虚拟 DOM 和上一次的虚拟 DOM 经过 diff 后的差异化的部分。</p>\n<p>假设在任意时候有，VirtualDom1 &#x3D;&#x3D; DOM1 （组织结构相同, 显然虚拟 DOM 和真实 DOM 是不可能完全相等的，这里的&#x3D;&#x3D;是 js 中非完全相等）。当有新数据来的时候，我生成 VirtualDom2，然后去和 VirtualDom1 做 diff，得到一个 Patch（差异化的结果）。然后将这个 Patch 去应用到 DOM1 上，得到 DOM2。如果一切正常，那么有 VirtualDom2 &#x3D;&#x3D; DOM2（同样是结构上的相等）。</p>\n<p>这里你可以做一些小实验，去破坏 VirtualDom1 &#x3D;&#x3D; DOM1 这个假设（手动在 DOM 里删除一些 Element，这时候 VirtualDom 里的 Element 没有被删除，所以两边不一样了）。<br>然后给新的数据，你会发现生成的界面就不是你想要的那个界面了。</p>\n<p>最后，回到为什么 Virtual Dom 快这个问题上。<br>其实是由于每次生成 virtual dom 很快，diff 生成 patch 也比较快，而在对 DOM 进行 patch 的时候，虽然 DOM 的变更比较慢，但是 React 能够根据 Patch 的内容，优化一部分 DOM 操作，比如之前的那个例子。</p>\n<p>重点就在最后，哪怕是我生成了 virtual dom(需要耗费时间)，哪怕是我跑了 diff（还需要花时间），但是我根据 patch 简化了那些 DOM 操作省下来的时间依然很可观（这个就是时间差的问题了，即节省下来的时间 &gt; 生成 virtual dom 的时间 + diff 时间）。所以总体上来说，还是比较快。</p>\n<p>简单发散一下思路，如果哪一天，DOM 本身的操作已经非常非常非常快了，并且我们手动对于 DOM 的操作都是精心设计优化过后的，那么加上了 VirtualDom 还会快吗？<br>当然不行了，毕竟你多做了这么多额外的工作。</p>\n<pre><code>    但是那一天会来到吗？\n    诶，大不了到时候不用Virtual DOM。\n</code></pre>\n<p>注： 此部分内容整理自：<a href=\"https://www.zhihu.com/question/29504639/answer/44680878\">https://www.zhihu.com/question/29504639/answer/44680878</a></p>\n<h2 id=\"虚拟-DOM-的简单实现（diff-算法）\"><a href=\"#虚拟-DOM-的简单实现（diff-算法）\" class=\"headerlink\" title=\"虚拟 DOM 的简单实现（diff 算法）\"></a>虚拟 DOM 的简单实现（diff 算法）</h2><p>目录</p>\n<ul>\n<li>1 前言</li>\n<li>2 对前端应用状态管理思考</li>\n<li>3 Virtual DOM 算法</li>\n<li>4 算法实现<ul>\n<li>4.1 步骤一：用 JS 对象模拟 DOM 树</li>\n<li>4.2 步骤二：比较两棵虚拟 DOM 树的差异</li>\n<li>4.3 步骤三：把差异应用到真正的 DOM 树上</li>\n</ul>\n</li>\n<li>5 结语</li>\n</ul>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在上面一部分中，我们已经简单介绍了虚拟 DOM 的答题思路和好处，这里我们将通过自己写一个虚拟 DOM 来加深对其的理解，有一些自己的思考。</p>\n<h3 id=\"对前端应用状态管理思考\"><a href=\"#对前端应用状态管理思考\" class=\"headerlink\" title=\"对前端应用状态管理思考\"></a>对前端应用状态管理思考</h3><p>维护状态，更新视图。</p>\n<h3 id=\"虚拟-DOM-算法\"><a href=\"#虚拟-DOM-算法\" class=\"headerlink\" title=\"虚拟 DOM 算法\"></a>虚拟 DOM 算法</h3><p>DOM 是很慢的，如果我们创建一个简单的 div，然后把他的所有的属性都打印出来，你会看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var div = document.createElement(&#x27;div&#x27;),</span><br><span class=\"line\">    str = &#x27;&#x27;;</span><br><span class=\"line\">for (var key in div) &#123;</span><br><span class=\"line\">  str = str + &#x27; &#x27; + key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(str);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830091841171-1021895840.png\" alt=\"image\"></p>\n<p>可以看到，这些属性还是非常惊人的，包括样式的修饰特性、一般的特性、方法等等，如果我们打印出其长度，可以得到惊人的 227 个。<br>而这仅仅是一层，真正的 DOM 元素是非常庞大的，这是因为标准就是这么设计的，而且操作他们的时候你要小心翼翼，轻微的触碰就有可能导致页面发生重排，这是杀死性能的罪魁祸首。</p>\n<p>而相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单，DOM 树上的结构信息我们都可以使用 JavaScript 对象很容易的表示出来。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var element = &#123;</span><br><span class=\"line\">      tagName: &#x27;ul&#x27;,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        id: &#x27;list&#x27;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      children: &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          tagName: &#x27;li&#x27;,</span><br><span class=\"line\">          props: &#123;</span><br><span class=\"line\">            class: &#x27;item&#x27;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          children: [&#x27;Item1&#x27;]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          tagName: &#x27;li&#x27;,</span><br><span class=\"line\">          props: &#123;</span><br><span class=\"line\">            class: &#x27;item&#x27;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          children: [&#x27;Item1&#x27;]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          tagName: &#x27;li&#x27;,</span><br><span class=\"line\">          props: &#123;</span><br><span class=\"line\">            class: &#x27;item&#x27;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          children: [&#x27;Item1&#x27;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，对于一个元素，我们只需要一个 JavaScript 对象就可以很容易的表示出来，这个对象中有三个属性:</p>\n<ol>\n<li>tagName: 用来表示这个元素的标签名。</li>\n<li>props: 用来表示这元素所包含的属性。</li>\n<li>children: 用来表示这元素的 children。</li>\n</ol>\n<p>而上面的这个对象使用 HTML 表示就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul id=&#x27;list&#x27;&gt;</span><br><span class=\"line\">  &lt;li class=&#x27;item&#x27;&gt;Item 1&lt;/li&gt;</span><br><span class=\"line\">  &lt;li class=&#x27;item&#x27;&gt;Item 2&lt;/li&gt;</span><br><span class=\"line\">  &lt;li class=&#x27;item&#x27;&gt;Item 3&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>OK! 既然原来的 DOM 信息可以使用 JavaScript 来表示，那么反过来，我们就可以用这个 JavaScript 对象来构建一个真正的 DOM 树。</p>\n<p>所以之前所说的状态变更的时候会重新构建这个 JavaScript 对象，然后呢，用新渲染的对象和旧的对象去对比， 记录两棵树的差异，记录下来的就是我们需要改变的地方。 这就是所谓的虚拟 DOM，包括下面的几个步骤：</p>\n<ol>\n<li>用 JavaScript 对象来表示 DOM 树的结构； 然后用这个树构建一个真正的 DOM 树，插入到文档中。</li>\n<li>当状态变更的时候，重新构造一个新的对象树，然后用这个新的树和旧的树作对比，记录两个树的差异。</li>\n<li>把 2 所记录的差异应用在步骤一所构建的真正的 DOM 树上，视图就更新了。</li>\n</ol>\n<p>Virtual DOM 的本质就是在 JS 和 DOM 之间做一个缓存，可以类比 CPU 和硬盘，既然硬盘这么慢，我们就也在他们之间添加一个缓存； 既然 DOM 这么慢，我们就可以在 JS 和 DOM 之间添加一个缓存。 CPU（JS）只操作内存（虚拟 DOM），最后的时候在把变更写入硬盘（DOM）。</p>\n<h3 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><h4 id=\"1、-用-JavaScript-对象模拟-DOM-树\"><a href=\"#1、-用-JavaScript-对象模拟-DOM-树\" class=\"headerlink\" title=\"1、 用 JavaScript 对象模拟 DOM 树\"></a>1、 用 JavaScript 对象模拟 DOM 树</h4><p>用 JavaScript 对象来模拟一个 DOM 节点并不难，你只需要记录他的节点类型（tagName）、属性（props）、子节点（children）。</p>\n<p>element.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Element(tagName, props, children) &#123;</span><br><span class=\"line\">  this.tagName = tagName;</span><br><span class=\"line\">  this.props = props;</span><br><span class=\"line\">  this.children = children;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = function (tagName, props, children) &#123;</span><br><span class=\"line\">   return new Element(tagName, props, children);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这个构造函数，我们就可以传入标签名、属性以及子节点了，tagName 可以在我们 render 的时候直接根据它来创建真实的元素，这里的 props 使用一个对象传入，可以方便我们遍历。</p>\n<p>基本使用方法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var el = require(&#x27;./element&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">var ul = el(&#x27;ul&#x27;, &#123;id: &#x27;list&#x27;&#125;, [</span><br><span class=\"line\">    el(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item1&#x27;]),</span><br><span class=\"line\">    el(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item2&#x27;]),</span><br><span class=\"line\">    el(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item3&#x27;])</span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n\n<p>然而，现在的 ul 只是 JavaScript 表示的一个 DOM 结构，页面上并没有这个结构，所有我们可以根据 ul 构建一个真正的<code>&lt;ul&gt;</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Element.prototype.render = function () &#123;</span><br><span class=\"line\">      // 根据tagName创建一个真实的元素</span><br><span class=\"line\">      var el = document.createElement(this.tagName);</span><br><span class=\"line\">      // 得到这个元素的属性对象，方便我们遍历。</span><br><span class=\"line\">      var props = this.props;</span><br><span class=\"line\"></span><br><span class=\"line\">      for (var propName in props) &#123;</span><br><span class=\"line\">        // 获取到这个元素值</span><br><span class=\"line\">        var propValue = props[propName];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 通过setAttribute设置元素属性。</span><br><span class=\"line\">        el.setAttribute(propName, propValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 注意： 这里的children，我们传入的是一个数组，所以，children不存在时我们用【】来替代。</span><br><span class=\"line\">      var children = this.children || [];</span><br><span class=\"line\"></span><br><span class=\"line\">      //遍历children</span><br><span class=\"line\">      children.forEach(function (child) &#123;</span><br><span class=\"line\">        var childEl = (child instanceof Element)</span><br><span class=\"line\">                      ? child.render()</span><br><span class=\"line\">                      : document.createTextNode(child);</span><br><span class=\"line\">        // 无论childEl是元素还是文字节点，都需要添加到这个元素中。</span><br><span class=\"line\">        el.appendChild(childEl);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      return el;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，render 方法会根据 tagName 构建一个真正的 DOM 节点，然后设置这个节点的属性，最后递归的把自己的子节点也构建起来，所以只需要调用 ul 的 render 方法，通过 document.body.appendChild 就可以挂载到真实的页面上了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;div&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    function Element(tagName, props, children) &#123;</span><br><span class=\"line\">      this.tagName = tagName;</span><br><span class=\"line\">      this.props = props;</span><br><span class=\"line\">      this.children = children;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    var ul = new Element(&#x27;ul&#x27;, &#123;id: &#x27;list&#x27;&#125;, [</span><br><span class=\"line\">        new Element(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item1&#x27;]),</span><br><span class=\"line\">        new Element(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item2&#x27;]),</span><br><span class=\"line\">        new Element(&#x27;li&#x27;, &#123;class: &#x27;item&#x27;&#125;, [&#x27;item3&#x27;])</span><br><span class=\"line\">      ]);</span><br><span class=\"line\"></span><br><span class=\"line\">    Element.prototype.render = function () &#123;</span><br><span class=\"line\">      // 根据tagName创建一个真实的元素</span><br><span class=\"line\">      var el = document.createElement(this.tagName);</span><br><span class=\"line\">      // 得到这个元素的属性对象，方便我们遍历。</span><br><span class=\"line\">      var props = this.props;</span><br><span class=\"line\"></span><br><span class=\"line\">      for (var propName in props) &#123;</span><br><span class=\"line\">        // 获取到这个元素值</span><br><span class=\"line\">        var propValue = props[propName];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 通过setAttribute设置元素属性。</span><br><span class=\"line\">        el.setAttribute(propName, propValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 注意： 这里的children，我们传入的是一个数组，所以，children不存在时我们用【】来替代。</span><br><span class=\"line\">      var children = this.children || [];</span><br><span class=\"line\"></span><br><span class=\"line\">      //遍历children</span><br><span class=\"line\">      children.forEach(function (child) &#123;</span><br><span class=\"line\">        var childEl = (child instanceof Element)</span><br><span class=\"line\">                      ? child.render()</span><br><span class=\"line\">                      : document.createTextNode(child);</span><br><span class=\"line\">        // 无论childEl是元素还是文字节点，都需要添加到这个元素中。</span><br><span class=\"line\">        el.appendChild(childEl);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      return el;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var ulRoot = ul.render();</span><br><span class=\"line\">    document.body.appendChild(ulRoot);</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面的这段代码，就可以渲染出下面的结果了：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830101420718-2040904880.png\" alt=\"image\"></p>\n<h4 id=\"2、比较两颗虚拟-DOM-树的差异\"><a href=\"#2、比较两颗虚拟-DOM-树的差异\" class=\"headerlink\" title=\"2、比较两颗虚拟 DOM 树的差异\"></a>2、比较两颗虚拟 DOM 树的差异</h4><p>比较两颗 DOM 树的差异是 Virtual DOM 算法中最为核心的部分，这也就是所谓的 Virtual DOM 的 diff 算法。 两个树的完全的 diff 算法是一个时间复杂度为 O(n3) 的问题。 但是在前端中，你会很少跨层地移动 DOM 元素，所以真实的 DOM 算法会对同一个层级的元素进行对比。</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830101733202-1167202046.png\" alt=\"image\"></p>\n<p>上图中，div 只会和同一层级的 div 对比，第二层级的只会和第二层级对比。 这样算法复杂度就可以达到 O(n)。</p>\n<p><strong>（1）深度遍历优先，记录差异</strong></p>\n<p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每一个节点就会有一个唯一的标记：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1044137/201708/1044137-20170830102245702-1187605690.png\" alt=\"image\"></p>\n<p>上面的这个遍历过程就是深度优先，即深度完全完成之后，再转移位置。 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比，如果有差异的话就记录到一个对象里面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// diff函数，对比两颗树</span><br><span class=\"line\">function diff(oldTree, newTree) &#123;</span><br><span class=\"line\">  // 当前的节点的标志。因为在深度优先遍历的过程中，每个节点都有一个index。</span><br><span class=\"line\">  var index = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 在遍历到每个节点的时候，都需要进行对比，找到差异，并记录在下面的对象中。</span><br><span class=\"line\">  var pathches = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 开始进行深度优先遍历</span><br><span class=\"line\">  dfsWalk(oldTree, newTree, index, pathches);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 最终diff算法返回的是一个两棵树的差异。</span><br><span class=\"line\">  return pathches;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 对两棵树进行深度优先遍历。</span><br><span class=\"line\">function dfsWalk(oldNode, newNode, index, pathches) &#123;</span><br><span class=\"line\">  // 对比oldNode和newNode的不同，记录下来</span><br><span class=\"line\">  pathches[index] = [...];</span><br><span class=\"line\"></span><br><span class=\"line\">  diffChildren(oldNode.children, newNode.children, index, pathches);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 遍历子节点</span><br><span class=\"line\">function diffChildren(oldChildren, newChildren, index, pathches) &#123;</span><br><span class=\"line\">  var leftNode = null;</span><br><span class=\"line\">  var currentNodeIndex = index;</span><br><span class=\"line\">  oldChildren.forEach(function (child, i) &#123;</span><br><span class=\"line\">    var newChild = newChildren[i];</span><br><span class=\"line\">    currentNodeIndex = (leftNode &amp;&amp; leftNode.count)</span><br><span class=\"line\">    ? currentNodeIndex + leftNode.count + 1</span><br><span class=\"line\">    : currentNodeIndex + 1</span><br><span class=\"line\"></span><br><span class=\"line\">    // 深度遍历子节点</span><br><span class=\"line\">    dfsWalk(child, newChild, currentNodeIndex, pathches);</span><br><span class=\"line\">    leftNode = child;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如，上面的 div 和新的 div 有差异，当前的标记是 0， 那么我们可以使用数组来存储新旧节点的不同：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...]</span><br></pre></td></tr></table></figure>\n\n<p>同理使用 patches[1]来记录 p，使用 patches[3]来记录 ul，以此类推。</p>\n<p><strong>（2）差异类型</strong></p>\n<p>上面说的节点的差异指的是什么呢？ 对 DOM 操作可能会：</p>\n<ol>\n<li>替换原来的节点，如把上面的 div 换成了 section。</li>\n<li>移动、删除、新增子节点， 例如上面 div 的子节点，把 p 和 ul 顺序互换。</li>\n<li>修改了节点的属性。</li>\n<li>对于文本节点，文本内容可能会改变。 例如修改上面的文本内容 2 内容为 Virtual DOM2.<br>　　所以，我们可以定义下面的几种类型：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var REPLACE = 0;</span><br><span class=\"line\">var REORDER = 1;</span><br><span class=\"line\">var PROPS = 2;</span><br><span class=\"line\">var TEXT = 3;</span><br></pre></td></tr></table></figure>\n\n<p>对于节点替换，很简单，判断新旧节点的 tagName 是不是一样的，如果不一样的说明需要替换掉。 如 div 换成了 section，就记录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">patches[0] = [&#123;</span><br><span class=\"line\">  type: REPALCE,</span><br><span class=\"line\">  node: newNode // el(&#x27;section&#x27;, props, children)</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，如果给 div 新增了属性 id 为 container，就记录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pathches[0] = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    type: REPLACE,</span><br><span class=\"line\">    node: newNode</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    type: PROPS,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      id: &#x27;container&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>如果是文本节点发生了变化，那么就记录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pathches[2] = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    type:  TEXT,</span><br><span class=\"line\">    content: &#x27;virtual DOM2&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>那么如果我们把 div 的子节点重新排序下了呢？ 比如 p、ul、div 的顺序换成了 div、p、ul，那么这个该怎么对比呢？ 如果按照同级进行顺序对比的话，他们就会被替换掉，如 p 和 div 的 tagName 不同，p 就会被 div 所代替，最终，三个节点就都会被替换，这样 DOM 开销就会非常大，而实际上是不需要替换节点的，只需要移动就可以了， 我们只需要知道怎么去移动。这里牵扯到了两个列表的对比算法，如下。</p>\n<p><strong>（3）列表对比算法</strong></p>\n<p>假设现在可以用英文字母唯一地标识每一个子节点：</p>\n<p>旧的节点顺序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a b c d e f g h i</span><br></pre></td></tr></table></figure>\n\n<p>现在对节点进行了删除、插入、移动的操作。新增 j 节点，删除 e 节点，移动 h 节点：</p>\n<p>新的节点顺序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a b c h d f g i j</span><br></pre></td></tr></table></figure>\n\n<p>现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），最常见的解决算法是 Levenshtein Distance，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定 DOM 操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考代码。</p>\n<p>我们能够获取到某个父节点的子节点的操作，就可以记录下来：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">patches[0] = [&#123;</span><br><span class=\"line\">  type: REORDER,</span><br><span class=\"line\">  moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>但是要注意的是，因为 tagName 是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识 key，列表对比的时候，使用 key 进行对比，这样才能复用老的 DOM 树上的节点。</p>\n<p>这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 diff.js。</p>\n<h3 id=\"3、把差异引用到真正的-DOM-树上\"><a href=\"#3、把差异引用到真正的-DOM-树上\" class=\"headerlink\" title=\"3、把差异引用到真正的 DOM 树上\"></a>3、把差异引用到真正的 DOM 树上</h3><p>因为步骤一所构建的 JavaScript 对象树和 render 出来真正的 DOM 树的信息、结构是一样的。所以我们可以对那棵 DOM 树也进行深度优先的遍历，遍历的时候从步骤二生成的 patches 对象中找出当前遍历的节点差异，然后进行 DOM 操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function patch (node, patches) &#123;</span><br><span class=\"line\">  var walker = &#123;index: 0&#125;</span><br><span class=\"line\">  dfsWalk(node, walker, patches)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function dfsWalk (node, walker, patches) &#123;</span><br><span class=\"line\">  var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异</span><br><span class=\"line\"></span><br><span class=\"line\">  var len = node.childNodes</span><br><span class=\"line\">    ? node.childNodes.length</span><br><span class=\"line\">    : 0</span><br><span class=\"line\">  for (var i = 0; i &lt; len; i++) &#123; // 深度遍历子节点</span><br><span class=\"line\">    var child = node.childNodes[i]</span><br><span class=\"line\">    walker.index++</span><br><span class=\"line\">    dfsWalk(child, walker, patches)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (currentPatches) &#123;</span><br><span class=\"line\">    applyPatches(node, currentPatches) // 对当前节点进行DOM操作</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function applyPatches (node, currentPatches) &#123;</span><br><span class=\"line\">  currentPatches.forEach(function (currentPatch) &#123;</span><br><span class=\"line\">    switch (currentPatch.type) &#123;</span><br><span class=\"line\">      case REPLACE:</span><br><span class=\"line\">        node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case REORDER:</span><br><span class=\"line\">        reorderChildren(node, currentPatch.moves)</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case PROPS:</span><br><span class=\"line\">        setProps(node, currentPatch.props)</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case TEXT:</span><br><span class=\"line\">        node.textContent = currentPatch.content</span><br><span class=\"line\">        break</span><br><span class=\"line\">      default:</span><br><span class=\"line\">        throw new Error(&#x27;Unknown patch type &#x27; + currentPatch.type)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5、结语</p>\n<p>virtual DOM 算法主要实现上面步骤的三个函数： element、diff、patch，然后就可以实际的进行使用了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 1. 构建虚拟DOM</span><br><span class=\"line\">var tree = el(&#x27;div&#x27;, &#123;&#x27;id&#x27;: &#x27;container&#x27;&#125;, [</span><br><span class=\"line\">    el(&#x27;h1&#x27;, &#123;style: &#x27;color: blue&#x27;&#125;, [&#x27;simple virtal dom&#x27;]),</span><br><span class=\"line\">    el(&#x27;p&#x27;, [&#x27;Hello, virtual-dom&#x27;]),</span><br><span class=\"line\">    el(&#x27;ul&#x27;, [el(&#x27;li&#x27;)])</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 通过虚拟DOM构建真正的DOM</span><br><span class=\"line\">var root = tree.render()</span><br><span class=\"line\">document.body.appendChild(root)</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. 生成新的虚拟DOM</span><br><span class=\"line\">var newTree = el(&#x27;div&#x27;, &#123;&#x27;id&#x27;: &#x27;container&#x27;&#125;, [</span><br><span class=\"line\">    el(&#x27;h1&#x27;, &#123;style: &#x27;color: red&#x27;&#125;, [&#x27;simple virtal dom&#x27;]),</span><br><span class=\"line\">    el(&#x27;p&#x27;, [&#x27;Hello, virtual-dom&#x27;]),</span><br><span class=\"line\">    el(&#x27;ul&#x27;, [el(&#x27;li&#x27;), el(&#x27;li&#x27;)])</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">// 4. 比较两棵虚拟DOM树的不同</span><br><span class=\"line\">var patches = diff(tree, newTree)</span><br><span class=\"line\"></span><br><span class=\"line\">// 5. 在真正的DOM元素上应用变更</span><br><span class=\"line\">patch(root, patches)</span><br></pre></td></tr></table></figure>\n\n<p>当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的 ReactJS 了。</p>\n<ul>\n<li>源码地址： <a href=\"https://github.com/livoras/simple-virtual-dom\">https://github.com/livoras/simple-virtual-dom</a></li>\n<li>参考文章：<a href=\"https://github.com/livoras/blog/issues/13\">https://github.com/livoras/blog/issues/13</a></li>\n</ul>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"百度地图使用笔记","url":"/2022/12/16/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","content":"<h2 id=\"地图级别控制\"><a href=\"#地图级别控制\" class=\"headerlink\" title=\"地图级别控制\"></a>地图级别控制</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 百度地图API功能</span><br><span class=\"line\">var map = new BMap.Map(&quot;allmap&quot;, &#123;enableMapClick:false&#125;);//构造底图时，关闭底图可点功能</span><br><span class=\"line\"></span><br><span class=\"line\">// 初始化地图,设置中心点坐标(城市名)和地图级别</span><br><span class=\"line\">map.centerAndZoom(&quot;上海&quot;,15);</span><br><span class=\"line\">map.centerAndZoom(new BMap.Point(116.404, 39.915), 11);</span><br><span class=\"line\"></span><br><span class=\"line\">// 移动地图到中心点</span><br><span class=\"line\">map.panTo(new BMap.Point(113.262232,23.154345));</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置缩放级别</span><br><span class=\"line\">map.setZoom(14);</span><br><span class=\"line\"></span><br><span class=\"line\">// 开启地图缩放</span><br><span class=\"line\">map.enableScrollWheelZoom();</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以拖拽</span><br><span class=\"line\">marker.enableDragging();</span><br><span class=\"line\"></span><br><span class=\"line\">// 不可以拖拽</span><br><span class=\"line\">marker.disableDragging();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"获取两点之间距离\"><a href=\"#获取两点之间距离\" class=\"headerlink\" title=\"获取两点之间距离\"></a>获取两点之间距离</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var pointA = new BMap.Point(106.486654,29.490295);  // 创建点坐标A--大渡口区</span><br><span class=\"line\">var pointB = new BMap.Point(106.581515,29.615467);  // 创建点坐标B--江北区</span><br><span class=\"line\">alert(&#x27;从大渡口区到江北区的距离是：&#x27;+(map.getDistance(pointA,pointB)).toFixed(2)+&#x27; 米。&#x27;);  //获取两点距离</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加-图形，点，线，面-文字\"><a href=\"#添加-图形，点，线，面-文字\" class=\"headerlink\" title=\"添加 图形，点，线，面 文字\"></a>添加 图形，点，线，面 文字</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//  marker是随着地图缩放级别，尺寸变化的</span><br><span class=\"line\">var marker = new BMap.Marker(new BMap.Point(116.404, 39.915)); // 创建点</span><br><span class=\"line\"></span><br><span class=\"line\">// 折线</span><br><span class=\"line\">var polyline = new BMap.Polyline([</span><br><span class=\"line\">new BMap.Point(116.399, 39.910),</span><br><span class=\"line\">new BMap.Point(116.405, 39.920),</span><br><span class=\"line\">new BMap.Point(116.425, 39.900)</span><br><span class=\"line\">], &#123;strokeColor: &quot;blue&quot;, strokeWeight: 2, strokeOpacity: 0.5&#125;);   //创建折线</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 创建圆</span><br><span class=\"line\">var circle = new BMap.Circle(</span><br><span class=\"line\">point, 1500,</span><br><span class=\"line\">&#123;strokeColor: &quot;blue&quot;,</span><br><span class=\"line\">  fillColor: &quot;#ccc&quot;,</span><br><span class=\"line\">  strokeWeight: 2,</span><br><span class=\"line\">  strokeOpacity: 0.5,</span><br><span class=\"line\">  fillOpacity: 0.7&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 多边形</span><br><span class=\"line\">var polygon = new BMap.Polygon([</span><br><span class=\"line\">new BMap.Point(116.387112, 39.920977),</span><br><span class=\"line\">new BMap.Point(116.385243, 39.913063),</span><br><span class=\"line\">new BMap.Point(116.394226, 39.917988),</span><br><span class=\"line\">new BMap.Point(116.401772, 39.921364),</span><br><span class=\"line\">new BMap.Point(116.41248, 39.927893)</span><br><span class=\"line\">], &#123;strokeColor: &quot;blue&quot;, strokeWeight: 2, strokeOpacity: 0.5&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//创建矩形</span><br><span class=\"line\">var pStart = new BMap.Point(116.392214, 39.918985);</span><br><span class=\"line\">var pEnd = new BMap.Point(116.41478, 39.911901);</span><br><span class=\"line\">var rectangle = new BMap.Polygon([</span><br><span class=\"line\">new BMap.Point(pStart.lng, pStart.lat),</span><br><span class=\"line\">new BMap.Point(pEnd.lng, pStart.lat),</span><br><span class=\"line\">new BMap.Point(pEnd.lng, pEnd.lat),</span><br><span class=\"line\">new BMap.Point(pStart.lng, pEnd.lat)</span><br><span class=\"line\">], &#123;strokeColor: &quot;blue&quot;, strokeWeight: 2, strokeOpacity: 0.5&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 开启(关闭)点线面的编辑(可以拖拽，移动点)</span><br><span class=\"line\">polygon.enableEditing()</span><br><span class=\"line\">polygon.disableEditing()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 文字label</span><br><span class=\"line\">var opts = &#123;</span><br><span class=\"line\">  position : new BMap.Point(116.417854,39.921988),    // 指定文本标注所在的地理位置</span><br><span class=\"line\">  offset   : new BMap.Size(30, -30)    //设置文本偏移量</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var label = new BMap.Label(&quot;欢迎使用百度地图，这是一个简单的文本标注哦~&quot;, opts);  // 创建文本标注对象</span><br><span class=\"line\">label.setStyle(&#123;</span><br><span class=\"line\">  color : &quot;red&quot;,</span><br><span class=\"line\">  fontSize : &quot;12px&quot;,</span><br><span class=\"line\">  height : &quot;20px&quot;,</span><br><span class=\"line\">  lineHeight : &quot;20px&quot;,</span><br><span class=\"line\">  fontFamily:&quot;微软雅黑&quot;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 覆盖物显示，隐藏</span><br><span class=\"line\">marker.show()</span><br><span class=\"line\">marker.hide()</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加覆盖物</span><br><span class=\"line\">map.addOverlay(marker);</span><br><span class=\"line\"></span><br><span class=\"line\">// 清除覆盖物</span><br><span class=\"line\">map.clearOverlays();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除指定覆盖物\"><a href=\"#删除指定覆盖物\" class=\"headerlink\" title=\"删除指定覆盖物\"></a>删除指定覆盖物</h2><blockquote>\n<p>getOverlays 方法可以获取 覆盖物数组，getLabel 方法可以，获取他的 label</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function deletePoint()&#123;</span><br><span class=\"line\">        var allOverlay = map.getOverlays();</span><br><span class=\"line\">        for (var i = 0; i &lt; allOverlay.length -1; i++)&#123;</span><br><span class=\"line\">            if(allOverlay[i].getLabel().content == &quot;我是id=1&quot;)&#123;</span><br><span class=\"line\">                map.removeOverlay(allOverlay[i]);</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"marker-自定义-icon\"><a href=\"#marker-自定义-icon\" class=\"headerlink\" title=\"marker 自定义 icon\"></a>marker 自定义 icon</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 创建小狐狸icon</span><br><span class=\"line\">var pt = new BMap.Point(116.417, 39.909);</span><br><span class=\"line\">var myIcon = new BMap.Icon(&quot;http://lbsyun.baidu.com/jsdemo/img/fox.gif&quot;, new BMap.Size(300,157));</span><br><span class=\"line\">var marker2 = new BMap.Marker(pt,&#123;icon:myIcon&#125;);  // 创建标注</span><br><span class=\"line\">map.addOverlay(marker2);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"加载海量点\"><a href=\"#加载海量点\" class=\"headerlink\" title=\"加载海量点\"></a>加载海量点</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// data source</span><br><span class=\"line\">var data = &#123;&quot;data&quot;:[[74.438,39.006,1]]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if (document.createElement(&#x27;canvas&#x27;).getContext) &#123;  // 判断当前浏览器是否支持绘制海量点</span><br><span class=\"line\">    var points = [];  // 添加海量点数据</span><br><span class=\"line\">    for (var i = 0; i &lt; data.data.length; i++) &#123;</span><br><span class=\"line\">      points.push(new BMap.Point(data.data[i][0], data.data[i][1]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var options = &#123;</span><br><span class=\"line\">        size: BMAP_POINT_SIZE_SMALL,</span><br><span class=\"line\">        shape: BMAP_POINT_SHAPE_STAR,</span><br><span class=\"line\">        color: &#x27;#d340c3&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var pointCollection = new BMap.PointCollection(points, options);  // 初始化PointCollection</span><br><span class=\"line\">    pointCollection.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">      alert(&#x27;单击点的坐标为：&#x27; + e.point.lng + &#x27;,&#x27; + e.point.lat);  // 监听点击事件</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    map.addOverlay(pointCollection);  // 添加Overlay</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    alert(&#x27;请在chrome、safari、IE8+以上浏览器查看本示例&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"两点之间-画弧线-圆弧\"><a href=\"#两点之间-画弧线-圆弧\" class=\"headerlink\" title=\"两点之间 画弧线 圆弧\"></a>两点之间 画弧线 圆弧</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//  引入一个库</span><br><span class=\"line\"> &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/library/CurveLine/1.5/src/CurveLine.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var points = []</span><br><span class=\"line\">points.push( new BMap.Point(116.432045,39.910683) )</span><br><span class=\"line\">points.push( new BMap.Point(120.129721,30.314429) )</span><br><span class=\"line\">points.push( new BMap.Point(121.491121,25.127053) )</span><br><span class=\"line\">var curve = new BMapLib.CurveLine(points, &#123;strokeColor:&quot;blue&quot;, strokeWeight:3, strokeOpacity:0.5&#125;); //创建弧线对象</span><br><span class=\"line\">map.addOverlay(curve); //添加到地图中</span><br><span class=\"line\">curve.enableEditing(); //开启编辑功能</span><br><span class=\"line\"></span><br><span class=\"line\">//  centre:椭圆中心点,X:横向经度,Y:纵向纬度</span><br><span class=\"line\">function add_oval(centre,x,y)&#123;</span><br><span class=\"line\">  var assemble= []</span><br><span class=\"line\">  var angle;</span><br><span class=\"line\">  var dot;</span><br><span class=\"line\">  var tangent=x/y;</span><br><span class=\"line\">  for(i=0;i&lt;36;i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    angle = (2* Math.PI / 36) * i;</span><br><span class=\"line\">    dot = new BMap.Point(centre.lng+Math.sin(angle)*y*tangent, centre.lat+Math.cos(angle)*y);</span><br><span class=\"line\">    assemble.push(dot);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return assemble;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var oval = new BMap.Polygon(add_oval(point,0.1,0.3), &#123;strokeColor:&quot;blue&quot;, strokeWeight:6, strokeOpacity:0.5&#125;);</span><br><span class=\"line\">map.addOverlay(oval);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"画行政区\"><a href=\"#画行政区\" class=\"headerlink\" title=\"画行政区\"></a>画行政区</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getBoundary()&#123;</span><br><span class=\"line\">  var bdary = new BMap.Boundary();</span><br><span class=\"line\">  console.log(bdary)</span><br><span class=\"line\">  bdary.get(&quot;上海市徐汇区&quot;, function(rs)&#123;       //获取行政区域</span><br><span class=\"line\">    map.clearOverlays();        //清除地图覆盖物</span><br><span class=\"line\"></span><br><span class=\"line\">    // rs.boundaries 是一个数组，每个元素，是地理位置的字符串 &quot;12,12;123,23&quot;</span><br><span class=\"line\">    var count = rs.boundaries.length;</span><br><span class=\"line\">    if (count === 0) &#123;</span><br><span class=\"line\">      alert(&#x27;未能获取当前输入行政区域&#x27;);</span><br><span class=\"line\">      return ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(rs.boundaries)</span><br><span class=\"line\">    var pointArray = [];</span><br><span class=\"line\">    for (var i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">      var ply = new BMap.Polygon(rs.boundaries[i],</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          strokeWeight: 2,</span><br><span class=\"line\">          strokeColor: &quot;#ff0000&quot;,</span><br><span class=\"line\">          fillColor: &#x27;blue&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ); //建立多边形覆盖物</span><br><span class=\"line\">      map.addOverlay(ply);  //添加覆盖物</span><br><span class=\"line\">      pointArray = pointArray.concat(ply.getPath());</span><br><span class=\"line\">      console.log(pointArray)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map.setViewport(pointArray);    //调整视野</span><br><span class=\"line\">    addlabel();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义覆盖物\"><a href=\"#自定义覆盖物\" class=\"headerlink\" title=\"自定义覆盖物\"></a>自定义覆盖物</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 复杂的自定义覆盖物</span><br><span class=\"line\">function ComplexCustomOverlay(point, text, mouseoverText)&#123;</span><br><span class=\"line\">  this._point = point;</span><br><span class=\"line\">  this._text = text;</span><br><span class=\"line\">  this._overText = mouseoverText;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ComplexCustomOverlay.prototype = new BMap.Overlay();</span><br><span class=\"line\">ComplexCustomOverlay.prototype.initialize = function(map)&#123;</span><br><span class=\"line\">  this._map = map;</span><br><span class=\"line\">  var div = this._div = document.createElement(&quot;div&quot;);</span><br><span class=\"line\">  div.style.position = &quot;absolute&quot;;</span><br><span class=\"line\">  div.style.zIndex = BMap.Overlay.getZIndex(this._point.lat);</span><br><span class=\"line\">  div.style.backgroundColor = &quot;#EE5D5B&quot;;</span><br><span class=\"line\">  div.style.border = &quot;1px solid #BC3B3A&quot;;</span><br><span class=\"line\">  div.style.color = &quot;white&quot;;</span><br><span class=\"line\">  div.style.height = &quot;18px&quot;;</span><br><span class=\"line\">  div.style.padding = &quot;2px&quot;;</span><br><span class=\"line\">  div.style.lineHeight = &quot;18px&quot;;</span><br><span class=\"line\">  div.style.whiteSpace = &quot;nowrap&quot;;</span><br><span class=\"line\">  div.style.MozUserSelect = &quot;none&quot;;</span><br><span class=\"line\">  div.style.fontSize = &quot;12px&quot;</span><br><span class=\"line\">  var span = this._span = document.createElement(&quot;span&quot;);</span><br><span class=\"line\">  div.appendChild(span);</span><br><span class=\"line\">  span.appendChild(document.createTextNode(this._text));</span><br><span class=\"line\">  var that = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  var arrow = this._arrow = document.createElement(&quot;div&quot;);</span><br><span class=\"line\">  arrow.style.background = &quot;url(http://map.baidu.com/fwmap/upload/r/map/fwmap/static/house/images/label.png) no-repeat&quot;;</span><br><span class=\"line\">  arrow.style.position = &quot;absolute&quot;;</span><br><span class=\"line\">  arrow.style.width = &quot;11px&quot;;</span><br><span class=\"line\">  arrow.style.height = &quot;10px&quot;;</span><br><span class=\"line\">  arrow.style.top = &quot;22px&quot;;</span><br><span class=\"line\">  arrow.style.left = &quot;10px&quot;;</span><br><span class=\"line\">  arrow.style.overflow = &quot;hidden&quot;;</span><br><span class=\"line\">  div.appendChild(arrow);</span><br><span class=\"line\"></span><br><span class=\"line\">  div.onmouseover = function()&#123;</span><br><span class=\"line\">    this.style.backgroundColor = &quot;#6BADCA&quot;;</span><br><span class=\"line\">    this.style.borderColor = &quot;#0000ff&quot;;</span><br><span class=\"line\">    this.getElementsByTagName(&quot;span&quot;)[0].innerHTML = that._overText;</span><br><span class=\"line\">    arrow.style.backgroundPosition = &quot;0px -20px&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  div.onmouseout = function()&#123;</span><br><span class=\"line\">    this.style.backgroundColor = &quot;#EE5D5B&quot;;</span><br><span class=\"line\">    this.style.borderColor = &quot;#BC3B3A&quot;;</span><br><span class=\"line\">    this.getElementsByTagName(&quot;span&quot;)[0].innerHTML = that._text;</span><br><span class=\"line\">    arrow.style.backgroundPosition = &quot;0px 0px&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  mp.getPanes().labelPane.appendChild(div);</span><br><span class=\"line\"></span><br><span class=\"line\">  return div;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ComplexCustomOverlay.prototype.draw = function()&#123;</span><br><span class=\"line\">  var map = this._map;</span><br><span class=\"line\">  var pixel = map.pointToOverlayPixel(this._point);</span><br><span class=\"line\">  this._div.style.left = pixel.x - parseInt(this._arrow.style.left) + &quot;px&quot;;</span><br><span class=\"line\">  this._div.style.top  = pixel.y - 30 + &quot;px&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var txt = &quot;银湖海岸城&quot;, mouseoverTxt = txt + &quot; &quot; + parseInt(Math.random() * 1000,10) + &quot;套&quot; ;</span><br><span class=\"line\"></span><br><span class=\"line\">var myCompOverlay = new ComplexCustomOverlay(new BMap.Point(116.407845,39.914101), &quot;银湖海岸城&quot;,mouseoverTxt);</span><br><span class=\"line\"></span><br><span class=\"line\">mp.addOverlay(myCompOverlay);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"点聚合-放大缩小\"><a href=\"#点聚合-放大缩小\" class=\"headerlink\" title=\"点聚合(放大缩小)\"></a>点聚合(放大缩小)</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/library/TextIconOverlay/1.2/src/TextIconOverlay_min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/library/MarkerClusterer/1.2/src/MarkerClusterer_min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// markers 是一个marker数组</span><br><span class=\"line\">var markerClusterer = new BMapLib.MarkerClusterer(map, &#123;markers:markers&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"矢量图-图标\"><a href=\"#矢量图-图标\" class=\"headerlink\" title=\"矢量图 图标\"></a>矢量图 图标</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var vectorFCArrow = new BMap.Marker(new BMap.Point(point.lng-0.01,point.lat), &#123;</span><br><span class=\"line\">  // 初始化方向向上的闭合箭头</span><br><span class=\"line\">  icon: new BMap.Symbol(BMap_Symbol_SHAPE_FORWARD_CLOSED_ARROW, &#123;</span><br><span class=\"line\">    scale: 5,</span><br><span class=\"line\">    strokeWeight: 1,</span><br><span class=\"line\">    rotation: 0,//顺时针旋转30度</span><br><span class=\"line\">    fillColor: &#x27;red&#x27;,</span><br><span class=\"line\">    fillOpacity: 0.8</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var vectorStar = new BMap.Marker(new BMap.Point(point.lng+0.03,point.lat-0.03), &#123;</span><br><span class=\"line\">  // 初始化五角星symbol</span><br><span class=\"line\">  icon: new BMap.Symbol(BMap_Symbol_SHAPE_STAR, &#123;</span><br><span class=\"line\">    scale: 5,</span><br><span class=\"line\">    fillColor: &quot;pink&quot;,</span><br><span class=\"line\">    fillOpacity: 0.8</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"信息弹窗\"><a href=\"#信息弹窗\" class=\"headerlink\" title=\"信息弹窗\"></a>信息弹窗</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var infoWindow = new BMap.InfoWindow(&quot;地址：北京市东城区王府井大街88号乐天银泰百货八层&quot;, &#123;</span><br><span class=\"line\">  width : 200,     // 信息窗口宽度</span><br><span class=\"line\">  height: 100,     // 信息窗口高度</span><br><span class=\"line\">  title : &quot;海底捞王府井店&quot; , // 信息窗口标题</span><br><span class=\"line\">  enableMessage:true,//设置允许信息窗发送短息</span><br><span class=\"line\">  message:&quot;亲耐滴，晚上一起吃个饭吧？戳下面的链接看下地址喔~&quot;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">marker.addEventListener(&quot;click&quot;, function()&#123;</span><br><span class=\"line\">  map.openInfoWindow(infoWindow,point); //开启信息窗口</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"鼠标右键\"><a href=\"#鼠标右键\" class=\"headerlink\" title=\"鼠标右键\"></a>鼠标右键</h2><blockquote>\n<p>除了地图，marker 也支持加右键</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var menu = new BMap.ContextMenu();</span><br><span class=\"line\">var txtMenuItem = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        text:&#x27;放大&#x27;,</span><br><span class=\"line\">        callback:function()&#123;map.zoomIn()&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        text:&#x27;缩小&#x27;,</span><br><span class=\"line\">        callback:function()&#123;map.zoomOut()&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\">for(var i=0; i &lt; txtMenuItem.length; i++)&#123;</span><br><span class=\"line\">    menu.addItem(new BMap.MenuItem(txtMenuItem[i].text,txtMenuItem[i].callback,100));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">map.addContextMenu(menu);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"鼠标测距\"><a href=\"#鼠标测距\" class=\"headerlink\" title=\"鼠标测距\"></a>鼠标测距</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//  引入插件</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/library/DistanceTool/1.2/src/DistanceTool_min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var myDis = new BMapLib.DistanceTool(map);</span><br><span class=\"line\">map.addEventListener(&quot;load&quot;,function()&#123;</span><br><span class=\"line\">  myDis.open();  //开启鼠标测距</span><br><span class=\"line\">  //myDis.close();  //关闭鼠标测距大</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取点击点坐标</span><br><span class=\"line\">map.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class=\"line\">  alert(e.point.lng + &quot;,&quot; + e.point.lat);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"带箭头的-line\"><a href=\"#带箭头的-line\" class=\"headerlink\" title=\"带箭头的 line\"></a>带箭头的 line</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  /**</span><br><span class=\"line\">   * 变量定义：pixelStart： 线的一端屏幕坐标，pixelEnd：线的箭头端屏幕坐标；r：选取多长距离绘制箭头（单位像素，并不是CB对应的箭头的长度，而是红色线段对应的距离）；angle：箭头线（CB或者DB）与AB的夹角。</span><br><span class=\"line\">   1) 首先要将AB两点的经纬度坐标转换成屏幕坐标。</span><br><span class=\"line\">   2) 然后根据AB两点屏幕坐标以及r长度，计算绿色小绿点的屏幕坐标pixelTem。</span><br><span class=\"line\">   3) 然后根据B点、小绿点的屏幕坐标及angle角度，计算出C,D两点的屏幕坐标。</span><br><span class=\"line\">   4) 利用map的坐标转换方法，将C,D两点的屏幕坐标转成经纬度表示的坐标。</span><br><span class=\"line\">   5) 利用画线方法，绘制CBD多折线。</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">export function drawArrow(map, points) &#123;</span><br><span class=\"line\">  let polyline = new BMap.Polyline(</span><br><span class=\"line\">    points, &#123;strokeColor: &quot;white&quot;, strokeWeight: 3&#125;);</span><br><span class=\"line\">  map.addOverlay(polyline);</span><br><span class=\"line\"></span><br><span class=\"line\">  addArrow(polyline, 10, Math.PI / 7);</span><br><span class=\"line\"></span><br><span class=\"line\">  function addArrow(polyline, length, angleValue) &#123; //绘制箭头的函数</span><br><span class=\"line\">    let linePoint = polyline.getPath();//线的坐标串</span><br><span class=\"line\">    console.log(linePoint);</span><br><span class=\"line\">    let arrowCount = linePoint.length;</span><br><span class=\"line\">    for (let i = 1; i &lt; arrowCount; i++) &#123; //在拐点处绘制箭头</span><br><span class=\"line\"></span><br><span class=\"line\">      // pointToPixel 经纬度坐标转换为像素坐标</span><br><span class=\"line\">      let pixelStart = map.pointToPixel(linePoint[i - 1]);</span><br><span class=\"line\"></span><br><span class=\"line\">      let pixelEnd = map.pointToPixel(linePoint[i]);</span><br><span class=\"line\">      let angle = angleValue;//箭头和主线的夹角</span><br><span class=\"line\">      let r = length; // r/Math.sin(angle)代表箭头长度</span><br><span class=\"line\">      let delta = 0; //主线斜率，垂直时无斜率</span><br><span class=\"line\">      let param = 0; //代码简洁考虑</span><br><span class=\"line\">      let pixelTemX, pixelTemY;//临时点坐标</span><br><span class=\"line\">      let pixelX, pixelY, pixelX1, pixelY1;//箭头两个点</span><br><span class=\"line\">      if (pixelEnd.x - pixelStart.x == 0) &#123; //斜率不存在时</span><br><span class=\"line\">        pixelTemX = pixelEnd.x;</span><br><span class=\"line\">        if (pixelEnd.y &gt; pixelStart.y) &#123;</span><br><span class=\"line\">          pixelTemY = pixelEnd.y - r;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          pixelTemY = pixelEnd.y + r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //已知直角三角形两个点坐标及其中一个角，求另外一个点坐标算法</span><br><span class=\"line\">        pixelX = pixelTemX - r * Math.tan(angle);</span><br><span class=\"line\">        pixelX1 = pixelTemX + r * Math.tan(angle);</span><br><span class=\"line\">        pixelY = pixelY1 = pixelTemY;</span><br><span class=\"line\">      &#125; else  //斜率存在时</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        delta = (pixelEnd.y - pixelStart.y) / (pixelEnd.x - pixelStart.x);</span><br><span class=\"line\">        param = Math.sqrt(delta * delta + 1);</span><br><span class=\"line\"></span><br><span class=\"line\">        if ((pixelEnd.x - pixelStart.x) &lt; 0) //第二、三象限</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          pixelTemX = pixelEnd.x + r / param;</span><br><span class=\"line\">          pixelTemY = pixelEnd.y + delta * r / param;</span><br><span class=\"line\">        &#125; else//第一、四象限</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          pixelTemX = pixelEnd.x - r / param;</span><br><span class=\"line\">          pixelTemY = pixelEnd.y - delta * r / param;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //已知直角三角形两个点坐标及其中一个角，求另外一个点坐标算法</span><br><span class=\"line\">        pixelX = pixelTemX + Math.tan(angle) * r * delta / param;</span><br><span class=\"line\">        pixelY = pixelTemY - Math.tan(angle) * r / param;</span><br><span class=\"line\"></span><br><span class=\"line\">        pixelX1 = pixelTemX - Math.tan(angle) * r * delta / param;</span><br><span class=\"line\">        pixelY1 = pixelTemY + Math.tan(angle) * r / param;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      let pointArrow = map.pixelToPoint(new BMap.Pixel(pixelX, pixelY));</span><br><span class=\"line\">      let pointArrow1 = map.pixelToPoint(new BMap.Pixel(pixelX1, pixelY1));</span><br><span class=\"line\">      let Arrow = new BMap.Polyline([</span><br><span class=\"line\">        pointArrow,</span><br><span class=\"line\">        linePoint[i],</span><br><span class=\"line\">        pointArrow1</span><br><span class=\"line\">      ], &#123;strokeColor: &quot;white&quot;, strokeWeight: 3&#125;);</span><br><span class=\"line\">      map.addOverlay(Arrow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["webGL总结"],"tags":["webGL"]},{"title":"腾讯地图JavaScript API调用","url":"/2022/12/16/%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BEJavaScript-API%E8%B0%83%E7%94%A8/","content":"<h2 id=\"1、加载地图-API\"><a href=\"#1、加载地图-API\" class=\"headerlink\" title=\"1、加载地图 API\"></a>1、加载地图 API</h2><h3 id=\"页面直接引入\"><a href=\"#页面直接引入\" class=\"headerlink\" title=\"页面直接引入\"></a>页面直接引入</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script charset=&quot;utf-8&quot; src=&quot;https://map.qq.com/api/js?v=2.exp&amp;key=OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://map.qq.com/api/js?v=2.exp&key=OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77\">https://map.qq.com/api/js?v=2.exp&amp;key=OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77</a> 网址是 API 文件的位置，v2.0 指当前使用的 API 的版本标识，key&#x3D;[申请的开发密钥]</p>\n<h2 id=\"2、创建一个容纳地图的-div-容器\"><a href=\"#2、创建一个容纳地图的-div-容器\" class=\"headerlink\" title=\"2、创建一个容纳地图的 div 容器\"></a>2、创建一个容纳地图的 div 容器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;container&quot; style=&quot;width:500px; height:300px&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>要使地图在网页上显示，必须为其在网页中创建一个容器。通常，我们通过创建名为 div 的元素并在浏览器的文档对象模型 (DOM) 中获取此元素的引用执行此操作。</p>\n<p>在上述示例中，我们定义名为 “container” 的 div，并使用样式属性设置其尺寸。<strong>地图会自动使用容器尺寸调整自身的尺寸</strong>。</p>\n<h2 id=\"3、地图基本对象\"><a href=\"#3、地图基本对象\" class=\"headerlink\" title=\"3、地图基本对象\"></a>3、地图基本对象</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var map = new qq.maps.Map(document.getElementById(&#x27;container&#x27;),myoptions);</span><br></pre></td></tr></table></figure>\n\n<p>表示地图的 JavaScript 类是 Map 类。此类的对象在页面上定义单个地图。我们使用 JavaScript new 操作符创建此类的一个新实例。当创建新的地图实例时，在页面中指定一个 DOM 节点（通常是 div 元素）作为地图的容器。HTML 节点是 JavaScript document 对象的子节点，我们通过 document.getElementById() 方法获取对此元素的引用。此代码定义一个全局变量（名为 map），并将该变量分配给新的 Map 对象。函数 Map() 称为构造函数，其定义请参考《参考手册》</p>\n<p>myoptions 是地图的配置对象。</p>\n<h2 id=\"4、初始化地图\"><a href=\"#4、初始化地图\" class=\"headerlink\" title=\"4、初始化地图\"></a>4、初始化地图</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.panTo(new qq.maps.LatLng(39.916527,116.397128));</span><br></pre></td></tr></table></figure>\n\n<p>通过 Map 构造函数创建地图之后，还需要执行一个操作，即将其初始化。初始化通过地图的 panTo() 方法完成。panTo() 方法需要 LatLng 经纬度坐标，并且调用此方法必须在对地图执行任何其它操作（包括设置地图本身的任何其它属性）之前。</p>\n<p>LatLng 是 latitude 经度 Longitude 纬度 缩写</p>\n<h2 id=\"5、加载地图\"><a href=\"#5、加载地图\" class=\"headerlink\" title=\"5、加载地图\"></a>5、加载地图</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body onload=&quot;init()&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当 HTML 页面显示时，文档对象模型 (DOM) 即会扩展，接收其他外部图像和脚本并将其合并到 document 对象中。<strong>为了确保只有在完全加载页面后才将我们的地图放在页面上</strong>，我们仅在 HTML 页面的 元素收到 onload 事件后才执行构造 Map 的函数。这样做可以避免出现不可预期的行为，并使我们可以对地图绘制的方式和时间进行更多控制。body 标签的 onload 属性是事件处理程序的一个示例。腾讯 Maps Javascript API 还提供了一组事件，可供您进行处理以确定状态变化。有关详细信息，请参阅地图事件部分。</p>\n<p>参考案例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;简单地图&lt;/title&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt;</span><br><span class=\"line\">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">        html,body&#123;</span><br><span class=\"line\">            width:100%;</span><br><span class=\"line\">            height:100%;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        *&#123;</span><br><span class=\"line\">            margin:0px;</span><br><span class=\"line\">            padding:0px;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        body, button, input, select, textarea &#123;</span><br><span class=\"line\">            font: 12px/16px Verdana, Helvetica, Arial, sans-serif;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p&#123;</span><br><span class=\"line\">            width:603px;</span><br><span class=\"line\">            padding-top:3px;</span><br><span class=\"line\">            overflow:hidden;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .btn&#123;</span><br><span class=\"line\">            width:142px;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        #container&#123;</span><br><span class=\"line\">            min-width:600px;</span><br><span class=\"line\">            min-height:767px;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">    &lt;script charset=&quot;utf-8&quot; src=&quot;https://map.qq.com/api/js?v=2.exp&amp;key=OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        window.onload = function()&#123;</span><br><span class=\"line\">//直接加载地图</span><br><span class=\"line\">            //初始化地图函数  自定义函数名init</span><br><span class=\"line\">            function init() &#123;</span><br><span class=\"line\">                //定义map变量 调用 qq.maps.Map() 构造函数   获取地图显示容器</span><br><span class=\"line\">                var map = new qq.maps.Map(document.getElementById(&quot;container&quot;), &#123;</span><br><span class=\"line\">                    center: new qq.maps.LatLng(39.916527,116.397128),      // 地图的中心地理坐标。latitude 经度 Longitude 纬度</span><br><span class=\"line\">                    zoom:8                                                 // 设置缩放级别</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //调用初始化函数地图,可以写在body中 &lt;body onload=&quot;init()&quot;&gt;</span><br><span class=\"line\">            // init();</span><br><span class=\"line\"></span><br><span class=\"line\">            /*</span><br><span class=\"line\">            * function init() &#123;</span><br><span class=\"line\">                  var myLatlng = new qq.maps.LatLng(-34.397, 150.644);</span><br><span class=\"line\">                  var myOptions = &#123;</span><br><span class=\"line\">                    zoom: 8,</span><br><span class=\"line\">                    center: myLatlng,</span><br><span class=\"line\">                    mapTypeId: qq.maps.MapTypeId.ROADMAP</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  var map = new qq.maps.Map(document.getElementById(&quot;container&quot;), myOptions);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            * */</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body onload=&quot;init()&quot;&gt;</span><br><span class=\"line\">&lt;!--   定义地图显示容器   --&gt;</span><br><span class=\"line\">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"地图事件\"><a href=\"#地图事件\" class=\"headerlink\" title=\"地图事件\"></a>地图事件</h2><p>腾讯地图 API 具有事件接口，用户可以根据各自不同的需求添加不同的事件扩展。</p>\n<p>目前腾讯地图提供的事件类型有两类:</p>\n<ol>\n<li>用户事件（如“点击地图”鼠标事件）是从 DOM 传播到 腾讯 Maps API 中的。这些事件是独立的，并且与标准 DOM 事件不同。包括：<strong>单击事件(click)、双击事件(dblclick)、鼠标滑过事件(mouseover)、鼠标移动(mousemove)等</strong>；</li>\n<li>腾讯地图 API 特有的事件，MVC 状态更改通知反映了腾讯 Maps API 对象中的更改，并以 property_changed 惯例命名。如：缩放级别更改事件(zoom_changed)、内容更改事件(content_changed)等。</li>\n</ol>\n<h3 id=\"1、添加地图点击事件\"><a href=\"#1、添加地图点击事件\" class=\"headerlink\" title=\"1、添加地图点击事件\"></a>1、添加地图点击事件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var listener = qq.maps.event.addListener(</span><br><span class=\"line\">    map,</span><br><span class=\"line\">    &#x27;click&#x27;,</span><br><span class=\"line\">    function() &#123;</span><br><span class=\"line\">        alert(&#x27;您点击了地图。&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>使用 qq.maps.event.addListener() 可以将事件绑定到某一个对象上，返回一个监听者对象。方法<strong>第一个参数为被绑定事件的对象，第二个参数为事件类型，第三个参数为事件的处理方法</strong>。</p>\n<h3 id=\"2、事件中获取参数\"><a href=\"#2、事件中获取参数\" class=\"headerlink\" title=\"2、事件中获取参数\"></a>2、事件中获取参数</h3><p>addListener() 在事件被触发时会将 DOM 事件对象传入事件的处理方法，并在<strong>事件对象中添加鼠标当前位置的地理坐标属性 LatLng</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qq.maps.event.addListener(</span><br><span class=\"line\">    map,</span><br><span class=\"line\">    &#x27;click&#x27;,</span><br><span class=\"line\">    function(event) &#123;</span><br><span class=\"line\">        console.log(&#x27;经度&#x27;,event.latLng.lat,&#x27; 纬度:&#x27;,event.latLng.lng);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、移除事件\"><a href=\"#3、移除事件\" class=\"headerlink\" title=\"3、移除事件\"></a>3、移除事件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var listener = qq.maps.event.addListener(</span><br><span class=\"line\">    map,</span><br><span class=\"line\">    &#x27;click&#x27;,</span><br><span class=\"line\">    function() &#123;</span><br><span class=\"line\">        alert(&#x27;您点击了地图。&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">//移除 click 事件.</span><br><span class=\"line\">qq.maps.event.removeListener(listener);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"地图控件\"><a href=\"#地图控件\" class=\"headerlink\" title=\"地图控件\"></a>地图控件</h2><p>腾讯地图 API 控件是用户与地图交互的 UI 元素。API 提供多样的控件便于用户直接使用，并提供自定义控件 Control，最大限度满足用户需求。</p>\n<p>目前腾讯地图 API 中提供的控件有：</p>\n<ol>\n<li>导航控件</li>\n<li>比例尺控件</li>\n<li>自定义控件等</li>\n</ol>\n<h3 id=\"1、向地图添加控件\"><a href=\"#1、向地图添加控件\" class=\"headerlink\" title=\"1、向地图添加控件\"></a>1、向地图添加控件</h3><p>在地图上添加一个比例尺控件，并将控件放置在地图的左下角，可在代码中添加如下内容：</p>\n<p><strong>添加比例尺控件</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">map = new qq.maps.Map(</span><br><span class=\"line\">    document.getElementById(&quot;container&quot;),</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        center: new qq.maps.LatLng(39.914850, 116.403765),</span><br><span class=\"line\">        zoom: 13</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">var scaleControl = new qq.maps.ScaleControl(&#123;</span><br><span class=\"line\">    align: qq.maps.ALIGN.BOTTOM_LEFT,</span><br><span class=\"line\">    margin: qq.maps.Size(85, 15),</span><br><span class=\"line\">    map: map</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"地图覆盖物\"><a href=\"#地图覆盖物\" class=\"headerlink\" title=\"地图覆盖物\"></a>地图覆盖物</h2><p>覆盖物是指覆盖到地图上面的所有事物。覆盖物都有自己的地理属性，<strong>通过设置地理属性来控制覆盖物在地图中的显示位置</strong>。</p>\n<p>腾讯地图 API 中的主要包括的覆盖物有：</p>\n<ul>\n<li>标注</li>\n<li>折线</li>\n<li>多边形</li>\n<li>圆形</li>\n<li>信息窗口等</li>\n</ul>\n","categories":["webGL总结"],"tags":["webGL"]},{"title":"讲讲PWA","url":"/2022/10/24/%E8%AE%B2%E8%AE%B2PWA/","content":"<h2 id=\"一、背景\"><a href=\"#一、背景\" class=\"headerlink\" title=\"一、背景\"></a>一、背景</h2><p>大家都知道 Native app 体验确实很好，下载到手机上之后入口也方便。它也有一些缺点:</p>\n<ul>\n<li>开发成本高(ios 和安卓)</li>\n<li>软件上线需要审核</li>\n<li>版本更新需要将新版本上传到不同的应用商店</li>\n<li>想使用一个 app 就必须去下载才能使用，即使是偶尔需要使用一下下</li>\n</ul>\n<p>而 web 网页开发成本低，网站更新时上传最新的资源到服务器即可，用手机带的浏览器打开就可以使用。但是除了体验上比 Native app 还是差一些，还有一些明显的缺点</p>\n<ul>\n<li>手机桌面入口不够便捷，想要进入一个页面必须要记住它的 url 或者加入书签</li>\n<li>没网络就没响应，不具备离线能力</li>\n<li>不像 APP 一样能进行消息推送<br>那么什么是 PWA 呢？</li>\n</ul>\n<h2 id=\"二、What’s-PWA\"><a href=\"#二、What’s-PWA\" class=\"headerlink\" title=\"二、What’s PWA?\"></a>二、What’s PWA?</h2><p>PWA 全称 Progressive Web App，即渐进式 WEB 应用。</p>\n<p>一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能<br>解决了哪些问题？</p>\n<ul>\n<li>可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏</li>\n<li>实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能</li>\n<li>实现了消息推送<br>它解决了上述提到的问题，这些特性将使得 Web 应用渐进式接近原生 App。</li>\n</ul>\n<h2 id=\"三、PWA-的实现\"><a href=\"#三、PWA-的实现\" class=\"headerlink\" title=\"三、PWA 的实现\"></a>三、PWA 的实现</h2><h3 id=\"3-1-Manifest-实现添加至主屏幕\"><a href=\"#3-1-Manifest-实现添加至主屏幕\" class=\"headerlink\" title=\"3.1 Manifest 实现添加至主屏幕\"></a>3.1 Manifest 实现添加至主屏幕</h3><p><strong>index.html</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;title&gt;Minimal PWA&lt;/title&gt;</span><br><span class=\"line\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot; /&gt;</span><br><span class=\"line\">  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt;</span><br><span class=\"line\">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;main.css&quot;&gt;</span><br><span class=\"line\">  &lt;link rel=&quot;icon&quot; href=&quot;/e.png&quot; type=&quot;image/png&quot; /&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>manifest.json</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;Minimal PWA&quot;, // 必填 显示的插件名称</span><br><span class=\"line\">  &quot;short_name&quot;: &quot;PWA Demo&quot;, // 可选  在APP launcher和新的tab页显示，如果没有设置，则使用name</span><br><span class=\"line\">  &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //用于描述应用</span><br><span class=\"line\">  &quot;display&quot;: &quot;standalone&quot;, // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的</span><br><span class=\"line\">  &quot;start_url&quot;: &quot;/&quot;, // 应用启动时的url</span><br><span class=\"line\">  &quot;theme_color&quot;: &quot;#313131&quot;, // 桌面图标的背景色</span><br><span class=\"line\">  &quot;background_color&quot;: &quot;#313131&quot;, // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。</span><br><span class=\"line\">  &quot;icons&quot;: [ // 桌面图标，是一个数组</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &quot;src&quot;: &quot;icon/lowres.webp&quot;,</span><br><span class=\"line\">    &quot;sizes&quot;: &quot;48x48&quot;,  // 以空格分隔的图片尺寸</span><br><span class=\"line\">    &quot;type&quot;: &quot;image/webp&quot;  // 帮助userAgent快速排除不支持的类型</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;src&quot;: &quot;icon/lowres&quot;,</span><br><span class=\"line\">    &quot;sizes&quot;: &quot;48x48&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;src&quot;: &quot;icon/hd_hi.ico&quot;,</span><br><span class=\"line\">    &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;src&quot;: &quot;icon/hd_hi.svg&quot;,</span><br><span class=\"line\">    &quot;sizes&quot;: &quot;72x72&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Manifest 参考文档：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Manifest\">https://developer.mozilla.org/zh-CN/docs/Web/Manifest</a><br>可以打开网站 <a href=\"https://developers.google.cn/web/showcase/2015/chrome-dev-summit\">https://developers.google.cn/web/showcase/2015/chrome-dev-summit</a> 查看添加至主屏幕的动图。</p>\n<p>如果用的是安卓手机，可以下载 chrome 浏览器自己操作看看</p>\n</blockquote>\n<h3 id=\"3-2-service-worker-实现离线缓存\"><a href=\"#3-2-service-worker-实现离线缓存\" class=\"headerlink\" title=\"3.2 service worker 实现离线缓存\"></a>3.2 service worker 实现离线缓存</h3><h4 id=\"3-2-1-什么是-service-worker\"><a href=\"#3-2-1-什么是-service-worker\" class=\"headerlink\" title=\"3.2.1 什么是 service worker\"></a>3.2.1 什么是 service worker</h4><p>Service Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000012353478?w=747&h=240\" alt=\"image\"></p>\n<p>Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的 HTTP 请求，从而完全控制你的网站。</p>\n<p><strong>最主要的特点</strong></p>\n<ul>\n<li>在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。</li>\n<li>网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost)</li>\n<li>运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求</li>\n<li>单独的作用域范围，单独的运行环境和执行线程</li>\n<li>不能操作页面 DOM。但可以通过事件机制来处理</li>\n<li>事件驱动型服务线程<blockquote>\n<p>为什么要求网站必须是 HTTPS 的，大概是因为 service worker 权限太大能拦截所有页面的请求吧，如果 http 的网站安装 service worker 很容易被攻击</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>浏览器支持情况</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000012353479?w=2494&h=588\" alt=\"image\"></p>\n<blockquote>\n<p>浏览器支持情况详见： <a href=\"https://caniuse.com/#feat=serviceworkers\">https://caniuse.com/#feat=serviceworkers</a></p>\n</blockquote>\n<p><strong>生命周期</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000012353480?w=726&h=629\" alt=\"image\"></p>\n<p>当用户首次导航至 URL 时，服务器会返回响应的网页。</p>\n<ul>\n<li>第 1 步:当你调用 register() 函数时， Service Worker 开始下载。</li>\n<li>第 2 步:在注册过程中，浏览器会下载、解析并执行 Service Worker ()。如果在此步骤中出现任何错误，register() 返回的 promise 都会执行 reject 操作，并且 Service Worker 会被废弃。</li>\n<li>第 3 步:一旦 Service Worker 成功执行了，install 事件就会激活</li>\n<li>第 4 步:安装完成，Service Worker 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，Service Worker 便已准备就绪，随时可以使用了！</li>\n</ul>\n<blockquote>\n<p>chrome:&#x2F;&#x2F;serviceworker-internals 来了解当前浏览器中所有已安装 Service Worker 的详细情况</p>\n</blockquote>\n<h4 id=\"3-2-2-HTTP-缓存与-service-worker-缓存\"><a href=\"#3-2-2-HTTP-缓存与-service-worker-缓存\" class=\"headerlink\" title=\"3.2.2 HTTP 缓存与 service worker 缓存\"></a>3.2.2 HTTP 缓存与 service worker 缓存</h4><p><strong>HTTP 缓存</strong><br>Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。<br>使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期。</p>\n<p><strong>service worker 缓存</strong></p>\n<p>Service Workers 的强大在于它们拦截 HTTP 请求的能力<br>进入任何传入的 HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！</p>\n<h4 id=\"3-2-3-实现离线缓存\"><a href=\"#3-2-3-实现离线缓存\" class=\"headerlink\" title=\"3.2.3 实现离线缓存\"></a>3.2.3 实现离线缓存</h4><p><strong>index.html</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Hello Caching World!&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;!-- Image --&gt;</span><br><span class=\"line\">    &lt;img src=&quot;/images/hello.png&quot; /&gt;</span><br><span class=\"line\">    &lt;!-- JavaScript --&gt;</span><br><span class=\"line\">    &lt;script async src=&quot;/js/script.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">      // 注册 service worker</span><br><span class=\"line\">      if (&#x27;serviceWorker&#x27; in navigator) &#123;</span><br><span class=\"line\">        navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;, &#123;scope: &#x27;/&#x27;&#125;).then(function (registration) &#123;</span><br><span class=\"line\">          // 注册成功</span><br><span class=\"line\">          console.log(&#x27;ServiceWorker registration successful with scope: &#x27;, registration.scope);</span><br><span class=\"line\">        &#125;).catch(function (err) &#123;</span><br><span class=\"line\">          // 注册失败 :(</span><br><span class=\"line\">          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注：Service Worker 的注册路径决定了其 scope 默认作用页面的范围。<br>如果 service-worker.js 是在 &#x2F;sw&#x2F; 页面路径下，这使得该 Service Worker 默认只会收到 页面&#x2F;sw&#x2F; 路径下的 fetch 事件。<br>如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。<br>如果希望改变它的作用域，可在第二个参数设置 scope 范围。示例中将其改为了根目录，即对整个站点生效。</p>\n</blockquote>\n<p><strong>service-worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var cacheName = &#x27;helloWorld&#x27;;     // 缓存的名称</span><br><span class=\"line\">// install 事件，它发生在浏览器安装并注册 Service Worker 时</span><br><span class=\"line\">self.addEventListener(&#x27;install&#x27;, event =&gt; &#123;</span><br><span class=\"line\">/* event.waitUtil 用于在安装成功之前执行一些预装逻辑</span><br><span class=\"line\"> 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率</span><br><span class=\"line\"> 安装成功后 ServiceWorker 状态会从 installing 变为 installed */</span><br><span class=\"line\">  event.waitUntil(</span><br><span class=\"line\">    caches.open(cacheName)</span><br><span class=\"line\">    .then(cache =&gt; cache.addAll([    // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。</span><br><span class=\"line\">      &#x27;/js/script.js&#x27;,</span><br><span class=\"line\">      &#x27;/images/hello.png&#x27;</span><br><span class=\"line\">    ]))</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。</span><br><span class=\"line\">如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。</span><br><span class=\"line\">*/</span><br><span class=\"line\">self.addEventListener(&#x27;fetch&#x27;, function (event) &#123;</span><br><span class=\"line\">  event.respondWith(</span><br><span class=\"line\">    caches.match(event.request)</span><br><span class=\"line\">    .then(function (response) &#123;</span><br><span class=\"line\">      if (response) &#123;</span><br><span class=\"line\">        return response;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      var requestToCache = event.request.clone();  //</span><br><span class=\"line\">      return fetch(requestToCache).then(</span><br><span class=\"line\">        function (response) &#123;</span><br><span class=\"line\">          if (!response || response.status !== 200) &#123;</span><br><span class=\"line\">            return response;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          var responseToCache = response.clone();</span><br><span class=\"line\">          caches.open(cacheName)</span><br><span class=\"line\">            .then(function (cache) &#123;</span><br><span class=\"line\">              cache.put(requestToCache, responseToCache);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          return response;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注：为什么用 request.clone()和 response.clone()<br>需要这么做是因为 request 和 response 是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 HTTP 请求还要再消耗一次，所以我们需要在此时克隆请求<br>Clone the request—a request is a stream and can only be consumed once.</p>\n</blockquote>\n<h3 id=\"3-2-4-调试相关\"><a href=\"#3-2-4-调试相关\" class=\"headerlink\" title=\"3.2.4 调试相关\"></a>3.2.4 调试相关</h3><p>chrome 浏览器打开 <a href=\"https://googlechrome.github.io/samples/service-worker/basic/index.html\">https://googlechrome.github.io/samples/service-worker/basic/index.html</a> ，这是一个实现了 service worker 离线缓存功能的网站，打开调试工具</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000012353481?w=1438&h=430\" alt=\"image\"></p>\n<p>介绍一个图中的 1.和 2.</p>\n<ol>\n<li>勾选可以模拟网站离线情况，勾选后 network 会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示</li>\n<li>当前 service worker 的 scope。它能够拦截 h<a href=\"https://googlechrome.github.io/samples/service-worker/basic/index.html%E4%B8%8B%E7%9A%84%E8%AF%B7%E6%B1%82\">ttps:&#x2F;&#x2F;googlechrome.github.i…</a>，同样也能够拦截<a href=\"https://googlechrome.github.io/samples/service-worker/basic/\">https://googlechrome.github.i...</a>下的请求</li>\n</ol>\n<blockquote>\n<p>调试面板具体代表的什么参看 <a href=\"https://x5.tencent.com/tbs/guide/serviceworker.html\">https://x5.tencent.com/tbs/guide/serviceworker.html</a> 的第三部分</p>\n</blockquote>\n<h3 id=\"3-3-service-worker-实现消息推送\"><a href=\"#3-3-service-worker-实现消息推送\" class=\"headerlink\" title=\"3.3 service worker 实现消息推送\"></a>3.3 service worker 实现消息推送</h3><p><img src=\"https://segmentfault.com/img/remote/1460000012353482?w=677&h=368\" alt=\"image\"></p>\n<ul>\n<li>步骤一、提示用户并获得他们的订阅详细信息</li>\n<li>步骤二、将这些详细信息保存在服务器上</li>\n<li>步骤三、在需要时发送任何消息<blockquote>\n<p>不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging<GCM> 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>步骤一和步骤二</strong><br><strong>index.html</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Progressive Times&lt;/title&gt;</span><br><span class=\"line\">    &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">      var endpoint;</span><br><span class=\"line\">      var key;</span><br><span class=\"line\">      var authSecret;</span><br><span class=\"line\">      var vapidPublicKey = &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;;</span><br><span class=\"line\">      // 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用</span><br><span class=\"line\">      function urlBase64ToUint8Array(base64String) &#123;</span><br><span class=\"line\">        const padding = &#x27;=&#x27;.repeat((4 - base64String.length % 4) % 4);</span><br><span class=\"line\">        const base64 = (base64String + padding)</span><br><span class=\"line\">          .replace(/\\-/g, &#x27;+&#x27;)</span><br><span class=\"line\">          .replace(/_/g, &#x27;/&#x27;);</span><br><span class=\"line\">        const rawData = window.atob(base64);</span><br><span class=\"line\">        const outputArray = new Uint8Array(rawData.length);</span><br><span class=\"line\">        for (let i = 0; i &lt; rawData.length; ++i) &#123;</span><br><span class=\"line\">          outputArray[i] = rawData.charCodeAt(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return outputArray;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (&#x27;serviceWorker&#x27; in navigator) &#123;</span><br><span class=\"line\">        navigator.serviceWorker.register(&#x27;sw.js&#x27;).then(function (registration) &#123;</span><br><span class=\"line\">          return registration.pushManager.getSubscription()</span><br><span class=\"line\">            .then(function (subscription) &#123;</span><br><span class=\"line\">              if (subscription) &#123;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              return registration.pushManager.subscribe(&#123;</span><br><span class=\"line\">                  userVisibleOnly: true,</span><br><span class=\"line\">                  applicationServerKey: urlBase64ToUint8Array(vapidPublicKey)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .then(function (subscription) &#123;</span><br><span class=\"line\">                  var rawKey = subscription.getKey ? subscription.getKey(&#x27;p256dh&#x27;) : &#x27;&#x27;;</span><br><span class=\"line\">                  key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : &#x27;&#x27;;</span><br><span class=\"line\">                  var rawAuthSecret = subscription.getKey ? subscription.getKey(&#x27;auth&#x27;) : &#x27;&#x27;;</span><br><span class=\"line\">                  authSecret = rawAuthSecret ?</span><br><span class=\"line\">                    btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : &#x27;&#x27;;</span><br><span class=\"line\">                  endpoint = subscription.endpoint;</span><br><span class=\"line\">                  return fetch(&#x27;./register&#x27;, &#123;</span><br><span class=\"line\">                    method: &#x27;post&#x27;,</span><br><span class=\"line\">                    headers: new Headers(&#123;</span><br><span class=\"line\">                      &#x27;content-type&#x27;: &#x27;application/json&#x27;</span><br><span class=\"line\">                    &#125;),</span><br><span class=\"line\">                    body: JSON.stringify(&#123;</span><br><span class=\"line\">                      endpoint: subscription.endpoint,</span><br><span class=\"line\">                      key: key,</span><br><span class=\"line\">                      authSecret: authSecret,</span><br><span class=\"line\">                    &#125;),</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;).catch(function (err) &#123;</span><br><span class=\"line\">          // 注册失败 :(</span><br><span class=\"line\">          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>步骤三 服务器发送消息给 service worker</strong></p>\n<p>app.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const webpush = require(&#x27;web-push&#x27;);</span><br><span class=\"line\">const express = require(&#x27;express&#x27;);</span><br><span class=\"line\">var bodyParser = require(&#x27;body-parser&#x27;);</span><br><span class=\"line\">const app = express();</span><br><span class=\"line\">webpush.setVapidDetails(</span><br><span class=\"line\">  &#x27;mailto:contact@deanhume.com&#x27;,</span><br><span class=\"line\">  &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;,</span><br><span class=\"line\">  &#x27;p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0&#x27;</span><br><span class=\"line\">);</span><br><span class=\"line\">app.post(&#x27;/register&#x27;, function (req, res) &#123;</span><br><span class=\"line\">  var endpoint = req.body.endpoint;</span><br><span class=\"line\">  saveRegistrationDetails(endpoint, key, authSecret);</span><br><span class=\"line\">  const pushSubscription = &#123;</span><br><span class=\"line\">    endpoint: req.body.endpoint,</span><br><span class=\"line\">    keys: &#123;</span><br><span class=\"line\">      auth: req.body.authSecret,</span><br><span class=\"line\">      p256dh: req.body.key</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  var body = &#x27;Thank you for registering&#x27;;</span><br><span class=\"line\">  var iconUrl = &#x27;https://example.com/images/homescreen.png&#x27;;</span><br><span class=\"line\">  // 发送 Web 推送消息</span><br><span class=\"line\">  webpush.sendNotification(pushSubscription,</span><br><span class=\"line\">      JSON.stringify(&#123;</span><br><span class=\"line\">        msg: body,</span><br><span class=\"line\">        url: &#x27;http://localhost:3111/&#x27;,</span><br><span class=\"line\">        icon: iconUrl</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    .then(result =&gt; res.sendStatus(201))</span><br><span class=\"line\">    .catch(err =&gt; &#123;</span><br><span class=\"line\">      console.log(err);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.listen(3111, function () &#123;</span><br><span class=\"line\">  console.log(&#x27;Web push app listening on port 3111!&#x27;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>service worker 监听 push 事件，将通知详情推送给用户</strong></p>\n<p>service-worker.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#x27;push&#x27;, function (event) &#123;</span><br><span class=\"line\"> // 检查服务端是否发来了任何有效载荷数据</span><br><span class=\"line\">  var payload = event.data ? JSON.parse(event.data.text()) : &#x27;no payload&#x27;;</span><br><span class=\"line\">  var title = &#x27;Progressive Times&#x27;;</span><br><span class=\"line\">  event.waitUntil(</span><br><span class=\"line\">    // 使用提供的信息来显示 Web 推送通知</span><br><span class=\"line\">    self.registration.showNotification(title, &#123;</span><br><span class=\"line\">      body: payload.msg,</span><br><span class=\"line\">      url: payload.url,</span><br><span class=\"line\">      icon: payload.icon</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>扩展知识：<a href=\"https://lzw.me/a/pwa-service-worker.html#3.3\">service worker 的更新</a></p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"PWA-的优势\"><a href=\"#PWA-的优势\" class=\"headerlink\" title=\"PWA 的优势\"></a>PWA 的优势</h3><ul>\n<li>可以将 app 的快捷方式放置到桌面上，全屏运行，与原生 app 无异</li>\n<li>能够在各种网络环境下使用，包括网络差和断网条件下，不会显示 undefined</li>\n<li>推送消息的能力</li>\n<li>其本质是一个网页，没有原生 app 的各种启动条件，快速响应用户指令</li>\n</ul>\n<h3 id=\"PWA-存在的问题\"><a href=\"#PWA-存在的问题\" class=\"headerlink\" title=\"PWA 存在的问题\"></a>PWA 存在的问题</h3><ul>\n<li>支持率不高:现在 ios 手机端不支持 pwa，IE 也暂时不支持</li>\n<li>Chrome 在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低</li>\n<li>各大厂商还未明确支持 pwa</li>\n<li>依赖的 GCM 服务在国内无法使用</li>\n<li>微信小程序的竞争</li>\n</ul>\n<p>尽管有上述的一些缺点，PWA 技术仍然有很多可以使用的点。</p>\n<ul>\n<li>service worker 技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。</li>\n<li>service worker 实现消息推送，使用浏览器推送功能，吸引用户</li>\n<li>渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验。</li>\n</ul>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"试玩NodeJS多进程","url":"/2022/10/24/%E8%AF%95%E7%8E%A9NodeJS%E5%A4%9A%E8%BF%9B%E7%A8%8B/","content":"<p>NodeJS 的 JavaScript 运行在单个进程的单个线程上，一个 JavaScript 执行进程只能利用一个 CPU 核心，而如今大多数 CPU 均为多核 CPU，为了充分利用 CPU 资源，Node 提供了 child_process 和 cluster 模块来实现多进程以及进程管理。本文将根据 Master-Worker 模式，搭建一个简单的服务器集群来充分利用多核 CPU 资源，探索进程间通信、负载均衡、进程重启等知识。</p>\n<p>下图是 Master-Worker 模式，进程分为 master 进程和 worker 进程，master 进程负责调度或管理 worker 进程，worker 进程则负责具体的业务处理。在服务器层面，worker 可以是一个服务进程，负责处理来自客户端的请求，多个 worker 便相当于多个服务器，从而构成一个服务器集群。master 则是负责创建 worker，将来自客户端的请求分配到各个服务器上去处理，并监控 worker 的运行状态以及进行管理等操作。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162337266?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>本文将从 child_process 模块开始，熟悉该模块的基本用法。后面再继续进入 cluster 模块的学习。本文所用的代码示例可以从该仓库中找到–【<a href=\"https://github.com/hongchh/nodejs-demo/tree/master/multi-process\">multi-process</a>】。</p>\n<h2 id=\"一、child-process\"><a href=\"#一、child-process\" class=\"headerlink\" title=\"一、child_process\"></a>一、child_process</h2><h3 id=\"1-1、Hello-world\"><a href=\"#1-1、Hello-world\" class=\"headerlink\" title=\"1.1、Hello world\"></a>1.1、Hello world</h3><p>child_process 模块提供了 spawn()、exec()、execFile()、fork()这 4 个方法用于创建子进程，本文将使用 fork()方法来创建子进程，fork()方法只需指定要执行的 JavaScript 文件模块，即可创建 Node 的子进程。下面是简单的 HelloWorld 示例，master 进程根据 CPU 数量创建出相应数量的 worker 进程，worker 进程中利用进程 ID 来标记自己。</p>\n<p>以下是 master 进程代码，文件名为 master.js。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class=\"line\">const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">  childProcess.fork(&#x27;./worker.js&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;Master: Hello world.&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>以下是 worker 进程的代码，文件名为 worker.js。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;Worker-&#x27; + process.pid + &#x27;: Hello world.&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>node master.js</code>，得到如下结果，master 创建 4 个 worker 后输出 HelloWorld 信息，每个 worker 也分别输出自己的 HelloWorld 信息。</p>\n<p><img src=\"https://img-blog.csdn.net/201804111624180?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"1-2、父子进程间的通信\"><a href=\"#1-2、父子进程间的通信\" class=\"headerlink\" title=\"1.2、父子进程间的通信\"></a>1.2、父子进程间的通信</h3><p>创建 worker 之后，接下来实现 master 和 worker 之间的通信。Node 父子进程之间可以通过<code>on(&#39;message&#39;)</code>和<code>send()</code>来实现通信，<code>on(&#39;message&#39;)</code>其实是监听 message 事件，当该进程收到其他进程发送的消息时，便会触发 message 事件。<code>send()</code>方法则是用于向其他进程发送信息。master 进程中调用<code>child_process</code>的<code>fork()</code>方法后会得到一个子进程的实例，通过这个实例可以监听来自子进程的消息或者向子进程发送消息。worker 进程则通过 process 对象接口监听来自父进程的消息或者向父进程发送消息。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162446285?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>下面是简单示例，master 创建 worker 之后，向 worker 发送信息，worker 在收到 master 的信息后将信息输出，并回复 master。master 收到回复后输出信息。</p>\n<p><strong>master.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class=\"line\">const worker = childProcess.fork(&#x27;./worker.js&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">worker.send(&#x27;Hello world.&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">worker.on(&#x27;message&#x27;, (msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;[Master] Received message from worker: &#x27; + msg)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">process.on(&#x27;message&#x27;, (msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;[Worker] Received message from master: &#x27; + msg)</span><br><span class=\"line\">  process.send(&#x27;Hi master.&#x27;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>node master.js</code>，结果如下，master 和 worker 可以正常通信。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162506991?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"1-3、Master-分发请求给-Worker-处理\"><a href=\"#1-3、Master-分发请求给-Worker-处理\" class=\"headerlink\" title=\"1.3、Master 分发请求给 Worker 处理\"></a>1.3、Master 分发请求给 Worker 处理</h3><p>进程通信时使用到的<code>send()</code>方法，除了发送普通的对象之外，还可以用于发送句柄。句柄是一种引用，可以用来标识资源，例如通过句柄可以标识一个 socket 对象、一个 server 对象等。利用句柄传递，可以实现请求的分发。master 进程创建一个 TCP 服务器监听特定端口，收到客户端的请求后，会得到一个 socket 对象，通过这个 socket 对象可以跟客户端进行通信从而处理客户端的请求。master 进程可以通过句柄传递将该 socket 对象发送给 worker 进程，让 worker 进程去处理请求。该模式的结构图如下，在 master 上还可以通过特定的算法实现负载均衡，将客户端的请求均衡地分发给 worker 去处理。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162530412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>下面是一个简单示例。master 创建 TCP 服务器并监听 8080 端口，收到请求后将请求分发给 worker 处理。worker 收到 master 发来的 socket 以后，通过 socket 对客户端进行响应。为方便看到请求的处理情况，worker 给出的响应内容会说明该请求是被哪个 worker 处理。</p>\n<p><strong>master.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class=\"line\">const net = require(&#x27;net&#x27;)</span><br><span class=\"line\">const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建工作进程</span><br><span class=\"line\">let workers = []</span><br><span class=\"line\">let cur = 0</span><br><span class=\"line\">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">  workers.push(childProcess.fork(&#x27;./worker.js&#x27;))</span><br><span class=\"line\">  console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建TCP服务器</span><br><span class=\"line\">const server = net.createServer()</span><br><span class=\"line\"></span><br><span class=\"line\">// 服务器收到请求后分发给工作进程去处理</span><br><span class=\"line\">// 通过轮转方式实现工作进程的负载均衡</span><br><span class=\"line\">server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">  workers[cur].send(&#x27;socket&#x27;, socket)</span><br><span class=\"line\">  cur = Number.parseInt((cur + 1) % cpuNum)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;TCP server: 127.0.0.1:8080&#x27;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">process.on(&#x27;message&#x27;, (msg, socket) =&gt; &#123;</span><br><span class=\"line\">  if (msg === &#x27;socket&#x27; &amp;&amp; socket) &#123;</span><br><span class=\"line\">    // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class=\"line\">    &#125;, 10)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>为了访问 TCP 服务器进行实验，这里需要写一个简单的 TCP 客户端，代码如下。该客户端会创建 10 个 TCP 连接，得到服务器响应之后将响应的内容进行输出。</p>\n<p><strong>tcp_client.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const net = require(&#x27;net&#x27;)</span><br><span class=\"line\">const maxConnectCount = 10</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i = 0; i &lt; maxConnectCount; ++i) &#123;</span><br><span class=\"line\">  net.createConnection(&#123;</span><br><span class=\"line\">    port: 8080,</span><br><span class=\"line\">    host: &#x27;127.0.0.1&#x27;</span><br><span class=\"line\">  &#125;).on(&#x27;data&#x27;, (data) =&gt; &#123;</span><br><span class=\"line\">    console.log(data.toString())</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先执行<code>node master.js</code>启动服务器，然后执行 node tcp_client.js 启动客户端。得到的结果如下，10 个请求被分发到不同服务器上进行处理，并且可以看到 master 中的轮转分发请求起到了作用，实现了简单的负载均衡。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162556605?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"1-4、Worker-监听同一个端口\"><a href=\"#1-4、Worker-监听同一个端口\" class=\"headerlink\" title=\"1.4、Worker 监听同一个端口\"></a>1.4、Worker 监听同一个端口</h3><p>前面说过，<code>send()</code>方法可以传递句柄，通过传递句柄，我们除了发送 socket 对象之外，还可以直接发送一个 server 对象。我们可以在 master 进程中创建一个 TCP 服务器，将服务器对象直接发送给 worker 进程，让 worker 去监听端口并处理请求。这样的话，master 和 worker 进程都会监听相同端口，当客户端发起请求时，请求可能被 master 接收，也可能被 worker 接收。而 master 不负责处理业务，如果请求被 master 接收到，由于 master 上没有处理业务的逻辑，请求将无法得到处理。因此可以实现为如下图所示的模式，master 将 TCP 服务器发送给 worker 使得所有 worker 监听同一个端口以后，master 关闭对端口的监听。这样便只有 worker 在监听同一端口，请求将会都被 worker 进行处理，与 master 无关。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162619227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>这种模式下，多个进程监听相同端口，当网络请求到来时，会进行抢占式调度，只有一个进程会抢到连接然后进行服务。因此，可以确保每个请求都会被特定的 worker 处理，而不是一个请求同时被多个 worker 处理。但由于是抢占式的调度，不能够保证每个 worker 的负载均衡。可能由于处理不同业务时 CPU 和 IO 繁忙度的不同导致进程抢到的请求数量不同，形成负载不均衡的情况。</p>\n<p>下面是简单示例。</p>\n<p><strong>master.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class=\"line\">const net = require(&#x27;net&#x27;)</span><br><span class=\"line\">const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建工作进程</span><br><span class=\"line\">let workers = []</span><br><span class=\"line\">let cur = 0</span><br><span class=\"line\">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">  workers.push(childProcess.fork(&#x27;./worker.js&#x27;))</span><br><span class=\"line\">  console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建TCP服务器</span><br><span class=\"line\">const server = net.createServer()</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;TCP server: 127.0.0.1:8080&#x27;)</span><br><span class=\"line\">  // 监听端口后将服务器句柄发送给工作进程</span><br><span class=\"line\">  for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">    workers[i].send(&#x27;server&#x27;, server)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 关闭主线程服务器的端口监听</span><br><span class=\"line\">  server.close()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">process.on(&#x27;message&#x27;, (msg, server) =&gt; &#123;</span><br><span class=\"line\">  if (msg === &#x27;server&#x27; &amp;&amp; server) &#123;</span><br><span class=\"line\">    server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">      // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class=\"line\">      &#125;, 10)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>继续使用之前的<code>tcp_client</code>来进行实验，先执行<code>node master.js</code>启动服务器，然后执行<code>node tcp_client.js</code>启动客户端。得到结果如下，请求可以被不同的 worker 进程处理，但由于 worker 进程是抢占式地为请求进行服务，所以不一定能实现每个 worker 的负载均衡。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162643242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"1-5、进程重启\"><a href=\"#1-5、进程重启\" class=\"headerlink\" title=\"1.5、进程重启\"></a>1.5、进程重启</h3><p>worker 进程可能因为某些异常情况而退出，为了提高集群的稳定性，master 进程需要监听子进程的存活状态，当子进程退出之后，master 进程要及时重启新的子进程。在 Node 中，子进程退出时，会在父进程中触发 exit 事件。父进程只需通过监听该事件便可知道子进程是否退出，并在退出的时候做出相应的处理。下面是在之前的监听同一端口模式下，增加了进程重启功能。进程重启时，master 进程需要重新传递 server 对象给新的 worker 进程，因此不能关闭 master 进程上的 server，否则在进程重启时 server 被关闭，得到的句柄将为空，无法正常传递。master 进程的 server 不关闭，会导致 master 进程也监听端口，会有部分请求被 master 进程接收，为了让着部分请求能够得到处理，可以在 master 进程添加处理业务的代码。由于 master 也参与了业务处理，业务处理进程的数量增加 1 个，所以 worker 进程可以少创建 1 个。这也就是下面简单示例中的做法。</p>\n<p>这种实现方式使得 master 既进行进程管理又参与了业务处理，如果要保持 master 只负责进程管理而不涉及业务处理，可以采取另外一种实现方式：master 接收到请求后，按照前面 1.3 节的做法将请求转发给 worker 进行处理，这样 master 将继续只负责对 worker 进程的管理。</p>\n<p><strong>master.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const childProcess = require(&#x27;child_process&#x27;)</span><br><span class=\"line\">const net = require(&#x27;net&#x27;)</span><br><span class=\"line\">const cpuNum = require(&#x27;os&#x27;).cpus().length - 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建工作进程</span><br><span class=\"line\">let workers = []</span><br><span class=\"line\">let cur = 0</span><br><span class=\"line\">for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">  workers.push(childProcess.fork(&#x27;./worker.js&#x27;))</span><br><span class=\"line\">  console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建TCP服务器</span><br><span class=\"line\">const server = net.createServer()</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于master进程也会监听端口。因此需要对请求做出处理</span><br><span class=\"line\">server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">  // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    socket.end(&#x27;Request handled by master&#x27;)</span><br><span class=\"line\">  &#125;, 10)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;TCP server: 127.0.0.1:8080&#x27;)</span><br><span class=\"line\">  // 监听端口后将服务器句柄发送给工作进程</span><br><span class=\"line\">  for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">    workers[i].send(&#x27;server&#x27;, server)</span><br><span class=\"line\">    // 工作进程退出后重启</span><br><span class=\"line\">    workers[i].on(&#x27;exit&#x27;, ((i) =&gt; &#123;</span><br><span class=\"line\">      return () =&gt; &#123;</span><br><span class=\"line\">        console.log(&#x27;Worker-&#x27; + workers[i].pid + &#x27; exited&#x27;)</span><br><span class=\"line\">        workers[i] = childProcess.fork(&#x27;./worker.js&#x27;)</span><br><span class=\"line\">        console.log(&#x27;Create worker-&#x27; + workers[i].pid)</span><br><span class=\"line\">        workers[i].send(&#x27;server&#x27;, server)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(i))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 关闭主线程服务器的端口监听</span><br><span class=\"line\">  // server.close()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">process.on(&#x27;message&#x27;, (msg, server) =&gt; &#123;</span><br><span class=\"line\">  if (msg === &#x27;server&#x27; &amp;&amp; server) &#123;</span><br><span class=\"line\">    server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">      // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class=\"line\">      &#125;, 10)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>node master.js</code>启动服务器后，可以通过任务管理器直接杀掉进程来模拟进程异常退出。可以看到 worker 进程退出后，master 能够发现并及时创建新的 worker 进程。任务管理器中的 Node 进程数量恢复原样。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162706612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdn.net/20180411162725201?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>执行<code>node tcp_client.js</code>启动客户端，客户端发出的连接请求被处理的情况如下，同样地，由于监听同一端口，进程之间采取抢占式服务，不一定保障负载均衡。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162742587?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h3 id=\"1-6、处理-HTTP-服务\"><a href=\"#1-6、处理-HTTP-服务\" class=\"headerlink\" title=\"1.6、处理 HTTP 服务\"></a>1.6、处理 HTTP 服务</h3><p>前面的示例所使用的是 TCP 服务器，如果要处理 HTTP 请求，需要使用 HTTP 服务器。而 HTTP 其实是基于 TCP 的，发送 HTTP 请求的时候同样也会发起 TCP 连接。只需要对前面的 TCP 服务器进行一点小改动便可以支持 HTTP 了。在进程中新增 HTTP 服务器，当 TCP 服务器收到请求时，把请求提交给 HTTP 服务器处理即可。下面是 worker 进程的改动示例。</p>\n<p><strong>worker.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const http = require(&#x27;http&#x27;)</span><br><span class=\"line\">const httpServer = http.createServer((req, res) =&gt; &#123;</span><br><span class=\"line\">  // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;)</span><br><span class=\"line\">    res.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class=\"line\">  &#125;, 10)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">process.on(&#x27;message&#x27;, (msg, server) =&gt; &#123;</span><br><span class=\"line\">  if (msg === &#x27;server&#x27; &amp;&amp; server) &#123;</span><br><span class=\"line\">    server.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">      // 提交给HTTP服务器处理</span><br><span class=\"line\">      httpServer.emit(&#x27;connection&#x27;, socket)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdn.net/20180411162802792?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h2 id=\"二、cluster\"><a href=\"#二、cluster\" class=\"headerlink\" title=\"二、cluster\"></a>二、cluster</h2><p>前面简单描述了使用 child_process 实现单机 Node 集群的做法，需要处理挺多的细节。Node 提供了 cluster 模块，该模块提供了更完善的 API，除了能够实现多进程充分利用 CPU 资源以外，还能够帮助我们更好地进行进程管理和处理进程的健壮性问题。下面是简单示例，if 条件语句判断当前进程是 master 还是 worker，master 进程会执行 if 语句块包含的代码，而 worker 进程则执行 else 语句块包含的代码。master 进程中，利用 cluster 模块创建了与 CPU 数量相应的 worker 进程，并通过监听 cluster 的 online 事件来判断 worker 的创建成功。在 worker 进程退出后，会触发 master 进程中 cluster 模块上的 exit 事件，通过监听该事件可以了解 worker 进程的退出情况并及时 fork 新的 worker。最后，worker 进程中只需创建服务器监听端口，对客户端请求做出处理即可。（这里设置相同端口 8080 之后，所有 worker 都将监听同一个端口）</p>\n<p><strong>server.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const cluster = require(&#x27;cluster&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">if (cluster.isMaster) &#123;</span><br><span class=\"line\">  const cpuNum = require(&#x27;os&#x27;).cpus().length</span><br><span class=\"line\"></span><br><span class=\"line\">  for (let i = 0; i &lt; cpuNum; ++i) &#123;</span><br><span class=\"line\">    cluster.fork()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 创建进程完成后输出提示信息</span><br><span class=\"line\">  cluster.on(&#x27;online&#x27;, (worker) =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;Create worker-&#x27; + worker.process.pid)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  // 子进程退出后重启</span><br><span class=\"line\">  cluster.on(&#x27;exit&#x27;, (worker, code, signal) =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;[Master] worker &#x27; + worker.process.pid + &#x27; died with code: &#x27; + code + &#x27;, and signal: &#x27; + signal)</span><br><span class=\"line\">    cluster.fork()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  const net = require(&#x27;net&#x27;)</span><br><span class=\"line\">  net.createServer().on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class=\"line\">    // 利用setTimeout模拟处理请求时的操作耗时</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      socket.end(&#x27;Request handled by worker-&#x27; + process.pid)</span><br><span class=\"line\">    &#125;, 10)</span><br><span class=\"line\">  &#125;).listen(8080)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>node server.js</code>启动服务器，继续按照之前的做法，利用任务管理器杀死进程，可以看到在进程被杀后 master 能够及时启动新的 worker。</p>\n<p><img src=\"https://img-blog.csdn.net/2018041116282181?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<p>继续运行 tcp_client，可以看到服务器能够正常处理请求。</p>\n<p><img src=\"https://img-blog.csdn.net/20180411162838577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbmdjaGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"image\"></p>\n<h2 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h2><p>利用<code>child_process</code>和<code>cluster</code>模块能够很好地实现<code>Master-Worker</code>模式多进程架构，实现单机服务器集群，充分利用了多核 CPU 资源。通过进程通信能够实现进程管理、重启以及负载均衡，从而提高集群的稳定性和健壮性。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"详解JavaScript中的Event Loop（事件循环）机制","url":"/2022/10/24/%E8%AF%A6%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84Event-Loop%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89%E6%9C%BA%E5%88%B6/","content":"<p><img src=\"https://pic4.zhimg.com/v2-0b35a3df0b2e2712839ce551062e6d7f_1440w.jpg?source=172ae18b\" alt=\"image\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我们都知道，javascript 从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。</p>\n<p>单线程意味着，javascript 代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p>\n<p>而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 I&#x2F;O 事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p>\n<p>单线程是必要的，也是 javascript 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 dom 操作。试想一下 如果 javascript 是多线程的，那么当两个线程同时对 dom 进行一项操作，例如一个向其添加事件，而另一个删除了这个 dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p>\n<p>当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了 javascript 的效率，因此开发出了 web worker 技术。这项技术号称让 javascript 成为一门多线程语言。</p>\n<p>然而，使用 web worker 技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行 I&#x2F;O 操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了 javascript 语言的单线程本质。</p>\n<p>可以预见，未来的 javascript 也会一直是一门单线程的语言。</p>\n<p>话说回来，前面提到 javascript 的另一个特点是“非阻塞”，那么 javascript 引擎到底是如何实现的这一点呢？答案就是今天这篇文章的主角——event loop（事件循环）。</p>\n<p>注：虽然 nodejs 中也存在与传统浏览器环境下的相似的事件循环。然而两者间却有着诸多不同，故把两者分开，单独解释。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"浏览器环境下-js-引擎的事件循环机制\"><a href=\"#浏览器环境下-js-引擎的事件循环机制\" class=\"headerlink\" title=\"浏览器环境下 js 引擎的事件循环机制\"></a>浏览器环境下 js 引擎的事件循环机制</h3><h4 id=\"1-执行栈与事件队列\"><a href=\"#1-执行栈与事件队列\" class=\"headerlink\" title=\"1.执行栈与事件队列\"></a>1.执行栈与事件队列</h4><p>当 javascript 代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p>\n<p>我们知道，当我们调用一个方法的时候，js 会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的 this 对象。 而当一系列方法被依次调用的时候，因为 js 是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p>\n<p>当一个脚本第一次执行的时候，js 引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么 js 会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js 会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p>\n<p>下面这个图片非常直观的展示了这个过程，其中的 global 就是初次运行脚本时向执行栈中加入的代码：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.webp\" alt=\"image\"></p>\n<p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p>\n<p>以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送 ajax 请求数据）执行后会如何呢？前文提过，js 的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。</p>\n<p>js 引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js 会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p>\n<p>这里还有一张图来展示这个过程：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-da078fa3eadf3db4bf455904ae06f84b_720w.jpg\" alt=\"image\"></p>\n<p>图中的 stack 表示我们所说的执行栈，web apis 则是代表一些异步事件，而 callback queue 即事件队列。</p>\n<h4 id=\"2-macro-task-与-micro-task\"><a href=\"#2-macro-task-与-micro-task\" class=\"headerlink\" title=\"2.macro task 与 micro task\"></a>2.macro task 与 micro task</h4><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p>\n<p>以下事件属于宏任务：</p>\n<ul>\n<li><code>setInterval()</code></li>\n<li><code>setTimeout()</code></li>\n</ul>\n<p>以下事件属于微任务</p>\n<ul>\n<li><code>new Promise()</code></li>\n<li><code>new MutaionObserver()</code></li>\n</ul>\n<p>前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回调加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p>\n<p>我们只需记住<strong>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p>\n<p>这样就能解释下面这段代码的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    console.log(1);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">    resolve(3)</span><br><span class=\"line\">&#125;).then(function(val)&#123;</span><br><span class=\"line\">    console.log(val);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"node-环境下的事件循环机制\"><a href=\"#node-环境下的事件循环机制\" class=\"headerlink\" title=\"node 环境下的事件循环机制\"></a>node 环境下的事件循环机制</h3><h4 id=\"1-与浏览器环境有何不同\"><a href=\"#1-与浏览器环境有何不同\" class=\"headerlink\" title=\"1.与浏览器环境有何不同?\"></a>1.与浏览器环境有何不同?</h4><p>在 node 中，事件循环表现出的状态与浏览器中大致相同。不同的是 node 中有一套自己的模型。node 中事件循环的实现是依靠的 libuv 引擎。我们知道 node 选择 chrome v8 引擎作为 js 解释器，v8 引擎将 js 代码分析后去调用对应的 node api，而这些 api 最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 node 中的事件循环存在于 libuv 引擎中。</p>\n<h4 id=\"2-事件循环模型\"><a href=\"#2-事件循环模型\" class=\"headerlink\" title=\"2.事件循环模型\"></a>2.事件循环模型</h4><p>下面是一个 libuv 引擎中的事件循环的模型:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────────────────────┐</span><br><span class=\"line\">┌─&gt;│        timers         │</span><br><span class=\"line\">│  └──────────┬────────────┘</span><br><span class=\"line\">│  ┌──────────┴────────────┐</span><br><span class=\"line\">│  │     I/O callbacks     │</span><br><span class=\"line\">│  └──────────┬────────────┘</span><br><span class=\"line\">│  ┌──────────┴────────────┐</span><br><span class=\"line\">│  │     idle, prepare     │</span><br><span class=\"line\">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class=\"line\">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class=\"line\">│  │         poll          │&lt;──connections───     │</span><br><span class=\"line\">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class=\"line\">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class=\"line\">│  │        check          │</span><br><span class=\"line\">│  └──────────┬────────────┘</span><br><span class=\"line\">│  ┌──────────┴────────────┐</span><br><span class=\"line\">└──┤    close callbacks    │</span><br><span class=\"line\">   └───────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>注：模型中的每一个方块代表事件循环的一个阶段</p>\n<p>这个模型是 node 官网上的一篇文章中给出的，我下面的解释也都来源于这篇文章。我会在文末把文章地址贴出来，有兴趣的朋友可以亲自看看原文。</p>\n<h3 id=\"3-事件循环各阶段详解\"><a href=\"#3-事件循环各阶段详解\" class=\"headerlink\" title=\"3.事件循环各阶段详解\"></a>3.事件循环各阶段详解</h3><p>从上面这个模型中，我们可以大致分析出 node 中的事件循环的顺序：</p>\n<p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I&#x2F;O 事件回调阶段(I&#x2F;O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段…</p>\n<p>以上各阶段的名称是根据我个人理解的翻译，为了避免错误和歧义，下面解释的时候会用英文来表示这些阶段。</p>\n<p>这些阶段大致的功能如下：</p>\n<ul>\n<li>timers: 这个阶段执行定时器队列中的回调如 <code>setTimeout()</code> 和 <code>setInterval()</code>。</li>\n<li>I&#x2F;O callbacks: 这个阶段执行几乎所有的回调。但是不包括 close 事件，定时器和<code>setImmediate()</code>的回调。</li>\n<li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li>\n<li>poll: 等待新的 I&#x2F;O 事件，node 在一些特殊情况下会阻塞在这里。</li>\n<li>check: <code>setImmediate()</code>的回调会在这个阶段执行。</li>\n<li>close callbacks: 例如<code>socket.on(&#39;close&#39;, ...)</code>这种 close 事件的回调。<br>下面我们来按照代码第一次进入 libuv 引擎后的顺序来详细解说这些阶段：</li>\n</ul>\n<h4 id=\"poll-阶段\"><a href=\"#poll-阶段\" class=\"headerlink\" title=\"poll 阶段\"></a>poll 阶段</h4><p>当个 v8 引擎将 js 代码解析后传入 libuv 引擎后，循环首先进入 poll 阶段。poll 阶段的执行逻辑如下： 先查看 poll queue 中是否有事件，有任务就按先进先出的顺序依次执行回调。 当 queue 为空时，会检查是否有 setImmediate()的 callback，如果有就进入 check 阶段执行这些 callback。但同时也会检查是否有到期的 timer，如果有，就把这些到期的 timer 的 callback 按照调用顺序放到 timer queue 中，之后循环会进入 timer 阶段执行 queue 中的 callback。 这两者的顺序是不固定的，受到代码运行的环境的影响。如果两者的 queue 都是空的，那么 loop 会在 poll 阶段停留，直到有一个 i&#x2F;o 事件返回，循环会进入 i&#x2F;o callback 阶段并立即执行这个事件的 callback。</p>\n<p>值得注意的是，poll 阶段在执行 poll queue 中的回调时实际上不会无限的执行下去。有两种情况 poll 阶段会终止执行 poll queue 中的下一个回调：1.所有回调执行完毕。2.执行数超过了 node 的限制。</p>\n<h4 id=\"check-阶段\"><a href=\"#check-阶段\" class=\"headerlink\" title=\"check 阶段\"></a>check 阶段</h4><p>check 阶段专门用来执行 setImmediate()方法的回调，当 poll 阶段进入空闲状态，并且 setImmediate queue 中有 callback 时，事件循环进入这个阶段。</p>\n<h4 id=\"close-阶段\"><a href=\"#close-阶段\" class=\"headerlink\" title=\"close 阶段\"></a>close 阶段</h4><p>当一个 socket 连接或者一个 handle 被突然关闭时（例如调用了 socket.destroy()方法），close 事件会被发送到这个阶段执行回调。否则事件会用 process.nextTick（）方法发送出去。</p>\n<h4 id=\"timer-阶段\"><a href=\"#timer-阶段\" class=\"headerlink\" title=\"timer 阶段\"></a>timer 阶段</h4><p>这个阶段以先进先出的方式执行所有到期的 timer 加入 timer 队列里的 callback，一个 timer callback 指得是一个通过 setTimeout 或者 setInterval 函数设置的回调函数。</p>\n<h4 id=\"I-x2F-O-callback-阶段\"><a href=\"#I-x2F-O-callback-阶段\" class=\"headerlink\" title=\"I&#x2F;O callback 阶段\"></a>I&#x2F;O callback 阶段</h4><p>如上文所言，这个阶段主要执行大部分 I&#x2F;O 事件的回调，包括一些为操作系统执行的回调。例如一个 TCP 连接生错误时，系统需要执行回调来获得这个错误的报告。</p>\n<h3 id=\"4-process-nextTick-setTimeout-与-setImmediate-的区别与使用场景\"><a href=\"#4-process-nextTick-setTimeout-与-setImmediate-的区别与使用场景\" class=\"headerlink\" title=\"4.process.nextTick,setTimeout 与 setImmediate 的区别与使用场景\"></a>4.process.nextTick,setTimeout 与 setImmediate 的区别与使用场景</h3><p>在 node 中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval 与之相同）与 setImmediate</p>\n<p>这三者间存在着一些非常不同的区别：</p>\n<h4 id=\"process-nextTick\"><a href=\"#process-nextTick\" class=\"headerlink\" title=\"process.nextTick()\"></a>process.nextTick()</h4><p>尽管没有提及，但是实际上 node 中存在着一个特殊的队列，即 nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，但是这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查 nextTick queue 中是否有任务，如果有，那么会先清空这个队列。与执行 poll queue 中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用 process.nextTick()方法会导致 node 进入一个死循环。。直到内存泄漏。</p>\n<p>那么何时使用这个方法比较合适呢？下面有一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const server = net.createServer(() =&gt; &#123;&#125;).listen(8080);</span><br><span class=\"line\"></span><br><span class=\"line\">server.on(&#x27;listening&#x27;, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这个例子中当，当 listen 方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发 listening 事件并执行其回调。然而，这时候<code>on(&#39;listening)</code>还没有将 callback 设置好，自然没有 callback 可以执行。为了避免出现这种情况，node 会在 listen 事件中使用<code>process.nextTick()</code>方法，确保事件在回调函数绑定后被触发。</p>\n<h4 id=\"setTimeout-和-setImmediate\"><a href=\"#setTimeout-和-setImmediate\" class=\"headerlink\" title=\"setTimeout()和 setImmediate()\"></a>setTimeout()和 setImmediate()</h4><p>在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。</p>\n<p><code>setTimeout()</code>方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node 会在可以执行 timer 回调的第一时间去执行你所设定的任务。</p>\n<p><code>setImmediate()</code>方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即 poll 阶段之后。有趣的是，这个名字的意义和之前提到过的<code>process.nextTick()</code>方法才是最匹配的。node 的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的 node 程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。</p>\n<p><code>setTimeout()</code>和不设置时间间隔的<code>setImmediate()</code>表现上及其相似。猜猜下面这段代码的结果是什么？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;timeout&#x27;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">setImmediate(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;immediate&#x27;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>实际上，答案是不一定。没错，就连 node 的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个 I&#x2F;O 事件的回调中。下面这段代码的顺序永远是固定的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.readFile(__filename, () =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        console.log(&#x27;timeout&#x27;);</span><br><span class=\"line\">    &#125;, 0);</span><br><span class=\"line\">    setImmediate(() =&gt; &#123;</span><br><span class=\"line\">        console.log(&#x27;immediate&#x27;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>答案永远是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">immediate</span><br><span class=\"line\">timeout</span><br></pre></td></tr></table></figure>\n\n<p>因为在 I&#x2F;O 事件的回调中，<code>setImmediate</code>方法的回调永远在 timer 的回调前执行。</p>\n<h2 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h2><p>javascript 的事件循环是这门语言中非常重要且基础的概念。清楚的了解了事件循环的执行顺序和每一个阶段的特点，可以使我们对一段异步代码的执行顺序有一个清晰的认识，从而减少代码运行的不确定性。合理的使用各种延迟事件的方法，有助于代码更好的按照其优先级去执行。这篇文章期望用最易理解的方式和语言准确描述事件循环这个复杂过程，但由于作者自己水平有限，文章中难免出现疏漏。如果您发现了文章中的一些问题，欢迎在留言中提出，我会尽量回复这些评论，把错误更正。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"重绘（redraw或repaint）与重排（reflow）","url":"/2022/10/24/%E9%87%8D%E7%BB%98%EF%BC%88redraw%E6%88%96repaint%EF%BC%89%E4%B8%8E%E9%87%8D%E6%8E%92%EF%BC%88reflow%EF%BC%89/","content":"<p>浏览器运行机制图：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1209205/201710/1209205-20171010151938027-587388886.png\" alt=\"image\"></p>\n<h2 id=\"浏览器的运行机制：layout：布局；\"><a href=\"#浏览器的运行机制：layout：布局；\" class=\"headerlink\" title=\"浏览器的运行机制：layout：布局；\"></a>浏览器的运行机制：layout：布局；</h2><p>1、<strong>构建 DOM 树（parse）</strong>：渲染引擎解析 HTML 文档，首先将标签转换成 DOM 树中的 DOM node（包括 js 生成的标签）生成内容树（Content Tree&#x2F;DOM Tree）；</p>\n<p>2、<strong>构建渲染树（construct）</strong>：解析对应的 CSS 样式文件信息（包括 js 生成的样式和外部 css 文件），而这些文件信息以及 HTML 中可见的指令（如<code>&lt;b&gt;&lt;/b&gt;</code>），构建渲染树（Rendering Tree&#x2F;Frame Tree）；</p>\n<p>3、<strong>布局渲染树（reflow&#x2F;layout）</strong>：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；</p>\n<p>4、<strong>绘制渲染树（paint&#x2F;repaint）</strong>：遍历渲染树，使用 UI 后端层来绘制每个节点。</p>\n<h2 id=\"重绘（repaint-或-redraw）：\"><a href=\"#重绘（repaint-或-redraw）：\" class=\"headerlink\" title=\"重绘（repaint 或 redraw）：\"></a>重绘（repaint 或 redraw）：</h2><p>当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。</p>\n<p>重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>\n<p>触发重绘的条件：改变元素外观属性。如：color，background-color 等。</p>\n<p>注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。</p>\n<h2 id=\"重排（重构-x2F-回流-x2F-reflow）：\"><a href=\"#重排（重构-x2F-回流-x2F-reflow）：\" class=\"headerlink\" title=\"重排（重构&#x2F;回流&#x2F;reflow）：\"></a>重排（重构&#x2F;回流&#x2F;reflow）：</h2><p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>\n<p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，<strong>重排必定会引发重绘，但重绘不一定会引发重排</strong>。</p>\n<p>触发重排的条件：任何页面布局和几何属性的改变都会触发重排，比如：</p>\n<p>1、页面渲染初始化；(无法避免)</p>\n<p>2、添加或删除可见的 DOM 元素；</p>\n<p>3、元素位置的改变，或者使用动画；</p>\n<p>4、元素尺寸的改变——大小，外边距，边框；</p>\n<p>5、浏览器窗口尺寸的变化（resize 事件发生时）；</p>\n<p>6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；</p>\n<p>7、读取某些元素属性：（offsetLeft&#x2F;Top&#x2F;Height&#x2F;Width,　 clientTop&#x2F;Left&#x2F;Width&#x2F;Height,　 scrollTop&#x2F;Left&#x2F;Width&#x2F;Height,　 width&#x2F;height,　 getComputedStyle(),　 currentStyle(IE)　)</p>\n<h2 id=\"重绘重排的代价：耗时，导致浏览器卡慢。\"><a href=\"#重绘重排的代价：耗时，导致浏览器卡慢。\" class=\"headerlink\" title=\"重绘重排的代价：耗时，导致浏览器卡慢。\"></a>重绘重排的代价：耗时，导致浏览器卡慢。</h2><h3 id=\"优化：\"><a href=\"#优化：\" class=\"headerlink\" title=\"优化：\"></a>优化：</h3><p>1、浏览器自己的优化：浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>\n<p>2、我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的 DOM 和样式的修改。并减少对 style 样式的请求。</p>\n<p>（1）直接改变元素的 className</p>\n<p>（2）display：none；先设置元素为 display：none；然后进行页面布局等操作；设置完成后将元素设置为 display：block；这样的话就只引发两次重绘和重排；</p>\n<p>（3）不要经常访问浏览器的 flush 队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流；</p>\n<p>（4）使用 cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</p>\n<p>（5）将需要多次重排的元素，position 属性设为 absolute 或 fixed，元素脱离了文档流，它的变化不会影响到其他元素；</p>\n<p>（6）如果需要创建多个 DOM 节点，可以使用 DocumentFragment 创建完后一次性的加入 document；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var fragment = document.createDocumentFragment();</span><br><span class=\"line\"></span><br><span class=\"line\">var li = document.createElement(&#x27;li&#x27;);</span><br><span class=\"line\">li.innerHTML = &#x27;apple&#x27;;</span><br><span class=\"line\">fragment.appendChild(li);</span><br><span class=\"line\"></span><br><span class=\"line\">var li = document.createElement(&#x27;li&#x27;);</span><br><span class=\"line\">li.innerHTML = &#x27;watermelon&#x27;;</span><br><span class=\"line\">fragment.appendChild(li);</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&#x27;fruit&#x27;).appendChild(fragment);</span><br></pre></td></tr></table></figure>\n\n<p>（7）尽量不要使用 table 布局。</p>\n","categories":["前端易混知识点"],"tags":["javascript"]},{"title":"高德地图JSapi","url":"/2022/12/16/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEJSapi/","content":"<blockquote>\n<p>简介： 1.js 显示地图，选择容器；设置地图的中心点，并标记。 var marker, map &#x3D; new AMap.</p>\n</blockquote>\n<h2 id=\"1-js-显示地图\"><a href=\"#1-js-显示地图\" class=\"headerlink\" title=\"1.js 显示地图\"></a>1.js 显示地图</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;http://cache.amap.com/lbs/static/main1119.css&quot;/&gt;&lt;!-- 引入高德地图的样式 --&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;http://webapi.amap.com/maps?v=1.3&amp;key=aafdf4a9edda043681ff641e6d9b9ee8&quot;&gt;&lt;/script&gt;&lt;!-- 传入key --&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cache.amap.com/lbs/static/addToolbar.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入高德地图js文件 --&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;container&quot; style=&quot;width:49%;height: 80%;&quot;&gt;&lt;/div&gt;&lt;!--放置地图的div  --&gt;</span><br><span class=\"line\">&lt;div id=&quot;container2&quot; style=&quot;width:49%;height: 80%;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/* 选择容器；设置地图的中心点，并标记 */</span><br><span class=\"line\">var marker, map = new AMap.Map(&quot;container&quot;, &#123;</span><br><span class=\"line\">    resizeEnable: true,</span><br><span class=\"line\">    center: [114.290924,30.601394],</span><br><span class=\"line\">    zoom: 13</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">/* 设置地图的中心点，并标记 */</span><br><span class=\"line\">var marker2, map2 = new AMap.Map(&quot;container2&quot;, &#123;</span><br><span class=\"line\">    resizeEnable: true,</span><br><span class=\"line\">    center: [114.290924,30.601394],</span><br><span class=\"line\">    zoom: 13</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-点击获取地图经纬度坐标；创建-marker-点\"><a href=\"#2-点击获取地图经纬度坐标；创建-marker-点\" class=\"headerlink\" title=\"2.点击获取地图经纬度坐标；创建 marker 点\"></a>2.点击获取地图经纬度坐标；创建 marker 点</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/* 点击获取地图坐标 */</span><br><span class=\"line\">var clickEventListener = map.on(&#x27;click&#x27;, function(e) &#123;</span><br><span class=\"line\"> document.getElementById(&quot;xy&quot;).value = e.lnglat.getLng() + &#x27;,&#x27; + e.lnglat.getLat();</span><br><span class=\"line\">  /* 点击一次新增一个标记点 */</span><br><span class=\"line\"> var marker= new AMap.Marker(&#123;</span><br><span class=\"line\">    map:map,</span><br><span class=\"line\">    position:[e.lnglat.getLng(),e.lnglat.getLat()]</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-在地图上绘制多边形折线\"><a href=\"#3-在地图上绘制多边形折线\" class=\"headerlink\" title=\"3.在地图上绘制多边形折线\"></a>3.在地图上绘制多边形折线</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//在地图上绘制折线</span><br><span class=\"line\">var editor=&#123;&#125;;</span><br><span class=\"line\">editor._polygon=(function()&#123;</span><br><span class=\"line\">    return new AMap.Polygon(&#123;</span><br><span class=\"line\">        map: map,</span><br><span class=\"line\">        path: lineArr,/* 这里是一个数组； */</span><br><span class=\"line\">        strokeColor: &quot;#0000ff&quot;,</span><br><span class=\"line\">        strokeOpacity: 1,</span><br><span class=\"line\">        strokeWeight: 3,</span><br><span class=\"line\">        fillColor: &quot;#CD2626&quot;,</span><br><span class=\"line\">        fillOpacity: 0.35</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">map.setFitView();</span><br><span class=\"line\">editor._polygonEditor= new AMap.PolyEditor(map, editor._polygon);</span><br></pre></td></tr></table></figure>\n\n<p>第二种绘制图形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 绘制轨迹</span><br><span class=\"line\">var polyline = new AMap.Polyline(&#123;</span><br><span class=\"line\">    map: map,</span><br><span class=\"line\">    path: lineArr,/* 这里是坐标数组 */</span><br><span class=\"line\">    strokeColor: &quot;red&quot;,  //线颜色</span><br><span class=\"line\">    strokeOpacity: 1,     //线透明度</span><br><span class=\"line\">    strokeWeight: 1,      //线宽</span><br><span class=\"line\">    strokeStyle: &quot;solid&quot;  //线样式</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">map.setFitView();</span><br><span class=\"line\">/*  将画线的区域渲染颜色*/</span><br><span class=\"line\">var polygon = new AMap.Polygon(&#123;</span><br><span class=\"line\">    map: map,</span><br><span class=\"line\">    fillOpacity:0.4,</span><br><span class=\"line\">    path: lineArr</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-开始编辑多边形；结束编辑多边形\"><a href=\"#4-开始编辑多边形；结束编辑多边形\" class=\"headerlink\" title=\"4.开始编辑多边形；结束编辑多边形\"></a>4.开始编辑多边形；结束编辑多边形</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/* 开始编辑 */</span><br><span class=\"line\">editor.startEditPolygon=function()&#123;</span><br><span class=\"line\">    editor._polygonEditor.open();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*结束编辑 */</span><br><span class=\"line\">editor.closeEditPolygon=function()&#123;</span><br><span class=\"line\">    /* 结束编辑时会自动将坐标全部存在数组内</span><br><span class=\"line\">        ；将数组转为字符串，以#号分隔 */</span><br><span class=\"line\">  var  arg = lineArr.join(&quot;#&quot;);</span><br><span class=\"line\">  document.getElementById(&quot;arg&quot;).value=arg+&quot;#&quot;; /* 这里是将数组转成的字符串存起来 */</span><br><span class=\"line\">  editor._polygonEditor.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-清除标记的方法\"><a href=\"#5-清除标记的方法\" class=\"headerlink\" title=\"5.清除标记的方法\"></a>5.清除标记的方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.clearMap();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6，当时为了去除地图上的样式，起到刷新地图的效果；没有找到更好的方法，选择的重新加载一遍地图。覆盖之前的；也就是在-div-里重新加载一次；\"><a href=\"#6，当时为了去除地图上的样式，起到刷新地图的效果；没有找到更好的方法，选择的重新加载一遍地图。覆盖之前的；也就是在-div-里重新加载一次；\" class=\"headerlink\" title=\"6，当时为了去除地图上的样式，起到刷新地图的效果；没有找到更好的方法，选择的重新加载一遍地图。覆盖之前的；也就是在 div 里重新加载一次；\"></a>6，当时为了去除地图上的样式，起到刷新地图的效果；没有找到更好的方法，选择的重新加载一遍地图。覆盖之前的；也就是在 div 里重新加载一次；</h2><h2 id=\"7，自定义图标以及样式\"><a href=\"#7，自定义图标以及样式\" class=\"headerlink\" title=\"7，自定义图标以及样式\"></a>7，自定义图标以及样式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">marker= new AMap.Marker(&#123;</span><br><span class=\"line\">    title:name,/* 鼠标放上去显示的标题 */</span><br><span class=\"line\">    map: map,</span><br><span class=\"line\">    position: arr,/*  坐标数组*/</span><br><span class=\"line\">    icon: new AMap.Icon(&#123;</span><br><span class=\"line\">        size: new AMap.Size(50,50),  //图标大小</span><br><span class=\"line\">        image: &quot;static/img/1.png&quot;,/*图片路径  */</span><br><span class=\"line\">        imageOffset: new AMap.Pixel(0,0)/* 偏移量 */</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">marker.setLabel(&#123;//label默认蓝框白底左上角显示，样式className为：amap-marker-label；可以在css样式里调整</span><br><span class=\"line\">    offset: new AMap.Pixel(-20,20),//修改label相对于maker的位置</span><br><span class=\"line\">    content:&quot;&lt;span style=&#x27;color: red&#x27;&gt;&quot;+name+&quot;&lt;/span&gt;&quot;/* 这里写的是html代码 */</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","categories":["webGL总结"],"tags":["webGL"]}]